

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="peiwithhao">
  <meta name="keywords" content="">
  
    <meta name="description" content="驱动，驱动！">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux_Kernel_0x01_LKMmaker">
<meta property="og:url" content="https://peiandhao.github.io/2023/06/20/Linux-Kernel-0x01-LKMmaker/index.html">
<meta property="og:site_name" content="peiwithhao&#39;s Valhalla">
<meta property="og:description" content="驱动，驱动！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://peiandhao.github.io/img/Linux_Kernel.png">
<meta property="article:published_time" content="2023-06-20T15:07:23.000Z">
<meta property="article:modified_time" content="2023-06-20T15:12:42.722Z">
<meta property="article:author" content="peiwithhao">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://peiandhao.github.io/img/Linux_Kernel.png">
  
  
  
  <title>Linux_Kernel_0x01_LKMmaker - peiwithhao&#39;s Valhalla</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"peiandhao.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"text"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Afm6UeM0VL6RfMOLAgwtyxs8-gzGzoHsz","app_key":"Vr60qrZIptqhJaXqWvDEknkH","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>p3ivv1+h@0</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/Linux_Kernel.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux_Kernel_0x01_LKMmaker"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        peiwithhao
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-20 23:07" pubdate>
          2023年6月20日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          145 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux_Kernel_0x01_LKMmaker</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="内核驱动简单认识"><a href="#内核驱动简单认识" class="headerlink" title="内核驱动简单认识"></a>内核驱动简单认识</h1><h2 id="自行编写驱动"><a href="#自行编写驱动" class="headerlink" title="自行编写驱动"></a>自行编写驱动</h2><p>首先咱们来介绍以下基础知识</p>
<h3 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h3><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p>
<ul>
<li>驱动程序（Device drivers）</li>
<li>设备驱动</li>
<li>文件系统驱动<br>…<br>内核扩展模块 (modules)<br>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe&#x2F;dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。</li>
</ul>
<p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。</p>
<p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p>
<hr>
<p>而Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。（而一般内核pwn中的漏洞出自这些模块里面，但是有的师傅也说内核也会有漏洞，这咱们以后再学）<br>这里比较常用的指令有以下几个：</p>
<ul>
<li>insmod: 讲指定模块加载到内核中</li>
<li>rmmod: 从内核中卸载指定模块</li>
<li>lsmod: 列出已经加载的模块</li>
<li>modprobe: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li>
<li>dmesg:输出内核态缓冲区的输出，这里跟用户态不一样，用户态一般输出到屏幕就完事了，内核中是输出到缓冲区。</li>
</ul>
<p>这里注意指令均需运行在管理员权限下。</p>
<hr>
<p>这里还注意一个特殊的函数ioctl</p>
<h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><p>直接查看 man 手册</p>
<pre><code class="hljs">NAME
       ioctl - control device

SYNOPSIS
       #include &lt;sys/ioctl.h&gt;

       int ioctl(int fd, unsigned long request, ...);

DESCRIPTION
       The ioctl() system call manipulates the underlying device parameters of special
       files.  In particular, many  operating  characteristics  of  character  special
       files  (e.g., terminals) may be controlled with ioctl() requests.  The argument
       fd must be an open file descriptor.

       The second argument is a device-dependent request code.  The third argument  is
       an  untyped  pointer  to  memory.  It&#39;s traditionally char *argp (from the days
       before void * was valid C), and will be so named for this discussion.

       An ioctl() request has encoded in it whether the argument is an in parameter or
       out  parameter, and the size of the argument argp in bytes.  Macros and defines
       used in specifying an ioctl() request are located in the file &lt;sys/ioctl.h&gt;.
</code></pre>
<p>可以看出 ioctl 也是一个系统调用，用于与设备通信。<br>int ioctl(int fd, unsigned long request, …) 的第一个参数为打开设备 (open) 返回的 文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。</p>
<p>使用 ioctl 进行通信的原因：</p>
<blockquote>
</blockquote>
<p>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。<br>比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。<br>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 Ioctl 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 Ioctl 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</p>
<h3 id="1-初级LKM模块"><a href="#1-初级LKM模块" class="headerlink" title="1.初级LKM模块"></a>1.初级LKM模块</h3><pre><code class="hljs">#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;

static int __init kernel_module_init(void)
&#123;
    printk(&quot;&lt;1&gt;Hello the Linux kernel world!\n&quot;);
    return 0;
&#125;

static void __exit kernel_module_exit(void)
&#123;
    printk(&quot;&lt;1&gt;Good bye the Linux kernel world! See you again!\n&quot;);
&#125;

module_init(kernel_module_init);
module_exit(kernel_module_exit);
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;peiwithhao&quot;);
</code></pre>
<p>当编写完成后咱们用make脚本进行编译链接，脚本如下</p>
<pre><code class="hljs">obj-m += peiwithhao
CURRENT_PATH := $(shell pwd)
LINUX_KERNEL := $(shell uname -r)
LINUX_KERNEL_PATH := /usr/src/linux-headers-$(LINUX_KERNEL)
all:
        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules
clean:
        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean
</code></pre>
<p>这里程序有几个注意点在以下标识</p>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul>
<li>linux&#x2F;module.h：对于LKM而言这是必须包含的一个头文件</li>
<li>linux&#x2F;kernel.h：载入内核相关信息</li>
<li>linux&#x2F;init.h：包含着一些有用的宏</li>
</ul>
<p>通常情况下，这三个头文件对于内核模块编程都是不可或缺的</p>
<h4 id="入口点-x2F-出口点"><a href="#入口点-x2F-出口点" class="headerlink" title="入口点&#x2F;出口点"></a>入口点&#x2F;出口点</h4><p>一个内核模块的入口点应当为 module_init()，出口函数应当为module_exit()，在内核载入&#x2F;卸载内核模块时会缺省调用这两个函数</p>
<p>在这里我们将自定义的两个函数的指针作为参数传入LKM入口函数&#x2F;出口函数中，以作为其入口&#x2F;出口函数</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p> __init &amp; __exit：这两个宏用以在函数结束后释放相应的内存<br>MODULE_AUTHOR() &amp; MODULE_LICENSE()：声明内核作者与发行所用许可证<br>printk()：内核态函数，用以在内核缓冲区写入信息，其中&lt;1&gt;标识着信息的紧急级别（一共有8个优先级，0为最高，相关宏定义于linux&#x2F;kernel.h中，这个大伙可以查查资料，在后面我一般用printk(KERN_INFO””),这个跟&lt;6&gt;好像时一个意思）</p>
<p>由于make我也才刚接触，所以这里不做解释免得误导大家。<br>这里继续<code>make</code>即可，然后咱们使用如下命令</p>
<pre><code class="hljs">insmod hellokernel.ko
lsmod
rmmod hellokernel
dmesg
</code></pre>
<p>这里由于我之前这个模块过于简单就忘保存了，所以引用一下师傅的图<br><img src="https://i.loli.net/2021/02/28/vJitGgkFTzcPx8a.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-提供IO接口"><a href="#2-提供IO接口" class="headerlink" title="2.提供IO接口"></a>2.提供IO接口</h3><p>虽然说我们的新模块成功跑起来了，但是除了在内核缓冲区进行输入输出以外好像就做不了什么了，我们希望我们写的内核模块能够向我们提供更多的功能并能够让用户与其进行交互，以发挥更多的作用<br>所以这里我们的首要步骤就是注册设备。而为了与设备进行交互，我们就需要驱动来为咱们隐藏底层做的很多事，就好比我想用打印机，但要是咱们编程的时候既要考虑到用户这边，又要考虑到设备这边的问题，咱们就太累了，幸好在计算机中没有什么是加一层解决不了的，如果不行，那就加两层。<br>所以出现了驱动的这一概念，驱动也就帮咱们隐藏了底层实现，咱们调用的时候只需要会open，read，write即可。</p>
<h4 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h4><p>在Linux中I&#x2F;O设备分为如下两类：</p>
<ul>
<li>字符设备：在I&#x2F;O传输过程中以字符为单位进行传输的设备，例如键盘、串口等。字符设备按照字符流的方式被有序访问，不能够进行随机读取</li>
<li>块设备：在块设备中，信息被存储在固定大小的块中，每个块有着自己的地址，例如硬盘、SD卡等。用户可以对块设备进行随机访问——从任意位置读取一定长度的数据</li>
</ul>
<h4 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h4><p>在注册设备之前，我们需要用到一个结构体——file_operations来完成对设备的一些相关定义，该结构体定义于include&#x2F;linux&#x2F;fs.h中，相关源码比较长不在此贴出，在其中定义了大量的函数指针,这里再之后的代码会体现出来，他也就是定义了open、read等系统调用的函数指针。</p>
<p>一个文件应当拥有一个file_operations实例，并指定相关系统调用函数指针所指向的自定义函数，在后续进行设备的注册时会使用该结构体</p>
<h4 id="主设备号-amp-次设备号"><a href="#主设备号-amp-次设备号" class="headerlink" title="主设备号 &amp; 次设备号"></a>主设备号 &amp; 次设备号</h4><p>在Linux内核中，使用类型dev_t（unsigned long）来标识一个设备的设备号。<br>一个字符的设备号由主设备号与次设备号组成，高字节存储主设备号，低字节存储次设备号：<br>主设备号：标识设备类型，使用宏MAJOR(dev_t dev)可以获取主设备号<br>次设备号：用以区分同类型设备，使用宏MINOR(dev_t dev)可以获取次设备号<br>Linux还提供了一个宏 MKDEV(int major, int minor);，用以通过主次设备号生成对应的设备号</p>
<h4 id="设备节点（struct-device-node-amp-struct-device）"><a href="#设备节点（struct-device-node-amp-struct-device）" class="headerlink" title="设备节点（struct device_node &amp; struct device）"></a>设备节点（struct device_node &amp; struct device）</h4><p>由于Linux中所有的设备都以文件的形式进行访问，这些文件存放在&#x2F;dev目录下，一个文件就是一个设备节点，如下图<br><img src="http://imgsrc.baidu.com/forum/pic/item/dcc451da81cb39dbc797769495160924aa183098.jpg" srcset="/img/loading.gif" lazyload></p>
<p>在Linux kernel中使用结构体device描述一个设备，该结构体定义于include&#x2F;linux&#x2F;device.h（内核源码路径）中，每个设备在内核中都有着其对应的device实例，其中记录着设备的相关信息</p>
<p>在DTS（Device Tree Source，设备树）中则使用device_node结构体表示一个设备</p>
<h4 id="设备类（struct-class）"><a href="#设备类（struct-class）" class="headerlink" title="设备类（struct class）"></a>设备类（struct class）</h4><p>在Linux kernel中使用结构体class用以表示高层次抽象的设备，该结构体定义于include&#x2F;linux&#x2F;device&#x2F;class.h中</p>
<p>每个设备节点实例中都应当包含着一个指向相应设备类实例的指针</p>
<p>设备的注册与注销<br>方便起见，我们接下来将会注册一个字符型设备，大致的一个步骤如下：</p>
<p>使用由内核提供的函数<code>register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)</code>进行字符型设备注册，该函数定义于include&#x2F;linux&#x2F;fs.h，会将注册成功后的主设备号返回，若失败则会返回一个负值，参数说明如下：<br>major：主设备号，若为0则由内核分配主设备号<br>name：设备名，由用户指定<br>fops：该设备的文件操作系统（file_operations结构体）指针<br>使用宏class_create(owner, name)创建设备类，该宏定义于include&#x2F;linux&#x2F;device.h中，其核心调用函数是__class_create(struct module *owner, const char *name, struct lock_class_key *key)</p>
<p>使用函数<code>device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)</code>创建设备节点，若成功则最终会在&#x2F;dev目录下生成我们的设备节点文件，各参数说明如下：</p>
<p>cls：该设备的设备类<br>parent：该设备的父设备节点，通常情况下应当为某种总线或主机控制器，若该设备为顶级设备则设为NULL<br>devt：该设备的设备号<br>drvdata：该驱动的相关信息，若无则填NULL<br>fmt：设备名称<br>设备的注销则是逆着上面的进程进行，同样有着相对应的三个函数：<code>device_destroy(struct class *cls, dev_t devt)</code>、<code>class_destroy(struct class *cls)</code>、<code>unregister_chrdev(unsigned int major, const char *name)</code>，用法相似，这里就不一一赘叙了</p>
<p>✳ 需要注意的是若是注册设备的进程中的某一步出错了，我们在退出内核态函数之前应当手动调用注销函数清理原先的相关资源</p>
<h4 id="设备权限"><a href="#设备权限" class="headerlink" title="设备权限"></a>设备权限</h4><p>内核模块运行在内核空间，所创建的设备节点只有root用户才有权限进行读写，对于其他用户而言便毫无意义，这并不是我们想要的，因此我们需要通过进一步的设置使得所有用户都有权限通过设备节点文件与我们的内核模块进行交互</p>
<p>在内核中使用inode结构体表示一个文件，该结构体定义于include&#x2F;linux&#x2F;fs.h中，其中用以标识权限的是成员i_mode</p>
<p>而在内核中对于使用flip_open()打开的文件，Linux内核中使用 file 结构体进行描述，该结构体定义于include&#x2F;linux&#x2F;fs.h中，其中有着指向内核中该文件的 inode 实例的指针，使用file_inode()函数可以获得一个 file 结构体中的 inode 结构体指针</p>
<p>那么我们不难想到，若是在内核模块中使用file_open()函数打开我们的设备节点文件，随后修改 file 结构体中的 inode 指针指向的 inode 实例的 i_mode 成员，便能够修改该文件的权限,</p>
<p>大伙可以照着敲一敲，逻辑很简单。</p>
<pre><code class="hljs">#include&lt;linux/module.h&gt;                //it have to exist
#include&lt;linux/kernel.h&gt;                //loading the information of kernel
#include&lt;linux/init.h&gt;                        //contain some useful define
#include&lt;linux/fs.h&gt;                        
#include&lt;linux/device.h&gt;

#define DEVICE_NAME &quot;peiwithhao&quot;
#define DEVICE_PATH &quot;/dev/peiwithhao&quot;
#define CLASS_NAME &quot;P_Wmodule&quot;

static int major_num;
static struct class * module_class = NULL;
static struct device * module_device = NULL;
static struct file * __file = NULL;
struct inode * __inode = NULL;

static struct file_operations PW_module_fo = &#123;                                                        //descripe the device
        .owner = THIS_MODULE
&#125;;

static int __init kernel_module_init(void)&#123;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:]Module loaded. Start to register device ...\n&quot;);
        major_num = register_chrdev(0,DEVICE_NAME,&amp;PW_module_fo);                        //register the major number
        if(major_num &lt;0)&#123;
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to register a major number! \n&quot;);
                return major_num;
        &#125;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Register completed ,major number: %d\n&quot;,major_num);
        
        module_class = class_create(THIS_MODULE,CLASS_NAME);                                //create the struct class
        if(IS_ERR(module_class))&#123;
                unregister_chrdev(major_num,DEVICE_NAME);
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to register class device!\n&quot;);
                return PTR_ERR(module_class);
        &#125;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Class Register complete. \n&quot;);

        module_device = device_create(module_class,NULL,MKDEV(major_num,0),NULL,DEVICE_NAME);        //create the device
        if(IS_ERR(module_class))&#123;
                class_destroy(module_class);
                unregister_chrdev(major_num,DEVICE_NAME);
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to create the device! \n&quot;);
                return PTR_ERR(module_class);
        &#125;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module Register complete. \n&quot;);

        __file = filp_open(DEVICE_PATH, O_RDONLY,0);                                                //open the file ,now that device
        if(IS_ERR(__file))&#123;
                device_destroy(module_class,MKDEV(major_num,0));
                class_destroy(module_class);
                unregister_chrdev(major_num,DEVICE_NAME);
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to change module privilege! \n&quot;);
                return PTR_ERR(__file);
        &#125;
        __inode = file_inode(__file);        
        __inode-&gt;i_mode |= 0666;                                
        filp_close(__file,NULL);
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module privilege change complete.... \n&quot;);
        return 0;
&#125;
static void __exit kernel_module_exit(void)&#123;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Start to clean up the module... \n&quot;);
        device_destroy(module_class,MKDEV(major_num,0));
        class_destroy(module_class);
        unregister_chrdev(major_num,DEVICE_NAME);
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module clean up complete. See you next time! \n&quot;);

&#125;
module_init(kernel_module_init);                //in
module_exit(kernel_module_exit);                //out
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;dawn&quot;);
</code></pre>
<p>之后就是编译make，然后测试，在这里咱们注册了一个device，所以咱们也可以到&#x2F;dev目录底下查看<br>dmesg查看效果<br><img src="http://imgsrc.baidu.com/forum/pic/item/37d12f2eb9389b5054bcf190c035e5dde6116eb4.jpg" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>这里注意下，为什么都要先lsmod 再rmmod呢，因为咱们在注册的时候会调用init那个函数，卸载时会调用exit，由于需要都看看进程所以一起用来算了</p>
</blockquote>
<h4 id="3-编写系统调用接口"><a href="#3-编写系统调用接口" class="headerlink" title="3.编写系统调用接口"></a>3.编写系统调用接口</h4><p>我们编写如下的三个简单的函数使得用户应用程式可以通过open、close、read、write、ioctl与其进行交互</p>
<p>在这里我们引入了自旋锁spinlock_t类型变量以增加对多线程的支持</p>
<p>需要注意的是file_operations结构体中ioctl的函数指针应当为unlocked_ioctl，close对应的函数指针应当为release</p>
<p> 还有就是内核空间与用户空间之间传递数据应当使用copy_from_user(void *to, const void *from, unsigned long n)、copy_to_user(void *to, const void *from, unsigned long n)函数，从函数名咱们就可以知道他的妙用。</p>
<p>代码如下，我稍作解释，对了这里分出了头文件，因为文件太长了，我一切跟着师傅走然后慢慢理解<br>首先是p_wmodule.h</p>
<pre><code class="hljs">#include&lt;linux/module.h&gt;                //it have to exist
#include&lt;linux/kernel.h&gt;                //loading the information of kernel
#include&lt;linux/init.h&gt;                        //contain some useful define
#include&lt;linux/fs.h&gt;                        
#include&lt;linux/device.h&gt;

#define DEVICE_NAME &quot;peiwithhao&quot;
#define DEVICE_PATH &quot;/dev/peiwithhao&quot;
#define CLASS_NAME &quot;p_wmodule&quot;
#define NOT_INIT 0xffffffff
#define READ_ONLY 0x1000
#define ALLOW_WRITE 0x1001
#define BUFFER_RESET 0x1002

static int major_num;
static int p_w_module_mode = READ_ONLY;
static struct class * module_class = NULL;
static struct device * module_device = NULL;
static void * buffer = NULL;
static spinlock_t spin;
static struct file * __file = NULL;
struct inode * __inode = NULL;

static int __init kernel_module_init(void);
static void __exit kernel_module_exit(void);
static int p_w_module_open(struct inode *,struct file *);
static ssize_t p_w_module_read(struct file *,char __user *,size_t,loff_t *);
static ssize_t p_w_module_write(struct file*,const char __user * ,size_t,loff_t *);
static int p_w_module_release(struct inode *, struct file *);
static long p_w_module_ioctl(struct file *,unsigned int,unsigned long);
static long __internal_p_w_module_ioctl(struct file * __file,unsigned int cmd,unsigned long param);

static struct file_operations PW_module_fo = &#123;                                                        //descripe the device
        .owner = THIS_MODULE,
        .unlocked_ioctl = p_w_module_ioctl,
        .open = p_w_module_open,
        .read = p_w_module_read,
        .write = p_w_module_write,
        .release = p_w_module_release,
&#125;;
</code></pre>
<p>再者之后就是p_wmodule.c了</p>
<pre><code class="hljs">#include&lt;linux/module.h&gt;                //it have to exist
#include&lt;linux/kernel.h&gt;                //loading the information of kernel
#include&lt;linux/init.h&gt;                        //contain some useful define
#include&lt;linux/fs.h&gt;                        
#include&lt;linux/device.h&gt;
#include&lt;linux/slab.h&gt;
#include &quot;p_wmodule.h&quot;

module_init(kernel_module_init);                //in
module_exit(kernel_module_exit);                //out
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;dawn&quot;);
        
static int __init kernel_module_init(void)&#123;
        spin_lock_init(&amp;spin);
        printk(KERN_INFO &quot;[peiwithhao_TestModule:]Module loaded. Start to register device ...\n&quot;);
        major_num = register_chrdev(0,DEVICE_NAME,&amp;PW_module_fo);                        //register the major number
        if(major_num &lt;0)&#123;
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to register a major number! \n&quot;);
                return major_num;
        &#125;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Register completed ,major number: %d\n&quot;,major_num);
        
        module_class = class_create(THIS_MODULE,CLASS_NAME);                                //create the struct class
        if(IS_ERR(module_class))&#123;
                unregister_chrdev(major_num,DEVICE_NAME);
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to register class device!\n&quot;);
                return PTR_ERR(module_class);
        &#125;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Class Register complete. \n&quot;);

        module_device = device_create(module_class,NULL,MKDEV(major_num,0),NULL,DEVICE_NAME);        //create the device
        if(IS_ERR(module_class))&#123;
                class_destroy(module_class);
                unregister_chrdev(major_num,DEVICE_NAME);
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to create the device! \n&quot;);
                return PTR_ERR(module_class);
        &#125;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module Register complete. \n&quot;);

        __file = filp_open(DEVICE_PATH, O_RDONLY,0);                                                //open the file ,now that device
        if(IS_ERR(__file))&#123;
                device_destroy(module_class,MKDEV(major_num,0));
                class_destroy(module_class);
                unregister_chrdev(major_num,DEVICE_NAME);
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to change module privilege! \n&quot;);
                return PTR_ERR(__file);
        &#125;
        __inode = file_inode(__file);        
        __inode-&gt;i_mode |= 0666;                                
        filp_close(__file,NULL);
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module privilege change complete.... \n&quot;);

        return 0;
&#125;
static void __exit kernel_module_exit(void)&#123;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Start to clean up the module... \n&quot;);
        device_destroy(module_class,MKDEV(major_num,0));
        class_destroy(module_class);
        unregister_chrdev(major_num,DEVICE_NAME);
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module clean up complete. See you next time! \n&quot;);
&#125;

static long p_w_module_ioctl(struct file * __file, unsigned  int cmd , unsigned long param)&#123;
        long ret;

        spin_lock(&amp;spin);

        ret = __internal_p_w_module_ioctl(__file , cmd, param);

        spin_unlock(&amp;spin);

        return ret;
&#125;

static long __internal_p_w_module_ioctl(struct file *__file,unsigned int cmd, unsigned long param)
&#123;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Received operation code : %d\n&quot;,cmd);
        switch(cmd)&#123;
                case READ_ONLY:
                        if(!buffer)&#123;
                                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Please reset the buffer at first!\n&quot;);
                                return -1;
                        &#125;
                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to READ_ONLY...\n&quot;);
                        p_w_module_mode = READ_ONLY;
                        break;
                case ALLOW_WRITE:
                        if(!buffer)&#123;
                                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Please reset the buffer at first!\n&quot;);
                                return -1;
                        &#125;
                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to ALLOW_WRITE..\n&quot;);
                        p_w_module_mode = ALLOW_WRITE;
                        break;
                case BUFFER_RESET:
                        if(!buffer)&#123;
                                buffer = kmalloc(0x500,GFP_ATOMIC);
                                if(buffer == NULL)&#123;
                                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to initialize the buffer. Kernel malloc error!\n&quot;);
                                        p_w_module_mode = NOT_INIT;
                                        return -1;
                                &#125;
                        &#125;
                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Buffer reset . Module operation mode reset to READ_ONLY...\n&quot;);
                        memset(buffer,0,0x500);
                        p_w_module_mode = READ_ONLY;
                        break;
                case NOT_INIT:
                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to NOT_INIT...&quot;);
                        p_w_module_mode = NOT_INIT;
                        kfree(buffer);
                        buffer = NULL;
                        return 0;
                default:
                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Invalid operation code\n&quot;);
                        return -1;
                &#125;
        return 0;
&#125;

static int p_w_module_open(struct inode * __inode, struct file * __file)&#123;
        spin_lock(&amp;spin);

        if(buffer == NULL)&#123;
                buffer = kmalloc(0x500,GFP_ATOMIC);
                if(buffer == NULL)&#123;
                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to initialize the buffer. Kernel malloc error!\n&quot;);
                        p_w_module_mode = NOT_INIT;
                        return -1;
                &#125;
                memset(buffer,0,0x500);
                p_w_module_mode = READ_ONLY;
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Device open,buffer initialized successfully...\n&quot;);
        &#125;
        else&#123;
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Warning: reopen the device may cause unexpected error in kernel!\n&quot;);
        &#125;
        spin_unlock(&amp;spin);

        return 0;
&#125;

static int p_w_module_release(struct inode * __inode, struct file * __file)&#123;
        spin_lock(&amp;spin);

        if(buffer)&#123;
                kfree(buffer);
                buffer = NULL ;
        &#125;
        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Device closed\n&quot;);
        spin_unlock(&amp;spin);
        return 0;
&#125;

static ssize_t p_w_module_read(struct file * __file ,char __user * user_buf,size_t size,loff_t *__loff)&#123;
        const char * const buf = (char*)buffer;
        int count;

        spin_lock(&amp;spin);

        if(p_w_module_mode == NOT_INIT)&#123;
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to NOT_INIT...&quot;);
                return -1;
        &#125;
        count = copy_to_user(user_buf,buf,size &gt; 0x500 ? 0x500 :size);
        spin_unlock(&amp;spin);

        return count;
&#125;
static ssize_t p_w_module_write(struct file * __file ,const char __user * user_buf,size_t size,loff_t *__loff)&#123;
        const char * const buf = (char*)buffer;
        int count;

        spin_lock(&amp;spin);

        if(p_w_module_mode == NOT_INIT)&#123;
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to NOT_INIT...&quot;);
                count =  -1;
        &#125;
        else if(p_w_module_mode == READ_ONLY)&#123;
                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to write under the mode READ_ONLY&quot;);
                count = -1;
        &#125;else
                count = copy_from_user(buf,user_buf,size &gt; 0x500?0x500 : size);

        spin_unlock(&amp;spin);

        return count;

&#125;
</code></pre>
<p>这里强烈建议大家跟着码一便，代码不是很长，在写的过程中你就可以懂这里的机制了。<br>这里我讲解一下，当我们注册了这个设备后，由于咱们再file_operations中已经定义了系统调用的函数指针，所以此时也就是调用咱们的实现了，就这么简单，然后这里的ioctl就是设置通信的权限等了。<br>咱们来编译试试看<br><img src="http://imgsrc.baidu.com/super/pic/item/8435e5dde71190ef577c831d8b1b9d16fcfa6068.jpg" srcset="/img/loading.gif" lazyload><br><img src="http://imgsrc.baidu.com/super/pic/item/c2cec3fdfc039245b233f0cdc294a4c27c1e2569.jpg" srcset="/img/loading.gif" lazyload></p>
<h4 id="4-测试一下咱们写的’驱动’"><a href="#4-测试一下咱们写的’驱动’" class="headerlink" title="4.测试一下咱们写的’驱动’"></a>4.测试一下咱们写的’驱动’</h4><p>c代码如下，十分简单</p>
<pre><code class="hljs">#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;sys/ioctl.h&gt;

char * buf = &quot;test for read and write..&quot;;

int main(void)&#123;
        char ch[0x100];
        int fd = open(&quot;/dev/peiwithhao&quot;,2);
        int len = strlen(buf);
        ioctl(fd,0x1000,NULL);                        //READ_ONLY

        write(fd,buf,len);
        ioctl(fd,0x1001,NULL);                        //ALLOW_WRITE
        write(fd,buf,len);
        read(fd,ch,len);
        write(0,ch,len);

        ioctl(fd,0x1002,NULL);                        //BUFFER_RESET
        read(fd,ch,len);
        write(0,ch,len);

        close(fd);
        return 0;

&#125;
</code></pre>
<p>简单链接后执行，<br><img src="http://imgsrc.baidu.com/forum/pic/item/bd315c6034a85edfb973efe10c540923dc547570.jpg" srcset="/img/loading.gif" lazyload><br>大伙可能初看没什么，但是注意这里咱们并没用使用printf函数，这里的输出是再内核中将我们输入缓冲区的值再输出出来。<br>我们再用dmesg看看<br><img src="http://imgsrc.baidu.com/forum/pic/item/35a85edf8db1cb137f9c2dd19854564e93584b7e.jpg" srcset="/img/loading.gif" lazyload><br>大获全胜！！！！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过一晚上的折腾，对于内核编程有了初步的认知，不会像之前那样摸不着头脑，在这里感谢arttnba3师傅博客的指点。</p>
<blockquote>
<p>师傅的隐秘小屋<br><a target="_blank" rel="noopener" href="https://arttnba3.cn/">https://arttnba3.cn/</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux-Kernel/" class="category-chain-item">Linux Kernel</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/pwn/">#pwn</a>
      
        <a href="/tags/kernel/">#kernel</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux_Kernel_0x01_LKMmaker</div>
      <div>https://peiandhao.github.io/2023/06/20/Linux-Kernel-0x01-LKMmaker/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>peiwithhao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/20/Linux-Kernel-0x00-Base/" title="Linux_Kernel_0x00_Base">
                        <span class="hidden-mobile">Linux_Kernel_0x00_Base</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Afm6UeM0VL6RfMOLAgwtyxs8-gzGzoHsz","appKey":"Vr60qrZIptqhJaXqWvDEknkH","path":"window.location.pathname","placeholder":"锐评一下","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Pei</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Hao</span></a> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/DynamicLine.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
