

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="peiwithhao">
  <meta name="keywords" content="">
  
    <meta name="description" content="看好了，格里沙，物理内存是这样用的！">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux_memory_manegement">
<meta property="og:url" content="https://peiandhao.github.io/2023/06/17/Linux-memory-manegement/index.html">
<meta property="og:site_name" content="peiwithhao&#39;s Valhalla">
<meta property="og:description" content="看好了，格里沙，物理内存是这样用的！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://peiandhao.github.io/img/linuxmm.jpg">
<meta property="article:published_time" content="2023-06-17T09:08:00.000Z">
<meta property="article:modified_time" content="2023-06-17T09:16:17.464Z">
<meta property="article:author" content="peiwithhao">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="source">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://peiandhao.github.io/img/linuxmm.jpg">
  
  
  
  <title>Linux_memory_manegement - peiwithhao&#39;s Valhalla</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"peiandhao.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"text"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Afm6UeM0VL6RfMOLAgwtyxs8-gzGzoHsz","app_key":"Vr60qrZIptqhJaXqWvDEknkH","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>p3ivv1+h@0</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/linuxmm.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux_memory_manegement"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        peiwithhao
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-17 17:08" pubdate>
          2023年6月17日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          41k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          340 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux_memory_manegement</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Linux内存管理源码分析"><a href="#Linux内存管理源码分析" class="headerlink" title="Linux内存管理源码分析"></a>Linux内存管理源码分析</h1><p>内核pwn学到UAF，发现又不太行了，虽说之前操作系统的知识没啥问题了，但是这里对于目前市面上的内存管理还是不了解，因此在这里再来浅浅分析一下，整体的数据部分，Linux采用<code>node</code>、<code>zone</code>、<code>page</code>三级表示，接下来我们来分别叙述，这里若涉及到源码大家可以点击下面链接查看Linux内核相应版本查看</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.11.22/source">Linux 内核源码</a></p>
<p>本篇主要是个人跟随着arttnba3师傅：</p>
<p><a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/">arttnba3</a></p>
<p>和cft56200_ln师傅：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/caofengtao1314/article/details/117321692?spm=1001.2014.3001.5502">cft56200_ln</a></p>
<h2 id="1-数据结构部分"><a href="#1-数据结构部分" class="headerlink" title="1. 数据结构部分"></a>1. 数据结构部分</h2><h3 id="node节点"><a href="#node节点" class="headerlink" title="node节点"></a>node节点</h3><p>我们首先需要知道，对于内存访问架构来讲，一般CPU都可以分为以下两种方式：</p>
<ul>
<li>UMA(一致性内存访问，Uniform Memory Access)，表示全局就一个<code>node</code>，且多个CPU通过1跟总线访问内存，且访问时间一致，类似SMP</li>
<li>NUMA(非一致性内存访问，Not-Uniform Memory Access)，每个CPU分配一块内存，存在多个<code>node</code>，且再不同情况下使用访问时间有所区别。</li>
</ul>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/fc1f4134970a304e84a7453394c8a786c8175c76.jpg" srcset="/img/loading.gif" lazyload></p>
<p>而<code>node</code>的结构体是采用<code>pglist_data</code>结构进行描述，定义在<code>/include/linux/mmzone.h</code>,如下：</p>
<pre><code class="hljs">/*
 * On NUMA machines, each NUMA node would have a pg_data_t to describe
 * it&#39;s memory layout. On UMA machines there is a single pglist_data which
 * describes the whole memory.（NUMA架构每个node都有个此结构来描述内存布局，而UMA就一个）
 *
 * Memory statistics and page replacement data structures are maintained on a
 * per-zone basis.
 */
typedef struct pglist_data &#123;
    /*
     * node_zones contains just the zones for THIS node. Not all of the
     * zones may be populated, but it is the full list. It is referenced by
     * this node&#39;s node_zonelists as well as other node&#39;s node_zonelists.
     */
    struct zone node_zones[MAX_NR_ZONES];

    /*
     * node_zonelists contains references to all zones in all nodes.
     * Generally the first zones will be references to this node&#39;s
     * node_zones.
     */
    struct zonelist node_zonelists[MAX_ZONELISTS];

    int nr_zones; /* number of populated zones in this node */
#ifdef CONFIG_FLAT_NODE_MEM_MAP	/* means !SPARSEMEM */
    struct page *node_mem_map;
#ifdef CONFIG_PAGE_EXTENSION
    struct page_ext *node_page_ext;
#endif
#endif
#if defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)
    /*
     * Must be held any time you expect node_start_pfn,
     * node_present_pages, node_spanned_pages or nr_zones to stay constant.
     * Also synchronizes pgdat-&gt;first_deferred_pfn during deferred page
     * init.
     *
     * pgdat_resize_lock() and pgdat_resize_unlock() are provided to
     * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG
     * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.
     *
     * Nests above zone-&gt;lock and zone-&gt;span_seqlock
     */
    spinlock_t node_size_lock;
#endif
    unsigned long node_start_pfn;
    unsigned long node_present_pages; /* total number of physical pages */
    unsigned long node_spanned_pages; /* total size of physical page
                         range, including holes */
    int node_id;
    wait_queue_head_t kswapd_wait;
    wait_queue_head_t pfmemalloc_wait;
    struct task_struct *kswapd;	/* Protected by
                       mem_hotplug_begin/end() */
    int kswapd_order;
    enum zone_type kswapd_highest_zoneidx;

    int kswapd_failures;		/* Number of &#39;reclaimed == 0&#39; runs */

#ifdef CONFIG_COMPACTION
    int kcompactd_max_order;
    enum zone_type kcompactd_highest_zoneidx;
    wait_queue_head_t kcompactd_wait;
    struct task_struct *kcompactd;
#endif
    /*
     * This is a per-node reserve of pages that are not available
     * to userspace allocations.
     */
    unsigned long		totalreserve_pages;

#ifdef CONFIG_NUMA
    /*
     * node reclaim becomes active if more unmapped pages exist.
     */
    unsigned long		min_unmapped_pages;
    unsigned long		min_slab_pages;
#endif /* CONFIG_NUMA */

    /* Write-intensive fields used by page reclaim */
    ZONE_PADDING(_pad1_)
    spinlock_t		lru_lock;

#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
    /*
     * If memory initialisation on large machines is deferred then this
     * is the first PFN that needs to be initialised.
     */
    unsigned long first_deferred_pfn;
#endif /* CONFIG_DEFERRED_STRUCT_PAGE_INIT */

#ifdef CONFIG_TRANSPARENT_HUGEPAGE
    struct deferred_split deferred_split_queue;
#endif

    /* Fields commonly accessed by the page reclaim scanner */

    /*
     * NOTE: THIS IS UNUSED IF MEMCG IS ENABLED.
     *
     * Use mem_cgroup_lruvec() to look up lruvecs.
     */
    struct lruvec		__lruvec;

    unsigned long		flags;

    ZONE_PADDING(_pad2_)

    /* Per-node vmstats */
    struct per_cpu_nodestat __percpu *per_cpu_nodestats;
    atomic_long_t		vm_stat[NR_VM_NODE_STAT_ITEMS];
&#125; pg_data_t;
</code></pre>
<p>下面单独指出一些重要字段：</p>
<ul>
<li><strong>node_zones</strong>:node_zones contains just the zones for THIS node. Not all of the zones may be populated, but it is the full list. It is referenced by this node’s node_zonelists as well as other node’s node_zonelists.说人话，他是一个<code>struct zone</code>类型的数组，包含了仅仅这个<code>node</code>下的所有的<code>zone</code>,这里注意并非所有<code>zone</code>都被填充，但是他是已经被充满了，他被下面即将讲到的一个链表节点<code>node_zonelists</code>和其他<code>node</code>的<code>node_zonelists</code>引用；</li>
<li><strong>node_zonelists</strong>:不标英语了，看着烦人，这里我直接写他的含义，他的定义是为了确定内存分配的时候对备用<code>zone</code>的搜索顺序，他同时可以包含非本<code>node</code>的<code>zone</code>，普遍他的第一个<code>zone</code>链接的是本<code>node</code>下的<code>zone</code>数组第一个，其实这个<code>struct zonelist</code>就是一个指向<code>zone</code>的指针加上其他元素，我们可以看看他的数据结构，这里直接引用<code>arttnba3</code>师傅的笔记，</li>
</ul>
<p>如下：</p>
<pre><code class="hljs">/*
 * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表，
 * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。
 *
 * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。
 * 用来访问所给的 zoneref 结构体信息的帮助函数有：
 *
 * zonelist_zone()	- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry
 * zonelist_zone_idx()	- 返回作为 entry 的 zone 的 index
 * zonelist_node_idx()	- 返回作为 entry 的 node 的 index
 */
struct zonelist &#123;
    struct zoneref _zonerefs[MAX_ZONES_PER_ZONELIST + 1];
&#125;;
</code></pre>
<p>   其中是一个<code>struct zoneref</code>数组，接下来再看看其中的结构</p>
<pre><code class="hljs">/*
 * 该结构包含了 zonelist 中一个 zone 的信息。 
 * 其被储存在这里以预防对大结构体的解引用与对表的查询。
 */
struct zoneref &#123;
    struct zone *zone;	/* 指向实际上的 zone 的指针 */
    int zone_idx;		/* zone_idx(zoneref-&gt;zone) */
&#125;;
</code></pre>
<p>   可以看到其就是一个指针而已</p>
<ul>
<li><strong>nr_zones</strong>:记录了该<code>node</code>中所有可用的<code>zone</code>数量</li>
<li><strong>node_start_pfn</strong>：<code>node</code>起始页的页框标号，这里的<code>pfn</code>我们在之后讲解，这里可以理解为该<code>node</code>所在的物理地址</li>
<li><strong>node_present_pages</strong>：<code>node</code>中物理页的总数量</li>
<li><strong>unsighnd long node_spanned_pages</strong>:<code>node</code>中物理页的总大小</li>
<li><strong>node_id</strong>：记录该<code>node</code>在系统中的标号，从0开始</li>
</ul>
<p>知道了其中的一些数据结构，接下来我们了解一下<code>node</code>的存储方式：我们可以在上面的网站中查找源码，在<code>/arch/x86/mm/numa.c</code>中看到其中定义了一个<code>pglist_data</code>的全局数组<code>node_data[]</code></p>
<pre><code class="hljs">struct pglist_data *node_data[MAX_NUMNODES] __read_mostly;
EXPORT_SYMBOL(node_data);
</code></pre>
<p>其中包含我们的所有<code>node</code>,下面来一个好图，为啥大伙画图都这么专业捏<br><img src="http://imgsrc.baidu.com/forum/pic/item/279759ee3d6d55fbada192ef28224f4a21a4dd90.jpg" srcset="/img/loading.gif" lazyload></p>
<p>当我们知晓了<code>node</code>节点的存储方式，我们需要另一个数组<code>node_status</code>来描述对应<code>node</code>节点的状态，他定义在<code>/mm/page_alloc.c</code>当中，也是一个全局数组（我是真佩服写Linux的这一群大佬，这文件的分布情况跟我自己写的那个操作系统相比简直天壤之别阿）</p>
<pre><code class="hljs">/*
 * Array of node states.
 */
nodemask_t node_states[NR_NODE_STATES] __read_mostly = &#123;
    [N_POSSIBLE] = NODE_MASK_ALL,
    [N_ONLINE] = &#123; &#123; [0] = 1UL &#125; &#125;,
#ifndef CONFIG_NUMA
    [N_NORMAL_MEMORY] = &#123; &#123; [0] = 1UL &#125; &#125;,
#ifdef CONFIG_HIGHMEM
    [N_HIGH_MEMORY] = &#123; &#123; [0] = 1UL &#125; &#125;,
#endif
    [N_MEMORY] = &#123; &#123; [0] = 1UL &#125; &#125;,
    [N_CPU] = &#123; &#123; [0] = 1UL &#125; &#125;,
#endif	/* NUMA */
&#125;;
EXPORT_SYMBOL(node_states);
</code></pre>
<p>而我们的<code>node_states</code>类型保存在<code>/include/linux/nodemask.h</code>,这里仍然直接引用<code>arttnba3</code>师傅</p>
<pre><code class="hljs">/*
 * 位掩码将为所有节点保存
 */
enum node_states &#123;
    N_POSSIBLE,        /* 节点在某个时刻是联机的 */
    N_ONLINE,        /* 节点是联机的 */
    N_NORMAL_MEMORY,    /* 节点有着普通的内存 */
#ifdef CONFIG_HIGHMEM
    N_HIGH_MEMORY,        /* 节点有着普通或高端内存 */
#else
    N_HIGH_MEMORY = N_NORMAL_MEMORY,
#endif
    N_MEMORY,        /* 节点有着内存(普通，高端，可移动) */
    N_CPU,        /* 节点有着一个或多个 cpu */
    N_GENERIC_INITIATOR,    /* 节点有一个或多个 Generic Initiators */
    NR_NODE_STATES
&#125;;
</code></pre>
<p>说完node，我来绘个图吧，这里老抄作业好像体现不出自己真正学到了东西<br><img src="http://imgsrc.baidu.com/forum/pic/item/4d086e061d950a7b0985aa0d4fd162d9f3d3c943.jpg" srcset="/img/loading.gif" lazyload></p>
<p>我们将在之后一步一步慢慢完善这个图片</p>
<h3 id="zone区域"><a href="#zone区域" class="headerlink" title="zone区域"></a>zone区域</h3><p>同样的，先说其数据结构<code>struct zone</code>，他位于<code>/include/linux/mmzone.h</code></p>
<pre><code class="hljs">struct zone &#123;
    /* Read-mostly fields */

    /* zone watermarks, access with *_wmark_pages(zone) macros */
    unsigned long _watermark[NR_WMARK];
    unsigned long watermark_boost;

    unsigned long nr_reserved_highatomic;

    /*
     * We don&#39;t know if the memory that we&#39;re going to allocate will be
     * freeable or/and it will be released eventually, so to avoid totally
     * wasting several GB of ram we must reserve some of the lower zone
     * memory (otherwise we risk to run OOM on the lower zones despite
     * there being tons of freeable ram on the higher zones).  This array is
     * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl
     * changes.
     */
    long lowmem_reserve[MAX_NR_ZONES];

#ifdef CONFIG_NUMA
    int node;
#endif
    struct pglist_data	*zone_pgdat;
    struct per_cpu_pageset __percpu *pageset;
    /*
     * the high and batch values are copied to individual pagesets for
     * faster access
     */
    int pageset_high;
    int pageset_batch;

#ifndef CONFIG_SPARSEMEM
    /*
     * Flags for a pageblock_nr_pages block. See pageblock-flags.h.
     * In SPARSEMEM, this map is stored in struct mem_section
     */
    unsigned long		*pageblock_flags;
#endif /* CONFIG_SPARSEMEM */

    /* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */
    unsigned long		zone_start_pfn;

    /*
     * spanned_pages is the total pages spanned by the zone, including
     * holes, which is calculated as:
     * 	spanned_pages = zone_end_pfn - zone_start_pfn;
     *
     * present_pages is physical pages existing within the zone, which
     * is calculated as:
     *	present_pages = spanned_pages - absent_pages(pages in holes);
     *
     * managed_pages is present pages managed by the buddy system, which
     * is calculated as (reserved_pages includes pages allocated by the
     * bootmem allocator):
     *	managed_pages = present_pages - reserved_pages;
     *
     * So present_pages may be used by memory hotplug or memory power
     * management logic to figure out unmanaged pages by checking
     * (present_pages - managed_pages). And managed_pages should be used
     * by page allocator and vm scanner to calculate all kinds of watermarks
     * and thresholds.
     *
     * Locking rules:
     *
     * zone_start_pfn and spanned_pages are protected by span_seqlock.
     * It is a seqlock because it has to be read outside of zone-&gt;lock,
     * and it is done in the main allocator path.  But, it is written
     * quite infrequently.
     *
     * The span_seq lock is declared along with zone-&gt;lock because it is
     * frequently read in proximity to zone-&gt;lock.  It&#39;s good to
     * give them a chance of being in the same cacheline.
     *
     * Write access to present_pages at runtime should be protected by
     * mem_hotplug_begin/end(). Any reader who can&#39;t tolerant drift of
     * present_pages should get_online_mems() to get a stable value.
     */
    atomic_long_t		managed_pages;
    unsigned long		spanned_pages;
    unsigned long		present_pages;

    const char		*name;

#ifdef CONFIG_MEMORY_ISOLATION
    /*
     * Number of isolated pageblock. It is used to solve incorrect
     * freepage counting problem due to racy retrieving migratetype
     * of pageblock. Protected by zone-&gt;lock.
     */
    unsigned long		nr_isolate_pageblock;
#endif

#ifdef CONFIG_MEMORY_HOTPLUG
    /* see spanned/present_pages for more description */
    seqlock_t		span_seqlock;
#endif

    int initialized;

    /* Write-intensive fields used from the page allocator */
    ZONE_PADDING(_pad1_)

    /* free areas of different sizes */
    struct free_area	free_area[MAX_ORDER];

    /* zone flags, see below */
    unsigned long		flags;

    /* Primarily protects free_area */
    spinlock_t		lock;

    /* Write-intensive fields used by compaction and vmstats. */
    ZONE_PADDING(_pad2_)

    /*
     * When free pages are below this point, additional steps are taken
     * when reading the number of free pages to avoid per-cpu counter
     * drift allowing watermarks to be breached
     */
    unsigned long percpu_drift_mark;

#if defined CONFIG_COMPACTION || defined CONFIG_CMA
    /* pfn where compaction free scanner should start */
    unsigned long		compact_cached_free_pfn;
    /* pfn where compaction migration scanner should start */
    unsigned long		compact_cached_migrate_pfn[ASYNC_AND_SYNC];
    unsigned long		compact_init_migrate_pfn;
    unsigned long		compact_init_free_pfn;
#endif

#ifdef CONFIG_COMPACTION
    /*
     * On compaction failure, 1&lt;&lt;compact_defer_shift compactions
     * are skipped before trying again. The number attempted since
     * last failure is tracked with compact_considered.
     * compact_order_failed is the minimum compaction failed order.
     */
    unsigned int		compact_considered;
    unsigned int		compact_defer_shift;
    int			compact_order_failed;
#endif

#if defined CONFIG_COMPACTION || defined CONFIG_CMA
    /* Set to true when the PG_migrate_skip bits should be cleared */
    bool			compact_blockskip_flush;
#endif

    bool			contiguous;

    ZONE_PADDING(_pad3_)
    /* Zone statistics */
    atomic_long_t		vm_stat[NR_VM_ZONE_STAT_ITEMS];
    atomic_long_t		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];
&#125; ____cacheline_internodealigned_in_smp;
</code></pre>
<p>同样地，我们来了解其中比较重要的字段</p>
<ul>
<li><strong>_watermark</strong> 水位线，一般表示剩余空闲页框，他又三个挡位，分别是<code>WMARK_MIN</code>,<code>WMARK_LOW</code>,<code>WMARK_HIGH</code>，他存放在<code>_watermark</code>数组当中，进行内存分配的时候，分配器会根据当前水位来采取不同的措施，下面搞个图：</li>
</ul>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/38dbb6fd5266d016ce8f7ae1d22bd40734fa3561.jpg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>lowmem_reserve</strong>:当本<code>zone</code>没有空闲块之后，会到别的<code>zone</code>中进行分配，避免分配内存全分配在低端<code>zone</code>，而我们不能保证这里分配的内存是可释放，或者最终会被释放的，出现低端<code>zone</code>区域内存提前耗尽，而高端<code>zone</code>区保留大量内存，因此声名该字段来保留一段内存，而这里的<code>zone</code>区内存是其他<code>zone</code>不能打扰的</p>
</li>
<li><p><strong>node</strong>:标识该<code>zone</code>所属<code>node</code>，当然，这里只在<code>NUMA</code>启动，<code>UMA</code>中只有一个<code>node</code>，不需要这个字段</p>
</li>
<li><p><strong>zone_pgdat</strong>:标识所属的<code>pglist_data</code>节点，同上面的<code>node</code></p>
</li>
<li><p><strong>pageset</strong>：由于目前都是多处理器CPU架构，因此对于临界区的同步互斥访问就是一个严重的问题，而防止出错的办法之一加锁解锁十分浪费资源，因此每个<code>zone</code>当中都为每一个CPU准备一个单独的页面仓库，最开始<code>buddy system</code>会首先将页面放置在各个CPU独自的页面仓库当中，需要进行分配的时候优先从其中分配，其类型结构体位于<code>/include/linux/mmzone.h</code></p>
<pre><code class="hljs">  struct per_cpu_pages &#123;
      int count;		/* number of pages in the list */
      int high;		/* high watermark, emptying needed */
      int batch;		/* chunk size for buddy add/remove */
  
      /* Lists of pages, one per migrate type stored on the pcp-lists */
      struct list_head lists[MIGRATE_PCPTYPES]; //双链表指针数组，指向空闲页们
  &#125;;
  struct per_cpu_pageset &#123;
      struct per_cpu_pages pcp;
  #ifdef CONFIG_NUMA
      s8 expire;
      u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];
  #endif
  #ifdef CONFIG_SMP
      s8 stat_threshold;
      s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];
  #endif
  &#125;;
</code></pre>
<p>  此结构是一个包括状态，他会被存放在每个CPU独立的<code>.data..percpu</code>段当中，下面再再再次引用<code>arttnba3</code>师傅的图，真的态🐂辣</p>
</li>
</ul>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/902397dda144ad340c83614e95a20cf431ad853f.jpg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>zone_start_pfn</strong>：该<code>zone</code>的起始物理地址编号pfn(page frame number)</p>
</li>
<li><p><strong>spanned_pages</strong>：本<code>zone</code>区域中内存的<code>page</code>总数</p>
</li>
<li><p><strong>present_pages</strong>：本<code>zone</code>中实际存在的物理页框数</p>
</li>
<li><p><strong>managed_pages</strong>：本<code>zone</code>中<code>buddy system</code>管理的页面数量</p>
</li>
<li><p><strong>free_area</strong>：<code>buddy_system</code>按照<code>order</code>管理的页面，为一个<code>free_area</code>结构体数组，具体定义如下：</p>
<pre><code class="hljs">  struct free_area &#123;
      struct list_head    free_list[MIGRATE_TYPES];
      unsigned long        nr_free;
  &#125;;
</code></pre>
</li>
</ul>
<p>看图好吧,这个<code>order</code>起始就是伙伴系统中的对于不同大小页分配的请求大小</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/f3d3572c11dfa9ec9b54b0de27d0f703908fc185.jpg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>flags</strong>：标识<code>zone</code>的状态</p>
</li>
<li><p><strong>vm_stat</strong>：统计数据，这里是一个数组，而数组大小取决于定义的枚举类型，如下：</p>
<pre><code class="hljs">  enum zone_stat_item &#123;
      /* First 128 byte cacheline (assuming 64 bit words) */
      NR_FREE_PAGES,
      NR_ZONE_LRU_BASE, /* Used only for compaction and reclaim retry */
      NR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,
      NR_ZONE_ACTIVE_ANON,
      NR_ZONE_INACTIVE_FILE,
      NR_ZONE_ACTIVE_FILE,
      NR_ZONE_UNEVICTABLE,
      NR_ZONE_WRITE_PENDING,	/* Count of dirty, writeback and unstable pages */
      NR_MLOCK,		/* mlock()ed pages found and moved off LRU */
      /* Second 128 byte cacheline */
      NR_BOUNCE,
  #if IS_ENABLED(CONFIG_ZSMALLOC)
      NR_ZSPAGES,		/* allocated in zsmalloc */
  #endif
      NR_FREE_CMA_PAGES,
      NR_VM_ZONE_STAT_ITEMS &#125;;
</code></pre>
</li>
</ul>
<p>讲完一般结构，这里需要注意，虽说我们的<code>node</code>节点中直接就是一个<code>zone</code>数组，但他们之间是有区别的，此在<code>/include/linux/mmzone.h</code>中有定义：</p>
<pre><code class="hljs">enum zone_type &#123;
    /*
     * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able
     * to DMA to all of the addressable memory (ZONE_NORMAL).
     * On architectures where this area covers the whole 32 bit address
     * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller
     * DMA addressing constraints. This distinction is important as a 32bit
     * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit
     * platforms may need both zones as they support peripherals with
     * different DMA addressing limitations.
     */
#ifdef CONFIG_ZONE_DMA
    ZONE_DMA,
#endif
#ifdef CONFIG_ZONE_DMA32
    ZONE_DMA32,
#endif
    /*
     * Normal addressable memory is in ZONE_NORMAL. DMA operations can be
     * performed on pages in ZONE_NORMAL if the DMA devices support
     * transfers to all addressable memory.
     */
    ZONE_NORMAL,
#ifdef CONFIG_HIGHMEM
    /*
     * A memory area that is only addressable by the kernel through
     * mapping portions into its own address space. This is for example
     * used by i386 to allow the kernel to address the memory beyond
     * 900MB. The kernel will set up special mappings (page
     * table entries on i386) for each page that the kernel needs to
     * access.
     */
    ZONE_HIGHMEM,
#endif
    /*
     * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains
     * movable pages with few exceptional cases described below. Main use
     * cases for ZONE_MOVABLE are to make memory offlining/unplug more
     * likely to succeed, and to locally limit unmovable allocations - e.g.,
     * to increase the number of THP/huge pages. Notable special cases are:
     *
     * 1. Pinned pages: (long-term) pinning of movable pages might
     *    essentially turn such pages unmovable. Memory offlining might
     *    retry a long time.
     * 2. memblock allocations: kernelcore/movablecore setups might create
     *    situations where ZONE_MOVABLE contains unmovable allocations
     *    after boot. Memory offlining and allocations fail early.
     * 3. Memory holes: kernelcore/movablecore setups might create very rare
     *    situations where ZONE_MOVABLE contains memory holes after boot,
     *    for example, if we have sections that are only partially
     *    populated. Memory offlining and allocations fail early.
     * 4. PG_hwpoison pages: while poisoned pages can be skipped during
     *    memory offlining, such pages cannot be allocated.
     * 5. Unmovable PG_offline pages: in paravirtualized environments,
     *    hotplugged memory blocks might only partially be managed by the
     *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The
     *    parts not manged by the buddy are unmovable PG_offline pages. In
     *    some cases (virtio-mem), such pages can be skipped during
     *    memory offlining, however, cannot be moved/allocated. These
     *    techniques might use alloc_contig_range() to hide previously
     *    exposed pages from the buddy again (e.g., to implement some sort
     *    of memory unplug in virtio-mem).
     *
     * In general, no unmovable allocations that degrade memory offlining
     * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())
     * have to expect that migrating pages in ZONE_MOVABLE can fail (even
     * if has_unmovable_pages() states that there are no unmovable pages,
     * there can be false negatives).
     */
    ZONE_MOVABLE,
#ifdef CONFIG_ZONE_DEVICE
    ZONE_DEVICE,
#endif
    __MAX_NR_ZONES

&#125;;
</code></pre>
<p>这里x86分别32位与64位都会有所区别，如下：<br>在32位中，<code>zone</code>可以分为<code>ZONE_DMA</code>、<code>ZONE_NORMAL</code>、<code>ZONE_HIGHMEM</code>，他们分别对应的起始和终止地址为</p>
<p><code>ZONE_DMA</code>：0~16MB</p>
<p><code>ZONE_NORMAL</code>：16~896MB</p>
<p><code>ZONE_HIGHMEM</code>:896~…MB</p>
<p>以上前两种类型是线性映射，也就是这里是直接映射的，也就是说存在虚拟地址就是物理地址的情形，后面的高端内存是不连续的</p>
<p>在64位中有所区别，<code>zone</code>分为如下三种</p>
<p><code>ZONE_DMA</code>：0~16MB</p>
<p><code>ZONE_DMA32</code>：16~4GB</p>
<p><code>ZONE_NORMAL</code>:4GB~…</p>
<p>内核中取消了高端内存的概念，接着上面咱们画的图，这里我们把<code>zone</code>补上</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/35a85edf8db1cb13cef9dada9854564e93584b63.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="page页框"><a href="#page页框" class="headerlink" title="page页框"></a>page页框</h3><p>终于来到了咱们的页框，这里的<code>page</code>对应的是物理页框而不是虚拟页，注意漏。<br>他对应的数据结构是<code>struct page</code>，位于<code>/include/linux/mm_types.h</code>如下：</p>
<pre><code class="hljs">struct page &#123;
    unsigned long flags;		/* Atomic flags, some possibly
                     * updated asynchronously */
    /*
     * Five words (20/40 bytes) are available in this union.
     * WARNING: bit 0 of the first word is used for PageTail(). That
     * means the other users of this union MUST NOT use the bit to
     * avoid collision and false-positive PageTail().
     */
    union &#123;
        struct &#123;	/* Page cache and anonymous pages */
            /**
             * @lru: Pageout list, eg. active_list protected by
             * lruvec-&gt;lru_lock.  Sometimes used as a generic list
             * by the page owner.
             */
            struct list_head lru;
            /* See page-flags.h for PAGE_MAPPING_FLAGS */
            struct address_space *mapping;
            pgoff_t index;		/* Our offset within mapping. */
            /**
             * @private: Mapping-private opaque data.
             * Usually used for buffer_heads if PagePrivate.
             * Used for swp_entry_t if PageSwapCache.
             * Indicates order in the buddy system if PageBuddy.
             */
            unsigned long private;
        &#125;;
        struct &#123;	/* page_pool used by netstack */
            /**
             * @dma_addr: might require a 64-bit value on
             * 32-bit architectures.
             */
            unsigned long dma_addr[2];
        &#125;;
        struct &#123;	/* slab, slob and slub */
            union &#123;
                struct list_head slab_list;
                struct &#123;	/* Partial pages */
                    struct page *next;
#ifdef CONFIG_64BIT
                    int pages;	/* Nr of pages left */
                    int pobjects;	/* Approximate count */
#else
                    short int pages;
                    short int pobjects;
#endif
                &#125;;
            &#125;;
            struct kmem_cache *slab_cache; /* not slob */
            /* Double-word boundary */
            void *freelist;		/* first free object */
            union &#123;
                void *s_mem;	/* slab: first object */
                unsigned long counters;		/* SLUB */
                struct &#123;			/* SLUB */
                    unsigned inuse:16;
                    unsigned objects:15;
                    unsigned frozen:1;
                &#125;;
            &#125;;
        &#125;;
        struct &#123;	/* Tail pages of compound page */
            unsigned long compound_head;	/* Bit zero is set */

            /* First tail page only */
            unsigned char compound_dtor;
            unsigned char compound_order;
            atomic_t compound_mapcount;
            unsigned int compound_nr; /* 1 &lt;&lt; compound_order */
        &#125;;
        struct &#123;	/* Second tail page of compound page */
            unsigned long _compound_pad_1;	/* compound_head */
            atomic_t hpage_pinned_refcount;
            /* For both global and memcg */
            struct list_head deferred_list;
        &#125;;
        struct &#123;	/* Page table pages */
            unsigned long _pt_pad_1;	/* compound_head */
            pgtable_t pmd_huge_pte; /* protected by page-&gt;ptl */
            unsigned long _pt_pad_2;	/* mapping */
            union &#123;
                struct mm_struct *pt_mm; /* x86 pgds only */
                atomic_t pt_frag_refcount; /* powerpc */
            &#125;;
#if ALLOC_SPLIT_PTLOCKS
            spinlock_t *ptl;
#else
            spinlock_t ptl;
#endif
        &#125;;
        struct &#123;	/* ZONE_DEVICE pages */
            /** @pgmap: Points to the hosting device page map. */
            struct dev_pagemap *pgmap;
            void *zone_device_data;
            /*
             * ZONE_DEVICE private pages are counted as being
             * mapped so the next 3 words hold the mapping, index,
             * and private fields from the source anonymous or
             * page cache page while the page is migrated to device
             * private memory.
             * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also
             * use the mapping, index, and private fields when
             * pmem backed DAX files are mapped.
             */
        &#125;;

        /** @rcu_head: You can use this to free a page by RCU. */
        struct rcu_head rcu_head;
    &#125;;

    union &#123;		/* This union is 4 bytes in size. */
        /*
         * If the page can be mapped to userspace, encodes the number
         * of times this page is referenced by a page table.
         */
        atomic_t _mapcount;

        /*
         * If the page is neither PageSlab nor mappable to userspace,
         * the value stored here may help determine what this page
         * is used for.  See page-flags.h for a list of page types
         * which are currently stored here.
         */
        unsigned int page_type;

        unsigned int active;		/* SLAB */
        int units;			/* SLOB */
    &#125;;

    /* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */
    atomic_t _refcount;

#ifdef CONFIG_MEMCG
    unsigned long memcg_data;
#endif

    /*
     * On machines where all RAM is mapped into kernel address space,
     * we can simply calculate the virtual address. On machines with
     * highmem some memory is mapped into kernel virtual memory
     * dynamically, so we need a place to store that address.
     * Note that this field could be 16 bits on x86 ... ;)
     *
     * Architectures with slow multiplication can define
     * WANT_PAGE_VIRTUAL in asm/page.h
     */
#if defined(WANT_PAGE_VIRTUAL)
    void *virtual;			/* Kernel virtual address (NULL if
                       not kmapped, ie. highmem) */
#endif /* WANT_PAGE_VIRTUAL */

#ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS
    int _last_cpupid;
#endif
&#125; _struct_page_alignment;
</code></pre>
<p>老样子，先解释关键字段</p>
<ul>
<li><p><strong>lru</strong>：最近未使用页这个概念在计算机组成原理或者说操作系统课程里面都会讲解，这里也就不过多描述，在linux内核当中，page通过该字段来组织成链表</p>
</li>
<li><p><strong>slab相关</strong>：用来存放<code>slab</code>相关成员</p>
<pre><code class="hljs">  struct &#123;    /* slab, slob and slub */
              union &#123;
                  struct list_head slab_list;
                  struct &#123;    /* Partial pages */
                      struct page *next;
  #ifdef CONFIG_64BIT
                      int pages;  /* Nr of pages left */
                      int pobjects;   /* Approximate count */
  #else
                      short int pages;   	
                      short int pobjects;
  #endif
                  &#125;;
              &#125;;
              struct kmem_cache *slab_cache; /* not slob */
              /* Double-word boundary */
              void *freelist;     /* first free object */
              union &#123;
                  void *s_mem;    /* slab: first object */
                  unsigned long counters;     /* SLUB */
                  struct &#123;            /* SLUB */
                      unsigned inuse:16;
                      unsigned objects:15;
                      unsigned frozen:1;
                  &#125;;
              &#125;;
          &#125;;
</code></pre>
</li>
</ul>
<p>下面给出又一张十分详细的图，是由简·李奥师傅所作</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/4ec2d5628535e5dd881a441633c6a7efcf1b62c1.jpg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>flags</strong>：表示该页所处在的状态，定义于<code>include/linux/page-flags.h</code>当中，他是一个枚举类型，如下：</p>
<pre><code class="hljs">  enum pageflags &#123;
      PG_locked,        /* Page is locked. Don&#39;t touch. */
      PG_referenced,
      PG_uptodate,
      PG_dirty,
      PG_lru,
      PG_active,
      PG_workingset,
      PG_waiters,        /* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */
      PG_error,
      PG_slab,
      PG_owner_priv_1,    /* Owner use. If pagecache, fs may use*/
      PG_arch_1,
      PG_reserved,
      PG_private,        /* If pagecache, has fs-private data */
      PG_private_2,        /* If pagecache, has fs aux data */
      PG_writeback,        /* Page is under writeback */
      PG_head,        /* A head page */
      PG_mappedtodisk,    /* Has blocks allocated on-disk */
      PG_reclaim,        /* To be reclaimed asap */
      PG_swapbacked,        /* Page is backed by RAM/swap */
      PG_unevictable,        /* Page is &quot;unevictable&quot;  */
  #ifdef CONFIG_MMU
      PG_mlocked,        /* Page is vma mlocked */
  #endif
  #ifdef CONFIG_ARCH_USES_PG_UNCACHED
      PG_uncached,        /* Page has been mapped as uncached */
  #endif
  #ifdef CONFIG_MEMORY_FAILURE
      PG_hwpoison,        /* hardware poisoned page. Don&#39;t touch */
  #endif
  #if defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)
      PG_young,
      PG_idle,
  #endif
  #ifdef CONFIG_64BIT
      PG_arch_2,
  #endif
      __NR_PAGEFLAGS,
  
      /* Filesystems */
      PG_checked = PG_owner_priv_1,
  
      /* SwapBacked */
      PG_swapcache = PG_owner_priv_1,    /* Swap page: swp_entry_t in private */
  
      /* Two page bits are conscripted by FS-Cache to maintain local caching
       * state.  These bits are set on pages belonging to the netfs&#39;s inodes
       * when those inodes are being locally cached.
       */
      PG_fscache = PG_private_2,    /* page backed by cache */
  
      /* XEN */
      /* Pinned in Xen as a read-only pagetable page. */
      PG_pinned = PG_owner_priv_1,
      /* Pinned as part of domain save (see xen_mm_pin_all()). */
      PG_savepinned = PG_dirty,
      /* Has a grant mapping of another (foreign) domain&#39;s page. */
      PG_foreign = PG_owner_priv_1,
      /* Remapped by swiotlb-xen. */
      PG_xen_remapped = PG_owner_priv_1,
  
      /* SLOB */
      PG_slob_free = PG_private,
  
      /* Compound pages. Stored in first tail page&#39;s flags */
      PG_double_map = PG_workingset,
  
      /* non-lru isolated movable page */
      PG_isolated = PG_reclaim,
  
      /* Only valid for buddy pages. Used to track pages that are reported */
      PG_reported = PG_uptodate,
  &#125;;
</code></pre>
<p>  这里采用的复用的手法，也就是说flags字段还容纳了其他元素，如下，结构划分位于<code>/include/linux/page-flags-layout.h</code>当中</p>
<pre><code class="hljs">  /*
   * page-&gt;flags layout:
   *
   * There are five possibilities for how page-&gt;flags get laid out.  The first
   * pair is for the normal case without sparsemem. The second pair is for
   * sparsemem when there is plenty of space for node and section information.
   * The last is when there is insufficient space in page-&gt;flags and a separate
   * lookup is necessary.
   *
   * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS |
   *      &quot; plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS |
   * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS |
   *      &quot; plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS |
   * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |
   */
</code></pre>
</li>
</ul>
<p> 可以看到在不同布局下他其实是可以用作指向归属的<code>zone</code>和<code>node</code>的</p>
<ul>
<li><p><strong>_mapcount</strong>：记录该页被页表映射的次数，初始值为-1，他是一个根据不同情况所采用的联合结构体，如果说他是被用户空间所映射，那么他会记录被映射的次数，但若是他没被映射到用户空间，页不是<code>PageSlab</code>,那么他为page_type字段，它定义于<code>/include/linux/page-flags.h</code>字段当中，如下：</p>
<pre><code class="hljs">  /*
   * For pages that are never mapped to userspace (and aren&#39;t PageSlab),
   * page_type may be used.  Because it is initialised to -1, we invert the
   * sense of the bit, so __SetPageFoo *clears* the bit used for PageFoo, and
   * __ClearPageFoo *sets* the bit used for PageFoo.  We reserve a few high and
   * low bits so that an underflow or overflow of page_mapcount() won&#39;t be
   * mistaken for a page type value.
   */
  
  #define PAGE_TYPE_BASE    0xf0000000
  /* Reserve        0x0000007f to catch underflows of page_mapcount */
  #define PAGE_MAPCOUNT_RESERVE    -128
  #define PG_buddy    0x00000080
  #define PG_offline    0x00000100
  #define PG_table    0x00000200
  #define PG_guard    0x00000400
</code></pre>
</li>
<li><p><strong>_refcount</strong>：用作该页在内核中的引用次数，初值为0，若大于0表示正在被使用，等于0表示空闲或将要被释放，内核函数<code>get_page()</code>和<code>put_page()</code>函数会来进行引用计数的增减，后者若引用计数器为1则会调用<code>__put_single_page()</code>释放该页面</p>
</li>
<li><p><strong>vitrual</strong>：指向物理页框对应虚拟地址（这里有点疑问那就是他被多个页表映射咋办捏，还是说每次切换进程的时候会刷新一下这里呢？）</p>
</li>
</ul>
<p>说完数据结构，还记得上面<code>flags</code>不同布局下对应的结构吗，linux一般提供了三种内存模型，定义在<code>/include/asm-generic/memory_model.h</code><br><img src="http://imgsrc.baidu.com/forum/pic/item/2fdda3cc7cd98d106098edf8643fb80e7aec90af.jpg" srcset="/img/loading.gif" lazyload></p>
<p>常用模型是<code>sparsemem</code>,所以我们只了解他，中文翻译过来就是离散内存模型。在这个模型下，内存中会存在一个<code>mem_section</code>类型的指针数组，而其中元素指向的<code>mem_section</code>结构体中的<code>section_mem_map</code>成员会指向一个<code>struct page</code>类型的数组，它对应于一个连续的物理地址空间，如下图所示</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/962bd40735fae6cdb11e4aa84ab30f2443a70f55.jpg" srcset="/img/loading.gif" lazyload></p>
<p>其中<code>mem_section</code>结构体的定义在<code>/include/linux/mmzone.h</code>当中，如下：</p>
<pre><code class="hljs">struct mem_section &#123;
    /*
     * This is, logically, a pointer to an array of struct
     * pages.  However, it is stored with some other magic.
     * (see sparse.c::sparse_init_one_section())
     *
     * Additionally during early boot we encode node id of
     * the location of the section here to guide allocation.
     * (see sparse.c::memory_present())
     *
     * Making it a UL at least makes someone do a cast
     * before using it wrong.
     */
    unsigned long section_mem_map;

    struct mem_section_usage *usage;
#ifdef CONFIG_PAGE_EXTENSION
    /*
     * If SPARSEMEM, pgdat doesn&#39;t have page_ext pointer. We use
     * section. (see page_ext.h about this.)
     */
    struct page_ext *page_ext;
    unsigned long pad;
#endif
    /*
     * WARNING: mem_section must be a power-of-2 in size for the
     * calculation and use of SECTION_ROOT_MASK to make sense.
     */
&#125;;
</code></pre>
<p>而我们的全局<code>mem_section</code>数组存放着指向所有<code>struct mem_section</code>结构体的指针，定义于<code>/mm/sparse.c</code>当中：</p>
<pre><code class="hljs">#ifdef CONFIG_SPARSEMEM_EXTREME
struct mem_section **mem_section;
#else
struct mem_section mem_section[NR_SECTION_ROOTS][SECTIONS_PER_ROOT]
    ____cacheline_internodealigned_in_smp;
#endif
</code></pre>
<p>咱们之前说到的数据结构都会使用<code>PFN</code>进行表示物理地址，但实际上他并不是物理地址，而是对应的某一个<code>page</code>的，而<code>pfn</code>的含义就是<code>page frame number</code>，他为每个物理页框所在位置都编了个号。而我们要通过<code>PFN</code>找到<code>page</code>或通过<code>page</code>找到<code>PFN</code>都需要这个<code>mem_section</code>结构体中的<code>section_mem_map</code>来实现。</p>
<h2 id="2-伙伴系统"><a href="#2-伙伴系统" class="headerlink" title="2.伙伴系统"></a>2.伙伴系统</h2><p>我们刚刚已经知道了，每个<code>zone</code>中包含一个<code>free_area</code>数组，其中就是一个个的双链表，且按照了<code>buddy system</code>的<code>order</code>进行管理，<br><img src="http://imgsrc.baidu.com/forum/pic/item/f3d3572c11dfa9ec9b54b0de27d0f703908fc185.jpg" srcset="/img/loading.gif" lazyload></p>
<p>而我们一个<code>free_area</code>中其实并不只有一个双向链表，他是按照不同的<code>migrate type</code>也就是迁移类型进行存放，主要是为了避免内存过于碎片化，如下图：</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/cb8065380cd79123d89a77bde8345982b3b78085.jpg" srcset="/img/loading.gif" lazyload></p>
<p>而这里的页面存在一个迁移类型，这决定了该页是否可以迁移，如下：</p>
<pre><code class="hljs">enum migratetype &#123;
    MIGRATE_UNMOVABLE, 			//不可移动
    MIGRATE_MOVABLE, 			//不可移动
    MIGRATE_RECLAIMABLE, 		//不能直接移动，但可以删除，例如文件映射页
    MIGRATE_PCPTYPES,	/* the number of types on the pcp lists */ //仅限同一节点内移动
    MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,
#ifdef CONFIG_CMA
    /*
     * MIGRATE_CMA migration type is designed to mimic the way
     * ZONE_MOVABLE works.  Only movable pages can be allocated
     * from MIGRATE_CMA pageblocks and page allocator never
     * implicitly change migration type of MIGRATE_CMA pageblock.
     *
     * The way to use it is to change migratetype of a range of
     * pageblocks to MIGRATE_CMA which can be done by
     * __free_pageblock_cma() function.  What is important though
     * is that a range of pageblocks must be aligned to
     * MAX_ORDER_NR_PAGES should biggest page be bigger then
     * a single pageblock.
     */
    MIGRATE_CMA, 				//连续的物理内存
#endif
#ifdef CONFIG_MEMORY_ISOLATION
    MIGRATE_ISOLATE,	/* can&#39;t allocate from here */
#endif
    MIGRATE_TYPES
&#125;;
</code></pre>
<p>下面仍然是一个<code>arttnba3</code>师傅所做的图</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/adaf2edda3cc7cd9d368d7107c01213fb90e91b6.jpg" srcset="/img/loading.gif" lazyload></p>
<p>而<code>free_area</code>中的结构中的<code>nr_free</code>表示的是当前<code>free_area</code>中空闲页面块的数量</p>
<pre><code class="hljs">struct free_area &#123;
    struct list_head	free_list[MIGRATE_TYPES];
    unsigned long		nr_free;
&#125;;
</code></pre>
<h3 id="1-分配页框"><a href="#1-分配页框" class="headerlink" title="1. 分配页框"></a>1. 分配页框</h3><p>内核中实现了几个函数接口来请求页框，最终都会调用<code>__alloc_pages_nodemask</code>，如下图</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/11385343fbf2b211dbb767878f8065380dd78e5a.jpg" srcset="/img/loading.gif" lazyload></p>
<p>其中核心的函数就是<code>__alloc_pages_nodemask</code>,这里我们需要先知道<code>gfp_mask</code>和<code>alloc_flags</code>这两个标志</p>
<p><strong>gfp_flags</strong></p>
<ol>
<li>__GFP_DMA：请求在ZONE_DMA区域中分配页面；</li>
<li>__GFP_HIGHMEM：请求在ZONE_HIGHMEM区域中分配页面；</li>
<li>__GFP_MOVABLE：ZONE_MOVALBE可用时在该区域分配页面，同时表示页面分配后可以在内存压缩时进行迁移，也能进行回收；</li>
<li>__GFP_RECLAIMABLE：请求分配到可恢复页面；</li>
<li>__GFP_HIGH：高优先级处理请求；</li>
<li>__GFP_IO：请求在分配期间进行 I&#x2F;O 操作；</li>
<li>__GFP_FS：请求在分配期间进行文件系统调用；</li>
<li>__GFP_ZERO：请求将分配的区域初始化为 0；</li>
<li>__GFP_NOFAIL：不允许请求失败，会无限重试；</li>
<li>__GFP_NORETRY：请求不重试内存分配请求；<br>这里我是直接引用的cft56200_ln师傅的图<br><img src="http://imgsrc.baidu.com/forum/pic/item/fc1f4134970a304ebfdb423394c8a786c8175c7a.jpg" srcset="/img/loading.gif" lazyload></li>
</ol>
<p><strong>alloc_flags</strong></p>
<ol>
<li>ALLOC_WMARK_MIN：仅在最小水位water mark及以上限制页面分配；</li>
<li>ALLOC_WMARK_LOW：仅在低水位water mark及以上限制页面分配；</li>
<li>ALLOC_WMARK_HIGH：仅在高水位water mark及以上限制页面分配；</li>
<li>ALLOC_HARDER：努力分配，一般在gfp_mask设置了__GFP_ATOMIC时会使用；</li>
<li>ALLOC_HIGH：高优先级分配，一般在gfp_mask设置了__GFP_HIGH时使用；</li>
<li>ALLOC_CPUSET：检查是否为正确的 cpuset；</li>
<li>ALLOC_CMA：允许从 CMA 区域进行分配</li>
</ol>
<p>下面就是该核心函数的函数体部分，他位于<code>/mm/page_alloc.c</code>当中，如下：</p>
<pre><code class="hljs">/*
 * This is the &#39;heart&#39; of the zoned buddy allocator.（看好了，兄弟系统是这么用的）
 */
struct page *
__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,
                            nodemask_t *nodemask)
&#123;
    struct page *page;
    unsigned int alloc_flags = ALLOC_WMARK_LOW;
    gfp_t alloc_mask; /* The gfp_t that was actually used for allocation */
    struct alloc_context ac = &#123; &#125;;

    /*
     * There are several places where we assume that the order value is sane
     * so bail out early if the request is out of bound.
     */
    if (unlikely(order &gt;= MAX_ORDER)) &#123;
        WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));
        return NULL;
    &#125;

    gfp_mask &amp;= gfp_allowed_mask;
    alloc_mask = gfp_mask;
    if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))
        return NULL;

    /*
     * Forbid the first pass from falling back to types that fragment
     * memory until all local zones are considered.
     */
    alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);

    /* First allocation attempt */
    page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);
    if (likely(page))
        goto out;

    /*
     * Apply scoped allocation constraints. This is mainly about GFP_NOFS
     * resp. GFP_NOIO which has to be inherited for all allocation requests
     * from a particular context which has been marked by
     * memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;.
     */
    alloc_mask = current_gfp_context(gfp_mask);
    ac.spread_dirty_pages = false;

    /*
     * Restore the original nodemask if it was potentially replaced with
     * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.
     */
    ac.nodemask = nodemask;

    page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);

out:
    if (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;
        unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != 0)) &#123;
        __free_pages(page, order);
        page = NULL;
    &#125;

    trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);

    return page;
&#125;
EXPORT_SYMBOL(__alloc_pages_nodemask);
</code></pre>
<p>上面函数概括为下面的步骤：</p>
<ol>
<li>检测环境，准备分配</li>
<li>快速分配，调用<code>get_page_from_freelist()</code></li>
<li>慢速分配，调用<code>__alloc_pages_slowpath()</code></li>
<li>快慢均失败，考虑页面回收，杀死进程后再次尝试</li>
</ol>
<p>其中准备函数<code>prepare_alloc_pages()</code>是设定一下环境值且从指定参数<code>node</code>中获取一个<code>zonelist</code>，这里就不多讲了，直接来讲解快速分配函数<code>get_page_from_freelist()</code>,他位于<code>/mm/page_alloc.c</code></p>
<pre><code class="hljs">static struct page *
get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,
                        const struct alloc_context *ac)
&#123;
    struct zoneref *z;
    struct zone *zone;
    struct pglist_data *last_pgdat_dirty_limit = NULL;
    bool no_fallback;

retry:
    /*
     * 扫描 zonelist, 寻找有着足够空闲块的zone
     * See also __cpuset_node_allowed() comment in kernel/cpuset.c.
     */
    no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;
    z = ac-&gt;preferred_zoneref;
    for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,
                    ac-&gt;nodemask) &#123;
        struct page *page;
        unsigned long mark;

        if (cpusets_enabled() &amp;&amp;
            (alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;
            !__cpuset_zone_allowed(zone, gfp_mask))
                continue;
        /*
         * When allocating a page cache page for writing, we
         * want to get it from a node that is within its dirty
         * limit, such that no single node holds more than its
         * proportional share of globally allowed dirty pages.
         * The dirty limits take into account the node&#39;s
         * lowmem reserves and high watermark so that kswapd
         * should be able to balance it without having to
         * write pages from its LRU list.
         *
         * XXX: For now, allow allocations to potentially
         * exceed the per-node dirty limit in the slowpath
         * (spread_dirty_pages unset) before going into reclaim,
         * which is important when on a NUMA setup the allowed
         * nodes are together not big enough to reach the
         * global limit.  The proper fix for these situations
         * will require awareness of nodes in the
         * dirty-throttling and the flusher threads.
         */
        if (ac-&gt;spread_dirty_pages) &#123;
            if (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)
                continue;

            if (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;
                last_pgdat_dirty_limit = zone-&gt;zone_pgdat;
                continue;
            &#125;
        &#125;

        if (no_fallback &amp;&amp; nr_online_nodes &gt; 1 &amp;&amp;
            zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;
            int local_nid;

            /*
             * If moving to a remote node, retry but allow
             * fragmenting fallbacks. Locality is more important
             * than fragmentation avoidance.
             */
            local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);
            if (zone_to_nid(zone) != local_nid) &#123;
                alloc_flags &amp;= ~ALLOC_NOFRAGMENT;
                goto retry;
            &#125;
        &#125;

        mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);
        if (!zone_watermark_fast(zone, order, mark,
                       ac-&gt;highest_zoneidx, alloc_flags,
                       gfp_mask)) &#123;
            int ret;

#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
            /*
             * Watermark failed for this zone, but see if we can
             * grow this zone if it contains deferred pages.
             */
            if (static_branch_unlikely(&amp;deferred_pages)) &#123;
                if (_deferred_grow_zone(zone, order))
                    goto try_this_zone;
            &#125;
#endif
            /* Checked here to keep the fast path fast */
            BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);
            if (alloc_flags &amp; ALLOC_NO_WATERMARKS)
                goto try_this_zone;

            if (node_reclaim_mode == 0 ||
                !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))
                continue;

            ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);
            switch (ret) &#123;
            case NODE_RECLAIM_NOSCAN:
                /* did not scan */
                continue;
            case NODE_RECLAIM_FULL:
                /* scanned but unreclaimable */
                continue;
            default:
                /* did we reclaim enough */
                if (zone_watermark_ok(zone, order, mark,
                    ac-&gt;highest_zoneidx, alloc_flags))
                    goto try_this_zone;

                continue;
            &#125;
        &#125;

try_this_zone:   	//本zone正常水位
        page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,
                gfp_mask, alloc_flags, ac-&gt;migratetype);
        if (page) &#123;
            prep_new_page(page, order, gfp_mask, alloc_flags);

            /*
             * If this is a high-order atomic allocation then check
             * if the pageblock should be reserved for the future
             */
            if (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))
                reserve_highatomic_pageblock(page, zone, order);

            return page;
        &#125; else &#123;
#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
            /* Try again if zone has deferred pages */
            if (static_branch_unlikely(&amp;deferred_pages)) &#123;
                if (_deferred_grow_zone(zone, order))
                    goto try_this_zone;
            &#125;
#endif
        &#125;
    &#125;

    /*
     * It&#39;s possible on a UMA machine to get through all zones that are
     * fragmented. If avoiding fragmentation, reset and try again.
     */
    if (no_fallback) &#123;
        alloc_flags &amp;= ~ALLOC_NOFRAGMENT;
        goto retry;
    &#125;

    return NULL;
&#125;
</code></pre>
<p>其功能就是首先遍历当前的<code>zone</code>，判断当前<code>zone</code>是否满足low water mark水位，若不满足则进行一次快速回收操作，再次检测水位情况，若还是不能满足，则遍历下一个<code>zone</code>，然后采取同样的步骤，最后进入<code>rmqueue</code>函数，这就是<code>buddy system</code>的核心，过程可以简化看下图：</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/11385343fbf2b211d43468878f8065380dd78ee5.jpg" srcset="/img/loading.gif" lazyload></p>
<p>相比于代码，下图更加直观，之后我们来查看关键函数<code>rmqueue()</code>,它位于<code>/mm/page_alloc.c</code></p>
<pre><code class="hljs">/*
 * 从所给zone中获取页. 当order为0的时候，使用pcplists.
 */
static inline
struct page *rmqueue(struct zone *preferred_zone,
            struct zone *zone, unsigned int order,
            gfp_t gfp_flags, unsigned int alloc_flags,
            int migratetype)
&#123;
    unsigned long flags;
    struct page *page;

    if (likely(order == 0)) &#123;
        /*
          * 若没有开启`CMA`|设置`ALLOC_CMA`|迁移类型为MIGRATE_MOVABLE，则先从pcplist上分配
         */
        if (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||
                migratetype != MIGRATE_MOVABLE) &#123;
            page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,
                    migratetype, alloc_flags);
            goto out;
        &#125;
    &#125;

    /*
     * We most definitely don&#39;t want callers attempting to
     * allocate greater than order-1 page units with __GFP_NOFAIL.
     */
    WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; 1));
    spin_lock_irqsave(&amp;zone-&gt;lock, flags);

    do &#123;
        page = NULL;
        /*
         * order-0 request can reach here when the pcplist is skipped
         * due to non-CMA allocation context. HIGHATOMIC area is
         * reserved for high-order atomic allocation, so order-0
         * request should skip it.
         */
        if (order &gt; 0 &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123; //order大于0且带有ALLOC_HARDER，使用__rmqueue_smallest分配
            page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);
            if (page)
                trace_mm_page_alloc_zone_locked(page, order, migratetype);
        &#125;
        /*
         * 执行到这里说明order&gt;0,我们采用__rmqueue函数，这是真正的兄弟系统核心分配函数
         */
        if (!page)
            page = __rmqueue(zone, order, migratetype, alloc_flags);
    &#125; while (page &amp;&amp; check_new_pages(page, order));
    spin_unlock(&amp;zone-&gt;lock);
    if (!page)
        goto failed;
    __mod_zone_freepage_state(zone, -(1 &lt;&lt; order),
                  get_pcppage_migratetype(page));

    __count_zid_vm_events(PGALLOC, page_zonenum(page), 1 &lt;&lt; order);
    zone_statistics(preferred_zone, zone);
    local_irq_restore(flags);

out:
    /* Separate test+clear to avoid unnecessary atomics */
    if (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;
        clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);
        wakeup_kswapd(zone, 0, 0, zone_idx(zone));
    &#125;

    VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);
    return page;

failed:
    local_irq_restore(flags);
    return NULL;
&#125;
</code></pre>
<p>有部分注释，我在上面中西合璧标注了一下，接下来先提醒大家伙，之前咱们讲解<code>zone</code>上的一个字段<code>per-cpu pageset</code>,他是为了放置条件竞争的问题，为每个cpu单独设置一个仓库用来为<code>buddy system</code>进行迅速的分配，这里就是给出了<code>buddy system</code>先从他里面调用的函数代码，总结为一下流程</p>
<ol>
<li>若<code>order</code>为0，若没有开启<code>CMA</code>|设置<code>ALLOC_CMA</code>|迁移类型为MIGRATE_MOVABLE，则先从per-cpu pageset 中分配并且返回</li>
<li>order &gt;0 调用<code>__rmqueue_smallest()</code>分配</li>
<li>若未分配成功，这里不管order是否为0，调用<code>__rmqueue()</code>分配</li>
<li>结果检查，调用<code>check_new_pages()</code>，未通过则循环跳到第二步</li>
</ol>
<p>我们一个一个关键函数来查看，首先是分配<code>per_cpu_pageset</code>,也就是如下函数</p>
<p><strong>rmqueue_pcplist()</strong></p>
<pre><code class="hljs">/* Lock and remove page from the per-cpu list */
static struct page *rmqueue_pcplist(struct zone *preferred_zone,
            struct zone *zone, gfp_t gfp_flags,
            int migratetype, unsigned int alloc_flags)
&#123;
    struct per_cpu_pages *pcp;
    struct list_head *list;
    struct page *page;
    unsigned long flags;

    local_irq_save(flags); // 关中断
    pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;
    list = &amp;pcp-&gt;lists[migratetype]; // 获取迁移类型链表
    page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, list); // 分配
    if (page) &#123;
        __count_zid_vm_events(PGALLOC, page_zonenum(page), 1);
        zone_statistics(preferred_zone, zone);
    &#125;
    local_irq_restore(flags); // 开中断
    return page;
&#125;
</code></pre>
<p>主要是进行了一些同步互斥操作（开关中断），然后调用函数<code>__rmqueue_pcplist</code></p>
<pre><code class="hljs">/* 从 per-cpu 链表上取出 page, 调用者必须保护链表 */
static struct page *__rmqueue_pcplist(struct zone *zone, int migratetype,
            unsigned int alloc_flags,
            struct per_cpu_pages *pcp,
            struct list_head *list)
&#123;
    struct page *page;

    do &#123;
        if (list_empty(list)) &#123; // list 是空的
            // 
            pcp-&gt;count += rmqueue_bulk(zone, 0,
                    READ_ONCE(pcp-&gt;batch), list,
                    migratetype, alloc_flags);
            if (unlikely(list_empty(list)))
                return NULL;
        &#125;

        // 链表脱链
        page = list_first_entry(list, struct page, lru);
        list_del(&amp;page-&gt;lru);
        pcp-&gt;count--;
    &#125; while (check_new_pcp(page));

    return page;
&#125;
</code></pre>
<p>这里先判定链表，若为空，则调用<code>rmqueue_bulk()</code>函数，从<code>zone</code>上拿到pages之后再进行<code>unlink</code>，而<code>rmqueue_bulk()</code>函数最终会调用<code>__rmqueue()</code></p>
<pre><code class="hljs">/*
 * 为了高效率，从 buddy 分配器获得指定数量的元素, 
 * 所有的单个元素都在持有锁的情况下进行.  将其添加到提供的链表中.
 * 返回放置在 *list 链表上的 pages 数量.
 */
static int rmqueue_bulk(struct zone *zone, unsigned int order,
            unsigned long count, struct list_head *list,
            int migratetype, unsigned int alloc_flags)
&#123;
    int i, alloced = 0;

    spin_lock(&amp;zone-&gt;lock);
    for (i = 0; i &lt; count; ++i) &#123;
        struct page *page = __rmqueue(zone, order, migratetype,
                                alloc_flags);
        if (unlikely(page == NULL))
            break;

        if (unlikely(check_pcp_refill(page)))
            continue;

        /*
         * 由 expand() 返回的分割 buddy 页面在此处以物理页框顺序接收。
         * 页面被添加到 caller 的链表尾部。从 caller 的角度看，链表在
         * 某些情况下是按照页码排序的。这对一些可以从头部前向的IO设备是有用的，
         * 因为链表也是在物理页的顺序上的。这对于可以在物理页合理排序的情况下
         * 合并IO请求的IO设备是有用的。
         */
        list_add_tail(&amp;page-&gt;lru, list);
        alloced++;
        if (is_migrate_cma(get_pcppage_migratetype(page)))
            __mod_zone_page_state(zone, NR_FREE_CMA_PAGES,
                          -(1 &lt;&lt; order));
    &#125;

    /*
     * i pages were removed from the buddy list even if some leak due
     * to check_pcp_refill failing so adjust NR_FREE_PAGES based
     * on i. Do not confuse with &#39;alloced&#39; which is the number of
     * pages added to the pcp list.
     */
    __mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));
    spin_unlock(&amp;zone-&gt;lock);
    return alloced;
&#125;
</code></pre>
<p><strong>__rmqueue_smallest</strong><br>该函数就是由order对应的<code>free_area</code>中类型为<code>migration type</code>的链表上进行分配，如果不够则向高order处请求，由于这里都是以2^order来进行分配，因此如果说我order为1，且这里不够的话，我们就转而order为2的链表，将其中的块对半拆下到低order中，其中向更高order分配是通过循环和脱链完成，而拆高阶的page是通过<code>expand()</code>函数来进行的</p>
<pre><code class="hljs">/*
 * 对给定的 migrationtype 遍历 free lists 
 * 并从 freelists 上移除最小可用的页面
 */
static __always_inline
struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,
                        int migratetype)
&#123;
    unsigned int current_order;
    struct free_area *area;
    struct page *page;

    /* 在 preferred list 上寻找一个合适 size 的 page */
    for (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;
        area = &amp;(zone-&gt;free_area[current_order]);
        page = get_page_from_free_area(area, migratetype);
        if (!page)
            continue;
        del_page_from_free_list(page, zone, current_order);
        expand(zone, page, order, current_order, migratetype);
        set_pcppage_migratetype(page, migratetype);
        return page;
    &#125;

    return NULL;
&#125;
</code></pre>
<p>而拆分函数<code>expand</code>也比较简单</p>
<pre><code class="hljs">/*
 * 此处再分割的顺序对 IO subsystem 而言是十分重要的.
 * 请不要在有好的理由及回归测试前改变这个顺序。
 * 特别地，当大块的内存被分割，更小块（内存）被传递的顺序
 * 则由他们在该函数中被分割的顺序决定。
 * 根据实际测试，这是影响传递给IO子系统的 pages 顺序的主要因素，
 * 考虑到包含一个内存大块（由一系列小的分配作用）的 buddy system 的行为，
 * 这也是合理的。这种行为是 sglist 合并成功的关键因素。
 *
 * -- nyc
 */
static inline void expand(struct zone *zone, struct page *page,
    int low, int high, int migratetype)
&#123;
    unsigned long size = 1 &lt;&lt; high;

    while (high &gt; low) &#123;
        high--;
        size &gt;&gt;= 1;
        VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);

        /*
         * 标记为 guard pages (或 page), 这将允许在 buddy 将被
         * 释放时合并回分配器.对应的页表项不会被创建，
         * pages 在 虚拟地址空间上仍将保持不存在。
         */
        if (set_page_guard(zone, &amp;page[size], high, migratetype))
            continue;

        add_to_free_list(&amp;page[size], zone, high, migratetype);
        set_buddy_order(&amp;page[size], high);
    &#125;
&#125;
</code></pre>
<p><strong>__rmqueue()</strong></p>
<p>最开始我以为这个才是最终函数，但其实他不是，他反而还会调用<code>__rmqueue_smallest()</code></p>
<pre><code class="hljs">/*
 * 从 buddy allocator 上移除一个元素.
 * 在持有 zone-&gt;lock 时调用.
 */
static __always_inline struct page *
__rmqueue(struct zone *zone, unsigned int order, int migratetype,
                        unsigned int alloc_flags)
&#123;
    struct page *page;

    if (IS_ENABLED(CONFIG_CMA)) &#123;
        /*
         * 通过当半数空闲内存在 CMA 区域时从 CMA 中分配
         * 以平衡常规的与CMA区域的可迁移的分配。
         */
        if (alloc_flags &amp; ALLOC_CMA &amp;&amp;
            zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;
            zone_page_state(zone, NR_FREE_PAGES) / 2) &#123;
            page = __rmqueue_cma_fallback(zone, order);
            if (page)
                goto out;
        &#125;
    &#125;
retry:
    page = __rmqueue_smallest(zone, order, migratetype);
    if (unlikely(!page)) &#123;
        if (alloc_flags &amp; ALLOC_CMA)
            page = __rmqueue_cma_fallback(zone, order);

        if (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,
                                alloc_flags))
            goto retry;
    &#125;
out:
    if (page)
        trace_mm_page_alloc_zone_locked(page, order, migratetype);
    return page;
&#125;
</code></pre>
<p>整体快速分配可以看下面这张图</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/a6efce1b9d16fdfadde22b27f18f8c5495ee7b69.jpg" srcset="/img/loading.gif" lazyload></p>
<p>我们了解完了快速分配，接下来就是慢速分配了，其中他的功能包括了内存碎片化的整理和回收，他的代码太长，我就也只贴一部分，如下：</p>
<pre><code class="hljs">static inline struct page *
__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,
      struct alloc_context *ac)
&#123;
  page = __alloc_pages_direct_compact(gfp_mask, order, 
      alloc_flags, ac,
      INIT_COMPACT_PRIORITY,
      &amp;compact_result);
  ......
  page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac, 
       &amp;did_some_progress);
  ......
&#125;
</code></pre>
<p>其中内存碎片化也即是利用到迁移的知识，这里有两个关键函数，其中之一就是<code>__alloc_pages_direct_compact</code></p>
<pre><code class="hljs">static struct page *
__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,
  unsigned int alloc_flags, const struct alloc_context *ac,
  enum compact_priority prio, enum compact_result *compact_result)
&#123;
 struct page *page;
 unsigned int noreclaim_flag;
 
 if (!order)
  return NULL;
 
 noreclaim_flag = memalloc_noreclaim_save();
 *compact_result = try_to_compact_pages(gfp_mask, order, alloc_flags, ac,
         prio);
 memalloc_noreclaim_restore(noreclaim_flag);
 
 if (*compact_result &lt;= COMPACT_INACTIVE)
  return NULL;
 
 count_vm_event(COMPACTSTALL);
 
 page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);
 
 if (page) &#123;
  struct zone *zone = page_zone(page);
 
  zone-&gt;compact_blockskip_flush = false;
  compaction_defer_reset(zone, order, true);
  count_vm_event(COMPACTSUCCESS);
  return page;
 &#125;
 
 count_vm_event(COMPACTFAIL);
 
 cond_resched();
 
 return NULL;
&#125;
</code></pre>
<p>这里的函数也是迁移算法<code>memory compaction</code>的代码实现，该算法可以简化为下面的流程</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/242dd42a2834349b34c1834c8cea15ce37d3be30.jpg" srcset="/img/loading.gif" lazyload></p>
<p>也就是分为两个链表，一个专门遍历空闲页，一个专门遍历使用页，注意这俩要分别维持链表，然后最后进行交换操作就实现了迁移过程，且记住这个迁移是需要<code>page</code>本身是允许的才行,</p>
<p>在完成上述迁移操作后会再次尝试快速分配，这里的碎片化整理还有其他方式，但是我这里暂不区深究，先记录个图等我哪天想起来了再探索</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/e4dde71190ef76c6cae717e2d816fdfaae5167c6.jpg" srcset="/img/loading.gif" lazyload></p>
<p>而关于慢速分配还有个函数是<code>__alloc_pages_direct_reclaim()</code>，他的作用主要是回收，而不是碎片整理</p>
<p>最后来个整体分配页框的函数流程图<br><img src="http://imgsrc.baidu.com/forum/pic/item/810a19d8bc3eb135a3e35b72e31ea8d3fc1f44d7.jpg" srcset="/img/loading.gif" lazyload></p>
<h1 id="暂未完工"><a href="#暂未完工" class="headerlink" title="暂未完工"></a>暂未完工</h1><p>一天下来怎么硕呢，感觉都是几位师傅的博客一口一口的喂饭，虽说自己理解了大致过程，但是对于源码的解读还是太粗了，这个系列还有释放页框和slub算法的源码实现，slub算法我再上一篇博客中已经讲解了大致原理了哦，这里还差一部分，</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux-Kernel/" class="category-chain-item">Linux Kernel</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Linux/">#Linux</a>
      
        <a href="/tags/kernel/">#kernel</a>
      
        <a href="/tags/source/">#source</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux_memory_manegement</div>
      <div>https://peiandhao.github.io/2023/06/17/Linux-memory-manegement/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>peiwithhao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/17/Malloc-Free/" title="Malloc_Free">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Malloc_Free</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/17/CVE-2010-2883%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="CVE-2010-2883漏洞复现">
                        <span class="hidden-mobile">CVE-2010-2883漏洞复现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Afm6UeM0VL6RfMOLAgwtyxs8-gzGzoHsz","appKey":"Vr60qrZIptqhJaXqWvDEknkH","path":"window.location.pathname","placeholder":"锐评一下","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Pei</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Hao</span></a> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/DynamicLine.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
